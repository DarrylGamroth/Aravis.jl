module LibAravis

using Aravis_jll
export Aravis_jll

using CEnum: CEnum, @cenum

# Prologue file

# Intentionally minimal; add overrides here if Clang emits mismatched types.
const __extension__ = nothing
const __STDC_VERSION__ = 199901
const __has_attribute = 0
const __has_builtin = 0
const __has_feature = 0
const __has_extension = 0
const __has_include = 0
const __has_include_next = 0
const GLIB_DEPRECATED_MACRO_IN_2_26_FOR = nothing
const GLIB_DEPRECATED_MACRO_IN_2_30_FOR = nothing
const GLIB_DEPRECATED_MACRO_IN_2_32_FOR = nothing
const GLIB_DEPRECATED_MACRO_IN_2_48_FOR = nothing

# End of prologue file


const __uid_t = Cuint

const __pid_t = Cint

const __time_t = Clong

const time_t = __time_t

const pid_t = __pid_t

const uid_t = __uid_t

const pthread_t = Culong

struct __pthread_internal_list
    __prev::Ptr{__pthread_internal_list}
    __next::Ptr{__pthread_internal_list}
end

const __pthread_list_t = __pthread_internal_list

struct pthread_mutex_t
    data::NTuple{40, UInt8}
end

function Base.getproperty(x::Ptr{pthread_mutex_t}, f::Symbol)
    f === :__data && return Ptr{__pthread_mutex_s}(x + 0)
    f === :__size && return Ptr{NTuple{40, Cchar}}(x + 0)
    f === :__align && return Ptr{Clong}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::pthread_mutex_t, f::Symbol)
    r = Ref{pthread_mutex_t}(x)
    ptr = Base.unsafe_convert(Ptr{pthread_mutex_t}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{pthread_mutex_t}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::pthread_mutex_t, private::Bool = false)
    (:__data, :__size, :__align, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

const gsize = Culong

const gpointer = Ptr{Cvoid}

const guintptr = Culong

const glong = Clong

const guint8 = Cuchar

struct _GList
    data::gpointer
    next::Ptr{Cvoid} # next::Ptr{GList}
    prev::Ptr{Cvoid} # prev::Ptr{GList}
end

function Base.getproperty(x::_GList, f::Symbol)
    f === :next && return Ptr{GList}(getfield(x, f))
    f === :prev && return Ptr{GList}(getfield(x, f))
    return getfield(x, f)
end

const GList = _GList

struct _GSList
    data::gpointer
    next::Ptr{Cvoid} # next::Ptr{GSList}
end

function Base.getproperty(x::_GSList, f::Symbol)
    f === :next && return Ptr{GSList}(getfield(x, f))
    return getfield(x, f)
end

const GSList = _GSList

const guint = Cuint

"""
    _GQueue

[`GQueue`](@ref): : a pointer to the first element of the queue : a pointer to the last element of the queue : the number of elements in the queue

Contains the public fields of a [Queue](data-structures.html#double-ended-queues).
"""
struct _GQueue
    head::Ptr{GList}
    tail::Ptr{GList}
    length::guint
end

"""
[`GQueue`](@ref): : a pointer to the first element of the queue : a pointer to the last element of the queue : the number of elements in the queue

Contains the public fields of a [Queue](data-structures.html#double-ended-queues).
"""
const GQueue = _GQueue

# typedef void ( * GDestroyNotify ) ( gpointer data )
const GDestroyNotify = Ptr{Cvoid}

"""
    g_list_free_full(list, free_func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_list_free_full (GList *list, GDestroyNotify free_func);
```
"""
function g_list_free_full(list, free_func)
    @ccall libaravis.g_list_free_full(list::Ptr{GList}, free_func::GDestroyNotify)::Cvoid
end

"""
    g_slist_free_full(list, free_func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_slist_free_full (GSList *list, GDestroyNotify free_func);
```
"""
function g_slist_free_full(list, free_func)
    @ccall libaravis.g_slist_free_full(list::Ptr{GSList}, free_func::GDestroyNotify)::Cvoid
end

"""
    g_queue_free_full(queue, free_func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_queue_free_full (GQueue *queue, GDestroyNotify free_func);
```
"""
function g_queue_free_full(queue, free_func)
    @ccall libaravis.g_queue_free_full(queue::Ptr{GQueue}, free_func::GDestroyNotify)::Cvoid
end

"""
    g_autoptr_cleanup_generic_gfree(p)

### Prototype
```c
static inline void g_autoptr_cleanup_generic_gfree (void *p);
```
"""
function g_autoptr_cleanup_generic_gfree(p)
    @ccall libaravis.g_autoptr_cleanup_generic_gfree(p::Ptr{Cvoid})::Cvoid
end

const gint64 = Clong

const gint = Cint

const gulong = Culong

const gint16 = Cshort

const guint16 = Cushort

const gint32 = Cint

const guint32 = Cuint

const guint64 = Culong

const gssize = Clong

const gint8 = Int8

const gchar = Cchar

struct _GArray
    data::Ptr{gchar}
    len::guint
end

const GArray = _GArray

const gconstpointer = Ptr{Cvoid}

"""
    g_array_append_vals(array, data, len)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GArray* g_array_append_vals (GArray *array, gconstpointer data, guint len);
```
"""
function g_array_append_vals(array, data, len)
    @ccall libaravis.g_array_append_vals(array::Ptr{GArray}, data::gconstpointer, len::guint)::Ptr{GArray}
end

"""
    g_array_prepend_vals(array, data, len)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GArray* g_array_prepend_vals (GArray *array, gconstpointer data, guint len);
```
"""
function g_array_prepend_vals(array, data, len)
    @ccall libaravis.g_array_prepend_vals(array::Ptr{GArray}, data::gconstpointer, len::guint)::Ptr{GArray}
end

"""
    g_array_insert_vals(array, index_, data, len)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GArray* g_array_insert_vals (GArray *array, guint index_, gconstpointer data, guint len);
```
"""
function g_array_insert_vals(array, index_, data, len)
    @ccall libaravis.g_array_insert_vals(array::Ptr{GArray}, index_::guint, data::gconstpointer, len::guint)::Ptr{GArray}
end

const gintptr = Clong

const GQuark = guint32

"""
    g_quark_from_static_string(string)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GQuark g_quark_from_static_string (const gchar *string);
```
"""
function g_quark_from_static_string(string)
    @ccall libaravis.g_quark_from_static_string(string::Ptr{gchar})::GQuark
end

struct _GError
    domain::GQuark
    code::gint
    message::Ptr{gchar}
end

"""
[`GError`](@ref): : error domain, e.g. G\\_FILE\\_ERROR

```c++
: error code, e.g. %G_FILE_ERROR_NOENT
 @message: human-readable informative error message

 The `GError` structure contains information about
 an error that has occurred.
 

```
"""
const GError = _GError

"""
    g_return_if_fail_warning(log_domain, pretty_function, expression)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_return_if_fail_warning (const char *log_domain, const char *pretty_function, const char *expression);
```
"""
function g_return_if_fail_warning(log_domain, pretty_function, expression)
    @ccall libaravis.g_return_if_fail_warning(log_domain::Cstring, pretty_function::Cstring, expression::Cstring)::Cvoid
end

# typedef void ( * GErrorInitFunc ) ( GError * error )
"""
[`GErrorInitFunc`](@ref): : extended error

Specifies the type of function which is called just after an extended error instance is created and its fields filled. It should only initialize the fields in the private data, which can be received with the generated `*\\_get\\_private()` function.

Normally, it is better to use [`G_DEFINE_EXTENDED_ERROR`](@ref)(), as it already takes care of getting the private data from .

Since: 2.68
"""
const GErrorInitFunc = Ptr{Cvoid}

# typedef void ( * GErrorCopyFunc ) ( const GError * src_error , GError * dest_error )
"""
[`GErrorCopyFunc`](@ref): \\_error: source extended error

\\test \\_error: destination extended error

Specifies the type of function which is called when an extended error instance is copied. It is passed the pointer to the destination error and source error, and should copy only the fields of the private data from \\_error to

\\test \\_error.

Normally, it is better to use [`G_DEFINE_EXTENDED_ERROR`](@ref)(), as it already takes care of getting the private data from \\_error and

\\test \\_error.

Since: 2.68
"""
const GErrorCopyFunc = Ptr{Cvoid}

# typedef void ( * GErrorClearFunc ) ( GError * error )
"""
[`GErrorClearFunc`](@ref): : extended error to clear

Specifies the type of function which is called when an extended error instance is freed. It is passed the error pointer about to be freed, and should free the error's private data fields.

Normally, it is better to use [`G_DEFINE_EXTENDED_ERROR`](@ref)(), as it already takes care of getting the private data from .

Since: 2.68
"""
const GErrorClearFunc = Ptr{Cvoid}

"""
    g_error_domain_register_static(error_type_name, error_type_private_size, error_type_init, error_type_copy, error_type_clear)

### Prototype
```c
GLIB_AVAILABLE_IN_2_68 GQuark g_error_domain_register_static (const char *error_type_name, gsize error_type_private_size, GErrorInitFunc error_type_init, GErrorCopyFunc error_type_copy, GErrorClearFunc error_type_clear);
```
"""
function g_error_domain_register_static(error_type_name, error_type_private_size, error_type_init, error_type_copy, error_type_clear)
    @ccall libaravis.g_error_domain_register_static(error_type_name::Cstring, error_type_private_size::gsize, error_type_init::GErrorInitFunc, error_type_copy::GErrorCopyFunc, error_type_clear::GErrorClearFunc)::GQuark
end

"""
    g_bit_nth_lsf_impl(mask, nth_bit)

### Prototype
```c
static inline gint g_bit_nth_lsf_impl (gulong mask, gint nth_bit);
```
"""
function g_bit_nth_lsf_impl(mask, nth_bit)
    @ccall libaravis.g_bit_nth_lsf_impl(mask::gulong, nth_bit::gint)::gint
end

"""
    g_bit_nth_msf_impl(mask, nth_bit)

### Prototype
```c
static inline gint g_bit_nth_msf_impl (gulong mask, gint nth_bit);
```
"""
function g_bit_nth_msf_impl(mask, nth_bit)
    @ccall libaravis.g_bit_nth_msf_impl(mask::gulong, nth_bit::gint)::gint
end

"""
    g_bit_storage_impl(number)

### Prototype
```c
static inline guint g_bit_storage_impl (gulong number);
```
"""
function g_bit_storage_impl(number)
    @ccall libaravis.g_bit_storage_impl(number::gulong)::guint
end

"""
    g_thread_error_quark()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GQuark g_thread_error_quark (void);
```
"""
function g_thread_error_quark()
    @ccall libaravis.g_thread_error_quark()::GQuark
end

struct _GMutex
    data::NTuple{8, UInt8}
end

function Base.getproperty(x::Ptr{_GMutex}, f::Symbol)
    f === :p && return Ptr{gpointer}(x + 0)
    f === :i && return Ptr{NTuple{2, guint}}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::_GMutex, f::Symbol)
    r = Ref{_GMutex}(x)
    ptr = Base.unsafe_convert(Ptr{_GMutex}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{_GMutex}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::_GMutex, private::Bool = false)
    (:p, :i, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

const GMutex = _GMutex

"""
    g_mutex_lock(mutex)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_mutex_lock (GMutex *mutex);
```
"""
function g_mutex_lock(mutex)
    @ccall libaravis.g_mutex_lock(mutex::Ptr{GMutex})::Cvoid
end

"""
    g_mutex_unlock(mutex)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_mutex_unlock (GMutex *mutex);
```
"""
function g_mutex_unlock(mutex)
    @ccall libaravis.g_mutex_unlock(mutex::Ptr{GMutex})::Cvoid
end

const gboolean = gint

"""
    g_mutex_trylock(mutex)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_mutex_trylock (GMutex *mutex);
```
"""
function g_mutex_trylock(mutex)
    @ccall libaravis.g_mutex_trylock(mutex::Ptr{GMutex})::gboolean
end

"""
[`GMutexLocker`](@ref):

Opaque type. See [`g_mutex_locker_new`](@ref)() for details. Since: 2.44
"""
const GMutexLocker = Cvoid

"""
    g_mutex_locker_new(mutex)

[`g_mutex_locker_new`](@ref): : a mutex to lock

Lock  and return a new #[`GMutexLocker`](@ref). Unlock with [`g_mutex_locker_free`](@ref)(). Using [`g_mutex_unlock`](@ref)() on  while a #[`GMutexLocker`](@ref) exists can lead to undefined behaviour.

No allocation is performed, it is equivalent to a [`g_mutex_lock`](@ref)() call.

This is intended to be used with [`g_autoptr`](@ref)(). Note that [`g_autoptr`](@ref)() is only available when using GCC or clang, so the following example will only work with those compilers: |[ typedef struct { ... [`GMutex`](@ref) mutex; ... } MyObject;

static void my\\_object\\_do\\_stuff (MyObject *self) { [`g_autoptr`](@ref)([`GMutexLocker`](@ref)) locker = [`g_mutex_locker_new`](@ref) (&self->mutex);

// Code with mutex locked here

if (condition) // No need to unlock return;

// Optionally early unlock [`g_clear_pointer`](@ref) (&locker, [`g_mutex_locker_free`](@ref));

// Code with mutex unlocked here } ]|

Note that it is common for the declared variable to not be used in the scope, which causes some compilers to warn. That can be avoided by using [`G_GNUC_UNUSED`](@ref) or, since 2.80, [func.MUTEX\\_AUTO\\_LOCK].

Returns: a #[`GMutexLocker`](@ref) Since: 2.44

### Prototype
```c
static inline GMutexLocker * g_mutex_locker_new (GMutex *mutex);
```
"""
function g_mutex_locker_new(mutex)
    @ccall libaravis.g_mutex_locker_new(mutex::Ptr{GMutex})::Ptr{GMutexLocker}
end

@cenum GOnceStatus::UInt32 begin
    G_ONCE_STATUS_NOTCALLED = 0
    G_ONCE_STATUS_PROGRESS = 1
    G_ONCE_STATUS_READY = 2
end

struct _GOnce
    status::GOnceStatus
    retval::gpointer
end

const GOnce = _GOnce

# typedef gpointer ( * GThreadFunc ) ( gpointer data )
const GThreadFunc = Ptr{Cvoid}

"""
    g_once_impl(once, func, arg)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_once_impl (GOnce *once, GThreadFunc func, gpointer arg);
```
"""
function g_once_impl(once, func, arg)
    @ccall libaravis.g_once_impl(once::Ptr{GOnce}, func::GThreadFunc, arg::gpointer)::gpointer
end

"""
[`GRecMutexLocker`](@ref):

Opaque type. See [`g_rec_mutex_locker_new`](@ref)() for details. Since: 2.60
"""
const GRecMutexLocker = Cvoid

struct _GRecMutex
    p::gpointer
    i::NTuple{2, guint}
end

const GRecMutex = _GRecMutex

"""
    g_rec_mutex_locker_new(rec_mutex)

[`g_rec_mutex_locker_new`](@ref): _mutex: a recursive mutex to lock

Lock _mutex and return a new #[`GRecMutexLocker`](@ref). Unlock with [`g_rec_mutex_locker_free`](@ref)(). Using [`g_rec_mutex_unlock`](@ref)() on _mutex while a #[`GRecMutexLocker`](@ref) exists can lead to undefined behaviour.

No allocation is performed, it is equivalent to a [`g_rec_mutex_lock`](@ref)() call.

This is intended to be used with [`g_autoptr`](@ref)(). Note that [`g_autoptr`](@ref)() is only available when using GCC or clang, so the following example will only work with those compilers: |[ typedef struct { ... [`GRecMutex`](@ref) rec\\_mutex; ... } MyObject;

static void my\\_object\\_do\\_stuff (MyObject *self) { [`g_autoptr`](@ref)([`GRecMutexLocker`](@ref)) locker = [`g_rec_mutex_locker_new`](@ref) (&self->rec\\_mutex);

// Code with rec\\_mutex locked here

if (condition) // No need to unlock return;

// Optionally early unlock [`g_clear_pointer`](@ref) (&locker, [`g_rec_mutex_locker_free`](@ref));

// Code with rec\\_mutex unlocked here } ]|

Note that it is common for the declared variable to not be used in the scope, which causes some compilers to warn. That can be avoided by using [`G_GNUC_UNUSED`](@ref) or, since 2.80, [func.REC\\_MUTEX\\_AUTO\\_LOCK].

Returns: a #[`GRecMutexLocker`](@ref) Since: 2.60

### Prototype
```c
static inline GRecMutexLocker * g_rec_mutex_locker_new (GRecMutex *rec_mutex);
```
"""
function g_rec_mutex_locker_new(rec_mutex)
    @ccall libaravis.g_rec_mutex_locker_new(rec_mutex::Ptr{GRecMutex})::Ptr{GRecMutexLocker}
end

"""
[`GRWLockWriterLocker`](@ref):

Opaque type. See [`g_rw_lock_writer_locker_new`](@ref)() for details. Since: 2.62
"""
const GRWLockWriterLocker = Cvoid

struct _GRWLock
    p::gpointer
    i::NTuple{2, guint}
end

const GRWLock = _GRWLock

"""
    g_rw_lock_writer_locker_new(rw_lock)

[`g_rw_lock_writer_locker_new`](@ref): \\_lock: a #[`GRWLock`](@ref)

Obtain a write lock on \\_lock and return a new #[`GRWLockWriterLocker`](@ref). Unlock with [`g_rw_lock_writer_locker_free`](@ref)(). Using [`g_rw_lock_writer_unlock`](@ref)() on \\_lock while a #[`GRWLockWriterLocker`](@ref) exists can lead to undefined behaviour.

No allocation is performed, it is equivalent to a [`g_rw_lock_writer_lock`](@ref)() call.

This is intended to be used with [`g_autoptr`](@ref)(). Note that [`g_autoptr`](@ref)() is only available when using GCC or clang, so the following example will only work with those compilers: |[ typedef struct { ... [`GRWLock`](@ref) rw\\_lock; [`GPtrArray`](@ref) *array; ... } MyObject;

static [`gchar`](@ref) * my\\_object\\_get\\_data (MyObject *self, [`guint`](@ref) index) { [`g_autoptr`](@ref)([`GRWLockReaderLocker`](@ref)) locker = [`g_rw_lock_reader_locker_new`](@ref) (&self->rw\\_lock);

// Code with a read lock obtained on rw\\_lock here

if (self->array == NULL) // No need to unlock return NULL;

if (index < self->array->len) // No need to unlock return [`g_ptr_array_index`](@ref) (self->array, index);

// Optionally early unlock [`g_clear_pointer`](@ref) (&locker, [`g_rw_lock_reader_locker_free`](@ref));

// Code with rw\\_lock unlocked here return NULL; }

static void my\\_object\\_set\\_data (MyObject *self, [`guint`](@ref) index, [`gpointer`](@ref) data) { [`g_autoptr`](@ref)([`GRWLockWriterLocker`](@ref)) locker = [`g_rw_lock_writer_locker_new`](@ref) (&self->rw\\_lock);

// Code with a write lock obtained on rw\\_lock here

if (self->array == NULL) self->array = [`g_ptr_array_new`](@ref) ();

if (condition) // No need to unlock return;

if (index >= self->array->len) [`g_ptr_array_set_size`](@ref) (self->array, index+1); [`g_ptr_array_index`](@ref) (self->array, index) = data;

// Optionally early unlock [`g_clear_pointer`](@ref) (&locker, [`g_rw_lock_writer_locker_free`](@ref));

// Code with rw\\_lock unlocked here } ]|

Note that it is common for the declared variable to not be used in the scope, which causes some compilers to warn. That can be avoided by using [`G_GNUC_UNUSED`](@ref) or, since 2.80, [func.RW\\_LOCK\\_WRITER\\_AUTO\\_LOCK].

Returns: a #[`GRWLockWriterLocker`](@ref) Since: 2.62

### Prototype
```c
static inline GRWLockWriterLocker * g_rw_lock_writer_locker_new (GRWLock *rw_lock);
```
"""
function g_rw_lock_writer_locker_new(rw_lock)
    @ccall libaravis.g_rw_lock_writer_locker_new(rw_lock::Ptr{GRWLock})::Ptr{GRWLockWriterLocker}
end

"""
[`GRWLockReaderLocker`](@ref):

Opaque type. See [`g_rw_lock_reader_locker_new`](@ref)() for details. Since: 2.62
"""
const GRWLockReaderLocker = Cvoid

"""
    g_rw_lock_reader_locker_new(rw_lock)

[`g_rw_lock_reader_locker_new`](@ref): \\_lock: a #[`GRWLock`](@ref)

Obtain a read lock on \\_lock and return a new #[`GRWLockReaderLocker`](@ref). Unlock with [`g_rw_lock_reader_locker_free`](@ref)(). Using [`g_rw_lock_reader_unlock`](@ref)() on \\_lock while a #[`GRWLockReaderLocker`](@ref) exists can lead to undefined behaviour.

No allocation is performed, it is equivalent to a [`g_rw_lock_reader_lock`](@ref)() call.

This is intended to be used with [`g_autoptr`](@ref)(). For a code sample, see [`g_rw_lock_writer_locker_new`](@ref)().

Returns: a #[`GRWLockReaderLocker`](@ref) Since: 2.62

### Prototype
```c
static inline GRWLockReaderLocker * g_rw_lock_reader_locker_new (GRWLock *rw_lock);
```
"""
function g_rw_lock_reader_locker_new(rw_lock)
    @ccall libaravis.g_rw_lock_reader_locker_new(rw_lock::Ptr{GRWLock})::Ptr{GRWLockReaderLocker}
end

"""
    g_bookmark_file_error_quark()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GQuark g_bookmark_file_error_quark (void);
```
"""
function g_bookmark_file_error_quark()
    @ccall libaravis.g_bookmark_file_error_quark()::GQuark
end

"""
    g_convert_error_quark()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GQuark g_convert_error_quark (void);
```
"""
function g_convert_error_quark()
    @ccall libaravis.g_convert_error_quark()::GQuark
end

const _GData = Cvoid

const GData = _GData

"""
    g_datalist_id_set_data_full(datalist, key_id, data, destroy_func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_datalist_id_set_data_full (GData **datalist, GQuark key_id, gpointer data, GDestroyNotify destroy_func);
```
"""
function g_datalist_id_set_data_full(datalist, key_id, data, destroy_func)
    @ccall libaravis.g_datalist_id_set_data_full(datalist::Ptr{Ptr{GData}}, key_id::GQuark, data::gpointer, destroy_func::GDestroyNotify)::Cvoid
end

"""
    g_quark_from_string(string)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GQuark g_quark_from_string (const gchar *string);
```
"""
function g_quark_from_string(string)
    @ccall libaravis.g_quark_from_string(string::Ptr{gchar})::GQuark
end

"""
    g_datalist_id_remove_no_notify(datalist, key_id)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_datalist_id_remove_no_notify (GData **datalist, GQuark key_id);
```
"""
function g_datalist_id_remove_no_notify(datalist, key_id)
    @ccall libaravis.g_datalist_id_remove_no_notify(datalist::Ptr{Ptr{GData}}, key_id::GQuark)::gpointer
end

"""
    g_quark_try_string(string)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GQuark g_quark_try_string (const gchar *string);
```
"""
function g_quark_try_string(string)
    @ccall libaravis.g_quark_try_string(string::Ptr{gchar})::GQuark
end

"""
    g_dataset_id_set_data_full(dataset_location, key_id, data, destroy_func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_dataset_id_set_data_full (gconstpointer dataset_location, GQuark key_id, gpointer data, GDestroyNotify destroy_func);
```
"""
function g_dataset_id_set_data_full(dataset_location, key_id, data, destroy_func)
    @ccall libaravis.g_dataset_id_set_data_full(dataset_location::gconstpointer, key_id::GQuark, data::gpointer, destroy_func::GDestroyNotify)::Cvoid
end

"""
    g_dataset_id_get_data(dataset_location, key_id)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_dataset_id_get_data (gconstpointer dataset_location, GQuark key_id);
```
"""
function g_dataset_id_get_data(dataset_location, key_id)
    @ccall libaravis.g_dataset_id_get_data(dataset_location::gconstpointer, key_id::GQuark)::gpointer
end

"""
    g_dataset_id_remove_no_notify(dataset_location, key_id)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_dataset_id_remove_no_notify (gconstpointer dataset_location, GQuark key_id);
```
"""
function g_dataset_id_remove_no_notify(dataset_location, key_id)
    @ccall libaravis.g_dataset_id_remove_no_notify(dataset_location::gconstpointer, key_id::GQuark)::gpointer
end

struct _GDate
    data::NTuple{8, UInt8}
end

function Base.getproperty(x::Ptr{_GDate}, f::Symbol)
    f === :julian_days && return (Ptr{guint}(x + 0), 0, 32)
    f === :julian && return (Ptr{guint}(x + 4), 0, 1)
    f === :dmy && return (Ptr{guint}(x + 4), 1, 1)
    f === :day && return (Ptr{guint}(x + 4), 2, 6)
    f === :month && return (Ptr{guint}(x + 4), 8, 4)
    f === :year && return (Ptr{guint}(x + 4), 12, 16)
    return getfield(x, f)
end

function Base.getproperty(x::_GDate, f::Symbol)
    r = Ref{_GDate}(x)
    ptr = Base.unsafe_convert(Ptr{_GDate}, r)
    fptr = getproperty(ptr, f)
    begin
        if fptr isa Ptr
            return GC.@preserve(r, unsafe_load(fptr))
        else
            (baseptr, offset, width) = fptr
            ty = eltype(baseptr)
            baseptr32 = convert(Ptr{UInt32}, baseptr)
            u64 = GC.@preserve(r, unsafe_load(baseptr32))
            if offset + width > 32
                u64 |= GC.@preserve(r, unsafe_load(baseptr32 + 4)) << 32
            end
            u64 = u64 >> offset & (1 << width - 1)
            return u64 % ty
        end
    end
end

function Base.setproperty!(x::Ptr{_GDate}, f::Symbol, v)
    fptr = getproperty(x, f)
    if fptr isa Ptr
        unsafe_store!(getproperty(x, f), v)
    else
        (baseptr, offset, width) = fptr
        baseptr32 = convert(Ptr{UInt32}, baseptr)
        u64 = unsafe_load(baseptr32)
        straddle = offset + width > 32
        if straddle
            u64 |= unsafe_load(baseptr32 + 4) << 32
        end
        mask = 1 << width - 1
        u64 &= ~(mask << offset)
        u64 |= (unsigned(v) & mask) << offset
        unsafe_store!(baseptr32, u64 & typemax(UInt32))
        if straddle
            unsafe_store!(baseptr32 + 4, u64 >> 32)
        end
    end
end

function Base.propertynames(x::_GDate, private::Bool = false)
    (:julian_days, :julian, :dmy, :day, :month, :year, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

const GDate = _GDate

@cenum GDateWeekday::UInt32 begin
    G_DATE_BAD_WEEKDAY = 0
    G_DATE_MONDAY = 1
    G_DATE_TUESDAY = 2
    G_DATE_WEDNESDAY = 3
    G_DATE_THURSDAY = 4
    G_DATE_FRIDAY = 5
    G_DATE_SATURDAY = 6
    G_DATE_SUNDAY = 7
end

"""
    g_date_get_weekday(date)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GDateWeekday g_date_get_weekday (const GDate *date);
```
"""
function g_date_get_weekday(date)
    @ccall libaravis.g_date_get_weekday(date::Ptr{GDate})::GDateWeekday
end

@cenum GDateMonth::UInt32 begin
    G_DATE_BAD_MONTH = 0
    G_DATE_JANUARY = 1
    G_DATE_FEBRUARY = 2
    G_DATE_MARCH = 3
    G_DATE_APRIL = 4
    G_DATE_MAY = 5
    G_DATE_JUNE = 6
    G_DATE_JULY = 7
    G_DATE_AUGUST = 8
    G_DATE_SEPTEMBER = 9
    G_DATE_OCTOBER = 10
    G_DATE_NOVEMBER = 11
    G_DATE_DECEMBER = 12
end

"""
    g_date_get_month(date)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GDateMonth g_date_get_month (const GDate *date);
```
"""
function g_date_get_month(date)
    @ccall libaravis.g_date_get_month(date::Ptr{GDate})::GDateMonth
end

const GDateYear = guint16

"""
    g_date_get_year(date)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GDateYear g_date_get_year (const GDate *date);
```
"""
function g_date_get_year(date)
    @ccall libaravis.g_date_get_year(date::Ptr{GDate})::GDateYear
end

const GDateDay = guint8

"""
    g_date_get_day(date)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GDateDay g_date_get_day (const GDate *date);
```
"""
function g_date_get_day(date)
    @ccall libaravis.g_date_get_day(date::Ptr{GDate})::GDateDay
end

"""
    g_date_get_julian(date)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint32 g_date_get_julian (const GDate *date);
```
"""
function g_date_get_julian(date)
    @ccall libaravis.g_date_get_julian(date::Ptr{GDate})::guint32
end

"""
    g_date_get_day_of_year(date)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_date_get_day_of_year (const GDate *date);
```
"""
function g_date_get_day_of_year(date)
    @ccall libaravis.g_date_get_day_of_year(date::Ptr{GDate})::guint
end

"""
    g_date_get_monday_week_of_year(date)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_date_get_monday_week_of_year (const GDate *date);
```
"""
function g_date_get_monday_week_of_year(date)
    @ccall libaravis.g_date_get_monday_week_of_year(date::Ptr{GDate})::guint
end

"""
    g_date_get_sunday_week_of_year(date)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_date_get_sunday_week_of_year (const GDate *date);
```
"""
function g_date_get_sunday_week_of_year(date)
    @ccall libaravis.g_date_get_sunday_week_of_year(date::Ptr{GDate})::guint
end

"""
    g_date_get_days_in_month(month, year)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint8 g_date_get_days_in_month (GDateMonth month, GDateYear year) G_GNUC_CONST;
```
"""
function g_date_get_days_in_month(month, year)
    @ccall libaravis.g_date_get_days_in_month(month::GDateMonth, year::GDateYear)::guint8
end

"""
    g_date_get_monday_weeks_in_year(year)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint8 g_date_get_monday_weeks_in_year (GDateYear year) G_GNUC_CONST;
```
"""
function g_date_get_monday_weeks_in_year(year)
    @ccall libaravis.g_date_get_monday_weeks_in_year(year::GDateYear)::guint8
end

"""
    g_date_get_sunday_weeks_in_year(year)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint8 g_date_get_sunday_weeks_in_year (GDateYear year) G_GNUC_CONST;
```
"""
function g_date_get_sunday_weeks_in_year(year)
    @ccall libaravis.g_date_get_sunday_weeks_in_year(year::GDateYear)::guint8
end

"""
    g_file_error_quark()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GQuark g_file_error_quark (void);
```
"""
function g_file_error_quark()
    @ccall libaravis.g_file_error_quark()::GQuark
end

"""
    g_path_get_dirname(file_name)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_path_get_dirname (const gchar *file_name) G_GNUC_MALLOC;
```
"""
function g_path_get_dirname(file_name)
    @ccall libaravis.g_path_get_dirname(file_name::Ptr{gchar})::Ptr{gchar}
end

struct _GNode
    data::gpointer
    next::Ptr{Cvoid} # next::Ptr{GNode}
    prev::Ptr{Cvoid} # prev::Ptr{GNode}
    parent::Ptr{Cvoid} # parent::Ptr{GNode}
    children::Ptr{Cvoid} # children::Ptr{GNode}
end

function Base.getproperty(x::_GNode, f::Symbol)
    f === :next && return Ptr{GNode}(getfield(x, f))
    f === :prev && return Ptr{GNode}(getfield(x, f))
    f === :parent && return Ptr{GNode}(getfield(x, f))
    f === :children && return Ptr{GNode}(getfield(x, f))
    return getfield(x, f)
end

const GNode = _GNode

"""
    g_node_insert_before(parent, sibling, node)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GNode* g_node_insert_before (GNode *parent, GNode *sibling, GNode *node);
```
"""
function g_node_insert_before(parent, sibling, node)
    @ccall libaravis.g_node_insert_before(parent::Ptr{GNode}, sibling::Ptr{GNode}, node::Ptr{GNode})::Ptr{GNode}
end

"""
    g_node_insert(parent, position, node)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GNode* g_node_insert (GNode *parent, gint position, GNode *node);
```
"""
function g_node_insert(parent, position, node)
    @ccall libaravis.g_node_insert(parent::Ptr{GNode}, position::gint, node::Ptr{GNode})::Ptr{GNode}
end

"""
    g_node_new(data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GNode* g_node_new (gpointer data);
```
"""
function g_node_new(data)
    @ccall libaravis.g_node_new(data::gpointer)::Ptr{GNode}
end

"""
    g_node_insert_after(parent, sibling, node)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GNode* g_node_insert_after (GNode *parent, GNode *sibling, GNode *node);
```
"""
function g_node_insert_after(parent, sibling, node)
    @ccall libaravis.g_node_insert_after(parent::Ptr{GNode}, sibling::Ptr{GNode}, node::Ptr{GNode})::Ptr{GNode}
end

"""
    g_node_prepend(parent, node)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GNode* g_node_prepend (GNode *parent, GNode *node);
```
"""
function g_node_prepend(parent, node)
    @ccall libaravis.g_node_prepend(parent::Ptr{GNode}, node::Ptr{GNode})::Ptr{GNode}
end

"""
    g_list_free_1(list)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_list_free_1 (GList *list);
```
"""
function g_list_free_1(list)
    @ccall libaravis.g_list_free_1(list::Ptr{GList})::Cvoid
end

"""
    g_list_free(list)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_list_free (GList *list);
```
"""
function g_list_free(list)
    @ccall libaravis.g_list_free(list::Ptr{GList})::Cvoid
end

struct _GHook
    data::gpointer
    next::Ptr{Cvoid} # next::Ptr{GHook}
    prev::Ptr{Cvoid} # prev::Ptr{GHook}
    ref_count::guint
    hook_id::gulong
    flags::guint
    func::gpointer
    destroy::GDestroyNotify
end

function Base.getproperty(x::_GHook, f::Symbol)
    f === :next && return Ptr{GHook}(getfield(x, f))
    f === :prev && return Ptr{GHook}(getfield(x, f))
    return getfield(x, f)
end

const GHook = _GHook

# typedef void ( * GHookFinalizeFunc ) ( GHookList * hook_list , GHook * hook )
const GHookFinalizeFunc = Ptr{Cvoid}

struct _GHookList
    data::NTuple{56, UInt8}
end

function Base.getproperty(x::Ptr{_GHookList}, f::Symbol)
    f === :seq_id && return Ptr{gulong}(x + 0)
    f === :hook_size && return (Ptr{guint}(x + 8), 0, 16)
    f === :is_setup && return (Ptr{guint}(x + 8), 16, 1)
    f === :hooks && return Ptr{Ptr{GHook}}(x + 16)
    f === :dummy3 && return Ptr{gpointer}(x + 24)
    f === :finalize_hook && return Ptr{GHookFinalizeFunc}(x + 32)
    f === :dummy && return Ptr{NTuple{2, gpointer}}(x + 40)
    return getfield(x, f)
end

function Base.getproperty(x::_GHookList, f::Symbol)
    r = Ref{_GHookList}(x)
    ptr = Base.unsafe_convert(Ptr{_GHookList}, r)
    fptr = getproperty(ptr, f)
    begin
        if fptr isa Ptr
            return GC.@preserve(r, unsafe_load(fptr))
        else
            (baseptr, offset, width) = fptr
            ty = eltype(baseptr)
            baseptr32 = convert(Ptr{UInt32}, baseptr)
            u64 = GC.@preserve(r, unsafe_load(baseptr32))
            if offset + width > 32
                u64 |= GC.@preserve(r, unsafe_load(baseptr32 + 4)) << 32
            end
            u64 = u64 >> offset & (1 << width - 1)
            return u64 % ty
        end
    end
end

function Base.setproperty!(x::Ptr{_GHookList}, f::Symbol, v)
    fptr = getproperty(x, f)
    if fptr isa Ptr
        unsafe_store!(getproperty(x, f), v)
    else
        (baseptr, offset, width) = fptr
        baseptr32 = convert(Ptr{UInt32}, baseptr)
        u64 = unsafe_load(baseptr32)
        straddle = offset + width > 32
        if straddle
            u64 |= unsafe_load(baseptr32 + 4) << 32
        end
        mask = 1 << width - 1
        u64 &= ~(mask << offset)
        u64 |= (unsigned(v) & mask) << offset
        unsafe_store!(baseptr32, u64 & typemax(UInt32))
        if straddle
            unsafe_store!(baseptr32 + 4, u64 >> 32)
        end
    end
end

function Base.propertynames(x::_GHookList, private::Bool = false)
    (:seq_id, :hook_size, :is_setup, :hooks, :dummy3, :finalize_hook, :dummy, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

const GHookList = _GHookList

"""
    g_hook_insert_before(hook_list, sibling, hook)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_hook_insert_before (GHookList *hook_list, GHook *sibling, GHook *hook);
```
"""
function g_hook_insert_before(hook_list, sibling, hook)
    @ccall libaravis.g_hook_insert_before(hook_list::Ptr{GHookList}, sibling::Ptr{GHook}, hook::Ptr{GHook})::Cvoid
end

"""
    g_slist_free_1(list)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_slist_free_1 (GSList *list);
```
"""
function g_slist_free_1(list)
    @ccall libaravis.g_slist_free_1(list::Ptr{GSList})::Cvoid
end

"""
    g_slist_free(list)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_slist_free (GSList *list);
```
"""
function g_slist_free(list)
    @ccall libaravis.g_slist_free(list::Ptr{GSList})::Cvoid
end

# typedef gboolean ( * GSourceFunc ) ( gpointer user_data )
"""
[`GSourceFunc`](@ref): \\_data: data passed to the function, set when the source was created with one of the above functions

Specifies the type of function passed to [func.timeout\\_add], [func.timeout\\_add\\_full], [func.idle\\_add], and [func.idle\\_add\\_full].

When calling [method.Source.set\\_callback], you may need to cast a function of a different type to this type. Use [func.SOURCE\\_FUNC] to avoid warnings about incompatible function types.

Returns: FALSE if the source should be removed. [const.SOURCE\\_CONTINUE] and [const.SOURCE\\_REMOVE] are more memorable names for the return value.
"""
const GSourceFunc = Ptr{Cvoid}

const guchar = Cuchar

"""
    g_strchomp(string)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_strchomp (gchar *string);
```
"""
function g_strchomp(string)
    @ccall libaravis.g_strchomp(string::Ptr{gchar})::Ptr{gchar}
end

"""
    g_strchug(string)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_strchug (gchar *string);
```
"""
function g_strchug(string)
    @ccall libaravis.g_strchug(string::Ptr{gchar})::Ptr{gchar}
end

"""
    g_strdup_inline(str)

### Prototype
```c
G_ALWAYS_INLINE static inline char * g_strdup_inline (const char *str);
```
"""
function g_strdup_inline(str)
    @ccall libaravis.g_strdup_inline(str::Cstring)::Cstring
end

"""
    g_number_parser_error_quark()

### Prototype
```c
GLIB_AVAILABLE_IN_2_54 GQuark g_number_parser_error_quark (void);
```
"""
function g_number_parser_error_quark()
    @ccall libaravis.g_number_parser_error_quark()::GQuark
end

struct _GString
    str::Ptr{gchar}
    len::gsize
    allocated_len::gsize
end

const GString = _GString

"""
    g_string_free_and_steal(string)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 gchar* g_string_free_and_steal (GString *string) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_string_free_and_steal(string)
    @ccall libaravis.g_string_free_and_steal(string::Ptr{GString})::Ptr{gchar}
end

"""
    g_string_append_c_inline(gstring, c)

### Prototype
```c
G_ALWAYS_INLINE static inline GString* g_string_append_c_inline (GString *gstring, gchar c);
```
"""
function g_string_append_c_inline(gstring, c)
    @ccall libaravis.g_string_append_c_inline(gstring::Ptr{GString}, c::gchar)::Ptr{GString}
end

"""
    g_string_append_len_inline(gstring, val, len)

### Prototype
```c
G_ALWAYS_INLINE static inline GString * g_string_append_len_inline (GString *gstring, const char *val, gssize len);
```
"""
function g_string_append_len_inline(gstring, val, len)
    @ccall libaravis.g_string_append_len_inline(gstring::Ptr{GString}, val::Cstring, len::gssize)::Ptr{GString}
end

"""
    g_string_truncate_inline(gstring, len)

### Prototype
```c
G_ALWAYS_INLINE static inline GString * g_string_truncate_inline (GString *gstring, gsize len);
```
"""
function g_string_truncate_inline(gstring, len)
    @ccall libaravis.g_string_truncate_inline(gstring::Ptr{GString}, len::gsize)::Ptr{GString}
end

"""
    g_io_channel_error_quark()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GQuark g_io_channel_error_quark (void);
```
"""
function g_io_channel_error_quark()
    @ccall libaravis.g_io_channel_error_quark()::GQuark
end

"""
    g_key_file_error_quark()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GQuark g_key_file_error_quark (void);
```
"""
function g_key_file_error_quark()
    @ccall libaravis.g_key_file_error_quark()::GQuark
end

"""
    g_markup_error_quark()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GQuark g_markup_error_quark (void);
```
"""
function g_markup_error_quark()
    @ccall libaravis.g_markup_error_quark()::GQuark
end

const _GVariantType = Cvoid

const GVariantType = _GVariantType

"""
    g_variant_type_checked_(type_string)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const GVariantType * g_variant_type_checked_ (const gchar *type_string);
```
"""
function g_variant_type_checked_(type_string)
    @ccall libaravis.g_variant_type_checked_(type_string::Ptr{gchar})::Ptr{GVariantType}
end

"""
    g_variant_parse_error_quark()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GQuark g_variant_parse_error_quark (void);
```
"""
function g_variant_parse_error_quark()
    @ccall libaravis.g_variant_parse_error_quark()::GQuark
end

"""
    g_get_monotonic_time()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint64 g_get_monotonic_time (void);
```
"""
function g_get_monotonic_time()
    @ccall libaravis.g_get_monotonic_time()::gint64
end

"""
    g_warn_message(domain, file, line, func, warnexpr)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_warn_message (const char *domain, const char *file, int line, const char *func, const char *warnexpr);
```
"""
function g_warn_message(domain, file, line, func, warnexpr)
    @ccall libaravis.g_warn_message(domain::Cstring, file::Cstring, line::Cint, func::Cstring, warnexpr::Cstring)::Cvoid
end

"""
    g_option_error_quark()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GQuark g_option_error_quark (void);
```
"""
function g_option_error_quark()
    @ccall libaravis.g_option_error_quark()::GQuark
end

const _GRand = Cvoid

const GRand = _GRand

"""
    g_rand_int(rand_)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint32 g_rand_int (GRand *rand_);
```
"""
function g_rand_int(rand_)
    @ccall libaravis.g_rand_int(rand_::Ptr{GRand})::guint32
end

"""
    g_random_int()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint32 g_random_int (void);
```
"""
function g_random_int()
    @ccall libaravis.g_random_int()::guint32
end

"""
    g_rc_box_alloc(block_size)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 gpointer g_rc_box_alloc (gsize block_size) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
```
"""
function g_rc_box_alloc(block_size)
    @ccall libaravis.g_rc_box_alloc(block_size::gsize)::gpointer
end

"""
    g_rc_box_alloc0(block_size)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 gpointer g_rc_box_alloc0 (gsize block_size) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
```
"""
function g_rc_box_alloc0(block_size)
    @ccall libaravis.g_rc_box_alloc0(block_size::gsize)::gpointer
end

"""
    g_atomic_rc_box_alloc(block_size)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 gpointer g_atomic_rc_box_alloc (gsize block_size) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
```
"""
function g_atomic_rc_box_alloc(block_size)
    @ccall libaravis.g_atomic_rc_box_alloc(block_size::gsize)::gpointer
end

"""
    g_atomic_rc_box_alloc0(block_size)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 gpointer g_atomic_rc_box_alloc0 (gsize block_size) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
```
"""
function g_atomic_rc_box_alloc0(block_size)
    @ccall libaravis.g_atomic_rc_box_alloc0(block_size::gsize)::gpointer
end

"""
    g_regex_error_quark()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GQuark g_regex_error_quark (void);
```
"""
function g_regex_error_quark()
    @ccall libaravis.g_regex_error_quark()::GQuark
end

struct _GScannerConfig
    data::NTuple{40, UInt8}
end

function Base.getproperty(x::Ptr{_GScannerConfig}, f::Symbol)
    f === :cset_skip_characters && return Ptr{Ptr{gchar}}(x + 0)
    f === :cset_identifier_first && return Ptr{Ptr{gchar}}(x + 8)
    f === :cset_identifier_nth && return Ptr{Ptr{gchar}}(x + 16)
    f === :cpair_comment_single && return Ptr{Ptr{gchar}}(x + 24)
    f === :case_sensitive && return (Ptr{guint}(x + 32), 0, 1)
    f === :skip_comment_multi && return (Ptr{guint}(x + 32), 1, 1)
    f === :skip_comment_single && return (Ptr{guint}(x + 32), 2, 1)
    f === :scan_comment_multi && return (Ptr{guint}(x + 32), 3, 1)
    f === :scan_identifier && return (Ptr{guint}(x + 32), 4, 1)
    f === :scan_identifier_1char && return (Ptr{guint}(x + 32), 5, 1)
    f === :scan_identifier_NULL && return (Ptr{guint}(x + 32), 6, 1)
    f === :scan_symbols && return (Ptr{guint}(x + 32), 7, 1)
    f === :scan_binary && return (Ptr{guint}(x + 32), 8, 1)
    f === :scan_octal && return (Ptr{guint}(x + 32), 9, 1)
    f === :scan_float && return (Ptr{guint}(x + 32), 10, 1)
    f === :scan_hex && return (Ptr{guint}(x + 32), 11, 1)
    f === :scan_hex_dollar && return (Ptr{guint}(x + 32), 12, 1)
    f === :scan_string_sq && return (Ptr{guint}(x + 32), 13, 1)
    f === :scan_string_dq && return (Ptr{guint}(x + 32), 14, 1)
    f === :numbers_2_int && return (Ptr{guint}(x + 32), 15, 1)
    f === :int_2_float && return (Ptr{guint}(x + 32), 16, 1)
    f === :identifier_2_string && return (Ptr{guint}(x + 32), 17, 1)
    f === :char_2_token && return (Ptr{guint}(x + 32), 18, 1)
    f === :symbol_2_token && return (Ptr{guint}(x + 32), 19, 1)
    f === :scope_0_fallback && return (Ptr{guint}(x + 32), 20, 1)
    f === :store_int64 && return (Ptr{guint}(x + 32), 21, 1)
    f === :padding_dummy && return Ptr{guint}(x + 36)
    return getfield(x, f)
end

function Base.getproperty(x::_GScannerConfig, f::Symbol)
    r = Ref{_GScannerConfig}(x)
    ptr = Base.unsafe_convert(Ptr{_GScannerConfig}, r)
    fptr = getproperty(ptr, f)
    begin
        if fptr isa Ptr
            return GC.@preserve(r, unsafe_load(fptr))
        else
            (baseptr, offset, width) = fptr
            ty = eltype(baseptr)
            baseptr32 = convert(Ptr{UInt32}, baseptr)
            u64 = GC.@preserve(r, unsafe_load(baseptr32))
            if offset + width > 32
                u64 |= GC.@preserve(r, unsafe_load(baseptr32 + 4)) << 32
            end
            u64 = u64 >> offset & (1 << width - 1)
            return u64 % ty
        end
    end
end

function Base.setproperty!(x::Ptr{_GScannerConfig}, f::Symbol, v)
    fptr = getproperty(x, f)
    if fptr isa Ptr
        unsafe_store!(getproperty(x, f), v)
    else
        (baseptr, offset, width) = fptr
        baseptr32 = convert(Ptr{UInt32}, baseptr)
        u64 = unsafe_load(baseptr32)
        straddle = offset + width > 32
        if straddle
            u64 |= unsafe_load(baseptr32 + 4) << 32
        end
        mask = 1 << width - 1
        u64 &= ~(mask << offset)
        u64 |= (unsigned(v) & mask) << offset
        unsafe_store!(baseptr32, u64 & typemax(UInt32))
        if straddle
            unsafe_store!(baseptr32 + 4, u64 >> 32)
        end
    end
end

function Base.propertynames(x::_GScannerConfig, private::Bool = false)
    (:cset_skip_characters, :cset_identifier_first, :cset_identifier_nth, :cpair_comment_single, :case_sensitive, :skip_comment_multi, :skip_comment_single, :scan_comment_multi, :scan_identifier, :scan_identifier_1char, :scan_identifier_NULL, :scan_symbols, :scan_binary, :scan_octal, :scan_float, :scan_hex, :scan_hex_dollar, :scan_string_sq, :scan_string_dq, :numbers_2_int, :int_2_float, :identifier_2_string, :char_2_token, :symbol_2_token, :scope_0_fallback, :store_int64, :padding_dummy, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

const GScannerConfig = _GScannerConfig

@cenum GTokenType::UInt32 begin
    G_TOKEN_EOF = 0
    G_TOKEN_LEFT_PAREN = 40
    G_TOKEN_RIGHT_PAREN = 41
    G_TOKEN_LEFT_CURLY = 123
    G_TOKEN_RIGHT_CURLY = 125
    G_TOKEN_LEFT_BRACE = 91
    G_TOKEN_RIGHT_BRACE = 93
    G_TOKEN_EQUAL_SIGN = 61
    G_TOKEN_COMMA = 44
    G_TOKEN_NONE = 256
    G_TOKEN_ERROR = 257
    G_TOKEN_CHAR = 258
    G_TOKEN_BINARY = 259
    G_TOKEN_OCTAL = 260
    G_TOKEN_INT = 261
    G_TOKEN_HEX = 262
    G_TOKEN_FLOAT = 263
    G_TOKEN_STRING = 264
    G_TOKEN_SYMBOL = 265
    G_TOKEN_IDENTIFIER = 266
    G_TOKEN_IDENTIFIER_NULL = 267
    G_TOKEN_COMMENT_SINGLE = 268
    G_TOKEN_COMMENT_MULTI = 269
    G_TOKEN_LAST = 270
end

struct _GTokenValue
    data::NTuple{8, UInt8}
end

function Base.getproperty(x::Ptr{_GTokenValue}, f::Symbol)
    f === :v_symbol && return Ptr{gpointer}(x + 0)
    f === :v_identifier && return Ptr{Ptr{gchar}}(x + 0)
    f === :v_binary && return Ptr{gulong}(x + 0)
    f === :v_octal && return Ptr{gulong}(x + 0)
    f === :v_int && return Ptr{gulong}(x + 0)
    f === :v_int64 && return Ptr{guint64}(x + 0)
    f === :v_float && return Ptr{gdouble}(x + 0)
    f === :v_hex && return Ptr{gulong}(x + 0)
    f === :v_string && return Ptr{Ptr{gchar}}(x + 0)
    f === :v_comment && return Ptr{Ptr{gchar}}(x + 0)
    f === :v_char && return Ptr{guchar}(x + 0)
    f === :v_error && return Ptr{guint}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::_GTokenValue, f::Symbol)
    r = Ref{_GTokenValue}(x)
    ptr = Base.unsafe_convert(Ptr{_GTokenValue}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{_GTokenValue}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::_GTokenValue, private::Bool = false)
    (:v_symbol, :v_identifier, :v_binary, :v_octal, :v_int, :v_int64, :v_float, :v_hex, :v_string, :v_comment, :v_char, :v_error, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

const GTokenValue = _GTokenValue

const _GHashTable = Cvoid

const GHashTable = _GHashTable

# typedef void ( * GScannerMsgFunc ) ( GScanner * scanner , gchar * message , gboolean error )
const GScannerMsgFunc = Ptr{Cvoid}

struct _GScanner
    data::NTuple{144, UInt8}
end

function Base.getproperty(x::Ptr{_GScanner}, f::Symbol)
    f === :user_data && return Ptr{gpointer}(x + 0)
    f === :max_parse_errors && return Ptr{guint}(x + 8)
    f === :parse_errors && return Ptr{guint}(x + 12)
    f === :input_name && return Ptr{Ptr{gchar}}(x + 16)
    f === :qdata && return Ptr{Ptr{GData}}(x + 24)
    f === :config && return Ptr{Ptr{GScannerConfig}}(x + 32)
    f === :token && return Ptr{GTokenType}(x + 40)
    f === :value && return Ptr{GTokenValue}(x + 48)
    f === :line && return Ptr{guint}(x + 56)
    f === :position && return Ptr{guint}(x + 60)
    f === :next_token && return Ptr{GTokenType}(x + 64)
    f === :next_value && return Ptr{GTokenValue}(x + 72)
    f === :next_line && return Ptr{guint}(x + 80)
    f === :next_position && return Ptr{guint}(x + 84)
    f === :symbol_table && return Ptr{Ptr{GHashTable}}(x + 88)
    f === :input_fd && return Ptr{gint}(x + 96)
    f === :text && return Ptr{Ptr{gchar}}(x + 104)
    f === :text_end && return Ptr{Ptr{gchar}}(x + 112)
    f === :buffer && return Ptr{Ptr{gchar}}(x + 120)
    f === :scope_id && return Ptr{guint}(x + 128)
    f === :msg_handler && return Ptr{GScannerMsgFunc}(x + 136)
    return getfield(x, f)
end

function Base.getproperty(x::_GScanner, f::Symbol)
    r = Ref{_GScanner}(x)
    ptr = Base.unsafe_convert(Ptr{_GScanner}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{_GScanner}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::_GScanner, private::Bool = false)
    (:user_data, :max_parse_errors, :parse_errors, :input_name, :qdata, :config, :token, :value, :line, :position, :next_token, :next_value, :next_line, :next_position, :symbol_table, :input_fd, :text, :text_end, :buffer, :scope_id, :msg_handler, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

const GScanner = _GScanner

"""
    g_scanner_scope_add_symbol(scanner, scope_id, symbol, value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_scanner_scope_add_symbol (GScanner *scanner, guint scope_id, const gchar *symbol, gpointer value);
```
"""
function g_scanner_scope_add_symbol(scanner, scope_id, symbol, value)
    @ccall libaravis.g_scanner_scope_add_symbol(scanner::Ptr{GScanner}, scope_id::guint, symbol::Ptr{gchar}, value::gpointer)::Cvoid
end

"""
    g_scanner_scope_remove_symbol(scanner, scope_id, symbol)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_scanner_scope_remove_symbol (GScanner *scanner, guint scope_id, const gchar *symbol);
```
"""
function g_scanner_scope_remove_symbol(scanner, scope_id, symbol)
    @ccall libaravis.g_scanner_scope_remove_symbol(scanner::Ptr{GScanner}, scope_id::guint, symbol::Ptr{gchar})::Cvoid
end

# typedef void ( * GHFunc ) ( gpointer key , gpointer value , gpointer user_data )
const GHFunc = Ptr{Cvoid}

"""
    g_scanner_scope_foreach_symbol(scanner, scope_id, func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_scanner_scope_foreach_symbol (GScanner *scanner, guint scope_id, GHFunc func, gpointer user_data);
```
"""
function g_scanner_scope_foreach_symbol(scanner, scope_id, func, user_data)
    @ccall libaravis.g_scanner_scope_foreach_symbol(scanner::Ptr{GScanner}, scope_id::guint, func::GHFunc, user_data::gpointer)::Cvoid
end

"""
    g_shell_error_quark()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GQuark g_shell_error_quark (void);
```
"""
function g_shell_error_quark()
    @ccall libaravis.g_shell_error_quark()::GQuark
end

"""
    g_slice_alloc(block_size)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_slice_alloc (gsize block_size) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
```
"""
function g_slice_alloc(block_size)
    @ccall libaravis.g_slice_alloc(block_size::gsize)::gpointer
end

"""
    g_slice_alloc0(block_size)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_slice_alloc0 (gsize block_size) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
```
"""
function g_slice_alloc0(block_size)
    @ccall libaravis.g_slice_alloc0(block_size::gsize)::gpointer
end

"""
    g_slice_copy(block_size, mem_block)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_slice_copy (gsize block_size, gconstpointer mem_block) G_GNUC_ALLOC_SIZE(1);
```
"""
function g_slice_copy(block_size, mem_block)
    @ccall libaravis.g_slice_copy(block_size::gsize, mem_block::gconstpointer)::gpointer
end

"""
    g_slice_free1(block_size, mem_block)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_slice_free1 (gsize block_size, gpointer mem_block);
```
"""
function g_slice_free1(block_size, mem_block)
    @ccall libaravis.g_slice_free1(block_size::gsize, mem_block::gpointer)::Cvoid
end

"""
    g_slice_free_chain_with_offset(block_size, mem_chain, next_offset)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_slice_free_chain_with_offset (gsize block_size, gpointer mem_chain, gsize next_offset);
```
"""
function g_slice_free_chain_with_offset(block_size, mem_chain, next_offset)
    @ccall libaravis.g_slice_free_chain_with_offset(block_size::gsize, mem_chain::gpointer, next_offset::gsize)::Cvoid
end

"""
    g_spawn_error_quark()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GQuark g_spawn_error_quark (void);
```
"""
function g_spawn_error_quark()
    @ccall libaravis.g_spawn_error_quark()::GQuark
end

"""
    g_spawn_exit_error_quark()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GQuark g_spawn_exit_error_quark (void);
```
"""
function g_spawn_exit_error_quark()
    @ccall libaravis.g_spawn_exit_error_quark()::GQuark
end

"""
    g_strcmp0(str1, str2)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL int g_strcmp0 (const char *str1, const char *str2);
```
"""
function g_strcmp0(str1, str2)
    @ccall libaravis.g_strcmp0(str1::Cstring, str2::Cstring)::Cint
end

"""
    g_assertion_message_cmpstr(domain, file, line, func, expr, arg1, cmp, arg2)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_assertion_message_cmpstr (const char *domain, const char *file, int line, const char *func, const char *expr, const char *arg1, const char *cmp, const char *arg2);
```
"""
function g_assertion_message_cmpstr(domain, file, line, func, expr, arg1, cmp, arg2)
    @ccall libaravis.g_assertion_message_cmpstr(domain::Cstring, file::Cstring, line::Cint, func::Cstring, expr::Cstring, arg1::Cstring, cmp::Cstring, arg2::Cstring)::Cvoid
end

"""
    g_assertion_message_cmpint(domain, file, line, func, expr, arg1, cmp, arg2, numtype)

### Prototype
```c
GLIB_AVAILABLE_IN_2_78 void g_assertion_message_cmpint (const char *domain, const char *file, int line, const char *func, const char *expr, guint64 arg1, const char *cmp, guint64 arg2, char numtype);
```
"""
function g_assertion_message_cmpint(domain, file, line, func, expr, arg1, cmp, arg2, numtype)
    @ccall libaravis.g_assertion_message_cmpint(domain::Cstring, file::Cstring, line::Cint, func::Cstring, expr::Cstring, arg1::guint64, cmp::Cstring, arg2::guint64, numtype::Cchar)::Cvoid
end

"""
    g_assertion_message_cmpnum(domain, file, line, func, expr, arg1, cmp, arg2, numtype)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_assertion_message_cmpnum (const char *domain, const char *file, int line, const char *func, const char *expr, long double arg1, const char *cmp, long double arg2, char numtype);
```
"""
function g_assertion_message_cmpnum(domain, file, line, func, expr, arg1, cmp, arg2, numtype)
    @ccall libaravis.g_assertion_message_cmpnum(domain::Cstring, file::Cstring, line::Cint, func::Cstring, expr::Cstring, arg1::Float64, cmp::Cstring, arg2::Float64, numtype::Cchar)::Cvoid
end

"""
    g_assertion_message(domain, file, line, func, message)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_assertion_message (const char *domain, const char *file, int line, const char *func, const char *message);
```
"""
function g_assertion_message(domain, file, line, func, message)
    @ccall libaravis.g_assertion_message(domain::Cstring, file::Cstring, line::Cint, func::Cstring, message::Cstring)::Cvoid
end

const _GVariant = Cvoid

const GVariant = _GVariant

"""
    g_variant_equal(one, two)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_variant_equal (gconstpointer one, gconstpointer two);
```
"""
function g_variant_equal(one, two)
    @ccall libaravis.g_variant_equal(one::gconstpointer, two::gconstpointer)::gboolean
end

"""
    g_variant_print(value, type_annotate)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar * g_variant_print (GVariant *value, gboolean type_annotate);
```
"""
function g_variant_print(value, type_annotate)
    @ccall libaravis.g_variant_print(value::Ptr{GVariant}, type_annotate::gboolean)::Ptr{gchar}
end

"""
    g_free(mem)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void (g_free) (gpointer mem);
```
"""
function g_free(mem)
    @ccall libaravis.g_free(mem::gpointer)::Cvoid
end

"""
    g_strv_length(str_array)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_strv_length (gchar **str_array);
```
"""
function g_strv_length(str_array)
    @ccall libaravis.g_strv_length(str_array::Ptr{Ptr{gchar}})::guint
end

"""
    g_assertion_message_cmpstrv(domain, file, line, func, expr, arg1, arg2, first_wrong_idx)

### Prototype
```c
GLIB_AVAILABLE_IN_2_68 void g_assertion_message_cmpstrv (const char *domain, const char *file, int line, const char *func, const char *expr, const char * const *arg1, const char * const *arg2, gsize first_wrong_idx);
```
"""
function g_assertion_message_cmpstrv(domain, file, line, func, expr, arg1, arg2, first_wrong_idx)
    @ccall libaravis.g_assertion_message_cmpstrv(domain::Cstring, file::Cstring, line::Cint, func::Cstring, expr::Cstring, arg1::Ptr{Cstring}, arg2::Ptr{Cstring}, first_wrong_idx::gsize)::Cvoid
end

"""
    g_strerror(errnum)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_strerror (gint errnum) G_GNUC_CONST;
```
"""
function g_strerror(errnum)
    @ccall libaravis.g_strerror(errnum::gint)::Ptr{gchar}
end

"""
    g_assertion_message_error(domain, file, line, func, expr, error, error_domain, error_code)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_assertion_message_error (const char *domain, const char *file, int line, const char *func, const char *expr, const GError *error, GQuark error_domain, int error_code);
```
"""
function g_assertion_message_error(domain, file, line, func, expr, error, error_domain, error_code)
    @ccall libaravis.g_assertion_message_error(domain::Cstring, file::Cstring, line::Cint, func::Cstring, expr::Cstring, error::Ptr{GError}, error_domain::GQuark, error_code::Cint)::Cvoid
end

"""
    g_assertion_message_expr(domain, file, line, func, expr)

### Prototype
```c
G_NORETURN GLIB_AVAILABLE_IN_ALL void g_assertion_message_expr (const char *domain, const char *file, int line, const char *func, const char *expr);
```
"""
function g_assertion_message_expr(domain, file, line, func, expr)
    @ccall libaravis.g_assertion_message_expr(domain::Cstring, file::Cstring, line::Cint, func::Cstring, expr::Cstring)::Cvoid
end

# typedef void ( * GTestFixtureFunc ) ( gpointer fixture , gconstpointer user_data )
const GTestFixtureFunc = Ptr{Cvoid}

"""
    g_test_add_vtable(testpath, data_size, test_data, data_setup, data_test, data_teardown)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_test_add_vtable (const char *testpath, gsize data_size, gconstpointer test_data, GTestFixtureFunc data_setup, GTestFixtureFunc data_test, GTestFixtureFunc data_teardown);
```
"""
function g_test_add_vtable(testpath, data_size, test_data, data_setup, data_test, data_teardown)
    @ccall libaravis.g_test_add_vtable(testpath::Cstring, data_size::gsize, test_data::gconstpointer, data_setup::GTestFixtureFunc, data_test::GTestFixtureFunc, data_teardown::GTestFixtureFunc)::Cvoid
end

"""
    g_test_queue_destroy(destroy_func, destroy_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_test_queue_destroy (GDestroyNotify destroy_func, gpointer destroy_data);
```
"""
function g_test_queue_destroy(destroy_func, destroy_data)
    @ccall libaravis.g_test_queue_destroy(destroy_func::GDestroyNotify, destroy_data::gpointer)::Cvoid
end

"""
    g_object_unref(object)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_object_unref (gpointer object);
```
"""
function g_object_unref(object)
    @ccall libaravis.g_object_unref(object::gpointer)::Cvoid
end

"""
    g_test_trap_assertions(domain, file, line, func, assertion_flags, pattern)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_test_trap_assertions (const char *domain, const char *file, int line, const char *func, guint64 assertion_flags, const char *pattern);
```
"""
function g_test_trap_assertions(domain, file, line, func, assertion_flags, pattern)
    @ccall libaravis.g_test_trap_assertions(domain::Cstring, file::Cstring, line::Cint, func::Cstring, assertion_flags::guint64, pattern::Cstring)::Cvoid
end

"""
    g_test_rand_int()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint32 g_test_rand_int (void);
```
"""
function g_test_rand_int()
    @ccall libaravis.g_test_rand_int()::gint32
end

"""
    g_test_assert_expected_messages_internal(domain, file, line, func)

### Prototype
```c
GLIB_AVAILABLE_IN_2_34 void g_test_assert_expected_messages_internal (const char *domain, const char *file, int line, const char *func);
```
"""
function g_test_assert_expected_messages_internal(domain, file, line, func)
    @ccall libaravis.g_test_assert_expected_messages_internal(domain::Cstring, file::Cstring, line::Cint, func::Cstring)::Cvoid
end

"""
    g_uri_error_quark()

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 GQuark g_uri_error_quark (void);
```
"""
function g_uri_error_quark()
    @ccall libaravis.g_uri_error_quark()::GQuark
end

const _GMemChunk = Cvoid

const GMemChunk = _GMemChunk

"""
    g_mem_chunk_alloc(mem_chunk)

### Prototype
```c
GLIB_DEPRECATED gpointer g_mem_chunk_alloc (GMemChunk *mem_chunk);
```
"""
function g_mem_chunk_alloc(mem_chunk)
    @ccall libaravis.g_mem_chunk_alloc(mem_chunk::Ptr{GMemChunk})::gpointer
end

"""
    g_mem_chunk_alloc0(mem_chunk)

### Prototype
```c
GLIB_DEPRECATED gpointer g_mem_chunk_alloc0 (GMemChunk *mem_chunk);
```
"""
function g_mem_chunk_alloc0(mem_chunk)
    @ccall libaravis.g_mem_chunk_alloc0(mem_chunk::Ptr{GMemChunk})::gpointer
end

"""
    g_mem_chunk_free(mem_chunk, mem)

### Prototype
```c
GLIB_DEPRECATED void g_mem_chunk_free (GMemChunk *mem_chunk, gpointer mem);
```
"""
function g_mem_chunk_free(mem_chunk, mem)
    @ccall libaravis.g_mem_chunk_free(mem_chunk::Ptr{GMemChunk}, mem::gpointer)::Cvoid
end

"""
    g_mem_chunk_new(name, atom_size, area_size, type)

### Prototype
```c
GLIB_DEPRECATED GMemChunk * g_mem_chunk_new (const gchar *name, gint atom_size, gsize area_size, gint type);
```
"""
function g_mem_chunk_new(name, atom_size, area_size, type)
    @ccall libaravis.g_mem_chunk_new(name::Ptr{gchar}, atom_size::gint, area_size::gsize, type::gint)::Ptr{GMemChunk}
end

const _GMainContext = Cvoid

"""
[`GMainContext`](@ref):

The [`GMainContext`](@ref) struct is an opaque data type representing a set of sources to be handled in a main loop.
"""
const GMainContext = _GMainContext

const _GMainLoop = Cvoid

"""
[`GMainLoop`](@ref):

The [`GMainLoop`](@ref) struct is an opaque data type representing the main event loop of a GLib or GTK application.
"""
const GMainLoop = _GMainLoop

"""
    g_main_loop_new(context, is_running)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GMainLoop *g_main_loop_new (GMainContext *context, gboolean is_running);
```
"""
function g_main_loop_new(context, is_running)
    @ccall libaravis.g_main_loop_new(context::Ptr{GMainContext}, is_running::gboolean)::Ptr{GMainLoop}
end

"""
    g_main_loop_run(loop)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_main_loop_run (GMainLoop *loop);
```
"""
function g_main_loop_run(loop)
    @ccall libaravis.g_main_loop_run(loop::Ptr{GMainLoop})::Cvoid
end

"""
    g_main_loop_quit(loop)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_main_loop_quit (GMainLoop *loop);
```
"""
function g_main_loop_quit(loop)
    @ccall libaravis.g_main_loop_quit(loop::Ptr{GMainLoop})::Cvoid
end

"""
    g_main_loop_unref(loop)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_main_loop_unref (GMainLoop *loop);
```
"""
function g_main_loop_unref(loop)
    @ccall libaravis.g_main_loop_unref(loop::Ptr{GMainLoop})::Cvoid
end

"""
    g_main_loop_is_running(loop)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_main_loop_is_running (GMainLoop *loop);
```
"""
function g_main_loop_is_running(loop)
    @ccall libaravis.g_main_loop_is_running(loop::Ptr{GMainLoop})::gboolean
end

"""
    g_main_context_iteration(context, may_block)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_main_context_iteration (GMainContext *context, gboolean may_block);
```
"""
function g_main_context_iteration(context, may_block)
    @ccall libaravis.g_main_context_iteration(context::Ptr{GMainContext}, may_block::gboolean)::gboolean
end

"""
    g_main_context_pending(context)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_main_context_pending (GMainContext *context);
```
"""
function g_main_context_pending(context)
    @ccall libaravis.g_main_context_pending(context::Ptr{GMainContext})::gboolean
end

# typedef gint ( * GPollFunc ) ( GPollFD * ufds , guint nfsd , gint timeout_ )
"""
[`GPollFunc`](@ref): : an array of #[`GPollFD`](@ref) elements : the number of elements in  \\_: the maximum time to wait for an event of the file descriptors. A negative value indicates an infinite timeout.

Specifies the type of function passed to [`g_main_context_set_poll_func`](@ref)(). The semantics of the function should match those of the poll() system call.

Returns: the number of #[`GPollFD`](@ref) elements which have events or errors reported, or -1 if an error occurred.
"""
const GPollFunc = Ptr{Cvoid}

"""
    g_main_context_set_poll_func(context, func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_main_context_set_poll_func (GMainContext *context, GPollFunc func);
```
"""
function g_main_context_set_poll_func(context, func)
    @ccall libaravis.g_main_context_set_poll_func(context::Ptr{GMainContext}, func::GPollFunc)::Cvoid
end

struct GStaticMutex
    data::NTuple{48, UInt8}
end

function Base.getproperty(x::Ptr{GStaticMutex}, f::Symbol)
    f === :mutex && return Ptr{Ptr{GMutex}}(x + 0)
    f === :unused && return Ptr{pthread_mutex_t}(x + 8)
    return getfield(x, f)
end

function Base.getproperty(x::GStaticMutex, f::Symbol)
    r = Ref{GStaticMutex}(x)
    ptr = Base.unsafe_convert(Ptr{GStaticMutex}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{GStaticMutex}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::GStaticMutex, private::Bool = false)
    (:mutex, :unused, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

"""
    g_static_mutex_get_mutex_impl(mutex)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32_FOR(GMutex) GMutex *g_static_mutex_get_mutex_impl (GStaticMutex *mutex);
```
"""
function g_static_mutex_get_mutex_impl(mutex)
    @ccall libaravis.g_static_mutex_get_mutex_impl(mutex::Ptr{GStaticMutex})::Ptr{GMutex}
end

"""
    g_mutex_init(mutex)

### Prototype
```c
GLIB_AVAILABLE_IN_2_32 void g_mutex_init (GMutex *mutex);
```
"""
function g_mutex_init(mutex)
    @ccall libaravis.g_mutex_init(mutex::Ptr{GMutex})::Cvoid
end

"""
    g_rec_mutex_init(rec_mutex)

### Prototype
```c
GLIB_AVAILABLE_IN_2_32 void g_rec_mutex_init (GRecMutex *rec_mutex);
```
"""
function g_rec_mutex_init(rec_mutex)
    @ccall libaravis.g_rec_mutex_init(rec_mutex::Ptr{GRecMutex})::Cvoid
end

"""
    g_rw_lock_init(rw_lock)

### Prototype
```c
GLIB_AVAILABLE_IN_2_32 void g_rw_lock_init (GRWLock *rw_lock);
```
"""
function g_rw_lock_init(rw_lock)
    @ccall libaravis.g_rw_lock_init(rw_lock::Ptr{GRWLock})::Cvoid
end

const GType = gsize

"""
    g_type_fundamental(type_id)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_type_fundamental (GType type_id);
```
"""
function g_type_fundamental(type_id)
    @ccall libaravis.g_type_fundamental(type_id::GType)::GType
end

"""
    g_type_test_flags(type, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gboolean g_type_test_flags (GType type, guint flags) G_GNUC_CONST;
```
"""
function g_type_test_flags(type, flags)
    @ccall libaravis.g_type_test_flags(type::GType, flags::guint)::gboolean
end

"""
    g_type_check_is_value_type(type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gboolean g_type_check_is_value_type (GType type) G_GNUC_CONST;
```
"""
function g_type_check_is_value_type(type)
    @ccall libaravis.g_type_check_is_value_type(type::GType)::gboolean
end

# typedef void ( * GTypeValueInitFunc ) ( GValue * value )
"""
[`GTypeValueInitFunc`](@ref): : the value to initialize

Initializes the value contents by setting the fields of the `value->data` array.

The data array of the #[`GValue`](@ref) passed into this function was zero-filled with `memset()`, so no care has to be taken to free any old contents. For example, in the case of a string value that may never be NULL, the implementation might look like:

|[<!-- language="C" --> value->data[0].v\\_pointer = [`g_strdup`](@ref) (""); ]|

Since: 2.78
"""
const GTypeValueInitFunc = Ptr{Cvoid}

# typedef void ( * GTypeValueFreeFunc ) ( GValue * value )
"""
[`GTypeValueFreeFunc`](@ref): : the value to free

Frees any old contents that might be left in the `value->data` array of the given value.

No resources may remain allocated through the #[`GValue`](@ref) contents after this function returns. E.g. for our above string type:

|[<!-- language="C" --> // only free strings without a specific flag for static storage if (!(value->data[1].v\\_uint & [`G_VALUE_NOCOPY_CONTENTS`](@ref))) [`g_free`](@ref) (value->data[0].v\\_pointer); ]|

Since: 2.78
"""
const GTypeValueFreeFunc = Ptr{Cvoid}

# typedef void ( * GTypeValueCopyFunc ) ( const GValue * src_value , GValue * dest_value )
"""
[`GTypeValueCopyFunc`](@ref): \\_value: the value to copy

\\test \\_value: (out): the location of the copy

Copies the content of a #[`GValue`](@ref) into another.

The

\\test \\_value is a #[`GValue`](@ref) with zero-filled data section and \\_value is a properly initialized #[`GValue`](@ref) of same type, or derived type.

The purpose of this function is to copy the contents of \\_value into

\\test \\_value in a way, that even after \\_value has been freed, the contents of

\\test \\_value remain valid. String type example:

|[<!-- language="C" --> dest\\_value->data[0].v\\_pointer = [`g_strdup`](@ref) (src\\_value->data[0].v\\_pointer); ]|

Since: 2.78
"""
const GTypeValueCopyFunc = Ptr{Cvoid}

# typedef gpointer ( * GTypeValuePeekPointerFunc ) ( const GValue * value )
"""
[`GTypeValuePeekPointerFunc`](@ref): : the value to peek

If the value contents fit into a pointer, such as objects or strings, return this pointer, so the caller can peek at the current contents.

To extend on our above string example:

|[<!-- language="C" --> return value->data[0].v\\_pointer; ]|

Returns: (transfer none): a pointer to the value contents

Since: 2.78
"""
const GTypeValuePeekPointerFunc = Ptr{Cvoid}

# typedef gchar * ( * GTypeValueCollectFunc ) ( GValue * value , guint n_collect_values , GTypeCValue * collect_values , guint collect_flags )
"""
[`GTypeValueCollectFunc`](@ref): : the value to initialize \\_collect\\_values: the number of collected values \\_values: (array length=n\\_collect\\_values): the collected values \\_flags: optional flags

This function is responsible for converting the values collected from a variadic argument list into contents suitable for storage in a #[`GValue`](@ref).

This function should setup  similar to #[`GTypeValueInitFunc`](@ref); e.g. for a string value that does not allow `NULL` pointers, it needs to either emit an error, or do an implicit conversion by storing an empty string.

The  passed in to this function has a zero-filled data array, so just like for #[`GTypeValueInitFunc`](@ref) it is guaranteed to not contain any old contents that might need freeing.

The \\_collect\\_values argument is the string length of the `collect_format` field of #[`GTypeValueTable`](@ref), and `collect_values` is an array of #[`GTypeCValue`](@ref) with length of \\_collect\\_values, containing the collected values according to `collect_format`.

The \\_flags argument provided as a hint by the caller. It may contain the flag G\\_VALUE\\_NOCOPY\\_CONTENTS indicating that the collected value contents may be considered static for the duration of the  lifetime. Thus an extra copy of the contents stored in \\_values is not required for assignment to .

For our above string example, we continue with:

|[<!-- language="C" --> if (!collect\\_values[0].v\\_pointer) value->data[0].v\\_pointer = [`g_strdup`](@ref) (""); else if (collect\\_flags & [`G_VALUE_NOCOPY_CONTENTS`](@ref)) { value->data[0].v\\_pointer = collect\\_values[0].v\\_pointer; // keep a flag for the value\\_free() implementation to not free this string value->data[1].v\\_uint = [`G_VALUE_NOCOPY_CONTENTS`](@ref); } else value->data[0].v\\_pointer = [`g_strdup`](@ref) (collect\\_values[0].v\\_pointer); return NULL; ]|

It should be noted, that it is generally a bad idea to follow the G\\_VALUE\\_NOCOPY\\_CONTENTS hint for reference counted types. Due to reentrancy requirements and reference count assertions performed by the signal emission code, reference counts should always be incremented for reference counted contents stored in the `value->data` array. To deviate from our string example for a moment, and taking a look at an exemplary implementation for `[`GTypeValueTable`](@ref).collect\\_value()` of [`GObject`](@ref):

|[<!-- language="C" --> [`GObject`](@ref) *object = [`G_OBJECT`](@ref) (collect\\_values[0].v\\_pointer); [`g_return_val_if_fail`](@ref) (object != NULL, [`g_strdup_printf`](@ref) ("Object p passed as invalid NULL pointer", object)); // never honour [`G_VALUE_NOCOPY_CONTENTS`](@ref) for ref-counted types value->data[0].v\\_pointer = [`g_object_ref`](@ref) (object); return NULL; ]|

The reference count for valid objects is always incremented, regardless of `collect_flags`. For invalid objects, the example returns a newly allocated string without altering `value`.

Upon success, `collect\\_value()` needs to return `NULL`. If, however, an error condition occurred, `collect\\_value()` should return a newly allocated string containing an error diagnostic.

The calling code makes no assumptions about the `value` contents being valid upon error returns, `value` is simply thrown away without further freeing. As such, it is a good idea to not allocate [`GValue`](@ref) contents prior to returning an error; however, `collect\\_values()` is not obliged to return a correctly setup  for error returns, simply because any non-`NULL` return is considered a fatal programming error, and further program behaviour is undefined.

Returns: (transfer full) (nullable): `NULL` on success, otherwise a newly allocated error string on failure

Since: 2.78
"""
const GTypeValueCollectFunc = Ptr{Cvoid}

# typedef gchar * ( * GTypeValueLCopyFunc ) ( const GValue * value , guint n_collect_values , GTypeCValue * collect_values , guint collect_flags )
"""
[`GTypeValueLCopyFunc`](@ref): : the value to lcopy \\_collect\\_values: the number of collected values \\_values: (array length=n\\_collect\\_values): the collected locations for storage \\_flags: optional flags

This function is responsible for storing the `value` contents into arguments passed through a variadic argument list which got collected into `collect_values` according to `lcopy_format`.

The `n_collect_values` argument equals the string length of `lcopy_format`, and `collect_flags` may contain G\\_VALUE\\_NOCOPY\\_CONTENTS.

In contrast to #[`GTypeValueCollectFunc`](@ref), this function is obliged to always properly support G\\_VALUE\\_NOCOPY\\_CONTENTS.

Similar to #[`GTypeValueCollectFunc`](@ref) the function may prematurely abort by returning a newly allocated string describing an error condition. To complete the string example:

|[<!-- language="C" --> [`gchar`](@ref) **string\\_p = collect\\_values[0].v\\_pointer; [`g_return_val_if_fail`](@ref) (string\\_p != NULL, [`g_strdup`](@ref) ("string location passed as NULL"));

if (collect\\_flags & [`G_VALUE_NOCOPY_CONTENTS`](@ref)) *string\\_p = value->data[0].v\\_pointer; else *string\\_p = [`g_strdup`](@ref) (value->data[0].v\\_pointer); ]|

And an illustrative version of this function for reference-counted types:

|[<!-- language="C" --> [`GObject`](@ref) **object\\_p = collect\\_values[0].v\\_pointer; [`g_return_val_if_fail`](@ref) (object\\_p != NULL, [`g_strdup`](@ref) ("object location passed as NULL"));

if (value->data[0].v\\_pointer == NULL) *object\\_p = NULL; else if (collect\\_flags & [`G_VALUE_NOCOPY_CONTENTS`](@ref)) // always honour *object\\_p = value->data[0].v\\_pointer; else *object\\_p = [`g_object_ref`](@ref) (value->data[0].v\\_pointer);

return NULL; ]|

Returns: (transfer full) (nullable): `NULL` on success, otherwise a newly allocated error string on failure

Since: 2.78
"""
const GTypeValueLCopyFunc = Ptr{Cvoid}

"""
    _GTypeValueTable

[`GTypeValueTable`](@ref): \\_init: Function to initialize a [`GValue`](@ref) \\_free: Function to free a [`GValue`](@ref) \\_copy: Function to copy a [`GValue`](@ref) \\_peek\\_pointer: Function to peek the contents of a [`GValue`](@ref) if they fit into a pointer \\_format: A string format describing how to collect the contents of this value bit-by-bit. Each character in the format represents an argument to be collected, and the characters themselves indicate the type of the argument. Currently supported arguments are:

- `'i'`: Integers, passed as `collect\\_values[].v\\_int` - `'l'`: Longs, passed as `collect\\_values[].v\\_long` - `'d'`: Doubles, passed as `collect\\_values[].v\\_double` - `'p'`: Pointers, passed as `collect\\_values[].v\\_pointer`

It should be noted that for variable argument list construction, ANSI C promotes every type smaller than an integer to an int, and floats to doubles. So for collection of short int or char, `'i'` needs to be used, and for collection of floats `'d'`. \\_value: Function to initialize a [`GValue`](@ref) from the values collected from variadic arguments \\_format: Format description of the arguments to collect for \\_value, analogous to \\_format. Usually, \\_format string consists only of `'p'`s to provide lcopy\\_value() with pointers to storage locations. \\_value: Function to store the contents of a value into the locations collected from variadic arguments

The #[`GTypeValueTable`](@ref) provides the functions required by the #[`GValue`](@ref) implementation, to serve as a container for values of a type.
"""
struct _GTypeValueTable
    value_init::GTypeValueInitFunc
    value_free::GTypeValueFreeFunc
    value_copy::GTypeValueCopyFunc
    value_peek_pointer::GTypeValuePeekPointerFunc
    collect_format::Ptr{gchar}
    collect_value::GTypeValueCollectFunc
    lcopy_format::Ptr{gchar}
    lcopy_value::GTypeValueLCopyFunc
end

"""
[`GTypeValueTable`](@ref): \\_init: Function to initialize a [`GValue`](@ref) \\_free: Function to free a [`GValue`](@ref) \\_copy: Function to copy a [`GValue`](@ref) \\_peek\\_pointer: Function to peek the contents of a [`GValue`](@ref) if they fit into a pointer \\_format: A string format describing how to collect the contents of this value bit-by-bit. Each character in the format represents an argument to be collected, and the characters themselves indicate the type of the argument. Currently supported arguments are:

- `'i'`: Integers, passed as `collect\\_values[].v\\_int` - `'l'`: Longs, passed as `collect\\_values[].v\\_long` - `'d'`: Doubles, passed as `collect\\_values[].v\\_double` - `'p'`: Pointers, passed as `collect\\_values[].v\\_pointer`

It should be noted that for variable argument list construction, ANSI C promotes every type smaller than an integer to an int, and floats to doubles. So for collection of short int or char, `'i'` needs to be used, and for collection of floats `'d'`. \\_value: Function to initialize a [`GValue`](@ref) from the values collected from variadic arguments \\_format: Format description of the arguments to collect for \\_value, analogous to \\_format. Usually, \\_format string consists only of `'p'`s to provide lcopy\\_value() with pointers to storage locations. \\_value: Function to store the contents of a value into the locations collected from variadic arguments

The #[`GTypeValueTable`](@ref) provides the functions required by the #[`GValue`](@ref) implementation, to serve as a container for values of a type.
"""
const GTypeValueTable = _GTypeValueTable

"""
    g_type_value_table_peek(type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GTypeValueTable* g_type_value_table_peek (GType type);
```
"""
function g_type_value_table_peek(type)
    @ccall libaravis.g_type_value_table_peek(type::GType)::Ptr{GTypeValueTable}
end

"""
    _GTypeClass

[`GTypeClass`](@ref):

An opaque structure used as the base of all classes.
"""
struct _GTypeClass
    g_type::GType
end

"""
[`GTypeClass`](@ref):

An opaque structure used as the base of all classes.
"""
const GTypeClass = _GTypeClass

"""
    _GTypeInstance

[`GTypeInstance`](@ref):

An opaque structure used as the base of all type instances.
"""
struct _GTypeInstance
    g_class::Ptr{GTypeClass}
end

"""
[`GTypeInstance`](@ref):

An opaque structure used as the base of all type instances.
"""
const GTypeInstance = _GTypeInstance

"""
    g_type_check_instance(instance)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gboolean g_type_check_instance (GTypeInstance *instance) G_GNUC_PURE;
```
"""
function g_type_check_instance(instance)
    @ccall libaravis.g_type_check_instance(instance::Ptr{GTypeInstance})::gboolean
end

"""
    g_type_check_instance_cast(instance, iface_type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GTypeInstance* g_type_check_instance_cast (GTypeInstance *instance, GType iface_type);
```
"""
function g_type_check_instance_cast(instance, iface_type)
    @ccall libaravis.g_type_check_instance_cast(instance::Ptr{GTypeInstance}, iface_type::GType)::Ptr{GTypeInstance}
end

"""
    g_type_check_instance_is_a(instance, iface_type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gboolean g_type_check_instance_is_a (GTypeInstance *instance, GType iface_type) G_GNUC_PURE;
```
"""
function g_type_check_instance_is_a(instance, iface_type)
    @ccall libaravis.g_type_check_instance_is_a(instance::Ptr{GTypeInstance}, iface_type::GType)::gboolean
end

"""
    g_type_check_instance_is_fundamentally_a(instance, fundamental_type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_42 gboolean g_type_check_instance_is_fundamentally_a (GTypeInstance *instance, GType fundamental_type) G_GNUC_PURE;
```
"""
function g_type_check_instance_is_fundamentally_a(instance, fundamental_type)
    @ccall libaravis.g_type_check_instance_is_fundamentally_a(instance::Ptr{GTypeInstance}, fundamental_type::GType)::gboolean
end

"""
    g_type_interface_peek(instance_class, iface_type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gpointer g_type_interface_peek (gpointer instance_class, GType iface_type);
```
"""
function g_type_interface_peek(instance_class, iface_type)
    @ccall libaravis.g_type_interface_peek(instance_class::gpointer, iface_type::GType)::gpointer
end

"""
    g_type_check_class_cast(g_class, is_a_type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GTypeClass* g_type_check_class_cast (GTypeClass *g_class, GType is_a_type);
```
"""
function g_type_check_class_cast(g_class, is_a_type)
    @ccall libaravis.g_type_check_class_cast(g_class::Ptr{GTypeClass}, is_a_type::GType)::Ptr{GTypeClass}
end

"""
    g_type_check_class_is_a(g_class, is_a_type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gboolean g_type_check_class_is_a (GTypeClass *g_class, GType is_a_type) G_GNUC_PURE;
```
"""
function g_type_check_class_is_a(g_class, is_a_type)
    @ccall libaravis.g_type_check_class_is_a(g_class::Ptr{GTypeClass}, is_a_type::GType)::gboolean
end

struct __JL_Ctag_24
    data::NTuple{8, UInt8}
end

function Base.getproperty(x::Ptr{__JL_Ctag_24}, f::Symbol)
    f === :v_int && return Ptr{gint}(x + 0)
    f === :v_uint && return Ptr{guint}(x + 0)
    f === :v_long && return Ptr{glong}(x + 0)
    f === :v_ulong && return Ptr{gulong}(x + 0)
    f === :v_int64 && return Ptr{gint64}(x + 0)
    f === :v_uint64 && return Ptr{guint64}(x + 0)
    f === :v_float && return Ptr{gfloat}(x + 0)
    f === :v_double && return Ptr{gdouble}(x + 0)
    f === :v_pointer && return Ptr{gpointer}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::__JL_Ctag_24, f::Symbol)
    r = Ref{__JL_Ctag_24}(x)
    ptr = Base.unsafe_convert(Ptr{__JL_Ctag_24}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{__JL_Ctag_24}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::__JL_Ctag_24, private::Bool = false)
    (:v_int, :v_uint, :v_long, :v_ulong, :v_int64, :v_uint64, :v_float, :v_double, :v_pointer, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

"""
    _GValue

[`GValue`](@ref):

An opaque structure used to hold different types of values.

Before it can be used, a [`GValue`](@ref) has to be initialized to a specific type by calling [method.Value.init] on it.

Many types which are stored within a [`GValue`](@ref) need to allocate data on the heap, so [method.Value.unset] must always be called on a [`GValue`](@ref) to free any such data once youre finished with the [`GValue`](@ref), even if the [`GValue`](@ref) itself is stored on the stack.

The data within the structure has protected scope: it is accessible only to functions within a [struct.TypeValueTable] structure, or implementations of the `g\\_value\\_*()` API. That is, code which implements new fundamental types.

[`GValue`](@ref) users cannot make any assumptions about how data is stored within the 2 element

\\date union, and the \\_type member should only be accessed through the [func.VALUE\\_TYPE] macro and related macros.
"""
struct _GValue
    data::NTuple{24, UInt8}
end

function Base.getproperty(x::Ptr{_GValue}, f::Symbol)
    f === :g_type && return Ptr{GType}(x + 0)
    f === :data && return Ptr{NTuple{2, __JL_Ctag_24}}(x + 8)
    return getfield(x, f)
end

function Base.getproperty(x::_GValue, f::Symbol)
    r = Ref{_GValue}(x)
    ptr = Base.unsafe_convert(Ptr{_GValue}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{_GValue}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::_GValue, private::Bool = false)
    (:g_type, :data, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

"""
[`GValue`](@ref):

An opaque structure used to hold different types of values.

Before it can be used, a [`GValue`](@ref) has to be initialized to a specific type by calling [method.Value.init] on it.

Many types which are stored within a [`GValue`](@ref) need to allocate data on the heap, so [method.Value.unset] must always be called on a [`GValue`](@ref) to free any such data once youre finished with the [`GValue`](@ref), even if the [`GValue`](@ref) itself is stored on the stack.

The data within the structure has protected scope: it is accessible only to functions within a [struct.TypeValueTable] structure, or implementations of the `g\\_value\\_*()` API. That is, code which implements new fundamental types.

[`GValue`](@ref) users cannot make any assumptions about how data is stored within the 2 element

\\date union, and the \\_type member should only be accessed through the [func.VALUE\\_TYPE] macro and related macros.
"""
const GValue = _GValue

"""
    g_type_check_value(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gboolean g_type_check_value (const GValue *value) G_GNUC_PURE;
```
"""
function g_type_check_value(value)
    @ccall libaravis.g_type_check_value(value::Ptr{GValue})::gboolean
end

"""
    g_type_check_value_holds(value, type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gboolean g_type_check_value_holds (const GValue *value, GType type) G_GNUC_PURE;
```
"""
function g_type_check_value_holds(value, type)
    @ccall libaravis.g_type_check_value_holds(value::Ptr{GValue}, type::GType)::gboolean
end

"""
    _GTypeInterface

[`GTypeInterface`](@ref):

An opaque structure used as the base of all interface types.
"""
struct _GTypeInterface
    g_type::GType
    g_instance_type::GType
end

"""
[`GTypeInterface`](@ref):

An opaque structure used as the base of all interface types.
"""
const GTypeInterface = _GTypeInterface

"""
    g_type_instance_get_private(instance, private_type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gpointer g_type_instance_get_private (GTypeInstance *instance, GType private_type);
```
"""
function g_type_instance_get_private(instance, private_type)
    @ccall libaravis.g_type_instance_get_private(instance::Ptr{GTypeInstance}, private_type::GType)::gpointer
end

"""
    g_type_add_instance_private(class_type, private_size)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_38 gint g_type_add_instance_private (GType class_type, gsize private_size);
```
"""
function g_type_add_instance_private(class_type, private_size)
    @ccall libaravis.g_type_add_instance_private(class_type::GType, private_size::gsize)::gint
end

"""
    g_type_class_get_private(klass, private_type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gpointer g_type_class_get_private (GTypeClass *klass, GType private_type);
```
"""
function g_type_class_get_private(klass, private_type)
    @ccall libaravis.g_type_class_get_private(klass::Ptr{GTypeClass}, private_type::GType)::gpointer
end

"""
    g_type_class_unref(g_class)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_type_class_unref (gpointer g_class);
```
"""
function g_type_class_unref(g_class)
    @ccall libaravis.g_type_class_unref(g_class::gpointer)::Cvoid
end

"""
    g_type_class_peek_parent(g_class)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gpointer g_type_class_peek_parent (gpointer g_class);
```
"""
function g_type_class_peek_parent(g_class)
    @ccall libaravis.g_type_class_peek_parent(g_class::gpointer)::gpointer
end

"""
    g_type_class_adjust_private_offset(g_class, private_size_or_offset)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_38 void g_type_class_adjust_private_offset (gpointer g_class, gint *private_size_or_offset);
```
"""
function g_type_class_adjust_private_offset(g_class, private_size_or_offset)
    @ccall libaravis.g_type_class_adjust_private_offset(g_class::gpointer, private_size_or_offset::Ptr{gint})::Cvoid
end

# typedef void ( * GClassInitFunc ) ( gpointer g_class , gpointer class_data )
"""
[`GClassInitFunc`](@ref): \\_class: (type [`GObject`](@ref).TypeClass): The #[`GTypeClass`](@ref) structure to initialize.

`_data: The @class_data member supplied via the #GTypeInfo structure.`

A callback function used by the type system to initialize the class of a specific type.

This function should initialize all static class members.

The initialization process of a class involves:

- Copying common members from the parent class over to the derived class structure. - Zero initialization of the remaining members not copied over from the parent class. - Invocation of the [`GBaseInitFunc`](@ref)() initializers of all parent types and the class' type. - Invocation of the class' [`GClassInitFunc`](@ref)() initializer.

Since derived classes are partially initialized through a memory copy of the parent class, the general rule is that [`GBaseInitFunc`](@ref)() and [`GBaseFinalizeFunc`](@ref)() should take care of necessary reinitialization and release of those class members that were introduced by the type that specified these [`GBaseInitFunc`](@ref)()/[`GBaseFinalizeFunc`](@ref)(). [`GClassInitFunc`](@ref)() should only care about initializing static class members, while dynamic class members (such as allocated strings or reference counted resources) are better handled by a [`GBaseInitFunc`](@ref)() for this type, so proper initialization of the dynamic class members is performed for class initialization of derived types as well.

An example may help to correspond the intend of the different class initializers:

|[<!-- language="C" --> typedef struct { [`GObjectClass`](@ref) parent\\_class; [`gint`](@ref) static\\_integer; [`gchar`](@ref) *dynamic\\_string; } TypeAClass; static void type\\_a\\_base\\_class\\_init (TypeAClass *class) { class->dynamic\\_string = [`g_strdup`](@ref) ("some string"); } static void type\\_a\\_base\\_class\\_finalize (TypeAClass *class) { [`g_free`](@ref) (class->dynamic\\_string); } static void type\\_a\\_class\\_init (TypeAClass *class) { class->static\\_integer = 42; }

typedef struct { TypeAClass parent\\_class; [`gfloat`](@ref) static\\_float; [`GString`](@ref) *dynamic\\_gstring; } TypeBClass; static void type\\_b\\_base\\_class\\_init (TypeBClass *class) { class->dynamic\\_gstring = [`g_string_new`](@ref) ("some other string"); } static void type\\_b\\_base\\_class\\_finalize (TypeBClass *class) { [`g_string_free`](@ref) (class->dynamic\\_gstring); } static void type\\_b\\_class\\_init (TypeBClass *class) { class->static\\_float = 3.14159265358979323846; } ]|

Initialization of TypeBClass will first cause initialization of TypeAClass (derived classes reference their parent classes, see [`g_type_class_ref`](@ref)() on this).

Initialization of TypeAClass roughly involves zero-initializing its fields, then calling its [`GBaseInitFunc`](@ref)() type\\_a\\_base\\_class\\_init() to allocate its dynamic members (dynamic\\_string), and finally calling its [`GClassInitFunc`](@ref)() type\\_a\\_class\\_init() to initialize its static members (static\\_integer). The first step in the initialization process of TypeBClass is then a plain memory copy of the contents of TypeAClass into TypeBClass and  zero-initialization of the remaining fields in TypeBClass. The dynamic members of TypeAClass within TypeBClass now need reinitialization which is performed by calling type\\_a\\_base\\_class\\_init() with an argument of TypeBClass.

After that, the [`GBaseInitFunc`](@ref)() of TypeBClass, type\\_b\\_base\\_class\\_init() is called to allocate the dynamic members of TypeBClass (dynamic\\_gstring), and finally the [`GClassInitFunc`](@ref)() of TypeBClass, type\\_b\\_class\\_init(), is called to complete the initialization process with the static members (static\\_float).

Corresponding finalization counter parts to the [`GBaseInitFunc`](@ref)() functions have to be provided to release allocated resources at class finalization time.
"""
const GClassInitFunc = Ptr{Cvoid}

# typedef void ( * GInstanceInitFunc ) ( GTypeInstance * instance , gpointer g_class )
"""
[`GInstanceInitFunc`](@ref): : The instance to initialize \\_class: (type [`GObject`](@ref).TypeClass): The class of the type the instance is created for

A callback function used by the type system to initialize a new instance of a type.

This function initializes all instance members and allocates any resources required by it.

Initialization of a derived instance involves calling all its parent types instance initializers, so the class member of the instance is altered during its initialization to always point to the class that belongs to the type the current initializer was introduced for.

The extended members of  are guaranteed to have been filled with zeros before this function is called.
"""
const GInstanceInitFunc = Ptr{Cvoid}

"""
    GTypeFlags

[`GTypeFlags`](@ref): \\_TYPE\\_FLAG\\_NONE: No special flags. Since: 2.74 \\_TYPE\\_FLAG\\_ABSTRACT: Indicates an abstract type. No instances can be created for an abstract type \\_TYPE\\_FLAG\\_VALUE\\_ABSTRACT: Indicates an abstract value type, i.e. a type that introduces a value table, but can't be used for [`g_value_init`](@ref)() \\_TYPE\\_FLAG\\_FINAL: Indicates a final type. A final type is a non-derivable leaf node in a deep derivable type hierarchy tree. Since: 2.70 \\_TYPE\\_FLAG\\_DEPRECATED: The type is deprecated and may be removed in a future version. A warning will be emitted if it is instantiated while running with `G\\_ENABLE\\_DIAGNOSTIC=1`. Since 2.76

Bit masks used to check or determine characteristics of a type.
"""
@cenum GTypeFlags::UInt32 begin
    G_TYPE_FLAG_NONE = 0
    G_TYPE_FLAG_ABSTRACT = 16
    G_TYPE_FLAG_VALUE_ABSTRACT = 32
    G_TYPE_FLAG_FINAL = 64
    G_TYPE_FLAG_DEPRECATED = 128
end

"""
    g_type_register_static_simple(parent_type, type_name, class_size, class_init, instance_size, instance_init, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_type_register_static_simple (GType parent_type, const gchar *type_name, guint class_size, GClassInitFunc class_init, guint instance_size, GInstanceInitFunc instance_init, GTypeFlags flags);
```
"""
function g_type_register_static_simple(parent_type, type_name, class_size, class_init, instance_size, instance_init, flags)
    @ccall libaravis.g_type_register_static_simple(parent_type::GType, type_name::Ptr{gchar}, class_size::guint, class_init::GClassInitFunc, instance_size::guint, instance_init::GInstanceInitFunc, flags::GTypeFlags)::GType
end

"""
    g_intern_static_string(string)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_intern_static_string (const gchar *string);
```
"""
function g_intern_static_string(string)
    @ccall libaravis.g_intern_static_string(string::Ptr{gchar})::Ptr{gchar}
end

"""
    g_type_interface_add_prerequisite(interface_type, prerequisite_type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_type_interface_add_prerequisite (GType interface_type, GType prerequisite_type);
```
"""
function g_type_interface_add_prerequisite(interface_type, prerequisite_type)
    @ccall libaravis.g_type_interface_add_prerequisite(interface_type::GType, prerequisite_type::GType)::Cvoid
end

# typedef void ( * GInterfaceInitFunc ) ( gpointer g_iface , gpointer iface_data )
"""
[`GInterfaceInitFunc`](@ref): \\_iface: (type [`GObject`](@ref).TypeInterface): The interface structure to initialize \\_data: The

`_data supplied via the #GInterfaceInfo structure`

A callback function used by the type system to initialize a new interface.

This function should initialize all internal data and* allocate any resources required by the interface.

The members of \\_data are guaranteed to have been filled with zeros before this function is called.
"""
const GInterfaceInitFunc = Ptr{Cvoid}

# typedef void ( * GInterfaceFinalizeFunc ) ( gpointer g_iface , gpointer iface_data )
"""
[`GInterfaceFinalizeFunc`](@ref): \\_iface: (type [`GObject`](@ref).TypeInterface): The interface structure to finalize \\_data: The

`_data supplied via the #GInterfaceInfo structure`

A callback function used by the type system to finalize an interface.

This function should destroy any internal data and release any resources allocated by the corresponding [`GInterfaceInitFunc`](@ref)() function.
"""
const GInterfaceFinalizeFunc = Ptr{Cvoid}

"""
    _GInterfaceInfo

[`GInterfaceInfo`](@ref):

`_init: location of the interface initialization function`

`_finalize: location of the interface finalization function`

`_data: user-supplied data passed to the interface init/finalize functions`

A structure that provides information to the type system which is used specifically for managing interface types.
"""
struct _GInterfaceInfo
    interface_init::GInterfaceInitFunc
    interface_finalize::GInterfaceFinalizeFunc
    interface_data::gpointer
end

"""
[`GInterfaceInfo`](@ref):

`_init: location of the interface initialization function`

`_finalize: location of the interface finalization function`

`_data: user-supplied data passed to the interface init/finalize functions`

A structure that provides information to the type system which is used specifically for managing interface types.
"""
const GInterfaceInfo = _GInterfaceInfo

"""
    g_type_add_interface_static(instance_type, interface_type, info)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_type_add_interface_static (GType instance_type, GType interface_type, const GInterfaceInfo *info);
```
"""
function g_type_add_interface_static(instance_type, interface_type, info)
    @ccall libaravis.g_type_add_interface_static(instance_type::GType, interface_type::GType, info::Ptr{GInterfaceInfo})::Cvoid
end

# typedef gpointer ( * GBoxedCopyFunc ) ( gpointer boxed )
"""
[`GBoxedCopyFunc`](@ref): : (not nullable): The boxed structure to be copied.

This function is provided by the user and should produce a copy of the passed in boxed structure.

Returns: (not nullable): The newly created copy of the boxed structure.
"""
const GBoxedCopyFunc = Ptr{Cvoid}

# typedef void ( * GBoxedFreeFunc ) ( gpointer boxed )
"""
[`GBoxedFreeFunc`](@ref): : (not nullable): The boxed structure to be freed.

This function is provided by the user and should free the boxed structure passed.
"""
const GBoxedFreeFunc = Ptr{Cvoid}

"""
    g_boxed_type_register_static(name, boxed_copy, boxed_free)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_boxed_type_register_static (const gchar *name, GBoxedCopyFunc boxed_copy, GBoxedFreeFunc boxed_free);
```
"""
function g_boxed_type_register_static(name, boxed_copy, boxed_free)
    @ccall libaravis.g_boxed_type_register_static(name::Ptr{gchar}, boxed_copy::GBoxedCopyFunc, boxed_free::GBoxedFreeFunc)::GType
end

"""
    g_pointer_type_register_static(name)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_pointer_type_register_static (const gchar *name);
```
"""
function g_pointer_type_register_static(name)
    @ccall libaravis.g_pointer_type_register_static(name::Ptr{gchar})::GType
end

"""
    g_type_name(type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL const gchar * g_type_name (GType type);
```
"""
function g_type_name(type)
    @ccall libaravis.g_type_name(type::GType)::Ptr{gchar}
end

"""
    GParamFlags

[`GParamFlags`](@ref): \\_PARAM\\_READABLE: the parameter is readable \\_PARAM\\_WRITABLE: the parameter is writable \\_PARAM\\_READWRITE: alias for G\\_PARAM\\_READABLE | G\\_PARAM\\_WRITABLE \\_PARAM\\_CONSTRUCT: the parameter will be set upon object construction. See [vfunc.constructed] for more details \\_PARAM\\_CONSTRUCT\\_ONLY: the parameter can only be set upon object construction. See [vfunc.constructed] for more details \\_PARAM\\_LAX\\_VALIDATION: upon parameter conversion (see [`g_param_value_convert`](@ref)()) strict validation is not required \\_PARAM\\_STATIC\\_NAME: the string used as name when constructing the  parameter is guaranteed to remain valid and unmodified for the lifetime of the parameter.  Since 2.8 \\_PARAM\\_STATIC\\_NICK: the string used as nick when constructing the parameter is guaranteed to remain valid and unmmodified for the lifetime of the parameter. Since 2.8 \\_PARAM\\_STATIC\\_BLURB: the string used as blurb when constructing the  parameter is guaranteed to remain valid and  unmodified for the lifetime of the parameter.  Since 2.8 \\_PARAM\\_EXPLICIT\\_NOTIFY: calls to [`g_object_set_property`](@ref)() for this property will not automatically result in a "notify" signal being emitted: the implementation must call [`g_object_notify`](@ref)() themselves in case the property actually changes. Since: 2.42. \\_PARAM\\_PRIVATE: internal \\_PARAM\\_DEPRECATED: the parameter is deprecated and will be removed in a future version. A warning will be generated if it is used while running with G\\_ENABLE\\_DIAGNOSTIC=1. Since 2.26

Through the #[`GParamFlags`](@ref) flag values, certain aspects of parameters can be configured.

See also: G\\_PARAM\\_STATIC\\_STRINGS
"""
@cenum GParamFlags::Int32 begin
    G_PARAM_READABLE = 1
    G_PARAM_WRITABLE = 2
    G_PARAM_READWRITE = 3
    G_PARAM_CONSTRUCT = 4
    G_PARAM_CONSTRUCT_ONLY = 8
    G_PARAM_LAX_VALIDATION = 16
    G_PARAM_STATIC_NAME = 32
    G_PARAM_PRIVATE = 32
    G_PARAM_STATIC_NICK = 64
    G_PARAM_STATIC_BLURB = 128
    G_PARAM_EXPLICIT_NOTIFY = 1073741824
    G_PARAM_DEPRECATED = -2147483648
end

struct _GParamSpec
    g_type_instance::GTypeInstance
    name::Ptr{gchar}
    flags::GParamFlags
    value_type::GType
    owner_type::GType
    _nick::Ptr{gchar}
    _blurb::Ptr{gchar}
    qdata::Ptr{GData}
    ref_count::guint
    param_id::guint
end

const GParamSpec = _GParamSpec

"""
    _GParamSpecClass

[`GParamSpecClass`](@ref): \\_type\\_class: the parent class \\_type: the #[`GValue`](@ref) type for this parameter : The instance finalization function (optional), should chain  up to the finalize method of the parent class. \\_set\\_default: Resets a  to the default value for this type (recommended, the default is [`g_value_reset`](@ref)()), see  [`g_param_value_set_default`](@ref)(). \\_validate: Ensures that the contents of  comply with the  specifications set out by this type (optional), see  [`g_param_value_validate`](@ref)(). \\_cmp: Compares  with  according to this type (recommended, the default is memcmp()), see [`g_param_values_cmp`](@ref)(). \\_is\\_valid: Checks if contents of  comply with the specifications set out by this type, without modifying the value. This vfunc is optional. If it isn't set, [`GObject`](@ref) will use \\_validate. Since 2.74

The class structure for the [`GParamSpec`](@ref) type. Normally, [`GParamSpec`](@ref) classes are filled by [`g_param_type_register_static`](@ref)().
"""
struct _GParamSpecClass
    g_type_class::GTypeClass
    value_type::GType
    finalize::Ptr{Cvoid}
    value_set_default::Ptr{Cvoid}
    value_validate::Ptr{Cvoid}
    values_cmp::Ptr{Cvoid}
    value_is_valid::Ptr{Cvoid}
    dummy::NTuple{3, gpointer}
end

"""
[`GParamSpecClass`](@ref): \\_type\\_class: the parent class \\_type: the #[`GValue`](@ref) type for this parameter : The instance finalization function (optional), should chain  up to the finalize method of the parent class. \\_set\\_default: Resets a  to the default value for this type (recommended, the default is [`g_value_reset`](@ref)()), see  [`g_param_value_set_default`](@ref)(). \\_validate: Ensures that the contents of  comply with the  specifications set out by this type (optional), see  [`g_param_value_validate`](@ref)(). \\_cmp: Compares  with  according to this type (recommended, the default is memcmp()), see [`g_param_values_cmp`](@ref)(). \\_is\\_valid: Checks if contents of  comply with the specifications set out by this type, without modifying the value. This vfunc is optional. If it isn't set, [`GObject`](@ref) will use \\_validate. Since 2.74

The class structure for the [`GParamSpec`](@ref) type. Normally, [`GParamSpec`](@ref) classes are filled by [`g_param_type_register_static`](@ref)().
"""
const GParamSpecClass = _GParamSpecClass

# typedef void ( * GClosureNotify ) ( gpointer data , GClosure * closure )
"""
[`GClosureNotify`](@ref):

\\date : data specified when registering the notification callback : the #[`GClosure`](@ref) on which the notification is emitted

The type used for the various notification callbacks which can be registered on closures.
"""
const GClosureNotify = Ptr{Cvoid}

struct _GClosureNotifyData
    data::gpointer
    notify::GClosureNotify
end

const GClosureNotifyData = _GClosureNotifyData

struct _GClosure
    data::NTuple{32, UInt8}
end

function Base.getproperty(x::Ptr{_GClosure}, f::Symbol)
    f === :ref_count && return (Ptr{guint}(x + 0), 0, 15)
    f === :meta_marshal_nouse && return (Ptr{guint}(x + 0), 15, 1)
    f === :n_guards && return (Ptr{guint}(x + 0), 16, 1)
    f === :n_fnotifiers && return (Ptr{guint}(x + 0), 17, 2)
    f === :n_inotifiers && return (Ptr{guint}(x + 0), 19, 8)
    f === :in_inotify && return (Ptr{guint}(x + 0), 27, 1)
    f === :floating && return (Ptr{guint}(x + 0), 28, 1)
    f === :derivative_flag && return (Ptr{guint}(x + 0), 29, 1)
    f === :in_marshal && return (Ptr{guint}(x + 0), 30, 1)
    f === :is_invalid && return (Ptr{guint}(x + 0), 31, 1)
    f === :marshal && return Ptr{Ptr{Cvoid}}(x + 8)
    f === :data && return Ptr{gpointer}(x + 16)
    f === :notifiers && return Ptr{Ptr{GClosureNotifyData}}(x + 24)
    return getfield(x, f)
end

function Base.getproperty(x::_GClosure, f::Symbol)
    r = Ref{_GClosure}(x)
    ptr = Base.unsafe_convert(Ptr{_GClosure}, r)
    fptr = getproperty(ptr, f)
    begin
        if fptr isa Ptr
            return GC.@preserve(r, unsafe_load(fptr))
        else
            (baseptr, offset, width) = fptr
            ty = eltype(baseptr)
            baseptr32 = convert(Ptr{UInt32}, baseptr)
            u64 = GC.@preserve(r, unsafe_load(baseptr32))
            if offset + width > 32
                u64 |= GC.@preserve(r, unsafe_load(baseptr32 + 4)) << 32
            end
            u64 = u64 >> offset & (1 << width - 1)
            return u64 % ty
        end
    end
end

function Base.setproperty!(x::Ptr{_GClosure}, f::Symbol, v)
    fptr = getproperty(x, f)
    if fptr isa Ptr
        unsafe_store!(getproperty(x, f), v)
    else
        (baseptr, offset, width) = fptr
        baseptr32 = convert(Ptr{UInt32}, baseptr)
        u64 = unsafe_load(baseptr32)
        straddle = offset + width > 32
        if straddle
            u64 |= unsafe_load(baseptr32 + 4) << 32
        end
        mask = 1 << width - 1
        u64 &= ~(mask << offset)
        u64 |= (unsigned(v) & mask) << offset
        unsafe_store!(baseptr32, u64 & typemax(UInt32))
        if straddle
            unsafe_store!(baseptr32 + 4, u64 >> 32)
        end
    end
end

function Base.propertynames(x::_GClosure, private::Bool = false)
    (:ref_count, :meta_marshal_nouse, :n_guards, :n_fnotifiers, :n_inotifiers, :in_inotify, :floating, :derivative_flag, :in_marshal, :is_invalid, :marshal, :data, :notifiers, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

const GClosure = _GClosure

# typedef void ( * GCallback ) ( void )
"""
[`GCallback`](@ref):

The type used for callback functions in structure definitions and function  signatures.

This doesn't mean that all callback functions must take no parameters and return void. The required signature of a callback function is determined by the context in which is used (e.g. the signal to which it is connected).

Use [`G_CALLBACK`](@ref)() to cast the callback function to a #[`GCallback`](@ref).
"""
const GCallback = Ptr{Cvoid}

"""
    g_cclosure_marshal_BOOLEAN__FLAGS(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_cclosure_marshal_BOOLEAN__FLAGS (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
```
"""
function g_cclosure_marshal_BOOLEAN__FLAGS(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)
    @ccall libaravis.g_cclosure_marshal_BOOLEAN__FLAGS(closure::Ptr{GClosure}, return_value::Ptr{GValue}, n_param_values::guint, param_values::Ptr{GValue}, invocation_hint::gpointer, marshal_data::gpointer)::Cvoid
end

"""
    g_cclosure_marshal_BOOLEAN__BOXED_BOXED(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_cclosure_marshal_BOOLEAN__BOXED_BOXED (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
```
"""
function g_cclosure_marshal_BOOLEAN__BOXED_BOXED(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)
    @ccall libaravis.g_cclosure_marshal_BOOLEAN__BOXED_BOXED(closure::Ptr{GClosure}, return_value::Ptr{GValue}, n_param_values::guint, param_values::Ptr{GValue}, invocation_hint::gpointer, marshal_data::gpointer)::Cvoid
end

"""
    g_signal_handler_disconnect(instance, handler_id)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_signal_handler_disconnect (gpointer instance, gulong handler_id);
```
"""
function g_signal_handler_disconnect(instance, handler_id)
    @ccall libaravis.g_signal_handler_disconnect(instance::gpointer, handler_id::gulong)::Cvoid
end

"""
    GConnectFlags

[`GConnectFlags`](@ref): \\_CONNECT\\_DEFAULT: Default behaviour (no special flags). Since: 2.74 \\_CONNECT\\_AFTER: If set, the handler should be called after the default handler of the signal. Normally, the handler is called before the default handler. \\_CONNECT\\_SWAPPED: If set, the instance and data should be swapped when calling the handler; see [`g_signal_connect_swapped`](@ref)() for an example.

The connection flags are used to specify the behaviour of a signal's  connection.
"""
@cenum GConnectFlags::UInt32 begin
    G_CONNECT_DEFAULT = 0
    G_CONNECT_AFTER = 1
    G_CONNECT_SWAPPED = 2
end

"""
    g_signal_connect_data(instance, detailed_signal, c_handler, data, destroy_data, connect_flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gulong g_signal_connect_data (gpointer instance, const gchar *detailed_signal, GCallback c_handler, gpointer data, GClosureNotify destroy_data, GConnectFlags connect_flags);
```
"""
function g_signal_connect_data(instance, detailed_signal, c_handler, data, destroy_data, connect_flags)
    @ccall libaravis.g_signal_connect_data(instance::gpointer, detailed_signal::Ptr{gchar}, c_handler::GCallback, data::gpointer, destroy_data::GClosureNotify, connect_flags::GConnectFlags)::gulong
end

"""
    GSignalMatchType

[`GSignalMatchType`](@ref): \\_SIGNAL\\_MATCH\\_ID: The signal id must be equal. \\_SIGNAL\\_MATCH\\_DETAIL: The signal detail must be equal. \\_SIGNAL\\_MATCH\\_CLOSURE: The closure must be the same. \\_SIGNAL\\_MATCH\\_FUNC: The C closure callback must be the same. \\_SIGNAL\\_MATCH\\_DATA: The closure data must be the same. \\_SIGNAL\\_MATCH\\_UNBLOCKED: Only unblocked signals may be matched.

The match types specify what [`g_signal_handlers_block_matched`](@ref)(), [`g_signal_handlers_unblock_matched`](@ref)() and [`g_signal_handlers_disconnect_matched`](@ref)() match signals by.
"""
@cenum GSignalMatchType::UInt32 begin
    G_SIGNAL_MATCH_ID = 1
    G_SIGNAL_MATCH_DETAIL = 2
    G_SIGNAL_MATCH_CLOSURE = 4
    G_SIGNAL_MATCH_FUNC = 8
    G_SIGNAL_MATCH_DATA = 16
    G_SIGNAL_MATCH_UNBLOCKED = 32
end

"""
    g_signal_handlers_disconnect_matched(instance, mask, signal_id, detail, closure, func, data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL guint g_signal_handlers_disconnect_matched (gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data);
```
"""
function g_signal_handlers_disconnect_matched(instance, mask, signal_id, detail, closure, func, data)
    @ccall libaravis.g_signal_handlers_disconnect_matched(instance::gpointer, mask::GSignalMatchType, signal_id::guint, detail::GQuark, closure::Ptr{GClosure}, func::gpointer, data::gpointer)::guint
end

"""
    g_signal_handlers_block_matched(instance, mask, signal_id, detail, closure, func, data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL guint g_signal_handlers_block_matched (gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data);
```
"""
function g_signal_handlers_block_matched(instance, mask, signal_id, detail, closure, func, data)
    @ccall libaravis.g_signal_handlers_block_matched(instance::gpointer, mask::GSignalMatchType, signal_id::guint, detail::GQuark, closure::Ptr{GClosure}, func::gpointer, data::gpointer)::guint
end

"""
    g_signal_handlers_unblock_matched(instance, mask, signal_id, detail, closure, func, data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL guint g_signal_handlers_unblock_matched (gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data);
```
"""
function g_signal_handlers_unblock_matched(instance, mask, signal_id, detail, closure, func, data)
    @ccall libaravis.g_signal_handlers_unblock_matched(instance::gpointer, mask::GSignalMatchType, signal_id::guint, detail::GQuark, closure::Ptr{GClosure}, func::gpointer, data::gpointer)::guint
end

"""
    g_date_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_date_get_type (void) G_GNUC_CONST;
```
"""
function g_date_get_type()
    @ccall libaravis.g_date_get_type()::GType
end

"""
    g_strv_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_strv_get_type (void) G_GNUC_CONST;
```
"""
function g_strv_get_type()
    @ccall libaravis.g_strv_get_type()::GType
end

"""
    g_gstring_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_gstring_get_type (void) G_GNUC_CONST;
```
"""
function g_gstring_get_type()
    @ccall libaravis.g_gstring_get_type()::GType
end

"""
    g_hash_table_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_hash_table_get_type (void) G_GNUC_CONST;
```
"""
function g_hash_table_get_type()
    @ccall libaravis.g_hash_table_get_type()::GType
end

"""
    g_regex_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_regex_get_type (void) G_GNUC_CONST;
```
"""
function g_regex_get_type()
    @ccall libaravis.g_regex_get_type()::GType
end

"""
    g_match_info_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_30 GType g_match_info_get_type (void) G_GNUC_CONST;
```
"""
function g_match_info_get_type()
    @ccall libaravis.g_match_info_get_type()::GType
end

"""
    g_array_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_array_get_type (void) G_GNUC_CONST;
```
"""
function g_array_get_type()
    @ccall libaravis.g_array_get_type()::GType
end

"""
    g_byte_array_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_byte_array_get_type (void) G_GNUC_CONST;
```
"""
function g_byte_array_get_type()
    @ccall libaravis.g_byte_array_get_type()::GType
end

"""
    g_ptr_array_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_ptr_array_get_type (void) G_GNUC_CONST;
```
"""
function g_ptr_array_get_type()
    @ccall libaravis.g_ptr_array_get_type()::GType
end

"""
    g_bytes_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_bytes_get_type (void) G_GNUC_CONST;
```
"""
function g_bytes_get_type()
    @ccall libaravis.g_bytes_get_type()::GType
end

"""
    g_variant_type_get_gtype()

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_variant_type_get_gtype (void) G_GNUC_CONST;
```
"""
function g_variant_type_get_gtype()
    @ccall libaravis.g_variant_type_get_gtype()::GType
end

"""
    g_error_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_error_get_type (void) G_GNUC_CONST;
```
"""
function g_error_get_type()
    @ccall libaravis.g_error_get_type()::GType
end

"""
    g_date_time_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_date_time_get_type (void) G_GNUC_CONST;
```
"""
function g_date_time_get_type()
    @ccall libaravis.g_date_time_get_type()::GType
end

"""
    g_time_zone_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_time_zone_get_type (void) G_GNUC_CONST;
```
"""
function g_time_zone_get_type()
    @ccall libaravis.g_time_zone_get_type()::GType
end

"""
    g_io_channel_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_io_channel_get_type (void) G_GNUC_CONST;
```
"""
function g_io_channel_get_type()
    @ccall libaravis.g_io_channel_get_type()::GType
end

"""
    g_io_condition_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_io_condition_get_type (void) G_GNUC_CONST;
```
"""
function g_io_condition_get_type()
    @ccall libaravis.g_io_condition_get_type()::GType
end

"""
    g_variant_builder_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_variant_builder_get_type (void) G_GNUC_CONST;
```
"""
function g_variant_builder_get_type()
    @ccall libaravis.g_variant_builder_get_type()::GType
end

"""
    g_variant_dict_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_40 GType g_variant_dict_get_type (void) G_GNUC_CONST;
```
"""
function g_variant_dict_get_type()
    @ccall libaravis.g_variant_dict_get_type()::GType
end

"""
    g_main_loop_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_30 GType g_main_loop_get_type (void) G_GNUC_CONST;
```
"""
function g_main_loop_get_type()
    @ccall libaravis.g_main_loop_get_type()::GType
end

"""
    g_main_context_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_30 GType g_main_context_get_type (void) G_GNUC_CONST;
```
"""
function g_main_context_get_type()
    @ccall libaravis.g_main_context_get_type()::GType
end

"""
    g_source_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_30 GType g_source_get_type (void) G_GNUC_CONST;
```
"""
function g_source_get_type()
    @ccall libaravis.g_source_get_type()::GType
end

"""
    g_pollfd_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_36 GType g_pollfd_get_type (void) G_GNUC_CONST;
```
"""
function g_pollfd_get_type()
    @ccall libaravis.g_pollfd_get_type()::GType
end

"""
    g_markup_parse_context_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_36 GType g_markup_parse_context_get_type (void) G_GNUC_CONST;
```
"""
function g_markup_parse_context_get_type()
    @ccall libaravis.g_markup_parse_context_get_type()::GType
end

"""
    g_key_file_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_key_file_get_type (void) G_GNUC_CONST;
```
"""
function g_key_file_get_type()
    @ccall libaravis.g_key_file_get_type()::GType
end

"""
    g_mapped_file_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_40 GType g_mapped_file_get_type (void) G_GNUC_CONST;
```
"""
function g_mapped_file_get_type()
    @ccall libaravis.g_mapped_file_get_type()::GType
end

"""
    g_thread_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_36 GType g_thread_get_type (void) G_GNUC_CONST;
```
"""
function g_thread_get_type()
    @ccall libaravis.g_thread_get_type()::GType
end

"""
    g_checksum_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_36 GType g_checksum_get_type (void) G_GNUC_CONST;
```
"""
function g_checksum_get_type()
    @ccall libaravis.g_checksum_get_type()::GType
end

"""
    g_option_group_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_44 GType g_option_group_get_type (void) G_GNUC_CONST;
```
"""
function g_option_group_get_type()
    @ccall libaravis.g_option_group_get_type()::GType
end

"""
    g_uri_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_66 GType g_uri_get_type (void) G_GNUC_CONST;
```
"""
function g_uri_get_type()
    @ccall libaravis.g_uri_get_type()::GType
end

"""
    g_tree_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_68 GType g_tree_get_type (void) G_GNUC_CONST;
```
"""
function g_tree_get_type()
    @ccall libaravis.g_tree_get_type()::GType
end

"""
    g_pattern_spec_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_70 GType g_pattern_spec_get_type (void) G_GNUC_CONST;
```
"""
function g_pattern_spec_get_type()
    @ccall libaravis.g_pattern_spec_get_type()::GType
end

"""
    g_bookmark_file_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_76 GType g_bookmark_file_get_type (void) G_GNUC_CONST;
```
"""
function g_bookmark_file_get_type()
    @ccall libaravis.g_bookmark_file_get_type()::GType
end

"""
    g_hmac_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_80 GType g_hmac_get_type (void) G_GNUC_CONST;
```
"""
function g_hmac_get_type()
    @ccall libaravis.g_hmac_get_type()::GType
end

"""
    g_dir_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_80 GType g_dir_get_type (void) G_GNUC_CONST;
```
"""
function g_dir_get_type()
    @ccall libaravis.g_dir_get_type()::GType
end

"""
    g_rand_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_80 GType g_rand_get_type (void) G_GNUC_CONST;
```
"""
function g_rand_get_type()
    @ccall libaravis.g_rand_get_type()::GType
end

"""
    g_strv_builder_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_80 GType g_strv_builder_get_type (void) G_GNUC_CONST;
```
"""
function g_strv_builder_get_type()
    @ccall libaravis.g_strv_builder_get_type()::GType
end

"""
    g_closure_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_closure_get_type (void) G_GNUC_CONST;
```
"""
function g_closure_get_type()
    @ccall libaravis.g_closure_get_type()::GType
end

"""
    g_value_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_value_get_type (void) G_GNUC_CONST;
```
"""
function g_value_get_type()
    @ccall libaravis.g_value_get_type()::GType
end

struct _GObject
    g_type_instance::GTypeInstance
    ref_count::guint
    qdata::Ptr{GData}
end

const GObject = _GObject

"""
    _GObjectClass

[`GObjectClass`](@ref): \\_type\\_class: the parent class : the  function is called by [`g_object_new`](@ref) () to  complete the object initialization after all the construction properties are set. The first thing a  implementation must do is chain up to the  of the parent class. Overriding  should be rarely  needed, e.g. to handle construct properties, or to implement singletons.

The class structure for the [`GObject`](@ref) type.

|[<!-- language="C" --> // Example of implementing a singleton using a constructor. static MySingleton *the\\_singleton = NULL;

static [`GObject`](@ref)* my\\_singleton\\_constructor ([`GType`](@ref) type, [`guint`](@ref) n\\_construct\\_params, [`GObjectConstructParam`](@ref) *construct\\_params) { [`GObject`](@ref) *object;

if (!the\\_singleton) { object = [`G_OBJECT_CLASS`](@ref) (parent\\_class)->constructor (type, n\\_construct\\_params, construct\\_params); the\\_singleton = MY\\_SINGLETON (object); } else object = [`g_object_ref`](@ref) ([`G_OBJECT`](@ref) (the\\_singleton));

return object; } ]|

# See also
\\_property: the generic setter for all properties of this type. Should be overridden for every type with properties. If implementations of, \\_property don't emit property change notification explicitly, this will be done implicitly by the type system. However, if the notify signal is emitted explicitly, the type system will not emit it a second time. \\_property: the generic getter for all properties of this type. Should be overridden for every type with properties. : the  function is supposed to drop all references to other  objects, but keep the instance otherwise intact, so that client method  invocations still work. It may be run multiple times (due to reference  loops). Before returning,  should chain up to the  method  of the parent class. : instance finalization function, should finish the finalization of  the instance begun in  and chain up to the  method of the  parent class. \\_properties\\_changed: emits property change notification for a bunch of properties. Overriding \\_properties\\_changed should be rarely  needed. : the class closure for the notify signal : the  function is called by [`g_object_new`](@ref)() as the final step of the object creation process. At the point of the call, all construction properties have been set on the object. The purpose of this call is to allow for object initialisation steps that can only be performed after construction properties have been set.  implementors should chain up to the  call of their parent class to allow it to complete its initialisation.
"""
struct _GObjectClass
    g_type_class::GTypeClass
    construct_properties::Ptr{GSList}
    constructor::Ptr{Cvoid}
    set_property::Ptr{Cvoid}
    get_property::Ptr{Cvoid}
    dispose::Ptr{Cvoid}
    finalize::Ptr{Cvoid}
    dispatch_properties_changed::Ptr{Cvoid}
    notify::Ptr{Cvoid}
    constructed::Ptr{Cvoid}
    flags::gsize
    n_construct_properties::gsize
    pspecs::gpointer
    n_pspecs::gsize
    pdummy::NTuple{3, gpointer}
end

"""
[`GObjectClass`](@ref): \\_type\\_class: the parent class : the  function is called by [`g_object_new`](@ref) () to  complete the object initialization after all the construction properties are set. The first thing a  implementation must do is chain up to the  of the parent class. Overriding  should be rarely  needed, e.g. to handle construct properties, or to implement singletons.

The class structure for the [`GObject`](@ref) type.

|[<!-- language="C" --> // Example of implementing a singleton using a constructor. static MySingleton *the\\_singleton = NULL;

static [`GObject`](@ref)* my\\_singleton\\_constructor ([`GType`](@ref) type, [`guint`](@ref) n\\_construct\\_params, [`GObjectConstructParam`](@ref) *construct\\_params) { [`GObject`](@ref) *object;

if (!the\\_singleton) { object = [`G_OBJECT_CLASS`](@ref) (parent\\_class)->constructor (type, n\\_construct\\_params, construct\\_params); the\\_singleton = MY\\_SINGLETON (object); } else object = [`g_object_ref`](@ref) ([`G_OBJECT`](@ref) (the\\_singleton));

return object; } ]|

# See also
\\_property: the generic setter for all properties of this type. Should be overridden for every type with properties. If implementations of, \\_property don't emit property change notification explicitly, this will be done implicitly by the type system. However, if the notify signal is emitted explicitly, the type system will not emit it a second time. \\_property: the generic getter for all properties of this type. Should be overridden for every type with properties. : the  function is supposed to drop all references to other  objects, but keep the instance otherwise intact, so that client method  invocations still work. It may be run multiple times (due to reference  loops). Before returning,  should chain up to the  method  of the parent class. : instance finalization function, should finish the finalization of  the instance begun in  and chain up to the  method of the  parent class. \\_properties\\_changed: emits property change notification for a bunch of properties. Overriding \\_properties\\_changed should be rarely  needed. : the class closure for the notify signal : the  function is called by [`g_object_new`](@ref)() as the final step of the object creation process. At the point of the call, all construction properties have been set on the object. The purpose of this call is to allow for object initialisation steps that can only be performed after construction properties have been set.  implementors should chain up to the  call of their parent class to allow it to complete its initialisation.
"""
const GObjectClass = _GObjectClass

"""
    g_initially_unowned_get_type()

[`GInitiallyUnowned`](@ref):

A type for objects that have an initially floating reference.

All the fields in the [`GInitiallyUnowned`](@ref) structure are private to the implementation and should never be accessed directly.

[`GInitiallyUnownedClass`](@ref):

The class structure for the [`GInitiallyUnowned`](@ref) type.

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_initially_unowned_get_type (void);
```
"""
function g_initially_unowned_get_type()
    @ccall libaravis.g_initially_unowned_get_type()::GType
end

const GInitiallyUnowned = _GObject

"""
[`GObjectClass`](@ref): \\_type\\_class: the parent class : the  function is called by [`g_object_new`](@ref) () to  complete the object initialization after all the construction properties are set. The first thing a  implementation must do is chain up to the  of the parent class. Overriding  should be rarely  needed, e.g. to handle construct properties, or to implement singletons.

The class structure for the [`GObject`](@ref) type.

|[<!-- language="C" --> // Example of implementing a singleton using a constructor. static MySingleton *the\\_singleton = NULL;

static [`GObject`](@ref)* my\\_singleton\\_constructor ([`GType`](@ref) type, [`guint`](@ref) n\\_construct\\_params, [`GObjectConstructParam`](@ref) *construct\\_params) { [`GObject`](@ref) *object;

if (!the\\_singleton) { object = [`G_OBJECT_CLASS`](@ref) (parent\\_class)->constructor (type, n\\_construct\\_params, construct\\_params); the\\_singleton = MY\\_SINGLETON (object); } else object = [`g_object_ref`](@ref) ([`G_OBJECT`](@ref) (the\\_singleton));

return object; } ]|

# See also
\\_property: the generic setter for all properties of this type. Should be overridden for every type with properties. If implementations of, \\_property don't emit property change notification explicitly, this will be done implicitly by the type system. However, if the notify signal is emitted explicitly, the type system will not emit it a second time. \\_property: the generic getter for all properties of this type. Should be overridden for every type with properties. : the  function is supposed to drop all references to other  objects, but keep the instance otherwise intact, so that client method  invocations still work. It may be run multiple times (due to reference  loops). Before returning,  should chain up to the  method  of the parent class. : instance finalization function, should finish the finalization of  the instance begun in  and chain up to the  method of the  parent class. \\_properties\\_changed: emits property change notification for a bunch of properties. Overriding \\_properties\\_changed should be rarely  needed. : the class closure for the notify signal : the  function is called by [`g_object_new`](@ref)() as the final step of the object creation process. At the point of the call, all construction properties have been set on the object. The purpose of this call is to allow for object initialisation steps that can only be performed after construction properties have been set.  implementors should chain up to the  call of their parent class to allow it to complete its initialisation.
"""
const GInitiallyUnownedClass = _GObjectClass

"""
    g_binding_flags_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_binding_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_binding_flags_get_type()
    @ccall libaravis.g_binding_flags_get_type()::GType
end

"""
    g_binding_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_binding_get_type (void) G_GNUC_CONST;
```
"""
function g_binding_get_type()
    @ccall libaravis.g_binding_get_type()::GType
end

const _GBinding = Cvoid

const GBinding = _GBinding

"""
    g_binding_group_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_72 GType g_binding_group_get_type (void) G_GNUC_CONST;
```
"""
function g_binding_group_get_type()
    @ccall libaravis.g_binding_group_get_type()::GType
end

const _GBindingGroup = Cvoid

const GBindingGroup = _GBindingGroup

"""
    _GEnumValue

[`GEnumValue`](@ref): : the enum value \\_name: the name of the value \\_nick: the nickname of the value

A structure which contains a single enum value, its name, and its nickname.
"""
struct _GEnumValue
    value::gint
    value_name::Ptr{gchar}
    value_nick::Ptr{gchar}
end

"""
[`GEnumValue`](@ref): : the enum value \\_name: the name of the value \\_nick: the nickname of the value

A structure which contains a single enum value, its name, and its nickname.
"""
const GEnumValue = _GEnumValue

"""
    _GEnumClass

[`GEnumClass`](@ref): \\_type\\_class: the parent class : the smallest possible value. : the largest possible value. \\_values: the number of possible values. : an array of #[`GEnumValue`](@ref) structs describing the  individual values.

The class of an enumeration type holds information about its  possible values.
"""
struct _GEnumClass
    g_type_class::GTypeClass
    minimum::gint
    maximum::gint
    n_values::guint
    values::Ptr{GEnumValue}
end

"""
[`GEnumClass`](@ref): \\_type\\_class: the parent class : the smallest possible value. : the largest possible value. \\_values: the number of possible values. : an array of #[`GEnumValue`](@ref) structs describing the  individual values.

The class of an enumeration type holds information about its  possible values.
"""
const GEnumClass = _GEnumClass

"""
    _GFlagsValue

[`GFlagsValue`](@ref): : the flags value \\_name: the name of the value \\_nick: the nickname of the value

A structure which contains a single flags value, its name, and its nickname.
"""
struct _GFlagsValue
    value::guint
    value_name::Ptr{gchar}
    value_nick::Ptr{gchar}
end

"""
[`GFlagsValue`](@ref): : the flags value \\_name: the name of the value \\_nick: the nickname of the value

A structure which contains a single flags value, its name, and its nickname.
"""
const GFlagsValue = _GFlagsValue

"""
    _GFlagsClass

[`GFlagsClass`](@ref): \\_type\\_class: the parent class : a mask covering all possible values. \\_values: the number of possible values. : an array of #[`GFlagsValue`](@ref) structs describing the  individual values.

The class of a flags type holds information about its  possible values.
"""
struct _GFlagsClass
    g_type_class::GTypeClass
    mask::guint
    n_values::guint
    values::Ptr{GFlagsValue}
end

"""
[`GFlagsClass`](@ref): \\_type\\_class: the parent class : a mask covering all possible values. \\_values: the number of possible values. : an array of #[`GFlagsValue`](@ref) structs describing the  individual values.

The class of a flags type holds information about its  possible values.
"""
const GFlagsClass = _GFlagsClass

"""
    g_enum_register_static(name, const_static_values)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_enum_register_static (const gchar *name, const GEnumValue *const_static_values);
```
"""
function g_enum_register_static(name, const_static_values)
    @ccall libaravis.g_enum_register_static(name::Ptr{gchar}, const_static_values::Ptr{GEnumValue})::GType
end

"""
    g_flags_register_static(name, const_static_values)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_flags_register_static (const gchar *name, const GFlagsValue *const_static_values);
```
"""
function g_flags_register_static(name, const_static_values)
    @ccall libaravis.g_flags_register_static(name::Ptr{gchar}, const_static_values::Ptr{GFlagsValue})::GType
end

"""
    g_unicode_type_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_60 GType g_unicode_type_get_type (void) G_GNUC_CONST;
```
"""
function g_unicode_type_get_type()
    @ccall libaravis.g_unicode_type_get_type()::GType
end

"""
    g_unicode_break_type_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_60 GType g_unicode_break_type_get_type (void) G_GNUC_CONST;
```
"""
function g_unicode_break_type_get_type()
    @ccall libaravis.g_unicode_break_type_get_type()::GType
end

"""
    g_unicode_script_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_60 GType g_unicode_script_get_type (void) G_GNUC_CONST;
```
"""
function g_unicode_script_get_type()
    @ccall libaravis.g_unicode_script_get_type()::GType
end

"""
    g_normalize_mode_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_60 GType g_normalize_mode_get_type (void) G_GNUC_CONST;
```
"""
function g_normalize_mode_get_type()
    @ccall libaravis.g_normalize_mode_get_type()::GType
end

"""
    _GParamSpecChar

[`GParamSpecChar`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion : minimum value for the property specified : maximum value for the property specified \\_value: default value for the property specified

A #[`GParamSpec`](@ref) derived structure that contains the meta data for character properties.
"""
struct _GParamSpecChar
    parent_instance::GParamSpec
    minimum::gint8
    maximum::gint8
    default_value::gint8
end

"""
[`GParamSpecChar`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion : minimum value for the property specified : maximum value for the property specified \\_value: default value for the property specified

A #[`GParamSpec`](@ref) derived structure that contains the meta data for character properties.
"""
const GParamSpecChar = _GParamSpecChar

"""
    _GParamSpecUChar

[`GParamSpecUChar`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion : minimum value for the property specified : maximum value for the property specified \\_value: default value for the property specified

A #[`GParamSpec`](@ref) derived structure that contains the meta data for unsigned character properties.
"""
struct _GParamSpecUChar
    parent_instance::GParamSpec
    minimum::guint8
    maximum::guint8
    default_value::guint8
end

"""
[`GParamSpecUChar`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion : minimum value for the property specified : maximum value for the property specified \\_value: default value for the property specified

A #[`GParamSpec`](@ref) derived structure that contains the meta data for unsigned character properties.
"""
const GParamSpecUChar = _GParamSpecUChar

"""
    _GParamSpecBoolean

[`GParamSpecBoolean`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion \\_value: default value for the property specified

A #[`GParamSpec`](@ref) derived structure that contains the meta data for boolean properties.
"""
struct _GParamSpecBoolean
    parent_instance::GParamSpec
    default_value::gboolean
end

"""
[`GParamSpecBoolean`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion \\_value: default value for the property specified

A #[`GParamSpec`](@ref) derived structure that contains the meta data for boolean properties.
"""
const GParamSpecBoolean = _GParamSpecBoolean

"""
    _GParamSpecInt

[`GParamSpecInt`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion : minimum value for the property specified : maximum value for the property specified \\_value: default value for the property specified

A #[`GParamSpec`](@ref) derived structure that contains the meta data for integer properties.
"""
struct _GParamSpecInt
    parent_instance::GParamSpec
    minimum::gint
    maximum::gint
    default_value::gint
end

"""
[`GParamSpecInt`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion : minimum value for the property specified : maximum value for the property specified \\_value: default value for the property specified

A #[`GParamSpec`](@ref) derived structure that contains the meta data for integer properties.
"""
const GParamSpecInt = _GParamSpecInt

"""
    _GParamSpecUInt

[`GParamSpecUInt`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion : minimum value for the property specified : maximum value for the property specified \\_value: default value for the property specified

A #[`GParamSpec`](@ref) derived structure that contains the meta data for unsigned integer properties.
"""
struct _GParamSpecUInt
    parent_instance::GParamSpec
    minimum::guint
    maximum::guint
    default_value::guint
end

"""
[`GParamSpecUInt`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion : minimum value for the property specified : maximum value for the property specified \\_value: default value for the property specified

A #[`GParamSpec`](@ref) derived structure that contains the meta data for unsigned integer properties.
"""
const GParamSpecUInt = _GParamSpecUInt

"""
    _GParamSpecLong

[`GParamSpecLong`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion : minimum value for the property specified : maximum value for the property specified \\_value: default value for the property specified

A #[`GParamSpec`](@ref) derived structure that contains the meta data for long integer properties.
"""
struct _GParamSpecLong
    parent_instance::GParamSpec
    minimum::glong
    maximum::glong
    default_value::glong
end

"""
[`GParamSpecLong`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion : minimum value for the property specified : maximum value for the property specified \\_value: default value for the property specified

A #[`GParamSpec`](@ref) derived structure that contains the meta data for long integer properties.
"""
const GParamSpecLong = _GParamSpecLong

"""
    _GParamSpecULong

[`GParamSpecULong`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion : minimum value for the property specified : maximum value for the property specified \\_value: default value for the property specified

A #[`GParamSpec`](@ref) derived structure that contains the meta data for unsigned long integer properties.
"""
struct _GParamSpecULong
    parent_instance::GParamSpec
    minimum::gulong
    maximum::gulong
    default_value::gulong
end

"""
[`GParamSpecULong`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion : minimum value for the property specified : maximum value for the property specified \\_value: default value for the property specified

A #[`GParamSpec`](@ref) derived structure that contains the meta data for unsigned long integer properties.
"""
const GParamSpecULong = _GParamSpecULong

"""
    _GParamSpecInt64

[`GParamSpecInt64`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion : minimum value for the property specified : maximum value for the property specified \\_value: default value for the property specified

A #[`GParamSpec`](@ref) derived structure that contains the meta data for 64bit integer properties.
"""
struct _GParamSpecInt64
    parent_instance::GParamSpec
    minimum::gint64
    maximum::gint64
    default_value::gint64
end

"""
[`GParamSpecInt64`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion : minimum value for the property specified : maximum value for the property specified \\_value: default value for the property specified

A #[`GParamSpec`](@ref) derived structure that contains the meta data for 64bit integer properties.
"""
const GParamSpecInt64 = _GParamSpecInt64

"""
    _GParamSpecUInt64

[`GParamSpecUInt64`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion : minimum value for the property specified : maximum value for the property specified \\_value: default value for the property specified

A #[`GParamSpec`](@ref) derived structure that contains the meta data for unsigned 64bit integer properties.
"""
struct _GParamSpecUInt64
    parent_instance::GParamSpec
    minimum::guint64
    maximum::guint64
    default_value::guint64
end

"""
[`GParamSpecUInt64`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion : minimum value for the property specified : maximum value for the property specified \\_value: default value for the property specified

A #[`GParamSpec`](@ref) derived structure that contains the meta data for unsigned 64bit integer properties.
"""
const GParamSpecUInt64 = _GParamSpecUInt64

"""
[`gunichar`](@ref):

A type which can hold any UTF-32 or UCS-4 character code, also known as a Unicode code point.

If you want to produce the UTF-8 representation of a #[`gunichar`](@ref), use [`g_ucs4_to_utf8`](@ref)(). See also [`g_utf8_to_ucs4`](@ref)() for the reverse process.

To print/scan values of this type as integer, use G\\_GINT32\\_MODIFIER and/or G\\_GUINT32\\_FORMAT.

The notation to express a Unicode code point in running text is as a hexadecimal number with four to six digits and uppercase letters, prefixed by the string "U+". Leading zeros are omitted, unless the code point would have fewer than four hexadecimal digits. For example, "U+0041 LATIN CAPITAL LETTER A". To print a code point in the U+-notation, use the format string "U+\\04"[`G_GINT32_FORMAT`](@ref)"X". To scan, use the format string "U+\\06"[`G_GINT32_FORMAT`](@ref)"X".

|[ [`gunichar`](@ref) c; sscanf ("U+0041", "U+06"[`G_GINT32_FORMAT`](@ref)"X", &c) [`g_print`](@ref) ("Read U+04"[`G_GINT32_FORMAT`](@ref)"X", c); ]|
"""
const gunichar = guint32

"""
    _GParamSpecUnichar

[`GParamSpecUnichar`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion \\_value: default value for the property specified

A #[`GParamSpec`](@ref) derived structure that contains the meta data for unichar (unsigned integer) properties.
"""
struct _GParamSpecUnichar
    parent_instance::GParamSpec
    default_value::gunichar
end

"""
[`GParamSpecUnichar`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion \\_value: default value for the property specified

A #[`GParamSpec`](@ref) derived structure that contains the meta data for unichar (unsigned integer) properties.
"""
const GParamSpecUnichar = _GParamSpecUnichar

"""
    _GParamSpecEnum

[`GParamSpecEnum`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion

`_class: the #GEnumClass for the enum`

\\_value: default value for the property specified

A #[`GParamSpec`](@ref) derived structure that contains the meta data for enum  properties.
"""
struct _GParamSpecEnum
    parent_instance::GParamSpec
    enum_class::Ptr{GEnumClass}
    default_value::gint
end

"""
[`GParamSpecEnum`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion

`_class: the #GEnumClass for the enum`

\\_value: default value for the property specified

A #[`GParamSpec`](@ref) derived structure that contains the meta data for enum  properties.
"""
const GParamSpecEnum = _GParamSpecEnum

"""
    _GParamSpecFlags

[`GParamSpecFlags`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion \\_class: the #[`GFlagsClass`](@ref) for the flags \\_value: default value for the property specified

A #[`GParamSpec`](@ref) derived structure that contains the meta data for flags properties.
"""
struct _GParamSpecFlags
    parent_instance::GParamSpec
    flags_class::Ptr{GFlagsClass}
    default_value::guint
end

"""
[`GParamSpecFlags`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion \\_class: the #[`GFlagsClass`](@ref) for the flags \\_value: default value for the property specified

A #[`GParamSpec`](@ref) derived structure that contains the meta data for flags properties.
"""
const GParamSpecFlags = _GParamSpecFlags

const gfloat = Cfloat

"""
    _GParamSpecFloat

[`GParamSpecFloat`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion : minimum value for the property specified : maximum value for the property specified \\_value: default value for the property specified : values closer than  will be considered identical by [`g_param_values_cmp`](@ref)(); the default value is 1e-30.

A #[`GParamSpec`](@ref) derived structure that contains the meta data for float properties.
"""
struct _GParamSpecFloat
    parent_instance::GParamSpec
    minimum::gfloat
    maximum::gfloat
    default_value::gfloat
    epsilon::gfloat
end

"""
[`GParamSpecFloat`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion : minimum value for the property specified : maximum value for the property specified \\_value: default value for the property specified : values closer than  will be considered identical by [`g_param_values_cmp`](@ref)(); the default value is 1e-30.

A #[`GParamSpec`](@ref) derived structure that contains the meta data for float properties.
"""
const GParamSpecFloat = _GParamSpecFloat

const gdouble = Cdouble

"""
    _GParamSpecDouble

[`GParamSpecDouble`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion : minimum value for the property specified : maximum value for the property specified \\_value: default value for the property specified : values closer than  will be considered identical by [`g_param_values_cmp`](@ref)(); the default value is 1e-90.

A #[`GParamSpec`](@ref) derived structure that contains the meta data for double properties.
"""
struct _GParamSpecDouble
    parent_instance::GParamSpec
    minimum::gdouble
    maximum::gdouble
    default_value::gdouble
    epsilon::gdouble
end

"""
[`GParamSpecDouble`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion : minimum value for the property specified : maximum value for the property specified \\_value: default value for the property specified : values closer than  will be considered identical by [`g_param_values_cmp`](@ref)(); the default value is 1e-90.

A #[`GParamSpec`](@ref) derived structure that contains the meta data for double properties.
"""
const GParamSpecDouble = _GParamSpecDouble

"""
    _GParamSpecString

[`GParamSpecString`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion \\_value: default value for the property specified \\_first: a string containing the allowed values for the first byte \\_nth: a string containing the allowed values for the subsequent bytes : the replacement byte for bytes which don't match \\_first or \\_nth. \\_fold\\_if\\_empty: replace empty string by NULL \\_non\\_null: replace NULL strings by an empty string

A #[`GParamSpec`](@ref) derived structure that contains the meta data for string properties.
"""
struct _GParamSpecString
    data::NTuple{104, UInt8}
end

function Base.getproperty(x::Ptr{_GParamSpecString}, f::Symbol)
    f === :parent_instance && return Ptr{GParamSpec}(x + 0)
    f === :default_value && return Ptr{Ptr{gchar}}(x + 72)
    f === :cset_first && return Ptr{Ptr{gchar}}(x + 80)
    f === :cset_nth && return Ptr{Ptr{gchar}}(x + 88)
    f === :substitutor && return Ptr{gchar}(x + 96)
    f === :null_fold_if_empty && return (Ptr{guint}(x + 96), 8, 1)
    f === :ensure_non_null && return (Ptr{guint}(x + 96), 9, 1)
    return getfield(x, f)
end

function Base.getproperty(x::_GParamSpecString, f::Symbol)
    r = Ref{_GParamSpecString}(x)
    ptr = Base.unsafe_convert(Ptr{_GParamSpecString}, r)
    fptr = getproperty(ptr, f)
    begin
        if fptr isa Ptr
            return GC.@preserve(r, unsafe_load(fptr))
        else
            (baseptr, offset, width) = fptr
            ty = eltype(baseptr)
            baseptr32 = convert(Ptr{UInt32}, baseptr)
            u64 = GC.@preserve(r, unsafe_load(baseptr32))
            if offset + width > 32
                u64 |= GC.@preserve(r, unsafe_load(baseptr32 + 4)) << 32
            end
            u64 = u64 >> offset & (1 << width - 1)
            return u64 % ty
        end
    end
end

function Base.setproperty!(x::Ptr{_GParamSpecString}, f::Symbol, v)
    fptr = getproperty(x, f)
    if fptr isa Ptr
        unsafe_store!(getproperty(x, f), v)
    else
        (baseptr, offset, width) = fptr
        baseptr32 = convert(Ptr{UInt32}, baseptr)
        u64 = unsafe_load(baseptr32)
        straddle = offset + width > 32
        if straddle
            u64 |= unsafe_load(baseptr32 + 4) << 32
        end
        mask = 1 << width - 1
        u64 &= ~(mask << offset)
        u64 |= (unsigned(v) & mask) << offset
        unsafe_store!(baseptr32, u64 & typemax(UInt32))
        if straddle
            unsafe_store!(baseptr32 + 4, u64 >> 32)
        end
    end
end

function Base.propertynames(x::_GParamSpecString, private::Bool = false)
    (:parent_instance, :default_value, :cset_first, :cset_nth, :substitutor, :null_fold_if_empty, :ensure_non_null, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

"""
[`GParamSpecString`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion \\_value: default value for the property specified \\_first: a string containing the allowed values for the first byte \\_nth: a string containing the allowed values for the subsequent bytes : the replacement byte for bytes which don't match \\_first or \\_nth. \\_fold\\_if\\_empty: replace empty string by NULL \\_non\\_null: replace NULL strings by an empty string

A #[`GParamSpec`](@ref) derived structure that contains the meta data for string properties.
"""
const GParamSpecString = _GParamSpecString

"""
    _GParamSpecParam

[`GParamSpecParam`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion

A #[`GParamSpec`](@ref) derived structure that contains the meta data for G\\_TYPE\\_PARAM properties.
"""
struct _GParamSpecParam
    parent_instance::GParamSpec
end

"""
[`GParamSpecParam`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion

A #[`GParamSpec`](@ref) derived structure that contains the meta data for G\\_TYPE\\_PARAM properties.
"""
const GParamSpecParam = _GParamSpecParam

"""
    _GParamSpecBoxed

[`GParamSpecBoxed`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion

A #[`GParamSpec`](@ref) derived structure that contains the meta data for boxed properties.
"""
struct _GParamSpecBoxed
    parent_instance::GParamSpec
end

"""
[`GParamSpecBoxed`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion

A #[`GParamSpec`](@ref) derived structure that contains the meta data for boxed properties.
"""
const GParamSpecBoxed = _GParamSpecBoxed

"""
    _GParamSpecPointer

[`GParamSpecPointer`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion

A #[`GParamSpec`](@ref) derived structure that contains the meta data for pointer properties.
"""
struct _GParamSpecPointer
    parent_instance::GParamSpec
end

"""
[`GParamSpecPointer`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion

A #[`GParamSpec`](@ref) derived structure that contains the meta data for pointer properties.
"""
const GParamSpecPointer = _GParamSpecPointer

"""
    _GParamSpecValueArray

[`GParamSpecValueArray`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion \\_spec: a #[`GParamSpec`](@ref) describing the elements contained in arrays of this property, may be NULL \\_n\\_elements: if greater than 0, arrays of this property will always have this many elements

A #[`GParamSpec`](@ref) derived structure that contains the meta data for #[`GValueArray`](@ref) properties.
"""
struct _GParamSpecValueArray
    parent_instance::GParamSpec
    element_spec::Ptr{GParamSpec}
    fixed_n_elements::guint
end

"""
[`GParamSpecValueArray`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion \\_spec: a #[`GParamSpec`](@ref) describing the elements contained in arrays of this property, may be NULL \\_n\\_elements: if greater than 0, arrays of this property will always have this many elements

A #[`GParamSpec`](@ref) derived structure that contains the meta data for #[`GValueArray`](@ref) properties.
"""
const GParamSpecValueArray = _GParamSpecValueArray

"""
    _GParamSpecObject

[`GParamSpecObject`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion

A #[`GParamSpec`](@ref) derived structure that contains the meta data for object properties.
"""
struct _GParamSpecObject
    parent_instance::GParamSpec
end

"""
[`GParamSpecObject`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion

A #[`GParamSpec`](@ref) derived structure that contains the meta data for object properties.
"""
const GParamSpecObject = _GParamSpecObject

"""
    _GParamSpecOverride

[`GParamSpecOverride`](@ref):

A #[`GParamSpec`](@ref) derived structure that redirects operations to other types of #[`GParamSpec`](@ref).

All operations other than getting or setting the value are redirected, including accessing the nick and blurb, validating a value, and so forth.

See [`g_param_spec_get_redirect_target`](@ref)() for retrieving the overridden property. #[`GParamSpecOverride`](@ref) is used in implementing [`g_object_class_override_property`](@ref)(), and will not be directly useful unless you are implementing a new base type similar to [`GObject`](@ref).

Since: 2.4
"""
struct _GParamSpecOverride
    parent_instance::GParamSpec
    overridden::Ptr{GParamSpec}
end

"""
[`GParamSpecOverride`](@ref):

A #[`GParamSpec`](@ref) derived structure that redirects operations to other types of #[`GParamSpec`](@ref).

All operations other than getting or setting the value are redirected, including accessing the nick and blurb, validating a value, and so forth.

See [`g_param_spec_get_redirect_target`](@ref)() for retrieving the overridden property. #[`GParamSpecOverride`](@ref) is used in implementing [`g_object_class_override_property`](@ref)(), and will not be directly useful unless you are implementing a new base type similar to [`GObject`](@ref).

Since: 2.4
"""
const GParamSpecOverride = _GParamSpecOverride

"""
    _GParamSpecGType

[`GParamSpecGType`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion

`_a_type: a #GType whose subtypes can occur as values`

A #[`GParamSpec`](@ref) derived structure that contains the meta data for #[`GType`](@ref) properties.

Since: 2.10
"""
struct _GParamSpecGType
    parent_instance::GParamSpec
    is_a_type::GType
end

"""
[`GParamSpecGType`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion

`_a_type: a #GType whose subtypes can occur as values`

A #[`GParamSpec`](@ref) derived structure that contains the meta data for #[`GType`](@ref) properties.

Since: 2.10
"""
const GParamSpecGType = _GParamSpecGType

"""
    _GParamSpecVariant

[`GParamSpecVariant`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion : a #[`GVariantType`](@ref), or NULL \\_value: a #[`GVariant`](@ref), or NULL

A #[`GParamSpec`](@ref) derived structure that contains the meta data for #[`GVariant`](@ref) properties.

When comparing values with [`g_param_values_cmp`](@ref)(), scalar values with the same type will be compared with [`g_variant_compare`](@ref)(). Other non-NULL variants will be checked for equality with [`g_variant_equal`](@ref)(), and their sort order is otherwise undefined. NULL is ordered before non-NULL variants. Two NULL values compare equal.

Since: 2.26
"""
struct _GParamSpecVariant
    parent_instance::GParamSpec
    type::Ptr{GVariantType}
    default_value::Ptr{GVariant}
    padding::NTuple{4, gpointer}
end

"""
[`GParamSpecVariant`](@ref): \\_instance: private #[`GParamSpec`](@ref) portion : a #[`GVariantType`](@ref), or NULL \\_value: a #[`GVariant`](@ref), or NULL

A #[`GParamSpec`](@ref) derived structure that contains the meta data for #[`GVariant`](@ref) properties.

When comparing values with [`g_param_values_cmp`](@ref)(), scalar values with the same type will be compared with [`g_variant_compare`](@ref)(). Other non-NULL variants will be checked for equality with [`g_variant_equal`](@ref)(), and their sort order is otherwise undefined. NULL is ordered before non-NULL variants. Two NULL values compare equal.

Since: 2.26
"""
const GParamSpecVariant = _GParamSpecVariant

"""
    g_signal_group_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_72 GType g_signal_group_get_type (void) G_GNUC_CONST;
```
"""
function g_signal_group_get_type()
    @ccall libaravis.g_signal_group_get_type()::GType
end

const _GSignalGroup = Cvoid

const GSignalGroup = _GSignalGroup

"""
    g_type_module_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_type_module_get_type (void) G_GNUC_CONST;
```
"""
function g_type_module_get_type()
    @ccall libaravis.g_type_module_get_type()::GType
end

struct _GTypeModule
    parent_instance::GObject
    use_count::guint
    type_infos::Ptr{GSList}
    interface_infos::Ptr{GSList}
    name::Ptr{gchar}
end

const GTypeModule = _GTypeModule

"""
    _GTypeModuleClass

[`GTypeModuleClass`](@ref): \\_class: the parent class : loads the module and registers one or more types using [`g_type_module_register_type`](@ref)(). : unloads the module

In order to implement dynamic loading of types based on #[`GTypeModule`](@ref),  the  and  functions in #[`GTypeModuleClass`](@ref) must be implemented.
"""
struct _GTypeModuleClass
    parent_class::GObjectClass
    load::Ptr{Cvoid}
    unload::Ptr{Cvoid}
    reserved1::Ptr{Cvoid}
    reserved2::Ptr{Cvoid}
    reserved3::Ptr{Cvoid}
    reserved4::Ptr{Cvoid}
end

"""
[`GTypeModuleClass`](@ref): \\_class: the parent class : loads the module and registers one or more types using [`g_type_module_register_type`](@ref)(). : unloads the module

In order to implement dynamic loading of types based on #[`GTypeModule`](@ref),  the  and  functions in #[`GTypeModuleClass`](@ref) must be implemented.
"""
const GTypeModuleClass = _GTypeModuleClass

# typedef void ( * GBaseInitFunc ) ( gpointer g_class )
"""
[`GBaseInitFunc`](@ref): \\_class: (type [`GObject`](@ref).TypeClass): The #[`GTypeClass`](@ref) structure to initialize

A callback function used by the type system to do base initialization of the class structures of derived types.

This function is called as part of the initialization process of all derived classes and should reallocate or reset all dynamic class members copied over from the parent class.

For example, class members (such as strings) that are not sufficiently handled by a plain memory copy of the parent class into the derived class have to be altered. See [`GClassInitFunc`](@ref)() for a discussion of the class initialization process.
"""
const GBaseInitFunc = Ptr{Cvoid}

# typedef void ( * GBaseFinalizeFunc ) ( gpointer g_class )
"""
[`GBaseFinalizeFunc`](@ref): \\_class: (type [`GObject`](@ref).TypeClass): The #[`GTypeClass`](@ref) structure to finalize

A callback function used by the type system to finalize those portions of a derived types class structure that were setup from the corresponding [`GBaseInitFunc`](@ref)() function.

Class finalization basically works the inverse way in which class initialization is performed.

See [`GClassInitFunc`](@ref)() for a discussion of the class initialization process.
"""
const GBaseFinalizeFunc = Ptr{Cvoid}

# typedef void ( * GClassFinalizeFunc ) ( gpointer g_class , gpointer class_data )
"""
[`GClassFinalizeFunc`](@ref): \\_class: (type [`GObject`](@ref).TypeClass): The #[`GTypeClass`](@ref) structure to finalize

`_data: The @class_data member supplied via the #GTypeInfo structure`

A callback function used by the type system to finalize a class.

This function is rarely needed, as dynamically allocated class resources should be handled by [`GBaseInitFunc`](@ref)() and [`GBaseFinalizeFunc`](@ref)().

Also, specification of a [`GClassFinalizeFunc`](@ref)() in the #[`GTypeInfo`](@ref) structure of a static type is invalid, because classes of static types will never be finalized (they are artificially kept alive when their reference count drops to zero).
"""
const GClassFinalizeFunc = Ptr{Cvoid}

"""
    _GTypeInfo

[`GTypeInfo`](@ref):

`_size: Size of the class structure (required for interface, classed and instantiatable types)`

\\_init: Location of the base initialization function (optional) \\_finalize: Location of the base finalization function (optional)

`_init: Location of the class initialization function for`

classed and instantiatable types. Location of the default vtable  initialization function for interface types. (optional) This function is used both to fill in virtual functions in the class or default vtable,  and to do type-specific setup such as registering signals and object properties.

`_finalize: Location of the class finalization function for`

classed and instantiatable types. Location of the default vtable finalization function for interface types. (optional)

`_data: User-supplied data passed to the class init/finalize functions`

\\_size: Size of the instance (object) structure (required for instantiatable types only) \\_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10 this field is ignored. \\_init: Location of the instance initialization function (optional, for instantiatable types only) \\_table: A #[`GTypeValueTable`](@ref) function table for generic handling of GValues of this type (usually only useful for fundamental types)

This structure is used to provide the type system with the information required to initialize and destruct (finalize) a type's class and its instances.

The initialized structure is passed to the [`g_type_register_static`](@ref)() function (or is copied into the provided #[`GTypeInfo`](@ref) structure in the [`g_type_plugin_complete_type_info`](@ref)()). The type system will perform a deep copy of this structure, so its memory does not need to be persistent across invocation of [`g_type_register_static`](@ref)().
"""
struct _GTypeInfo
    class_size::guint16
    base_init::GBaseInitFunc
    base_finalize::GBaseFinalizeFunc
    class_init::GClassInitFunc
    class_finalize::GClassFinalizeFunc
    class_data::gconstpointer
    instance_size::guint16
    n_preallocs::guint16
    instance_init::GInstanceInitFunc
    value_table::Ptr{GTypeValueTable}
end

"""
[`GTypeInfo`](@ref):

`_size: Size of the class structure (required for interface, classed and instantiatable types)`

\\_init: Location of the base initialization function (optional) \\_finalize: Location of the base finalization function (optional)

`_init: Location of the class initialization function for`

classed and instantiatable types. Location of the default vtable  initialization function for interface types. (optional) This function is used both to fill in virtual functions in the class or default vtable,  and to do type-specific setup such as registering signals and object properties.

`_finalize: Location of the class finalization function for`

classed and instantiatable types. Location of the default vtable finalization function for interface types. (optional)

`_data: User-supplied data passed to the class init/finalize functions`

\\_size: Size of the instance (object) structure (required for instantiatable types only) \\_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10 this field is ignored. \\_init: Location of the instance initialization function (optional, for instantiatable types only) \\_table: A #[`GTypeValueTable`](@ref) function table for generic handling of GValues of this type (usually only useful for fundamental types)

This structure is used to provide the type system with the information required to initialize and destruct (finalize) a type's class and its instances.

The initialized structure is passed to the [`g_type_register_static`](@ref)() function (or is copied into the provided #[`GTypeInfo`](@ref) structure in the [`g_type_plugin_complete_type_info`](@ref)()). The type system will perform a deep copy of this structure, so its memory does not need to be persistent across invocation of [`g_type_register_static`](@ref)().
"""
const GTypeInfo = _GTypeInfo

"""
    g_type_module_register_type(_module, parent_type, type_name, type_info, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_type_module_register_type (GTypeModule *module, GType parent_type, const gchar *type_name, const GTypeInfo *type_info, GTypeFlags flags);
```
"""
function g_type_module_register_type(_module, parent_type, type_name, type_info, flags)
    @ccall libaravis.g_type_module_register_type(_module::Ptr{GTypeModule}, parent_type::GType, type_name::Ptr{gchar}, type_info::Ptr{GTypeInfo}, flags::GTypeFlags)::GType
end

"""
    g_type_module_add_interface(_module, instance_type, interface_type, interface_info)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_type_module_add_interface (GTypeModule *module, GType instance_type, GType interface_type, const GInterfaceInfo *interface_info);
```
"""
function g_type_module_add_interface(_module, instance_type, interface_type, interface_info)
    @ccall libaravis.g_type_module_add_interface(_module::Ptr{GTypeModule}, instance_type::GType, interface_type::GType, interface_info::Ptr{GInterfaceInfo})::Cvoid
end

"""
    g_type_plugin_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_type_plugin_get_type (void) G_GNUC_CONST;
```
"""
function g_type_plugin_get_type()
    @ccall libaravis.g_type_plugin_get_type()::GType
end

const _GTypePlugin = Cvoid

const GTypePlugin = _GTypePlugin

# typedef void ( * GTypePluginUse ) ( GTypePlugin * plugin )
"""
[`GTypePluginUse`](@ref): : the #[`GTypePlugin`](@ref) whose use count should be increased

The type of the \\_plugin function of #[`GTypePluginClass`](@ref), which gets called to increase the use count of .
"""
const GTypePluginUse = Ptr{Cvoid}

# typedef void ( * GTypePluginUnuse ) ( GTypePlugin * plugin )
"""
[`GTypePluginUnuse`](@ref): : the #[`GTypePlugin`](@ref) whose use count should be decreased

The type of the \\_plugin function of #[`GTypePluginClass`](@ref).
"""
const GTypePluginUnuse = Ptr{Cvoid}

# typedef void ( * GTypePluginCompleteTypeInfo ) ( GTypePlugin * plugin , GType g_type , GTypeInfo * info , GTypeValueTable * value_table )
"""
[`GTypePluginCompleteTypeInfo`](@ref): : the #[`GTypePlugin`](@ref) \\_type: the #[`GType`](@ref) whose info is completed : the #[`GTypeInfo`](@ref) struct to fill in \\_table: the #[`GTypeValueTable`](@ref) to fill in

The type of the \\_type\\_info function of #[`GTypePluginClass`](@ref).
"""
const GTypePluginCompleteTypeInfo = Ptr{Cvoid}

# typedef void ( * GTypePluginCompleteInterfaceInfo ) ( GTypePlugin * plugin , GType instance_type , GType interface_type , GInterfaceInfo * info )
"""
[`GTypePluginCompleteInterfaceInfo`](@ref): : the #[`GTypePlugin`](@ref) \\_type: the #[`GType`](@ref) of an instantiatable type to which the interface is added

`_type: the #GType of the interface whose info is completed`

: the #[`GInterfaceInfo`](@ref) to fill in

The type of the \\_interface\\_info function of #[`GTypePluginClass`](@ref).
"""
const GTypePluginCompleteInterfaceInfo = Ptr{Cvoid}

"""
    _GTypePluginClass

[`GTypePluginClass`](@ref): \\_plugin: Increases the use count of the plugin. \\_plugin: Decreases the use count of the plugin. \\_type\\_info: Fills in the #[`GTypeInfo`](@ref) and  #[`GTypeValueTable`](@ref) structs for the type. The structs are initialized with `memset(s, 0, sizeof (s))` before calling this function. \\_interface\\_info: Fills in missing parts of the #[`GInterfaceInfo`](@ref)  for the interface. The structs is initialized with `memset(s, 0, sizeof (s))` before calling this function.

The #[`GTypePlugin`](@ref) interface is used by the type system in order to handle the lifecycle of dynamically loaded types.
"""
struct _GTypePluginClass
    base_iface::GTypeInterface
    use_plugin::GTypePluginUse
    unuse_plugin::GTypePluginUnuse
    complete_type_info::GTypePluginCompleteTypeInfo
    complete_interface_info::GTypePluginCompleteInterfaceInfo
end

"""
[`GTypePluginClass`](@ref): \\_plugin: Increases the use count of the plugin. \\_plugin: Decreases the use count of the plugin. \\_type\\_info: Fills in the #[`GTypeInfo`](@ref) and  #[`GTypeValueTable`](@ref) structs for the type. The structs are initialized with `memset(s, 0, sizeof (s))` before calling this function. \\_interface\\_info: Fills in missing parts of the #[`GInterfaceInfo`](@ref)  for the interface. The structs is initialized with `memset(s, 0, sizeof (s))` before calling this function.

The #[`GTypePlugin`](@ref) interface is used by the type system in order to handle the lifecycle of dynamically loaded types.
"""
const GTypePluginClass = _GTypePluginClass

"""
    g_value_array_get_type()

### Prototype
```c
GOBJECT_DEPRECATED_IN_2_32_FOR(GArray) GType g_value_array_get_type (void) G_GNUC_CONST;
```
"""
function g_value_array_get_type()
    @ccall libaravis.g_value_array_get_type()::GType
end

"""
    g_gtype_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_gtype_get_type (void);
```
"""
function g_gtype_get_type()
    @ccall libaravis.g_gtype_get_type()::GType
end

"""
[`ArvPixelFormat`](@ref):

A datatype to hold a pixel format.
"""
const ArvPixelFormat = guint32

"""
    arv_buffer_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvBuffer, arv_buffer, ARV, BUFFER, GObject);
```
"""
function arv_buffer_get_type()
    @ccall libaravis.arv_buffer_get_type()::GType
end

"""
    arv_stream_get_type()

### Prototype
```c
ARV_API G_DECLARE_DERIVABLE_TYPE (ArvStream, arv_stream, ARV, STREAM, GObject);
```
"""
function arv_stream_get_type()
    @ccall libaravis.arv_stream_get_type()::GType
end

"""
    arv_gv_stream_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvGvStream, arv_gv_stream, ARV, GV_STREAM, ArvStream);
```
"""
function arv_gv_stream_get_type()
    @ccall libaravis.arv_gv_stream_get_type()::GType
end

"""
    g_action_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_30 GType g_action_get_type (void) G_GNUC_CONST;
```
"""
function g_action_get_type()
    @ccall libaravis.g_action_get_type()::GType
end

const _GAction = Cvoid

const GAction = _GAction

struct _GActionInterface
    g_iface::GTypeInterface
    get_name::Ptr{Cvoid}
    get_parameter_type::Ptr{Cvoid}
    get_state_type::Ptr{Cvoid}
    get_state_hint::Ptr{Cvoid}
    get_enabled::Ptr{Cvoid}
    get_state::Ptr{Cvoid}
    change_state::Ptr{Cvoid}
    activate::Ptr{Cvoid}
end

const GActionInterface = _GActionInterface

"""
    g_action_group_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_action_group_get_type (void) G_GNUC_CONST;
```
"""
function g_action_group_get_type()
    @ccall libaravis.g_action_group_get_type()::GType
end

const _GActionGroup = Cvoid

const GActionGroup = _GActionGroup

struct _GActionGroupInterface
    g_iface::GTypeInterface
    has_action::Ptr{Cvoid}
    list_actions::Ptr{Cvoid}
    get_action_enabled::Ptr{Cvoid}
    get_action_parameter_type::Ptr{Cvoid}
    get_action_state_type::Ptr{Cvoid}
    get_action_state_hint::Ptr{Cvoid}
    get_action_state::Ptr{Cvoid}
    change_action_state::Ptr{Cvoid}
    activate_action::Ptr{Cvoid}
    action_added::Ptr{Cvoid}
    action_removed::Ptr{Cvoid}
    action_enabled_changed::Ptr{Cvoid}
    action_state_changed::Ptr{Cvoid}
    query_action::Ptr{Cvoid}
end

const GActionGroupInterface = _GActionGroupInterface

"""
    g_action_map_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GType g_action_map_get_type (void) G_GNUC_CONST;
```
"""
function g_action_map_get_type()
    @ccall libaravis.g_action_map_get_type()::GType
end

const _GActionMap = Cvoid

const GActionMap = _GActionMap

struct _GActionMapInterface
    g_iface::GTypeInterface
    lookup_action::Ptr{Cvoid}
    add_action::Ptr{Cvoid}
    remove_action::Ptr{Cvoid}
end

const GActionMapInterface = _GActionMapInterface

"""
    g_app_info_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_app_info_get_type (void) G_GNUC_CONST;
```
"""
function g_app_info_get_type()
    @ccall libaravis.g_app_info_get_type()::GType
end

const _GAppInfo = Cvoid

const GAppInfo = _GAppInfo

struct _GAppInfoIface
    g_iface::GTypeInterface
    dup::Ptr{Cvoid}
    equal::Ptr{Cvoid}
    get_id::Ptr{Cvoid}
    get_name::Ptr{Cvoid}
    get_description::Ptr{Cvoid}
    get_executable::Ptr{Cvoid}
    get_icon::Ptr{Cvoid}
    launch::Ptr{Cvoid}
    supports_uris::Ptr{Cvoid}
    supports_files::Ptr{Cvoid}
    launch_uris::Ptr{Cvoid}
    should_show::Ptr{Cvoid}
    set_as_default_for_type::Ptr{Cvoid}
    set_as_default_for_extension::Ptr{Cvoid}
    add_supports_type::Ptr{Cvoid}
    can_remove_supports_type::Ptr{Cvoid}
    remove_supports_type::Ptr{Cvoid}
    can_delete::Ptr{Cvoid}
    do_delete::Ptr{Cvoid}
    get_commandline::Ptr{Cvoid}
    get_display_name::Ptr{Cvoid}
    set_as_last_used_for_type::Ptr{Cvoid}
    get_supported_types::Ptr{Cvoid}
    launch_uris_async::Ptr{Cvoid}
    launch_uris_finish::Ptr{Cvoid}
end

"""
[`GAppInfoIface`](@ref): \\_iface: The parent interface. : Copies a [iface.AppInfo]. : Checks two [iface.AppInfo]s for equality. \\_id: Gets a string identifier for a [iface.AppInfo]. \\_name: Gets the name of the application for a [iface.AppInfo]. \\_description: Gets a short description for the application described by the [iface.AppInfo]. \\_executable: Gets the executable name for the [iface.AppInfo]. \\_icon: Gets the [iface.Icon] for the [iface.AppInfo]. : Launches an application specified by the [iface.AppInfo]. \\_uris: Indicates whether the application specified supports launching URIs. \\_files: Indicates whether the application specified accepts filename arguments. \\_uris: Launches an application with a list of URIs. \\_show: Returns whether an application should be shown (e.g. when getting a list of installed applications). [FreeDesktop.Org Startup Notification Specification](http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).

```c++
_delete: Deletes a [iface@Gio.AppInfo]. (Since 2.20)
 @get_commandline: Gets the commandline for the [iface@Gio.AppInfo].
   (Since 2.20)
 @get_display_name: Gets the display name for the [iface@Gio.AppInfo].
   (Since 2.24)
 @set_as_last_used_for_type: Sets the application as the last used. See
   [method@Gio.AppInfo.set_as_last_used_for_type].
 @get_supported_types: Retrieves the list of content types that @app_info
   claims to support.
 @launch_uris_async: Asynchronously launches an application with a list of
   URIs. (Since: 2.60)
 @launch_uris_finish: Finishes an operation started with @launch_uris_async.
   (Since: 2.60)

 Application Information interface, for operating system portability.
 

```

# See also
\\_as\\_default\\_for\\_type: Sets an application as default for a given content type., \\_as\\_default\\_for\\_extension: Sets an application as default for a given file extension. \\_supports\\_type: Adds to the [iface.AppInfo] information about supported file types. \\_remove\\_supports\\_type: Checks for support for removing supported file types from a [iface.AppInfo]. \\_supports\\_type: Removes a supported application type from a [iface.AppInfo]. \\_delete: Checks if a [iface.AppInfo] can be deleted. (Since 2.20)
"""
const GAppInfoIface = _GAppInfoIface

"""
    g_app_launch_context_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_app_launch_context_get_type (void) G_GNUC_CONST;
```
"""
function g_app_launch_context_get_type()
    @ccall libaravis.g_app_launch_context_get_type()::GType
end

const _GAppLaunchContextPrivate = Cvoid

const GAppLaunchContextPrivate = _GAppLaunchContextPrivate

"""
    _GAppLaunchContext

[`GAppLaunchContext`](@ref):

Integrating the launch with the launching application. This is used to handle for instance startup notification and launching the new application on the same screen as the launching window.
"""
struct _GAppLaunchContext
    parent_instance::GObject
    priv::Ptr{GAppLaunchContextPrivate}
end

"""
[`GAppLaunchContext`](@ref):

Integrating the launch with the launching application. This is used to handle for instance startup notification and launching the new application on the same screen as the launching window.
"""
const GAppLaunchContext = _GAppLaunchContext

struct _GAppLaunchContextClass
    parent_class::GObjectClass
    get_display::Ptr{Cvoid}
    get_startup_notify_id::Ptr{Cvoid}
    launch_failed::Ptr{Cvoid}
    launched::Ptr{Cvoid}
    launch_started::Ptr{Cvoid}
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
end

const GAppLaunchContextClass = _GAppLaunchContextClass

"""
    g_app_info_monitor_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_40 GType g_app_info_monitor_get_type (void);
```
"""
function g_app_info_monitor_get_type()
    @ccall libaravis.g_app_info_monitor_get_type()::GType
end

const _GAppInfoMonitor = Cvoid

const GAppInfoMonitor = _GAppInfoMonitor

"""
    g_application_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_application_get_type (void) G_GNUC_CONST;
```
"""
function g_application_get_type()
    @ccall libaravis.g_application_get_type()::GType
end

const _GApplicationPrivate = Cvoid

const GApplicationPrivate = _GApplicationPrivate

struct _GApplication
    parent_instance::GObject
    priv::Ptr{GApplicationPrivate}
end

const GApplication = _GApplication

struct _GApplicationClass
    parent_class::GObjectClass
    startup::Ptr{Cvoid}
    activate::Ptr{Cvoid}
    open::Ptr{Cvoid}
    command_line::Ptr{Cvoid}
    local_command_line::Ptr{Cvoid}
    before_emit::Ptr{Cvoid}
    after_emit::Ptr{Cvoid}
    add_platform_data::Ptr{Cvoid}
    quit_mainloop::Ptr{Cvoid}
    run_mainloop::Ptr{Cvoid}
    shutdown::Ptr{Cvoid}
    dbus_register::Ptr{Cvoid}
    dbus_unregister::Ptr{Cvoid}
    handle_local_options::Ptr{Cvoid}
    name_lost::Ptr{Cvoid}
    padding::NTuple{7, gpointer}
end

const GApplicationClass = _GApplicationClass

"""
    g_application_command_line_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_application_command_line_get_type (void) G_GNUC_CONST;
```
"""
function g_application_command_line_get_type()
    @ccall libaravis.g_application_command_line_get_type()::GType
end

const _GApplicationCommandLinePrivate = Cvoid

const GApplicationCommandLinePrivate = _GApplicationCommandLinePrivate

struct _GApplicationCommandLine
    parent_instance::GObject
    priv::Ptr{GApplicationCommandLinePrivate}
end

const GApplicationCommandLine = _GApplicationCommandLine

struct _GApplicationCommandLineClass
    parent_class::GObjectClass
    print_literal::Ptr{Cvoid}
    printerr_literal::Ptr{Cvoid}
    get_stdin::Ptr{Cvoid}
    done::Ptr{Cvoid}
    padding::NTuple{10, gpointer}
end

const GApplicationCommandLineClass = _GApplicationCommandLineClass

"""
    g_initable_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_initable_get_type (void) G_GNUC_CONST;
```
"""
function g_initable_get_type()
    @ccall libaravis.g_initable_get_type()::GType
end

const _GInitable = Cvoid

const GInitable = _GInitable

"""
    _GInitableIface

[`GInitableIface`](@ref): \\_iface: The parent interface. : Initializes the object.

Provides an interface for initializing object such that initialization may fail.

Since: 2.22
"""
struct _GInitableIface
    g_iface::GTypeInterface
    init::Ptr{Cvoid}
end

"""
[`GInitableIface`](@ref): \\_iface: The parent interface. : Initializes the object.

Provides an interface for initializing object such that initialization may fail.

Since: 2.22
"""
const GInitableIface = _GInitableIface

"""
    g_async_initable_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_async_initable_get_type (void) G_GNUC_CONST;
```
"""
function g_async_initable_get_type()
    @ccall libaravis.g_async_initable_get_type()::GType
end

const _GAsyncInitable = Cvoid

const GAsyncInitable = _GAsyncInitable

"""
    _GAsyncInitableIface

[`GAsyncInitableIface`](@ref): \\_iface: The parent interface. \\_async: Starts initialization of the object. \\_finish: Finishes initialization of the object.

Provides an interface for asynchronous initializing object such that initialization may fail.

Since: 2.22
"""
struct _GAsyncInitableIface
    g_iface::GTypeInterface
    init_async::Ptr{Cvoid}
    init_finish::Ptr{Cvoid}
end

"""
[`GAsyncInitableIface`](@ref): \\_iface: The parent interface. \\_async: Starts initialization of the object. \\_finish: Finishes initialization of the object.

Provides an interface for asynchronous initializing object such that initialization may fail.

Since: 2.22
"""
const GAsyncInitableIface = _GAsyncInitableIface

"""
    g_async_result_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_async_result_get_type (void) G_GNUC_CONST;
```
"""
function g_async_result_get_type()
    @ccall libaravis.g_async_result_get_type()::GType
end

const _GAsyncResult = Cvoid

const GAsyncResult = _GAsyncResult

"""
    _GAsyncResultIface

[`GAsyncResultIface`](@ref): \\_iface: The parent interface. \\_user\\_data: Gets the user data passed to the callback. \\_source\\_object: Gets the source object that issued the asynchronous operation.

`_tagged: Checks if a result is tagged with a particular source.`

Interface definition for [iface.AsyncResult].
"""
struct _GAsyncResultIface
    g_iface::GTypeInterface
    get_user_data::Ptr{Cvoid}
    get_source_object::Ptr{Cvoid}
    is_tagged::Ptr{Cvoid}
end

"""
[`GAsyncResultIface`](@ref): \\_iface: The parent interface. \\_user\\_data: Gets the user data passed to the callback. \\_source\\_object: Gets the source object that issued the asynchronous operation.

`_tagged: Checks if a result is tagged with a particular source.`

Interface definition for [iface.AsyncResult].
"""
const GAsyncResultIface = _GAsyncResultIface

"""
    g_input_stream_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_input_stream_get_type (void) G_GNUC_CONST;
```
"""
function g_input_stream_get_type()
    @ccall libaravis.g_input_stream_get_type()::GType
end

const _GInputStreamPrivate = Cvoid

const GInputStreamPrivate = _GInputStreamPrivate

struct _GInputStream
    parent_instance::GObject
    priv::Ptr{GInputStreamPrivate}
end

const GInputStream = _GInputStream

struct _GInputStreamClass
    parent_class::GObjectClass
    read_fn::Ptr{Cvoid}
    skip::Ptr{Cvoid}
    close_fn::Ptr{Cvoid}
    read_async::Ptr{Cvoid}
    read_finish::Ptr{Cvoid}
    skip_async::Ptr{Cvoid}
    skip_finish::Ptr{Cvoid}
    close_async::Ptr{Cvoid}
    close_finish::Ptr{Cvoid}
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
    _g_reserved4::Ptr{Cvoid}
    _g_reserved5::Ptr{Cvoid}
end

const GInputStreamClass = _GInputStreamClass

"""
    g_filter_input_stream_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_filter_input_stream_get_type (void) G_GNUC_CONST;
```
"""
function g_filter_input_stream_get_type()
    @ccall libaravis.g_filter_input_stream_get_type()::GType
end

struct _GFilterInputStream
    parent_instance::GInputStream
    base_stream::Ptr{GInputStream}
end

const GFilterInputStream = _GFilterInputStream

struct _GFilterInputStreamClass
    parent_class::GInputStreamClass
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
end

const GFilterInputStreamClass = _GFilterInputStreamClass

"""
    g_buffered_input_stream_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_buffered_input_stream_get_type (void) G_GNUC_CONST;
```
"""
function g_buffered_input_stream_get_type()
    @ccall libaravis.g_buffered_input_stream_get_type()::GType
end

const _GBufferedInputStreamPrivate = Cvoid

const GBufferedInputStreamPrivate = _GBufferedInputStreamPrivate

struct _GBufferedInputStream
    parent_instance::GFilterInputStream
    priv::Ptr{GBufferedInputStreamPrivate}
end

const GBufferedInputStream = _GBufferedInputStream

struct _GBufferedInputStreamClass
    parent_class::GFilterInputStreamClass
    fill::Ptr{Cvoid}
    fill_async::Ptr{Cvoid}
    fill_finish::Ptr{Cvoid}
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
    _g_reserved4::Ptr{Cvoid}
    _g_reserved5::Ptr{Cvoid}
end

const GBufferedInputStreamClass = _GBufferedInputStreamClass

"""
    g_output_stream_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_output_stream_get_type (void) G_GNUC_CONST;
```
"""
function g_output_stream_get_type()
    @ccall libaravis.g_output_stream_get_type()::GType
end

const _GOutputStreamPrivate = Cvoid

const GOutputStreamPrivate = _GOutputStreamPrivate

struct _GOutputStream
    parent_instance::GObject
    priv::Ptr{GOutputStreamPrivate}
end

const GOutputStream = _GOutputStream

struct _GOutputStreamClass
    parent_class::GObjectClass
    write_fn::Ptr{Cvoid}
    splice::Ptr{Cvoid}
    flush::Ptr{Cvoid}
    close_fn::Ptr{Cvoid}
    write_async::Ptr{Cvoid}
    write_finish::Ptr{Cvoid}
    splice_async::Ptr{Cvoid}
    splice_finish::Ptr{Cvoid}
    flush_async::Ptr{Cvoid}
    flush_finish::Ptr{Cvoid}
    close_async::Ptr{Cvoid}
    close_finish::Ptr{Cvoid}
    writev_fn::Ptr{Cvoid}
    writev_async::Ptr{Cvoid}
    writev_finish::Ptr{Cvoid}
    _g_reserved4::Ptr{Cvoid}
    _g_reserved5::Ptr{Cvoid}
    _g_reserved6::Ptr{Cvoid}
    _g_reserved7::Ptr{Cvoid}
    _g_reserved8::Ptr{Cvoid}
end

const GOutputStreamClass = _GOutputStreamClass

"""
    g_filter_output_stream_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_filter_output_stream_get_type (void) G_GNUC_CONST;
```
"""
function g_filter_output_stream_get_type()
    @ccall libaravis.g_filter_output_stream_get_type()::GType
end

struct _GFilterOutputStream
    parent_instance::GOutputStream
    base_stream::Ptr{GOutputStream}
end

const GFilterOutputStream = _GFilterOutputStream

struct _GFilterOutputStreamClass
    parent_class::GOutputStreamClass
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
end

const GFilterOutputStreamClass = _GFilterOutputStreamClass

"""
    g_buffered_output_stream_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_buffered_output_stream_get_type (void) G_GNUC_CONST;
```
"""
function g_buffered_output_stream_get_type()
    @ccall libaravis.g_buffered_output_stream_get_type()::GType
end

const _GBufferedOutputStreamPrivate = Cvoid

const GBufferedOutputStreamPrivate = _GBufferedOutputStreamPrivate

struct _GBufferedOutputStream
    parent_instance::GFilterOutputStream
    priv::Ptr{GBufferedOutputStreamPrivate}
end

const GBufferedOutputStream = _GBufferedOutputStream

struct _GBufferedOutputStreamClass
    parent_class::GFilterOutputStreamClass
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
end

const GBufferedOutputStreamClass = _GBufferedOutputStreamClass

"""
    g_bytes_icon_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_38 GType g_bytes_icon_get_type (void) G_GNUC_CONST;
```
"""
function g_bytes_icon_get_type()
    @ccall libaravis.g_bytes_icon_get_type()::GType
end

const _GBytesIcon = Cvoid

const GBytesIcon = _GBytesIcon

"""
    g_cancellable_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_cancellable_get_type (void) G_GNUC_CONST;
```
"""
function g_cancellable_get_type()
    @ccall libaravis.g_cancellable_get_type()::GType
end

const _GCancellablePrivate = Cvoid

const GCancellablePrivate = _GCancellablePrivate

struct _GCancellable
    parent_instance::GObject
    priv::Ptr{GCancellablePrivate}
end

const GCancellable = _GCancellable

struct _GCancellableClass
    parent_class::GObjectClass
    cancelled::Ptr{Cvoid}
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
    _g_reserved4::Ptr{Cvoid}
    _g_reserved5::Ptr{Cvoid}
end

const GCancellableClass = _GCancellableClass

"""
    g_converter_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_converter_get_type (void) G_GNUC_CONST;
```
"""
function g_converter_get_type()
    @ccall libaravis.g_converter_get_type()::GType
end

const _GConverter = Cvoid

const GConverter = _GConverter

"""
    _GConverterIface

[`GConverterIface`](@ref): \\_iface: The parent interface. : Converts data. : Reverts the internal state of the converter to its initial state.

Provides an interface for converting data from one type to another type. The conversion can be stateful and may fail at any place.

Since: 2.24
"""
struct _GConverterIface
    g_iface::GTypeInterface
    convert::Ptr{Cvoid}
    reset::Ptr{Cvoid}
end

"""
[`GConverterIface`](@ref): \\_iface: The parent interface. : Converts data. : Reverts the internal state of the converter to its initial state.

Provides an interface for converting data from one type to another type. The conversion can be stateful and may fail at any place.

Since: 2.24
"""
const GConverterIface = _GConverterIface

"""
    g_charset_converter_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_charset_converter_get_type (void) G_GNUC_CONST;
```
"""
function g_charset_converter_get_type()
    @ccall libaravis.g_charset_converter_get_type()::GType
end

const _GCharsetConverter = Cvoid

const GCharsetConverter = _GCharsetConverter

struct _GCharsetConverterClass
    parent_class::GObjectClass
end

const GCharsetConverterClass = _GCharsetConverterClass

"""
    g_converter_input_stream_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_converter_input_stream_get_type (void) G_GNUC_CONST;
```
"""
function g_converter_input_stream_get_type()
    @ccall libaravis.g_converter_input_stream_get_type()::GType
end

const _GConverterInputStreamPrivate = Cvoid

const GConverterInputStreamPrivate = _GConverterInputStreamPrivate

struct _GConverterInputStream
    parent_instance::GFilterInputStream
    priv::Ptr{GConverterInputStreamPrivate}
end

const GConverterInputStream = _GConverterInputStream

struct _GConverterInputStreamClass
    parent_class::GFilterInputStreamClass
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
    _g_reserved4::Ptr{Cvoid}
    _g_reserved5::Ptr{Cvoid}
end

const GConverterInputStreamClass = _GConverterInputStreamClass

"""
    g_converter_output_stream_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_converter_output_stream_get_type (void) G_GNUC_CONST;
```
"""
function g_converter_output_stream_get_type()
    @ccall libaravis.g_converter_output_stream_get_type()::GType
end

const _GConverterOutputStreamPrivate = Cvoid

const GConverterOutputStreamPrivate = _GConverterOutputStreamPrivate

struct _GConverterOutputStream
    parent_instance::GFilterOutputStream
    priv::Ptr{GConverterOutputStreamPrivate}
end

const GConverterOutputStream = _GConverterOutputStream

struct _GConverterOutputStreamClass
    parent_class::GFilterOutputStreamClass
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
    _g_reserved4::Ptr{Cvoid}
    _g_reserved5::Ptr{Cvoid}
end

const GConverterOutputStreamClass = _GConverterOutputStreamClass

"""
    g_credentials_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_credentials_get_type (void) G_GNUC_CONST;
```
"""
function g_credentials_get_type()
    @ccall libaravis.g_credentials_get_type()::GType
end

const _GCredentials = Cvoid

const GCredentials = _GCredentials

const _GCredentialsClass = Cvoid

const GCredentialsClass = _GCredentialsClass

"""
    g_datagram_based_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_48 GType g_datagram_based_get_type (void);
```
"""
function g_datagram_based_get_type()
    @ccall libaravis.g_datagram_based_get_type()::GType
end

const _GDatagramBased = Cvoid

const GDatagramBased = _GDatagramBased

"""
    _GDatagramBasedInterface

[`GDatagramBasedInterface`](@ref): \\_iface: The parent interface. \\_messages: Virtual method for [`g_datagram_based_receive_messages`](@ref)(). \\_messages: Virtual method for [`g_datagram_based_send_messages`](@ref)(). \\_source: Virtual method for [`g_datagram_based_create_source`](@ref)(). \\_check: Virtual method for [`g_datagram_based_condition_check`](@ref)(). \\_wait: Virtual method for [`g_datagram_based_condition_wait`](@ref)().

Provides an interface for socket-like objects which have datagram semantics, following the Berkeley sockets API. The interface methods are thin wrappers around the corresponding virtual methods, and no pre-processing of inputs is implemented  so implementations of this API must handle all functionality documented in the interface methods.

Since: 2.48
"""
struct _GDatagramBasedInterface
    g_iface::GTypeInterface
    receive_messages::Ptr{Cvoid}
    send_messages::Ptr{Cvoid}
    create_source::Ptr{Cvoid}
    condition_check::Ptr{Cvoid}
    condition_wait::Ptr{Cvoid}
end

"""
[`GDatagramBasedInterface`](@ref): \\_iface: The parent interface. \\_messages: Virtual method for [`g_datagram_based_receive_messages`](@ref)(). \\_messages: Virtual method for [`g_datagram_based_send_messages`](@ref)(). \\_source: Virtual method for [`g_datagram_based_create_source`](@ref)(). \\_check: Virtual method for [`g_datagram_based_condition_check`](@ref)(). \\_wait: Virtual method for [`g_datagram_based_condition_wait`](@ref)().

Provides an interface for socket-like objects which have datagram semantics, following the Berkeley sockets API. The interface methods are thin wrappers around the corresponding virtual methods, and no pre-processing of inputs is implemented  so implementations of this API must handle all functionality documented in the interface methods.

Since: 2.48
"""
const GDatagramBasedInterface = _GDatagramBasedInterface

"""
    g_data_input_stream_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_data_input_stream_get_type (void) G_GNUC_CONST;
```
"""
function g_data_input_stream_get_type()
    @ccall libaravis.g_data_input_stream_get_type()::GType
end

const _GDataInputStreamPrivate = Cvoid

const GDataInputStreamPrivate = _GDataInputStreamPrivate

struct _GDataInputStream
    parent_instance::GBufferedInputStream
    priv::Ptr{GDataInputStreamPrivate}
end

const GDataInputStream = _GDataInputStream

struct _GDataInputStreamClass
    parent_class::GBufferedInputStreamClass
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
    _g_reserved4::Ptr{Cvoid}
    _g_reserved5::Ptr{Cvoid}
end

const GDataInputStreamClass = _GDataInputStreamClass

"""
    g_data_output_stream_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_data_output_stream_get_type (void) G_GNUC_CONST;
```
"""
function g_data_output_stream_get_type()
    @ccall libaravis.g_data_output_stream_get_type()::GType
end

const _GDataOutputStreamPrivate = Cvoid

const GDataOutputStreamPrivate = _GDataOutputStreamPrivate

struct _GDataOutputStream
    parent_instance::GFilterOutputStream
    priv::Ptr{GDataOutputStreamPrivate}
end

const GDataOutputStream = _GDataOutputStream

struct _GDataOutputStreamClass
    parent_class::GFilterOutputStreamClass
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
    _g_reserved4::Ptr{Cvoid}
    _g_reserved5::Ptr{Cvoid}
end

const GDataOutputStreamClass = _GDataOutputStreamClass

"""
    g_dbus_action_group_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_action_group_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_action_group_get_type()
    @ccall libaravis.g_dbus_action_group_get_type()::GType
end

const _GDBusActionGroup = Cvoid

const GDBusActionGroup = _GDBusActionGroup

"""
    g_dbus_auth_observer_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_auth_observer_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_auth_observer_get_type()
    @ccall libaravis.g_dbus_auth_observer_get_type()::GType
end

const _GDBusAuthObserver = Cvoid

const GDBusAuthObserver = _GDBusAuthObserver

"""
    g_dbus_connection_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_connection_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_connection_get_type()
    @ccall libaravis.g_dbus_connection_get_type()::GType
end

const _GDBusConnection = Cvoid

const GDBusConnection = _GDBusConnection

"""
    g_dbus_error_quark()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GQuark g_dbus_error_quark (void);
```
"""
function g_dbus_error_quark()
    @ccall libaravis.g_dbus_error_quark()::GQuark
end

"""
    g_dbus_interface_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_interface_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_interface_get_type()
    @ccall libaravis.g_dbus_interface_get_type()::GType
end

const _GDBusInterface = Cvoid

const GDBusInterface = _GDBusInterface

"""
    _GDBusInterfaceIface

[`GDBusInterfaceIface`](@ref): \\_iface: The parent interface. \\_info: Returns a #[`GDBusInterfaceInfo`](@ref). See [`g_dbus_interface_get_info`](@ref)(). \\_object: Gets the enclosing #[`GDBusObject`](@ref). See [`g_dbus_interface_get_object`](@ref)().

Base type for D-Bus interfaces.

Since: 2.30

# See also
\\_object: Sets the enclosing #[`GDBusObject`](@ref). See [`g_dbus_interface_set_object`](@ref)(). \\_object: Gets a reference to the enclosing #[`GDBusObject`](@ref). See [`g_dbus_interface_dup_object`](@ref)(). Added in 2.32.
"""
struct _GDBusInterfaceIface
    parent_iface::GTypeInterface
    get_info::Ptr{Cvoid}
    get_object::Ptr{Cvoid}
    set_object::Ptr{Cvoid}
    dup_object::Ptr{Cvoid}
end

"""
[`GDBusInterfaceIface`](@ref): \\_iface: The parent interface. \\_info: Returns a #[`GDBusInterfaceInfo`](@ref). See [`g_dbus_interface_get_info`](@ref)(). \\_object: Gets the enclosing #[`GDBusObject`](@ref). See [`g_dbus_interface_get_object`](@ref)().

Base type for D-Bus interfaces.

Since: 2.30

# See also
\\_object: Sets the enclosing #[`GDBusObject`](@ref). See [`g_dbus_interface_set_object`](@ref)(). \\_object: Gets a reference to the enclosing #[`GDBusObject`](@ref). See [`g_dbus_interface_dup_object`](@ref)(). Added in 2.32.
"""
const GDBusInterfaceIface = _GDBusInterfaceIface

"""
    g_dbus_interface_skeleton_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_interface_skeleton_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_interface_skeleton_get_type()
    @ccall libaravis.g_dbus_interface_skeleton_get_type()::GType
end

const _GDBusInterfaceSkeletonPrivate = Cvoid

const GDBusInterfaceSkeletonPrivate = _GDBusInterfaceSkeletonPrivate

struct _GDBusInterfaceSkeleton
    parent_instance::GObject
    priv::Ptr{GDBusInterfaceSkeletonPrivate}
end

const GDBusInterfaceSkeleton = _GDBusInterfaceSkeleton

"""
    _GDBusInterfaceSkeletonClass

[`GDBusInterfaceSkeletonClass`](@ref): \\_class: The parent class. \\_info: Returns a #[`GDBusInterfaceInfo`](@ref). See [`g_dbus_interface_skeleton_get_info`](@ref)() for details. \\_vtable: Returns a #[`GDBusInterfaceVTable`](@ref). See [`g_dbus_interface_skeleton_get_vtable`](@ref)() for details. \\_properties: Returns a #[`GVariant`](@ref) with all properties. See [`g_dbus_interface_skeleton_get_properties`](@ref)(). : Emits outstanding changes, if any. See [`g_dbus_interface_skeleton_flush`](@ref)(). \\_authorize\\_method: Signal class handler for the #[`GDBusInterfaceSkeleton`](@ref)::g-authorize-method signal.

Class structure for #[`GDBusInterfaceSkeleton`](@ref).

Since: 2.30
"""
struct _GDBusInterfaceSkeletonClass
    parent_class::GObjectClass
    get_info::Ptr{Cvoid}
    get_vtable::Ptr{Cvoid}
    get_properties::Ptr{Cvoid}
    flush::Ptr{Cvoid}
    vfunc_padding::NTuple{8, gpointer}
    g_authorize_method::Ptr{Cvoid}
    signal_padding::NTuple{8, gpointer}
end

"""
[`GDBusInterfaceSkeletonClass`](@ref): \\_class: The parent class. \\_info: Returns a #[`GDBusInterfaceInfo`](@ref). See [`g_dbus_interface_skeleton_get_info`](@ref)() for details. \\_vtable: Returns a #[`GDBusInterfaceVTable`](@ref). See [`g_dbus_interface_skeleton_get_vtable`](@ref)() for details. \\_properties: Returns a #[`GVariant`](@ref) with all properties. See [`g_dbus_interface_skeleton_get_properties`](@ref)(). : Emits outstanding changes, if any. See [`g_dbus_interface_skeleton_flush`](@ref)(). \\_authorize\\_method: Signal class handler for the #[`GDBusInterfaceSkeleton`](@ref)::g-authorize-method signal.

Class structure for #[`GDBusInterfaceSkeleton`](@ref).

Since: 2.30
"""
const GDBusInterfaceSkeletonClass = _GDBusInterfaceSkeletonClass

"""
    g_dbus_node_info_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_node_info_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_node_info_get_type()
    @ccall libaravis.g_dbus_node_info_get_type()::GType
end

"""
    g_dbus_interface_info_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_interface_info_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_interface_info_get_type()
    @ccall libaravis.g_dbus_interface_info_get_type()::GType
end

"""
    g_dbus_method_info_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_method_info_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_method_info_get_type()
    @ccall libaravis.g_dbus_method_info_get_type()::GType
end

"""
    g_dbus_signal_info_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_signal_info_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_signal_info_get_type()
    @ccall libaravis.g_dbus_signal_info_get_type()::GType
end

"""
    g_dbus_property_info_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_property_info_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_property_info_get_type()
    @ccall libaravis.g_dbus_property_info_get_type()::GType
end

"""
    g_dbus_arg_info_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_arg_info_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_arg_info_get_type()
    @ccall libaravis.g_dbus_arg_info_get_type()::GType
end

"""
    g_dbus_annotation_info_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_annotation_info_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_annotation_info_get_type()
    @ccall libaravis.g_dbus_annotation_info_get_type()::GType
end

"""
    g_dbus_menu_model_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_menu_model_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_menu_model_get_type()
    @ccall libaravis.g_dbus_menu_model_get_type()::GType
end

const _GDBusMenuModel = Cvoid

const GDBusMenuModel = _GDBusMenuModel

"""
    g_dbus_message_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_message_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_message_get_type()
    @ccall libaravis.g_dbus_message_get_type()::GType
end

const _GDBusMessage = Cvoid

const GDBusMessage = _GDBusMessage

"""
    g_dbus_method_invocation_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_method_invocation_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_method_invocation_get_type()
    @ccall libaravis.g_dbus_method_invocation_get_type()::GType
end

const _GDBusMethodInvocation = Cvoid

const GDBusMethodInvocation = _GDBusMethodInvocation

"""
    g_dbus_object_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_object_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_object_get_type()
    @ccall libaravis.g_dbus_object_get_type()::GType
end

const _GDBusObject = Cvoid

const GDBusObject = _GDBusObject

"""
    _GDBusObjectIface

[`GDBusObjectIface`](@ref): \\_iface: The parent interface. \\_object\\_path: Returns the object path. See [`g_dbus_object_get_object_path`](@ref)(). \\_interfaces: Returns all interfaces. See [`g_dbus_object_get_interfaces`](@ref)(). \\_interface: Returns an interface by name. See [`g_dbus_object_get_interface`](@ref)().

`_added: Signal handler for the #GDBusObject::interface-added signal.`

`_removed: Signal handler for the #GDBusObject::interface-removed signal.`

Base object type for D-Bus objects.

Since: 2.30
"""
struct _GDBusObjectIface
    parent_iface::GTypeInterface
    get_object_path::Ptr{Cvoid}
    get_interfaces::Ptr{Cvoid}
    get_interface::Ptr{Cvoid}
    interface_added::Ptr{Cvoid}
    interface_removed::Ptr{Cvoid}
end

"""
[`GDBusObjectIface`](@ref): \\_iface: The parent interface. \\_object\\_path: Returns the object path. See [`g_dbus_object_get_object_path`](@ref)(). \\_interfaces: Returns all interfaces. See [`g_dbus_object_get_interfaces`](@ref)(). \\_interface: Returns an interface by name. See [`g_dbus_object_get_interface`](@ref)().

`_added: Signal handler for the #GDBusObject::interface-added signal.`

`_removed: Signal handler for the #GDBusObject::interface-removed signal.`

Base object type for D-Bus objects.

Since: 2.30
"""
const GDBusObjectIface = _GDBusObjectIface

"""
    g_dbus_object_manager_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_object_manager_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_object_manager_get_type()
    @ccall libaravis.g_dbus_object_manager_get_type()::GType
end

const _GDBusObjectManager = Cvoid

const GDBusObjectManager = _GDBusObjectManager

"""
    _GDBusObjectManagerIface

[`GDBusObjectManagerIface`](@ref): \\_iface: The parent interface. \\_object\\_path: Virtual function for [`g_dbus_object_manager_get_object_path`](@ref)(). \\_objects: Virtual function for [`g_dbus_object_manager_get_objects`](@ref)(). \\_object: Virtual function for [`g_dbus_object_manager_get_object`](@ref)(). \\_interface: Virtual function for [`g_dbus_object_manager_get_interface`](@ref)(). \\_added: Signal handler for the #[`GDBusObjectManager`](@ref)::object-added signal. \\_removed: Signal handler for the #[`GDBusObjectManager`](@ref)::object-removed signal.

`_added: Signal handler for the #GDBusObjectManager::interface-added signal.`

`_removed: Signal handler for the #GDBusObjectManager::interface-removed signal.`

Base type for D-Bus object managers.

Since: 2.30
"""
struct _GDBusObjectManagerIface
    parent_iface::GTypeInterface
    get_object_path::Ptr{Cvoid}
    get_objects::Ptr{Cvoid}
    get_object::Ptr{Cvoid}
    get_interface::Ptr{Cvoid}
    object_added::Ptr{Cvoid}
    object_removed::Ptr{Cvoid}
    interface_added::Ptr{Cvoid}
    interface_removed::Ptr{Cvoid}
end

"""
[`GDBusObjectManagerIface`](@ref): \\_iface: The parent interface. \\_object\\_path: Virtual function for [`g_dbus_object_manager_get_object_path`](@ref)(). \\_objects: Virtual function for [`g_dbus_object_manager_get_objects`](@ref)(). \\_object: Virtual function for [`g_dbus_object_manager_get_object`](@ref)(). \\_interface: Virtual function for [`g_dbus_object_manager_get_interface`](@ref)(). \\_added: Signal handler for the #[`GDBusObjectManager`](@ref)::object-added signal. \\_removed: Signal handler for the #[`GDBusObjectManager`](@ref)::object-removed signal.

`_added: Signal handler for the #GDBusObjectManager::interface-added signal.`

`_removed: Signal handler for the #GDBusObjectManager::interface-removed signal.`

Base type for D-Bus object managers.

Since: 2.30
"""
const GDBusObjectManagerIface = _GDBusObjectManagerIface

"""
    g_dbus_object_manager_client_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_object_manager_client_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_object_manager_client_get_type()
    @ccall libaravis.g_dbus_object_manager_client_get_type()::GType
end

const _GDBusObjectManagerClientPrivate = Cvoid

const GDBusObjectManagerClientPrivate = _GDBusObjectManagerClientPrivate

struct _GDBusObjectManagerClient
    parent_instance::GObject
    priv::Ptr{GDBusObjectManagerClientPrivate}
end

const GDBusObjectManagerClient = _GDBusObjectManagerClient

"""
    _GDBusObjectManagerClientClass

[`GDBusObjectManagerClientClass`](@ref): \\_class: The parent class.

`_proxy_signal: Signal class handler for the #GDBusObjectManagerClient::interface-proxy-signal signal.`

`_proxy_properties_changed: Signal class handler for the #GDBusObjectManagerClient::interface-proxy-properties-changed signal.`

Class structure for #[`GDBusObjectManagerClient`](@ref).

Since: 2.30
"""
struct _GDBusObjectManagerClientClass
    parent_class::GObjectClass
    interface_proxy_signal::Ptr{Cvoid}
    interface_proxy_properties_changed::Ptr{Cvoid}
    padding::NTuple{8, gpointer}
end

"""
[`GDBusObjectManagerClientClass`](@ref): \\_class: The parent class.

`_proxy_signal: Signal class handler for the #GDBusObjectManagerClient::interface-proxy-signal signal.`

`_proxy_properties_changed: Signal class handler for the #GDBusObjectManagerClient::interface-proxy-properties-changed signal.`

Class structure for #[`GDBusObjectManagerClient`](@ref).

Since: 2.30
"""
const GDBusObjectManagerClientClass = _GDBusObjectManagerClientClass

"""
    g_dbus_object_manager_server_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_object_manager_server_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_object_manager_server_get_type()
    @ccall libaravis.g_dbus_object_manager_server_get_type()::GType
end

const _GDBusObjectManagerServerPrivate = Cvoid

const GDBusObjectManagerServerPrivate = _GDBusObjectManagerServerPrivate

struct _GDBusObjectManagerServer
    parent_instance::GObject
    priv::Ptr{GDBusObjectManagerServerPrivate}
end

const GDBusObjectManagerServer = _GDBusObjectManagerServer

"""
    _GDBusObjectManagerServerClass

[`GDBusObjectManagerServerClass`](@ref): \\_class: The parent class.

Class structure for #[`GDBusObjectManagerServer`](@ref).

Since: 2.30
"""
struct _GDBusObjectManagerServerClass
    parent_class::GObjectClass
    padding::NTuple{8, gpointer}
end

"""
[`GDBusObjectManagerServerClass`](@ref): \\_class: The parent class.

Class structure for #[`GDBusObjectManagerServer`](@ref).

Since: 2.30
"""
const GDBusObjectManagerServerClass = _GDBusObjectManagerServerClass

"""
    g_dbus_object_proxy_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_object_proxy_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_object_proxy_get_type()
    @ccall libaravis.g_dbus_object_proxy_get_type()::GType
end

const _GDBusObjectProxyPrivate = Cvoid

const GDBusObjectProxyPrivate = _GDBusObjectProxyPrivate

struct _GDBusObjectProxy
    parent_instance::GObject
    priv::Ptr{GDBusObjectProxyPrivate}
end

const GDBusObjectProxy = _GDBusObjectProxy

"""
    _GDBusObjectProxyClass

[`GDBusObjectProxyClass`](@ref): \\_class: The parent class.

Class structure for #[`GDBusObjectProxy`](@ref).

Since: 2.30
"""
struct _GDBusObjectProxyClass
    parent_class::GObjectClass
    padding::NTuple{8, gpointer}
end

"""
[`GDBusObjectProxyClass`](@ref): \\_class: The parent class.

Class structure for #[`GDBusObjectProxy`](@ref).

Since: 2.30
"""
const GDBusObjectProxyClass = _GDBusObjectProxyClass

"""
    g_dbus_object_skeleton_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_object_skeleton_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_object_skeleton_get_type()
    @ccall libaravis.g_dbus_object_skeleton_get_type()::GType
end

const _GDBusObjectSkeletonPrivate = Cvoid

const GDBusObjectSkeletonPrivate = _GDBusObjectSkeletonPrivate

struct _GDBusObjectSkeleton
    parent_instance::GObject
    priv::Ptr{GDBusObjectSkeletonPrivate}
end

const GDBusObjectSkeleton = _GDBusObjectSkeleton

"""
    _GDBusObjectSkeletonClass

[`GDBusObjectSkeletonClass`](@ref): \\_class: The parent class. \\_method: Signal class handler for the #[`GDBusObjectSkeleton`](@ref)::authorize-method signal.

Class structure for #[`GDBusObjectSkeleton`](@ref).

Since: 2.30
"""
struct _GDBusObjectSkeletonClass
    parent_class::GObjectClass
    authorize_method::Ptr{Cvoid}
    padding::NTuple{8, gpointer}
end

"""
[`GDBusObjectSkeletonClass`](@ref): \\_class: The parent class. \\_method: Signal class handler for the #[`GDBusObjectSkeleton`](@ref)::authorize-method signal.

Class structure for #[`GDBusObjectSkeleton`](@ref).

Since: 2.30
"""
const GDBusObjectSkeletonClass = _GDBusObjectSkeletonClass

"""
    g_dbus_proxy_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_proxy_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_proxy_get_type()
    @ccall libaravis.g_dbus_proxy_get_type()::GType
end

const _GDBusProxyPrivate = Cvoid

const GDBusProxyPrivate = _GDBusProxyPrivate

struct _GDBusProxy
    parent_instance::GObject
    priv::Ptr{GDBusProxyPrivate}
end

const GDBusProxy = _GDBusProxy

"""
    _GDBusProxyClass

[`GDBusProxyClass`](@ref): \\_properties\\_changed: Signal class handler for the #[`GDBusProxy`](@ref)::g-properties-changed signal. \\_signal: Signal class handler for the #[`GDBusProxy`](@ref)::g-signal signal.

Class structure for #[`GDBusProxy`](@ref).

Since: 2.26
"""
struct _GDBusProxyClass
    parent_class::GObjectClass
    g_properties_changed::Ptr{Cvoid}
    g_signal::Ptr{Cvoid}
    padding::NTuple{32, gpointer}
end

"""
[`GDBusProxyClass`](@ref): \\_properties\\_changed: Signal class handler for the #[`GDBusProxy`](@ref)::g-properties-changed signal. \\_signal: Signal class handler for the #[`GDBusProxy`](@ref)::g-signal signal.

Class structure for #[`GDBusProxy`](@ref).

Since: 2.26
"""
const GDBusProxyClass = _GDBusProxyClass

"""
    g_dbus_server_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_server_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_server_get_type()
    @ccall libaravis.g_dbus_server_get_type()::GType
end

const _GDBusServer = Cvoid

const GDBusServer = _GDBusServer

"""
    g_debug_controller_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_72 G_DECLARE_INTERFACE(GDebugController, g_debug_controller, g, debug_controller, GObject);
```
"""
function g_debug_controller_get_type()
    @ccall libaravis.g_debug_controller_get_type()::GType
end

const _GDebugController = Cvoid

const GDebugController = _GDebugController

"""
    _GDebugControllerInterface

[`GDebugControllerInterface`](@ref): \\_iface: The parent interface.

The virtual function table for #[`GDebugController`](@ref).

Since: 2.72
"""
struct _GDebugControllerInterface
    g_iface::GTypeInterface
end

"""
[`GDebugControllerInterface`](@ref): \\_iface: The parent interface.

The virtual function table for #[`GDebugController`](@ref).

Since: 2.72
"""
const GDebugControllerInterface = _GDebugControllerInterface

"""
    g_debug_controller_dbus_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_72 G_DECLARE_DERIVABLE_TYPE (GDebugControllerDBus, g_debug_controller_dbus, G, DEBUG_CONTROLLER_DBUS, GObject);
```
"""
function g_debug_controller_dbus_get_type()
    @ccall libaravis.g_debug_controller_dbus_get_type()::GType
end

"""
    g_drive_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_drive_get_type (void) G_GNUC_CONST;
```
"""
function g_drive_get_type()
    @ccall libaravis.g_drive_get_type()::GType
end

const _GDrive = Cvoid

const GDrive = _GDrive

struct _GDriveIface
    g_iface::GTypeInterface
    changed::Ptr{Cvoid}
    disconnected::Ptr{Cvoid}
    eject_button::Ptr{Cvoid}
    get_name::Ptr{Cvoid}
    get_icon::Ptr{Cvoid}
    has_volumes::Ptr{Cvoid}
    get_volumes::Ptr{Cvoid}
    is_media_removable::Ptr{Cvoid}
    has_media::Ptr{Cvoid}
    is_media_check_automatic::Ptr{Cvoid}
    can_eject::Ptr{Cvoid}
    can_poll_for_media::Ptr{Cvoid}
    eject::Ptr{Cvoid}
    eject_finish::Ptr{Cvoid}
    poll_for_media::Ptr{Cvoid}
    poll_for_media_finish::Ptr{Cvoid}
    get_identifier::Ptr{Cvoid}
    enumerate_identifiers::Ptr{Cvoid}
    get_start_stop_type::Ptr{Cvoid}
    can_start::Ptr{Cvoid}
    can_start_degraded::Ptr{Cvoid}
    start::Ptr{Cvoid}
    start_finish::Ptr{Cvoid}
    can_stop::Ptr{Cvoid}
    stop::Ptr{Cvoid}
    stop_finish::Ptr{Cvoid}
    stop_button::Ptr{Cvoid}
    eject_with_operation::Ptr{Cvoid}
    eject_with_operation_finish::Ptr{Cvoid}
    get_sort_key::Ptr{Cvoid}
    get_symbolic_icon::Ptr{Cvoid}
    is_removable::Ptr{Cvoid}
end

"""
[`GDriveIface`](@ref): \\_iface: The parent interface. : Signal emitted when the drive is changed. : The removed signal that is emitted when the #[`GDrive`](@ref) have been disconnected. If the recipient is holding references to the object they should release them so the object can be finalized. \\_button: Signal emitted when the physical eject button (if any) of a drive have been pressed. \\_name: Returns the name for the given #[`GDrive`](@ref). \\_icon: Returns a #[`GIcon`](@ref) for the given #[`GDrive`](@ref). \\_volumes: Returns TRUE if the #[`GDrive`](@ref) has mountable volumes. \\_volumes: Returns a list #[`GList`](@ref) of #[`GVolume`](@ref) for the #[`GDrive`](@ref).

`_removable: Returns %TRUE if the #GDrive and/or its media is considered removable by the user. Since 2.50.`

`_media_removable: Returns %TRUE if the #GDrive supports removal and insertion of media.`

\\_media: Returns TRUE if the #[`GDrive`](@ref) has media inserted.

`_media_check_automatic: Returns %TRUE if the #GDrive is capable of automatically detecting media changes.`

\\_poll\\_for\\_media: Returns TRUE if the #[`GDrive`](@ref) is capable of manually polling for media change. \\_eject: Returns TRUE if the #[`GDrive`](@ref) can eject media. : Ejects a #[`GDrive`](@ref). \\_finish: Finishes an eject operation. \\_for\\_media: Poll for media insertion/removal on a #[`GDrive`](@ref). \\_for\\_media\\_finish: Finishes a media poll operation. \\_identifier: Returns the identifier of the given kind, or NULL if the #[`GDrive`](@ref) doesn't have one. \\_identifiers: Returns an array strings listing the kinds of identifiers which the #[`GDrive`](@ref) has. \\_start\\_stop\\_type: Gets a #[`GDriveStartStopType`](@ref) with details about starting/stopping the drive. Since 2.22. \\_stop: Returns TRUE if a #[`GDrive`](@ref) can be stopped. Since 2.22. : Stops a #[`GDrive`](@ref). Since 2.22. \\_finish: Finishes a stop operation. Since 2.22. \\_start: Returns TRUE if a #[`GDrive`](@ref) can be started. Since 2.22. \\_start\\_degraded: Returns TRUE if a #[`GDrive`](@ref) can be started degraded. Since 2.22. : Starts a #[`GDrive`](@ref). Since 2.22. \\_finish: Finishes a start operation. Since 2.22. \\_button: Signal emitted when the physical stop button (if any) of a drive have been pressed. Since 2.22. \\_with\\_operation: Starts ejecting a #[`GDrive`](@ref) using a #[`GMountOperation`](@ref). Since 2.22. \\_with\\_operation\\_finish: Finishes an eject operation using a #[`GMountOperation`](@ref). Since 2.22. \\_sort\\_key: Gets a key used for sorting #[`GDrive`](@ref) instances or NULL if no such key exists. Since 2.32. \\_symbolic\\_icon: Returns a symbolic #[`GIcon`](@ref) for the given #[`GDrive`](@ref). Since 2.34.

Interface for creating #[`GDrive`](@ref) implementations.
"""
const GDriveIface = _GDriveIface

"""
    g_dtls_connection_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_48 GType g_dtls_connection_get_type (void) G_GNUC_CONST;
```
"""
function g_dtls_connection_get_type()
    @ccall libaravis.g_dtls_connection_get_type()::GType
end

const _GDtlsConnection = Cvoid

const GDtlsConnection = _GDtlsConnection

"""
    _GDtlsConnectionInterface

[`GDtlsConnectionInterface`](@ref): \\_iface: The parent interface. \\_certificate: Check whether to accept a certificate. : Perform a handshake operation. \\_async: Start an asynchronous handshake operation. \\_finish: Finish an asynchronous handshake operation. : Shut down one or both directions of the connection. \\_async: Start an asynchronous shutdown operation. \\_finish: Finish an asynchronous shutdown operation.

Virtual method table for a #[`GDtlsConnection`](@ref) implementation.

Since: 2.48

# See also
\\_advertised\\_protocols: Set APLN protocol list (Since: 2.60) \\_negotiated\\_protocol: Get ALPN-negotiated protocol (Since: 2.60) \\_binding\\_data: Retrieve TLS channel binding data (Since: 2.66)
"""
struct _GDtlsConnectionInterface
    g_iface::GTypeInterface
    accept_certificate::Ptr{Cvoid}
    handshake::Ptr{Cvoid}
    handshake_async::Ptr{Cvoid}
    handshake_finish::Ptr{Cvoid}
    shutdown::Ptr{Cvoid}
    shutdown_async::Ptr{Cvoid}
    shutdown_finish::Ptr{Cvoid}
    set_advertised_protocols::Ptr{Cvoid}
    get_negotiated_protocol::Ptr{Cvoid}
    get_binding_data::Ptr{Cvoid}
end

"""
[`GDtlsConnectionInterface`](@ref): \\_iface: The parent interface. \\_certificate: Check whether to accept a certificate. : Perform a handshake operation. \\_async: Start an asynchronous handshake operation. \\_finish: Finish an asynchronous handshake operation. : Shut down one or both directions of the connection. \\_async: Start an asynchronous shutdown operation. \\_finish: Finish an asynchronous shutdown operation.

Virtual method table for a #[`GDtlsConnection`](@ref) implementation.

Since: 2.48

# See also
\\_advertised\\_protocols: Set APLN protocol list (Since: 2.60) \\_negotiated\\_protocol: Get ALPN-negotiated protocol (Since: 2.60) \\_binding\\_data: Retrieve TLS channel binding data (Since: 2.66)
"""
const GDtlsConnectionInterface = _GDtlsConnectionInterface

"""
    g_dtls_client_connection_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_48 GType g_dtls_client_connection_get_type (void) G_GNUC_CONST;
```
"""
function g_dtls_client_connection_get_type()
    @ccall libaravis.g_dtls_client_connection_get_type()::GType
end

const _GDtlsClientConnection = Cvoid

const GDtlsClientConnection = _GDtlsClientConnection

"""
    _GDtlsClientConnectionInterface

[`GDtlsClientConnectionInterface`](@ref): \\_iface: The parent interface.

vtable for a #[`GDtlsClientConnection`](@ref) implementation.

Since: 2.48
"""
struct _GDtlsClientConnectionInterface
    g_iface::GTypeInterface
end

"""
[`GDtlsClientConnectionInterface`](@ref): \\_iface: The parent interface.

vtable for a #[`GDtlsClientConnection`](@ref) implementation.

Since: 2.48
"""
const GDtlsClientConnectionInterface = _GDtlsClientConnectionInterface

"""
    g_dtls_server_connection_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_48 GType g_dtls_server_connection_get_type (void) G_GNUC_CONST;
```
"""
function g_dtls_server_connection_get_type()
    @ccall libaravis.g_dtls_server_connection_get_type()::GType
end

const _GDtlsServerConnection = Cvoid

const GDtlsServerConnection = _GDtlsServerConnection

"""
    _GDtlsServerConnectionInterface

[`GDtlsServerConnectionInterface`](@ref): \\_iface: The parent interface.

vtable for a #[`GDtlsServerConnection`](@ref) implementation.

Since: 2.48
"""
struct _GDtlsServerConnectionInterface
    g_iface::GTypeInterface
end

"""
[`GDtlsServerConnectionInterface`](@ref): \\_iface: The parent interface.

vtable for a #[`GDtlsServerConnection`](@ref) implementation.

Since: 2.48
"""
const GDtlsServerConnectionInterface = _GDtlsServerConnectionInterface

"""
    g_icon_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_icon_get_type (void) G_GNUC_CONST;
```
"""
function g_icon_get_type()
    @ccall libaravis.g_icon_get_type()::GType
end

const _GIcon = Cvoid

const GIcon = _GIcon

"""
    _GIconIface

[`GIconIface`](@ref): \\_iface: The parent interface. : A hash for a given #[`GIcon`](@ref). : Checks if two #GIcons are equal. \\_tokens: Serializes a #[`GIcon`](@ref) into tokens. The tokens must not contain any whitespace. Don't implement if the #[`GIcon`](@ref) can't be serialized (Since 2.20). \\_tokens: Constructs a #[`GIcon`](@ref) from tokens. Set the #[`GError`](@ref) if the tokens are malformed. Don't implement if the #[`GIcon`](@ref) can't be serialized (Since 2.20). : Serializes a #[`GIcon`](@ref) into a #[`GVariant`](@ref). Since: 2.38

[`GIconIface`](@ref) is used to implement [`GIcon`](@ref) types for various different systems. See #[`GThemedIcon`](@ref) and #[`GLoadableIcon`](@ref) for examples of how to implement this interface.
"""
struct _GIconIface
    g_iface::GTypeInterface
    hash::Ptr{Cvoid}
    equal::Ptr{Cvoid}
    to_tokens::Ptr{Cvoid}
    from_tokens::Ptr{Cvoid}
    serialize::Ptr{Cvoid}
end

"""
[`GIconIface`](@ref): \\_iface: The parent interface. : A hash for a given #[`GIcon`](@ref). : Checks if two #GIcons are equal. \\_tokens: Serializes a #[`GIcon`](@ref) into tokens. The tokens must not contain any whitespace. Don't implement if the #[`GIcon`](@ref) can't be serialized (Since 2.20). \\_tokens: Constructs a #[`GIcon`](@ref) from tokens. Set the #[`GError`](@ref) if the tokens are malformed. Don't implement if the #[`GIcon`](@ref) can't be serialized (Since 2.20). : Serializes a #[`GIcon`](@ref) into a #[`GVariant`](@ref). Since: 2.38

[`GIconIface`](@ref) is used to implement [`GIcon`](@ref) types for various different systems. See #[`GThemedIcon`](@ref) and #[`GLoadableIcon`](@ref) for examples of how to implement this interface.
"""
const GIconIface = _GIconIface

"""
    g_emblem_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_emblem_get_type (void) G_GNUC_CONST;
```
"""
function g_emblem_get_type()
    @ccall libaravis.g_emblem_get_type()::GType
end

const _GEmblem = Cvoid

const GEmblem = _GEmblem

const _GEmblemClass = Cvoid

const GEmblemClass = _GEmblemClass

"""
    g_emblemed_icon_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_emblemed_icon_get_type (void) G_GNUC_CONST;
```
"""
function g_emblemed_icon_get_type()
    @ccall libaravis.g_emblemed_icon_get_type()::GType
end

const _GEmblemedIconPrivate = Cvoid

const GEmblemedIconPrivate = _GEmblemedIconPrivate

struct _GEmblemedIcon
    parent_instance::GObject
    priv::Ptr{GEmblemedIconPrivate}
end

const GEmblemedIcon = _GEmblemedIcon

struct _GEmblemedIconClass
    parent_class::GObjectClass
end

const GEmblemedIconClass = _GEmblemedIconClass

"""
    g_file_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_file_get_type (void) G_GNUC_CONST;
```
"""
function g_file_get_type()
    @ccall libaravis.g_file_get_type()::GType
end

const _GFile = Cvoid

const GFile = _GFile

"""
    _GFileIface

[`GFileIface`](@ref): \\_iface: The parent interface. : Duplicates a #[`GFile`](@ref). : Creates a hash of a #[`GFile`](@ref). : Checks equality of two given #GFiles.

`_native: Checks to see if a file is native to the system.`

\\_uri\\_scheme: Checks to see if a #[`GFile`](@ref) has a given URI scheme. \\_uri\\_scheme: Gets the URI scheme for a #[`GFile`](@ref). \\_basename: Gets the basename for a given #[`GFile`](@ref). \\_path: Gets the current path within a #[`GFile`](@ref). \\_uri: Gets a URI for the path within a #[`GFile`](@ref). \\_parse\\_name: Gets the parsed name for the #[`GFile`](@ref). \\_parent: Gets the parent directory for the #[`GFile`](@ref). \\_matches: Checks whether a #[`GFile`](@ref) contains a specified file. \\_relative\\_path: Gets the path for a #[`GFile`](@ref) relative to a given path. \\_relative\\_path: Resolves a relative path for a #[`GFile`](@ref) to an absolute path. \\_child\\_for\\_display\\_name: Gets the child #[`GFile`](@ref) for a given display name. \\_children: Gets a #[`GFileEnumerator`](@ref) with the children of a #[`GFile`](@ref). \\_children\\_async: Asynchronously gets a #[`GFileEnumerator`](@ref) with the children of a #[`GFile`](@ref). \\_children\\_finish: Finishes asynchronously enumerating the children. \\_info: Gets the #[`GFileInfo`](@ref) for a #[`GFile`](@ref). \\_info\\_async: Asynchronously gets the #[`GFileInfo`](@ref) for a #[`GFile`](@ref). \\_info\\_finish: Finishes an asynchronous query info operation. \\_filesystem\\_info: Gets a #[`GFileInfo`](@ref) for the file system #[`GFile`](@ref) is on. \\_filesystem\\_info\\_async: Asynchronously gets a #[`GFileInfo`](@ref) for the file system #[`GFile`](@ref) is on. \\_filesystem\\_info\\_finish: Finishes asynchronously getting the file system info. \\_enclosing\\_mount: Gets a #[`GMount`](@ref) for the #[`GFile`](@ref). \\_enclosing\\_mount\\_async: Asynchronously gets the #[`GMount`](@ref) for a #[`GFile`](@ref). \\_enclosing\\_mount\\_finish: Finishes asynchronously getting the volume.

`. Since 2.38`

\\_disk\\_usage\\_async: Asynchronously recursively measures the disk usage of

`. Since 2.38`

\\_disk\\_usage\\_finish: Finishes an asynchronous recursive measurement of the disk usage of

`. Since 2.38`

\\_exists: Queries whether a file exists. Since 2.84

An interface for writing VFS file handles.

# See also
\\_display\\_name: Sets the display name for a #[`GFile`](@ref)., \\_display\\_name\\_async: Asynchronously sets a #[`GFile`](@ref)'s display name., \\_display\\_name\\_finish: Finishes asynchronously setting a #[`GFile`](@ref)'s display name. \\_settable\\_attributes: Returns a list of #GFileAttributeInfos that can be set. @\\_query\\_settable\\_attributes\\_async: Asynchronously gets a list of #GFileAttributeInfos that can be set. @\\_query\\_settable\\_attributes\\_finish: Finishes asynchronously querying settable attributes. \\_writable\\_namespaces: Returns a list of #[`GFileAttributeInfo`](@ref) namespaces that are writable. @\\_query\\_writable\\_namespaces\\_async: Asynchronously gets a list of #[`GFileAttributeInfo`](@ref) namespaces that are writable. @\\_query\\_writable\\_namespaces\\_finish: Finishes asynchronously querying the writable namespaces., \\_attribute: Sets a #[`GFileAttributeInfo`](@ref)., \\_attributes\\_from\\_info: Sets a #[`GFileAttributeInfo`](@ref) with information from a #[`GFileInfo`](@ref)., \\_attributes\\_async: Asynchronously sets a file's attributes., \\_attributes\\_finish: Finishes setting a file's attributes asynchronously. \\_fn: Reads a file asynchronously. \\_async: Asynchronously reads a file. \\_finish: Finishes asynchronously reading a file. \\_to: Writes to the end of a file. \\_to\\_async: Asynchronously writes to the end of a file. \\_to\\_finish: Finishes an asynchronous file append operation. : Creates a new file. \\_async: Asynchronously creates a file. \\_finish: Finishes asynchronously creating a file. : Replaces the contents of a file. \\_async: Asynchronously replaces the contents of a file. \\_finish: Finishes asynchronously replacing a file. \\_file: Deletes a file. \\_file\\_async: Asynchronously deletes a file. \\_file\\_finish: Finishes an asynchronous delete. : Sends a #[`GFile`](@ref) to the Trash location. \\_async: Asynchronously sends a #[`GFile`](@ref) to the Trash location. \\_finish: Finishes an asynchronous file trashing operation. \\_directory: Makes a directory. \\_directory\\_async: Asynchronously makes a directory. \\_directory\\_finish: Finishes making a directory asynchronously. \\_symbolic\\_link: (nullable): Makes a symbolic link. NULL if symbolic links are unsupported. \\_symbolic\\_link\\_async: Asynchronously makes a symbolic link \\_symbolic\\_link\\_finish: Finishes making a symbolic link asynchronously. : (nullable): Copies a file. NULL if copying is unsupported, which will cause [`GFile`](@ref) to use a fallback copy method where it reads from the source and writes to the destination. \\_async: Asynchronously copies a file. \\_finish: Finishes an asynchronous copy operation. : Moves a file. \\_async: Asynchronously moves a file. Since: 2.72 \\_finish: Finishes an asynchronous move operation. Since: 2.72 \\_mountable: Mounts a mountable object. \\_mountable\\_finish: Finishes a mounting operation. \\_mountable: Unmounts a mountable object. \\_mountable\\_finish: Finishes an unmount operation. \\_mountable: Ejects a mountable. \\_mountable\\_finish: Finishes an eject operation. \\_enclosing\\_volume: Mounts a specified location. \\_enclosing\\_volume\\_finish: Finishes mounting a specified location. \\_dir: Creates a #[`GFileMonitor`](@ref) for the location. \\_file: Creates a #[`GFileMonitor`](@ref) for the location. \\_readwrite: Open file read/write. Since 2.22. \\_readwrite\\_async: Asynchronously opens file read/write. Since 2.22. \\_readwrite\\_finish: Finishes an asynchronous open read/write. Since 2.22. \\_readwrite: Creates file read/write. Since 2.22. \\_readwrite\\_async: Asynchronously creates file read/write. Since 2.22. \\_readwrite\\_finish: Finishes an asynchronous creates read/write. Since 2.22. \\_readwrite: Replaces file read/write. Since 2.22. \\_readwrite\\_async: Asynchronously replaces file read/write. Since 2.22. \\_readwrite\\_finish: Finishes an asynchronous replace read/write. Since 2.22. \\_mountable: Starts a mountable object. Since 2.22. \\_mountable\\_finish: Finishes a start operation. Since 2.22. \\_mountable: Stops a mountable. Since 2.22. \\_mountable\\_finish: Finishes a stop operation. Since 2.22. \\_thread\\_contexts: a boolean that indicates whether the #[`GFile`](@ref) implementation supports thread-default contexts. Since 2.22. \\_mountable\\_with\\_operation: Unmounts a mountable object using a #[`GMountOperation`](@ref). Since 2.22. \\_mountable\\_with\\_operation\\_finish: Finishes an unmount operation using a #[`GMountOperation`](@ref). Since 2.22. \\_mountable\\_with\\_operation: Ejects a mountable object using a #[`GMountOperation`](@ref). Since 2.22. \\_mountable\\_with\\_operation\\_finish: Finishes an eject operation using a #[`GMountOperation`](@ref). Since 2.22. \\_mountable: Polls a mountable object for media changes. Since 2.22. \\_mountable\\_finish: Finishes a poll operation for media changes. Since 2.22. \\_disk\\_usage: Recursively measures the disk usage of
"""
struct _GFileIface
    g_iface::GTypeInterface
    dup::Ptr{Cvoid}
    hash::Ptr{Cvoid}
    equal::Ptr{Cvoid}
    is_native::Ptr{Cvoid}
    has_uri_scheme::Ptr{Cvoid}
    get_uri_scheme::Ptr{Cvoid}
    get_basename::Ptr{Cvoid}
    get_path::Ptr{Cvoid}
    get_uri::Ptr{Cvoid}
    get_parse_name::Ptr{Cvoid}
    get_parent::Ptr{Cvoid}
    prefix_matches::Ptr{Cvoid}
    get_relative_path::Ptr{Cvoid}
    resolve_relative_path::Ptr{Cvoid}
    get_child_for_display_name::Ptr{Cvoid}
    enumerate_children::Ptr{Cvoid}
    enumerate_children_async::Ptr{Cvoid}
    enumerate_children_finish::Ptr{Cvoid}
    query_info::Ptr{Cvoid}
    query_info_async::Ptr{Cvoid}
    query_info_finish::Ptr{Cvoid}
    query_filesystem_info::Ptr{Cvoid}
    query_filesystem_info_async::Ptr{Cvoid}
    query_filesystem_info_finish::Ptr{Cvoid}
    find_enclosing_mount::Ptr{Cvoid}
    find_enclosing_mount_async::Ptr{Cvoid}
    find_enclosing_mount_finish::Ptr{Cvoid}
    set_display_name::Ptr{Cvoid}
    set_display_name_async::Ptr{Cvoid}
    set_display_name_finish::Ptr{Cvoid}
    query_settable_attributes::Ptr{Cvoid}
    _query_settable_attributes_async::Ptr{Cvoid}
    _query_settable_attributes_finish::Ptr{Cvoid}
    query_writable_namespaces::Ptr{Cvoid}
    _query_writable_namespaces_async::Ptr{Cvoid}
    _query_writable_namespaces_finish::Ptr{Cvoid}
    set_attribute::Ptr{Cvoid}
    set_attributes_from_info::Ptr{Cvoid}
    set_attributes_async::Ptr{Cvoid}
    set_attributes_finish::Ptr{Cvoid}
    read_fn::Ptr{Cvoid}
    read_async::Ptr{Cvoid}
    read_finish::Ptr{Cvoid}
    append_to::Ptr{Cvoid}
    append_to_async::Ptr{Cvoid}
    append_to_finish::Ptr{Cvoid}
    create::Ptr{Cvoid}
    create_async::Ptr{Cvoid}
    create_finish::Ptr{Cvoid}
    replace::Ptr{Cvoid}
    replace_async::Ptr{Cvoid}
    replace_finish::Ptr{Cvoid}
    delete_file::Ptr{Cvoid}
    delete_file_async::Ptr{Cvoid}
    delete_file_finish::Ptr{Cvoid}
    trash::Ptr{Cvoid}
    trash_async::Ptr{Cvoid}
    trash_finish::Ptr{Cvoid}
    make_directory::Ptr{Cvoid}
    make_directory_async::Ptr{Cvoid}
    make_directory_finish::Ptr{Cvoid}
    make_symbolic_link::Ptr{Cvoid}
    make_symbolic_link_async::Ptr{Cvoid}
    make_symbolic_link_finish::Ptr{Cvoid}
    copy::Ptr{Cvoid}
    copy_async::Ptr{Cvoid}
    copy_finish::Ptr{Cvoid}
    move::Ptr{Cvoid}
    move_async::Ptr{Cvoid}
    move_finish::Ptr{Cvoid}
    mount_mountable::Ptr{Cvoid}
    mount_mountable_finish::Ptr{Cvoid}
    unmount_mountable::Ptr{Cvoid}
    unmount_mountable_finish::Ptr{Cvoid}
    eject_mountable::Ptr{Cvoid}
    eject_mountable_finish::Ptr{Cvoid}
    mount_enclosing_volume::Ptr{Cvoid}
    mount_enclosing_volume_finish::Ptr{Cvoid}
    monitor_dir::Ptr{Cvoid}
    monitor_file::Ptr{Cvoid}
    open_readwrite::Ptr{Cvoid}
    open_readwrite_async::Ptr{Cvoid}
    open_readwrite_finish::Ptr{Cvoid}
    create_readwrite::Ptr{Cvoid}
    create_readwrite_async::Ptr{Cvoid}
    create_readwrite_finish::Ptr{Cvoid}
    replace_readwrite::Ptr{Cvoid}
    replace_readwrite_async::Ptr{Cvoid}
    replace_readwrite_finish::Ptr{Cvoid}
    start_mountable::Ptr{Cvoid}
    start_mountable_finish::Ptr{Cvoid}
    stop_mountable::Ptr{Cvoid}
    stop_mountable_finish::Ptr{Cvoid}
    supports_thread_contexts::gboolean
    unmount_mountable_with_operation::Ptr{Cvoid}
    unmount_mountable_with_operation_finish::Ptr{Cvoid}
    eject_mountable_with_operation::Ptr{Cvoid}
    eject_mountable_with_operation_finish::Ptr{Cvoid}
    poll_mountable::Ptr{Cvoid}
    poll_mountable_finish::Ptr{Cvoid}
    measure_disk_usage::Ptr{Cvoid}
    measure_disk_usage_async::Ptr{Cvoid}
    measure_disk_usage_finish::Ptr{Cvoid}
    query_exists::Ptr{Cvoid}
end

"""
[`GFileIface`](@ref): \\_iface: The parent interface. : Duplicates a #[`GFile`](@ref). : Creates a hash of a #[`GFile`](@ref). : Checks equality of two given #GFiles.

`_native: Checks to see if a file is native to the system.`

\\_uri\\_scheme: Checks to see if a #[`GFile`](@ref) has a given URI scheme. \\_uri\\_scheme: Gets the URI scheme for a #[`GFile`](@ref). \\_basename: Gets the basename for a given #[`GFile`](@ref). \\_path: Gets the current path within a #[`GFile`](@ref). \\_uri: Gets a URI for the path within a #[`GFile`](@ref). \\_parse\\_name: Gets the parsed name for the #[`GFile`](@ref). \\_parent: Gets the parent directory for the #[`GFile`](@ref). \\_matches: Checks whether a #[`GFile`](@ref) contains a specified file. \\_relative\\_path: Gets the path for a #[`GFile`](@ref) relative to a given path. \\_relative\\_path: Resolves a relative path for a #[`GFile`](@ref) to an absolute path. \\_child\\_for\\_display\\_name: Gets the child #[`GFile`](@ref) for a given display name. \\_children: Gets a #[`GFileEnumerator`](@ref) with the children of a #[`GFile`](@ref). \\_children\\_async: Asynchronously gets a #[`GFileEnumerator`](@ref) with the children of a #[`GFile`](@ref). \\_children\\_finish: Finishes asynchronously enumerating the children. \\_info: Gets the #[`GFileInfo`](@ref) for a #[`GFile`](@ref). \\_info\\_async: Asynchronously gets the #[`GFileInfo`](@ref) for a #[`GFile`](@ref). \\_info\\_finish: Finishes an asynchronous query info operation. \\_filesystem\\_info: Gets a #[`GFileInfo`](@ref) for the file system #[`GFile`](@ref) is on. \\_filesystem\\_info\\_async: Asynchronously gets a #[`GFileInfo`](@ref) for the file system #[`GFile`](@ref) is on. \\_filesystem\\_info\\_finish: Finishes asynchronously getting the file system info. \\_enclosing\\_mount: Gets a #[`GMount`](@ref) for the #[`GFile`](@ref). \\_enclosing\\_mount\\_async: Asynchronously gets the #[`GMount`](@ref) for a #[`GFile`](@ref). \\_enclosing\\_mount\\_finish: Finishes asynchronously getting the volume.

`. Since 2.38`

\\_disk\\_usage\\_async: Asynchronously recursively measures the disk usage of

`. Since 2.38`

\\_disk\\_usage\\_finish: Finishes an asynchronous recursive measurement of the disk usage of

`. Since 2.38`

\\_exists: Queries whether a file exists. Since 2.84

An interface for writing VFS file handles.

# See also
\\_display\\_name: Sets the display name for a #[`GFile`](@ref)., \\_display\\_name\\_async: Asynchronously sets a #[`GFile`](@ref)'s display name., \\_display\\_name\\_finish: Finishes asynchronously setting a #[`GFile`](@ref)'s display name. \\_settable\\_attributes: Returns a list of #GFileAttributeInfos that can be set. @\\_query\\_settable\\_attributes\\_async: Asynchronously gets a list of #GFileAttributeInfos that can be set. @\\_query\\_settable\\_attributes\\_finish: Finishes asynchronously querying settable attributes. \\_writable\\_namespaces: Returns a list of #[`GFileAttributeInfo`](@ref) namespaces that are writable. @\\_query\\_writable\\_namespaces\\_async: Asynchronously gets a list of #[`GFileAttributeInfo`](@ref) namespaces that are writable. @\\_query\\_writable\\_namespaces\\_finish: Finishes asynchronously querying the writable namespaces., \\_attribute: Sets a #[`GFileAttributeInfo`](@ref)., \\_attributes\\_from\\_info: Sets a #[`GFileAttributeInfo`](@ref) with information from a #[`GFileInfo`](@ref)., \\_attributes\\_async: Asynchronously sets a file's attributes., \\_attributes\\_finish: Finishes setting a file's attributes asynchronously. \\_fn: Reads a file asynchronously. \\_async: Asynchronously reads a file. \\_finish: Finishes asynchronously reading a file. \\_to: Writes to the end of a file. \\_to\\_async: Asynchronously writes to the end of a file. \\_to\\_finish: Finishes an asynchronous file append operation. : Creates a new file. \\_async: Asynchronously creates a file. \\_finish: Finishes asynchronously creating a file. : Replaces the contents of a file. \\_async: Asynchronously replaces the contents of a file. \\_finish: Finishes asynchronously replacing a file. \\_file: Deletes a file. \\_file\\_async: Asynchronously deletes a file. \\_file\\_finish: Finishes an asynchronous delete. : Sends a #[`GFile`](@ref) to the Trash location. \\_async: Asynchronously sends a #[`GFile`](@ref) to the Trash location. \\_finish: Finishes an asynchronous file trashing operation. \\_directory: Makes a directory. \\_directory\\_async: Asynchronously makes a directory. \\_directory\\_finish: Finishes making a directory asynchronously. \\_symbolic\\_link: (nullable): Makes a symbolic link. NULL if symbolic links are unsupported. \\_symbolic\\_link\\_async: Asynchronously makes a symbolic link \\_symbolic\\_link\\_finish: Finishes making a symbolic link asynchronously. : (nullable): Copies a file. NULL if copying is unsupported, which will cause [`GFile`](@ref) to use a fallback copy method where it reads from the source and writes to the destination. \\_async: Asynchronously copies a file. \\_finish: Finishes an asynchronous copy operation. : Moves a file. \\_async: Asynchronously moves a file. Since: 2.72 \\_finish: Finishes an asynchronous move operation. Since: 2.72 \\_mountable: Mounts a mountable object. \\_mountable\\_finish: Finishes a mounting operation. \\_mountable: Unmounts a mountable object. \\_mountable\\_finish: Finishes an unmount operation. \\_mountable: Ejects a mountable. \\_mountable\\_finish: Finishes an eject operation. \\_enclosing\\_volume: Mounts a specified location. \\_enclosing\\_volume\\_finish: Finishes mounting a specified location. \\_dir: Creates a #[`GFileMonitor`](@ref) for the location. \\_file: Creates a #[`GFileMonitor`](@ref) for the location. \\_readwrite: Open file read/write. Since 2.22. \\_readwrite\\_async: Asynchronously opens file read/write. Since 2.22. \\_readwrite\\_finish: Finishes an asynchronous open read/write. Since 2.22. \\_readwrite: Creates file read/write. Since 2.22. \\_readwrite\\_async: Asynchronously creates file read/write. Since 2.22. \\_readwrite\\_finish: Finishes an asynchronous creates read/write. Since 2.22. \\_readwrite: Replaces file read/write. Since 2.22. \\_readwrite\\_async: Asynchronously replaces file read/write. Since 2.22. \\_readwrite\\_finish: Finishes an asynchronous replace read/write. Since 2.22. \\_mountable: Starts a mountable object. Since 2.22. \\_mountable\\_finish: Finishes a start operation. Since 2.22. \\_mountable: Stops a mountable. Since 2.22. \\_mountable\\_finish: Finishes a stop operation. Since 2.22. \\_thread\\_contexts: a boolean that indicates whether the #[`GFile`](@ref) implementation supports thread-default contexts. Since 2.22. \\_mountable\\_with\\_operation: Unmounts a mountable object using a #[`GMountOperation`](@ref). Since 2.22. \\_mountable\\_with\\_operation\\_finish: Finishes an unmount operation using a #[`GMountOperation`](@ref). Since 2.22. \\_mountable\\_with\\_operation: Ejects a mountable object using a #[`GMountOperation`](@ref). Since 2.22. \\_mountable\\_with\\_operation\\_finish: Finishes an eject operation using a #[`GMountOperation`](@ref). Since 2.22. \\_mountable: Polls a mountable object for media changes. Since 2.22. \\_mountable\\_finish: Finishes a poll operation for media changes. Since 2.22. \\_disk\\_usage: Recursively measures the disk usage of
"""
const GFileIface = _GFileIface

"""
    g_file_attribute_info_list_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_file_attribute_info_list_get_type (void);
```
"""
function g_file_attribute_info_list_get_type()
    @ccall libaravis.g_file_attribute_info_list_get_type()::GType
end

"""
    g_file_enumerator_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_file_enumerator_get_type (void) G_GNUC_CONST;
```
"""
function g_file_enumerator_get_type()
    @ccall libaravis.g_file_enumerator_get_type()::GType
end

const _GFileEnumeratorPrivate = Cvoid

const GFileEnumeratorPrivate = _GFileEnumeratorPrivate

struct _GFileEnumerator
    parent_instance::GObject
    priv::Ptr{GFileEnumeratorPrivate}
end

const GFileEnumerator = _GFileEnumerator

struct _GFileEnumeratorClass
    parent_class::GObjectClass
    next_file::Ptr{Cvoid}
    close_fn::Ptr{Cvoid}
    next_files_async::Ptr{Cvoid}
    next_files_finish::Ptr{Cvoid}
    close_async::Ptr{Cvoid}
    close_finish::Ptr{Cvoid}
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
    _g_reserved4::Ptr{Cvoid}
    _g_reserved5::Ptr{Cvoid}
    _g_reserved6::Ptr{Cvoid}
    _g_reserved7::Ptr{Cvoid}
end

const GFileEnumeratorClass = _GFileEnumeratorClass

"""
    g_file_icon_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_file_icon_get_type (void) G_GNUC_CONST;
```
"""
function g_file_icon_get_type()
    @ccall libaravis.g_file_icon_get_type()::GType
end

const _GFileIcon = Cvoid

const GFileIcon = _GFileIcon

const _GFileIconClass = Cvoid

const GFileIconClass = _GFileIconClass

"""
    g_file_info_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_file_info_get_type (void) G_GNUC_CONST;
```
"""
function g_file_info_get_type()
    @ccall libaravis.g_file_info_get_type()::GType
end

const _GFileInfo = Cvoid

const GFileInfo = _GFileInfo

const _GFileInfoClass = Cvoid

const GFileInfoClass = _GFileInfoClass

"""
    g_file_attribute_matcher_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_file_attribute_matcher_get_type (void) G_GNUC_CONST;
```
"""
function g_file_attribute_matcher_get_type()
    @ccall libaravis.g_file_attribute_matcher_get_type()::GType
end

"""
    g_file_input_stream_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_file_input_stream_get_type (void) G_GNUC_CONST;
```
"""
function g_file_input_stream_get_type()
    @ccall libaravis.g_file_input_stream_get_type()::GType
end

const _GFileInputStreamPrivate = Cvoid

const GFileInputStreamPrivate = _GFileInputStreamPrivate

struct _GFileInputStream
    parent_instance::GInputStream
    priv::Ptr{GFileInputStreamPrivate}
end

const GFileInputStream = _GFileInputStream

struct _GFileInputStreamClass
    parent_class::GInputStreamClass
    tell::Ptr{Cvoid}
    can_seek::Ptr{Cvoid}
    seek::Ptr{Cvoid}
    query_info::Ptr{Cvoid}
    query_info_async::Ptr{Cvoid}
    query_info_finish::Ptr{Cvoid}
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
    _g_reserved4::Ptr{Cvoid}
    _g_reserved5::Ptr{Cvoid}
end

const GFileInputStreamClass = _GFileInputStreamClass

"""
    g_io_error_quark()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GQuark g_io_error_quark (void);
```
"""
function g_io_error_quark()
    @ccall libaravis.g_io_error_quark()::GQuark
end

"""
    g_io_stream_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_io_stream_get_type (void) G_GNUC_CONST;
```
"""
function g_io_stream_get_type()
    @ccall libaravis.g_io_stream_get_type()::GType
end

const _GIOStreamPrivate = Cvoid

const GIOStreamPrivate = _GIOStreamPrivate

struct _GIOStream
    parent_instance::GObject
    priv::Ptr{GIOStreamPrivate}
end

const GIOStream = _GIOStream

struct _GIOStreamClass
    parent_class::GObjectClass
    get_input_stream::Ptr{Cvoid}
    get_output_stream::Ptr{Cvoid}
    close_fn::Ptr{Cvoid}
    close_async::Ptr{Cvoid}
    close_finish::Ptr{Cvoid}
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
    _g_reserved4::Ptr{Cvoid}
    _g_reserved5::Ptr{Cvoid}
    _g_reserved6::Ptr{Cvoid}
    _g_reserved7::Ptr{Cvoid}
    _g_reserved8::Ptr{Cvoid}
    _g_reserved9::Ptr{Cvoid}
    _g_reserved10::Ptr{Cvoid}
end

const GIOStreamClass = _GIOStreamClass

"""
    g_file_io_stream_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_file_io_stream_get_type (void) G_GNUC_CONST;
```
"""
function g_file_io_stream_get_type()
    @ccall libaravis.g_file_io_stream_get_type()::GType
end

const _GFileIOStreamPrivate = Cvoid

const GFileIOStreamPrivate = _GFileIOStreamPrivate

struct _GFileIOStream
    parent_instance::GIOStream
    priv::Ptr{GFileIOStreamPrivate}
end

const GFileIOStream = _GFileIOStream

struct _GFileIOStreamClass
    parent_class::GIOStreamClass
    tell::Ptr{Cvoid}
    can_seek::Ptr{Cvoid}
    seek::Ptr{Cvoid}
    can_truncate::Ptr{Cvoid}
    truncate_fn::Ptr{Cvoid}
    query_info::Ptr{Cvoid}
    query_info_async::Ptr{Cvoid}
    query_info_finish::Ptr{Cvoid}
    get_etag::Ptr{Cvoid}
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
    _g_reserved4::Ptr{Cvoid}
    _g_reserved5::Ptr{Cvoid}
end

const GFileIOStreamClass = _GFileIOStreamClass

"""
    g_file_monitor_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_file_monitor_get_type (void) G_GNUC_CONST;
```
"""
function g_file_monitor_get_type()
    @ccall libaravis.g_file_monitor_get_type()::GType
end

const _GFileMonitorPrivate = Cvoid

const GFileMonitorPrivate = _GFileMonitorPrivate

struct _GFileMonitor
    parent_instance::GObject
    priv::Ptr{GFileMonitorPrivate}
end

const GFileMonitor = _GFileMonitor

struct _GFileMonitorClass
    parent_class::GObjectClass
    changed::Ptr{Cvoid}
    cancel::Ptr{Cvoid}
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
    _g_reserved4::Ptr{Cvoid}
    _g_reserved5::Ptr{Cvoid}
end

const GFileMonitorClass = _GFileMonitorClass

"""
    g_filename_completer_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_filename_completer_get_type (void) G_GNUC_CONST;
```
"""
function g_filename_completer_get_type()
    @ccall libaravis.g_filename_completer_get_type()::GType
end

const _GFilenameCompleter = Cvoid

const GFilenameCompleter = _GFilenameCompleter

struct _GFilenameCompleterClass
    parent_class::GObjectClass
    got_completion_data::Ptr{Cvoid}
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
end

const GFilenameCompleterClass = _GFilenameCompleterClass

"""
    g_file_output_stream_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_file_output_stream_get_type (void) G_GNUC_CONST;
```
"""
function g_file_output_stream_get_type()
    @ccall libaravis.g_file_output_stream_get_type()::GType
end

const _GFileOutputStreamPrivate = Cvoid

const GFileOutputStreamPrivate = _GFileOutputStreamPrivate

struct _GFileOutputStream
    parent_instance::GOutputStream
    priv::Ptr{GFileOutputStreamPrivate}
end

const GFileOutputStream = _GFileOutputStream

struct _GFileOutputStreamClass
    parent_class::GOutputStreamClass
    tell::Ptr{Cvoid}
    can_seek::Ptr{Cvoid}
    seek::Ptr{Cvoid}
    can_truncate::Ptr{Cvoid}
    truncate_fn::Ptr{Cvoid}
    query_info::Ptr{Cvoid}
    query_info_async::Ptr{Cvoid}
    query_info_finish::Ptr{Cvoid}
    get_etag::Ptr{Cvoid}
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
    _g_reserved4::Ptr{Cvoid}
    _g_reserved5::Ptr{Cvoid}
end

const GFileOutputStreamClass = _GFileOutputStreamClass

"""
    g_inet_address_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_inet_address_get_type (void) G_GNUC_CONST;
```
"""
function g_inet_address_get_type()
    @ccall libaravis.g_inet_address_get_type()::GType
end

const _GInetAddressPrivate = Cvoid

const GInetAddressPrivate = _GInetAddressPrivate

struct _GInetAddress
    parent_instance::GObject
    priv::Ptr{GInetAddressPrivate}
end

const GInetAddress = _GInetAddress

struct _GInetAddressClass
    parent_class::GObjectClass
    to_string::Ptr{Cvoid}
    to_bytes::Ptr{Cvoid}
end

const GInetAddressClass = _GInetAddressClass

"""
    g_inet_address_mask_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GType g_inet_address_mask_get_type (void) G_GNUC_CONST;
```
"""
function g_inet_address_mask_get_type()
    @ccall libaravis.g_inet_address_mask_get_type()::GType
end

const _GInetAddressMaskPrivate = Cvoid

const GInetAddressMaskPrivate = _GInetAddressMaskPrivate

struct _GInetAddressMask
    parent_instance::GObject
    priv::Ptr{GInetAddressMaskPrivate}
end

const GInetAddressMask = _GInetAddressMask

struct _GInetAddressMaskClass
    parent_class::GObjectClass
end

const GInetAddressMaskClass = _GInetAddressMaskClass

"""
    g_socket_address_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_socket_address_get_type (void) G_GNUC_CONST;
```
"""
function g_socket_address_get_type()
    @ccall libaravis.g_socket_address_get_type()::GType
end

struct _GSocketAddress
    parent_instance::GObject
end

const GSocketAddress = _GSocketAddress

struct _GSocketAddressClass
    parent_class::GObjectClass
    get_family::Ptr{Cvoid}
    get_native_size::Ptr{Cvoid}
    to_native::Ptr{Cvoid}
end

const GSocketAddressClass = _GSocketAddressClass

"""
    g_inet_socket_address_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_inet_socket_address_get_type (void) G_GNUC_CONST;
```
"""
function g_inet_socket_address_get_type()
    @ccall libaravis.g_inet_socket_address_get_type()::GType
end

const _GInetSocketAddressPrivate = Cvoid

const GInetSocketAddressPrivate = _GInetSocketAddressPrivate

struct _GInetSocketAddress
    parent_instance::GSocketAddress
    priv::Ptr{GInetSocketAddressPrivate}
end

const GInetSocketAddress = _GInetSocketAddress

struct _GInetSocketAddressClass
    parent_class::GSocketAddressClass
end

const GInetSocketAddressClass = _GInetSocketAddressClass

"""
    g_app_info_create_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_app_info_create_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_app_info_create_flags_get_type()
    @ccall libaravis.g_app_info_create_flags_get_type()::GType
end

"""
    g_converter_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_converter_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_converter_flags_get_type()
    @ccall libaravis.g_converter_flags_get_type()::GType
end

"""
    g_converter_result_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_converter_result_get_type (void) G_GNUC_CONST;
```
"""
function g_converter_result_get_type()
    @ccall libaravis.g_converter_result_get_type()::GType
end

"""
    g_data_stream_byte_order_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_data_stream_byte_order_get_type (void) G_GNUC_CONST;
```
"""
function g_data_stream_byte_order_get_type()
    @ccall libaravis.g_data_stream_byte_order_get_type()::GType
end

"""
    g_data_stream_newline_type_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_data_stream_newline_type_get_type (void) G_GNUC_CONST;
```
"""
function g_data_stream_newline_type_get_type()
    @ccall libaravis.g_data_stream_newline_type_get_type()::GType
end

"""
    g_file_attribute_type_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_file_attribute_type_get_type (void) G_GNUC_CONST;
```
"""
function g_file_attribute_type_get_type()
    @ccall libaravis.g_file_attribute_type_get_type()::GType
end

"""
    g_file_attribute_info_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_file_attribute_info_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_file_attribute_info_flags_get_type()
    @ccall libaravis.g_file_attribute_info_flags_get_type()::GType
end

"""
    g_file_attribute_status_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_file_attribute_status_get_type (void) G_GNUC_CONST;
```
"""
function g_file_attribute_status_get_type()
    @ccall libaravis.g_file_attribute_status_get_type()::GType
end

"""
    g_file_query_info_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_file_query_info_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_file_query_info_flags_get_type()
    @ccall libaravis.g_file_query_info_flags_get_type()::GType
end

"""
    g_file_create_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_file_create_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_file_create_flags_get_type()
    @ccall libaravis.g_file_create_flags_get_type()::GType
end

"""
    g_file_measure_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_file_measure_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_file_measure_flags_get_type()
    @ccall libaravis.g_file_measure_flags_get_type()::GType
end

"""
    g_mount_mount_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_mount_mount_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_mount_mount_flags_get_type()
    @ccall libaravis.g_mount_mount_flags_get_type()::GType
end

"""
    g_mount_unmount_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_mount_unmount_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_mount_unmount_flags_get_type()
    @ccall libaravis.g_mount_unmount_flags_get_type()::GType
end

"""
    g_drive_start_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_drive_start_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_drive_start_flags_get_type()
    @ccall libaravis.g_drive_start_flags_get_type()::GType
end

"""
    g_drive_start_stop_type_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_drive_start_stop_type_get_type (void) G_GNUC_CONST;
```
"""
function g_drive_start_stop_type_get_type()
    @ccall libaravis.g_drive_start_stop_type_get_type()::GType
end

"""
    g_file_copy_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_file_copy_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_file_copy_flags_get_type()
    @ccall libaravis.g_file_copy_flags_get_type()::GType
end

"""
    g_file_monitor_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_file_monitor_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_file_monitor_flags_get_type()
    @ccall libaravis.g_file_monitor_flags_get_type()::GType
end

"""
    g_file_type_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_file_type_get_type (void) G_GNUC_CONST;
```
"""
function g_file_type_get_type()
    @ccall libaravis.g_file_type_get_type()::GType
end

"""
    g_filesystem_preview_type_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_filesystem_preview_type_get_type (void) G_GNUC_CONST;
```
"""
function g_filesystem_preview_type_get_type()
    @ccall libaravis.g_filesystem_preview_type_get_type()::GType
end

"""
    g_file_monitor_event_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_file_monitor_event_get_type (void) G_GNUC_CONST;
```
"""
function g_file_monitor_event_get_type()
    @ccall libaravis.g_file_monitor_event_get_type()::GType
end

"""
    g_io_error_enum_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_io_error_enum_get_type (void) G_GNUC_CONST;
```
"""
function g_io_error_enum_get_type()
    @ccall libaravis.g_io_error_enum_get_type()::GType
end

"""
    g_ask_password_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_ask_password_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_ask_password_flags_get_type()
    @ccall libaravis.g_ask_password_flags_get_type()::GType
end

"""
    g_password_save_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_password_save_get_type (void) G_GNUC_CONST;
```
"""
function g_password_save_get_type()
    @ccall libaravis.g_password_save_get_type()::GType
end

"""
    g_mount_operation_result_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_mount_operation_result_get_type (void) G_GNUC_CONST;
```
"""
function g_mount_operation_result_get_type()
    @ccall libaravis.g_mount_operation_result_get_type()::GType
end

"""
    g_output_stream_splice_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_output_stream_splice_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_output_stream_splice_flags_get_type()
    @ccall libaravis.g_output_stream_splice_flags_get_type()::GType
end

"""
    g_io_stream_splice_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_io_stream_splice_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_io_stream_splice_flags_get_type()
    @ccall libaravis.g_io_stream_splice_flags_get_type()::GType
end

"""
    g_emblem_origin_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_emblem_origin_get_type (void) G_GNUC_CONST;
```
"""
function g_emblem_origin_get_type()
    @ccall libaravis.g_emblem_origin_get_type()::GType
end

"""
    g_resolver_error_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_resolver_error_get_type (void) G_GNUC_CONST;
```
"""
function g_resolver_error_get_type()
    @ccall libaravis.g_resolver_error_get_type()::GType
end

"""
    g_resolver_record_type_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_resolver_record_type_get_type (void) G_GNUC_CONST;
```
"""
function g_resolver_record_type_get_type()
    @ccall libaravis.g_resolver_record_type_get_type()::GType
end

"""
    g_resource_error_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_resource_error_get_type (void) G_GNUC_CONST;
```
"""
function g_resource_error_get_type()
    @ccall libaravis.g_resource_error_get_type()::GType
end

"""
    g_resource_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_resource_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_resource_flags_get_type()
    @ccall libaravis.g_resource_flags_get_type()::GType
end

"""
    g_resource_lookup_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_resource_lookup_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_resource_lookup_flags_get_type()
    @ccall libaravis.g_resource_lookup_flags_get_type()::GType
end

"""
    g_socket_family_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_socket_family_get_type (void) G_GNUC_CONST;
```
"""
function g_socket_family_get_type()
    @ccall libaravis.g_socket_family_get_type()::GType
end

"""
    g_socket_type_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_socket_type_get_type (void) G_GNUC_CONST;
```
"""
function g_socket_type_get_type()
    @ccall libaravis.g_socket_type_get_type()::GType
end

"""
    g_socket_msg_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_socket_msg_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_socket_msg_flags_get_type()
    @ccall libaravis.g_socket_msg_flags_get_type()::GType
end

"""
    g_socket_protocol_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_socket_protocol_get_type (void) G_GNUC_CONST;
```
"""
function g_socket_protocol_get_type()
    @ccall libaravis.g_socket_protocol_get_type()::GType
end

"""
    g_zlib_compressor_format_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_zlib_compressor_format_get_type (void) G_GNUC_CONST;
```
"""
function g_zlib_compressor_format_get_type()
    @ccall libaravis.g_zlib_compressor_format_get_type()::GType
end

"""
    g_unix_socket_address_type_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_unix_socket_address_type_get_type (void) G_GNUC_CONST;
```
"""
function g_unix_socket_address_type_get_type()
    @ccall libaravis.g_unix_socket_address_type_get_type()::GType
end

"""
    g_bus_type_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_bus_type_get_type (void) G_GNUC_CONST;
```
"""
function g_bus_type_get_type()
    @ccall libaravis.g_bus_type_get_type()::GType
end

"""
    g_bus_name_owner_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_bus_name_owner_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_bus_name_owner_flags_get_type()
    @ccall libaravis.g_bus_name_owner_flags_get_type()::GType
end

"""
    g_bus_name_watcher_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_bus_name_watcher_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_bus_name_watcher_flags_get_type()
    @ccall libaravis.g_bus_name_watcher_flags_get_type()::GType
end

"""
    g_dbus_proxy_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_proxy_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_proxy_flags_get_type()
    @ccall libaravis.g_dbus_proxy_flags_get_type()::GType
end

"""
    g_dbus_error_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_error_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_error_get_type()
    @ccall libaravis.g_dbus_error_get_type()::GType
end

"""
    g_dbus_connection_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_connection_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_connection_flags_get_type()
    @ccall libaravis.g_dbus_connection_flags_get_type()::GType
end

"""
    g_dbus_capability_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_capability_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_capability_flags_get_type()
    @ccall libaravis.g_dbus_capability_flags_get_type()::GType
end

"""
    g_dbus_call_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_call_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_call_flags_get_type()
    @ccall libaravis.g_dbus_call_flags_get_type()::GType
end

"""
    g_dbus_message_type_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_message_type_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_message_type_get_type()
    @ccall libaravis.g_dbus_message_type_get_type()::GType
end

"""
    g_dbus_message_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_message_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_message_flags_get_type()
    @ccall libaravis.g_dbus_message_flags_get_type()::GType
end

"""
    g_dbus_message_header_field_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_message_header_field_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_message_header_field_get_type()
    @ccall libaravis.g_dbus_message_header_field_get_type()::GType
end

"""
    g_dbus_property_info_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_property_info_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_property_info_flags_get_type()
    @ccall libaravis.g_dbus_property_info_flags_get_type()::GType
end

"""
    g_dbus_subtree_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_subtree_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_subtree_flags_get_type()
    @ccall libaravis.g_dbus_subtree_flags_get_type()::GType
end

"""
    g_dbus_server_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_server_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_server_flags_get_type()
    @ccall libaravis.g_dbus_server_flags_get_type()::GType
end

"""
    g_dbus_signal_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_signal_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_signal_flags_get_type()
    @ccall libaravis.g_dbus_signal_flags_get_type()::GType
end

"""
    g_dbus_send_message_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_send_message_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_send_message_flags_get_type()
    @ccall libaravis.g_dbus_send_message_flags_get_type()::GType
end

"""
    g_credentials_type_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_credentials_type_get_type (void) G_GNUC_CONST;
```
"""
function g_credentials_type_get_type()
    @ccall libaravis.g_credentials_type_get_type()::GType
end

"""
    g_dbus_message_byte_order_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_message_byte_order_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_message_byte_order_get_type()
    @ccall libaravis.g_dbus_message_byte_order_get_type()::GType
end

"""
    g_application_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_application_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_application_flags_get_type()
    @ccall libaravis.g_application_flags_get_type()::GType
end

"""
    g_tls_error_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_tls_error_get_type (void) G_GNUC_CONST;
```
"""
function g_tls_error_get_type()
    @ccall libaravis.g_tls_error_get_type()::GType
end

"""
    g_tls_certificate_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_tls_certificate_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_tls_certificate_flags_get_type()
    @ccall libaravis.g_tls_certificate_flags_get_type()::GType
end

"""
    g_tls_authentication_mode_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_tls_authentication_mode_get_type (void) G_GNUC_CONST;
```
"""
function g_tls_authentication_mode_get_type()
    @ccall libaravis.g_tls_authentication_mode_get_type()::GType
end

"""
    g_tls_channel_binding_type_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_tls_channel_binding_type_get_type (void) G_GNUC_CONST;
```
"""
function g_tls_channel_binding_type_get_type()
    @ccall libaravis.g_tls_channel_binding_type_get_type()::GType
end

"""
    g_tls_channel_binding_error_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_tls_channel_binding_error_get_type (void) G_GNUC_CONST;
```
"""
function g_tls_channel_binding_error_get_type()
    @ccall libaravis.g_tls_channel_binding_error_get_type()::GType
end

"""
    g_tls_rehandshake_mode_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_tls_rehandshake_mode_get_type (void) G_GNUC_CONST;
```
"""
function g_tls_rehandshake_mode_get_type()
    @ccall libaravis.g_tls_rehandshake_mode_get_type()::GType
end

"""
    g_tls_password_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_tls_password_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_tls_password_flags_get_type()
    @ccall libaravis.g_tls_password_flags_get_type()::GType
end

"""
    g_tls_interaction_result_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_tls_interaction_result_get_type (void) G_GNUC_CONST;
```
"""
function g_tls_interaction_result_get_type()
    @ccall libaravis.g_tls_interaction_result_get_type()::GType
end

"""
    g_dbus_interface_skeleton_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_interface_skeleton_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_interface_skeleton_flags_get_type()
    @ccall libaravis.g_dbus_interface_skeleton_flags_get_type()::GType
end

"""
    g_dbus_object_manager_client_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_dbus_object_manager_client_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_dbus_object_manager_client_flags_get_type()
    @ccall libaravis.g_dbus_object_manager_client_flags_get_type()::GType
end

"""
    g_tls_database_verify_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_tls_database_verify_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_tls_database_verify_flags_get_type()
    @ccall libaravis.g_tls_database_verify_flags_get_type()::GType
end

"""
    g_tls_database_lookup_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_tls_database_lookup_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_tls_database_lookup_flags_get_type()
    @ccall libaravis.g_tls_database_lookup_flags_get_type()::GType
end

"""
    g_tls_certificate_request_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_tls_certificate_request_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_tls_certificate_request_flags_get_type()
    @ccall libaravis.g_tls_certificate_request_flags_get_type()::GType
end

"""
    g_tls_protocol_version_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_tls_protocol_version_get_type (void) G_GNUC_CONST;
```
"""
function g_tls_protocol_version_get_type()
    @ccall libaravis.g_tls_protocol_version_get_type()::GType
end

"""
    g_io_module_scope_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_io_module_scope_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_io_module_scope_flags_get_type()
    @ccall libaravis.g_io_module_scope_flags_get_type()::GType
end

"""
    g_socket_client_event_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_socket_client_event_get_type (void) G_GNUC_CONST;
```
"""
function g_socket_client_event_get_type()
    @ccall libaravis.g_socket_client_event_get_type()::GType
end

"""
    g_socket_listener_event_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_socket_listener_event_get_type (void) G_GNUC_CONST;
```
"""
function g_socket_listener_event_get_type()
    @ccall libaravis.g_socket_listener_event_get_type()::GType
end

"""
    g_test_dbus_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_test_dbus_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_test_dbus_flags_get_type()
    @ccall libaravis.g_test_dbus_flags_get_type()::GType
end

"""
    g_subprocess_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_subprocess_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_subprocess_flags_get_type()
    @ccall libaravis.g_subprocess_flags_get_type()::GType
end

"""
    g_notification_priority_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_notification_priority_get_type (void) G_GNUC_CONST;
```
"""
function g_notification_priority_get_type()
    @ccall libaravis.g_notification_priority_get_type()::GType
end

"""
    g_network_connectivity_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_network_connectivity_get_type (void) G_GNUC_CONST;
```
"""
function g_network_connectivity_get_type()
    @ccall libaravis.g_network_connectivity_get_type()::GType
end

"""
    g_pollable_return_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_pollable_return_get_type (void) G_GNUC_CONST;
```
"""
function g_pollable_return_get_type()
    @ccall libaravis.g_pollable_return_get_type()::GType
end

"""
    g_memory_monitor_warning_level_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_memory_monitor_warning_level_get_type (void) G_GNUC_CONST;
```
"""
function g_memory_monitor_warning_level_get_type()
    @ccall libaravis.g_memory_monitor_warning_level_get_type()::GType
end

"""
    g_resolver_name_lookup_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_resolver_name_lookup_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_resolver_name_lookup_flags_get_type()
    @ccall libaravis.g_resolver_name_lookup_flags_get_type()::GType
end

"""
    g_settings_bind_flags_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_settings_bind_flags_get_type (void) G_GNUC_CONST;
```
"""
function g_settings_bind_flags_get_type()
    @ccall libaravis.g_settings_bind_flags_get_type()::GType
end

"""
    g_module_error_quark()

### Prototype
```c
GMODULE_AVAILABLE_IN_2_70 GQuark g_module_error_quark (void);
```
"""
function g_module_error_quark()
    @ccall libaravis.g_module_error_quark()::GQuark
end

"""
    g_io_module_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_io_module_get_type (void) G_GNUC_CONST;
```
"""
function g_io_module_get_type()
    @ccall libaravis.g_io_module_get_type()::GType
end

const _GIOModule = Cvoid

const GIOModule = _GIOModule

const _GIOModuleClass = Cvoid

const GIOModuleClass = _GIOModuleClass

"""
    g_list_model_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_44 G_DECLARE_INTERFACE(GListModel, g_list_model, G, LIST_MODEL, GObject);
```
"""
function g_list_model_get_type()
    @ccall libaravis.g_list_model_get_type()::GType
end

"""
    g_list_store_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_44 G_DECLARE_FINAL_TYPE(GListStore, g_list_store, G, LIST_STORE, GObject);
```
"""
function g_list_store_get_type()
    @ccall libaravis.g_list_store_get_type()::GType
end

"""
    g_loadable_icon_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_loadable_icon_get_type (void) G_GNUC_CONST;
```
"""
function g_loadable_icon_get_type()
    @ccall libaravis.g_loadable_icon_get_type()::GType
end

const _GLoadableIcon = Cvoid

const GLoadableIcon = _GLoadableIcon

"""
    _GLoadableIconIface

[`GLoadableIconIface`](@ref): \\_iface: The parent interface. : Loads an icon. \\_async: Loads an icon asynchronously. \\_finish: Finishes an asynchronous icon load.

Interface for icons that can be loaded as a stream.
"""
struct _GLoadableIconIface
    g_iface::GTypeInterface
    load::Ptr{Cvoid}
    load_async::Ptr{Cvoid}
    load_finish::Ptr{Cvoid}
end

"""
[`GLoadableIconIface`](@ref): \\_iface: The parent interface. : Loads an icon. \\_async: Loads an icon asynchronously. \\_finish: Finishes an asynchronous icon load.

Interface for icons that can be loaded as a stream.
"""
const GLoadableIconIface = _GLoadableIconIface

"""
    g_memory_input_stream_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_memory_input_stream_get_type (void) G_GNUC_CONST;
```
"""
function g_memory_input_stream_get_type()
    @ccall libaravis.g_memory_input_stream_get_type()::GType
end

const _GMemoryInputStreamPrivate = Cvoid

const GMemoryInputStreamPrivate = _GMemoryInputStreamPrivate

struct _GMemoryInputStream
    parent_instance::GInputStream
    priv::Ptr{GMemoryInputStreamPrivate}
end

const GMemoryInputStream = _GMemoryInputStream

struct _GMemoryInputStreamClass
    parent_class::GInputStreamClass
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
    _g_reserved4::Ptr{Cvoid}
    _g_reserved5::Ptr{Cvoid}
end

const GMemoryInputStreamClass = _GMemoryInputStreamClass

"""
    g_memory_monitor_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_64 G_DECLARE_INTERFACE(GMemoryMonitor, g_memory_monitor, g, memory_monitor, GObject);
```
"""
function g_memory_monitor_get_type()
    @ccall libaravis.g_memory_monitor_get_type()::GType
end

const _GMemoryMonitor = Cvoid

const GMemoryMonitor = _GMemoryMonitor

struct _GMemoryMonitorInterface
    g_iface::GTypeInterface
    low_memory_warning::Ptr{Cvoid}
end

const GMemoryMonitorInterface = _GMemoryMonitorInterface

"""
    g_memory_output_stream_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_memory_output_stream_get_type (void) G_GNUC_CONST;
```
"""
function g_memory_output_stream_get_type()
    @ccall libaravis.g_memory_output_stream_get_type()::GType
end

const _GMemoryOutputStreamPrivate = Cvoid

const GMemoryOutputStreamPrivate = _GMemoryOutputStreamPrivate

struct _GMemoryOutputStream
    parent_instance::GOutputStream
    priv::Ptr{GMemoryOutputStreamPrivate}
end

const GMemoryOutputStream = _GMemoryOutputStream

struct _GMemoryOutputStreamClass
    parent_class::GOutputStreamClass
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
    _g_reserved4::Ptr{Cvoid}
    _g_reserved5::Ptr{Cvoid}
end

const GMemoryOutputStreamClass = _GMemoryOutputStreamClass

"""
    g_menu_model_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GType g_menu_model_get_type (void) G_GNUC_CONST;
```
"""
function g_menu_model_get_type()
    @ccall libaravis.g_menu_model_get_type()::GType
end

const _GMenuModelPrivate = Cvoid

const GMenuModelPrivate = _GMenuModelPrivate

struct _GMenuModel
    parent_instance::GObject
    priv::Ptr{GMenuModelPrivate}
end

const GMenuModel = _GMenuModel

"""
    _GMenuModelClass

[`GMenuModelClass`](@ref)::get\\_item\\_attributes: : the #[`GMenuModel`](@ref) to query \\_index: The #[`GMenuItem`](@ref) to query : (out) (element-type utf8 GLib.Variant): Attributes on the item

Gets all the attributes associated with the item in the menu model.

[`GMenuModelClass`](@ref)::get\\_item\\_links: : the #[`GMenuModel`](@ref) to query \\_index: The #[`GMenuItem`](@ref) to query

```c++
: (out) (element-type utf8 Gio.MenuModel): Links from the item

 Gets all the links associated with the item in the menu model.
 

```
"""
struct _GMenuModelClass
    parent_class::GObjectClass
    is_mutable::Ptr{Cvoid}
    get_n_items::Ptr{Cvoid}
    get_item_attributes::Ptr{Cvoid}
    iterate_item_attributes::Ptr{Cvoid}
    get_item_attribute_value::Ptr{Cvoid}
    get_item_links::Ptr{Cvoid}
    iterate_item_links::Ptr{Cvoid}
    get_item_link::Ptr{Cvoid}
end

"""
[`GMenuModelClass`](@ref)::get\\_item\\_attributes: : the #[`GMenuModel`](@ref) to query \\_index: The #[`GMenuItem`](@ref) to query : (out) (element-type utf8 GLib.Variant): Attributes on the item

Gets all the attributes associated with the item in the menu model.

[`GMenuModelClass`](@ref)::get\\_item\\_links: : the #[`GMenuModel`](@ref) to query \\_index: The #[`GMenuItem`](@ref) to query

```c++
: (out) (element-type utf8 Gio.MenuModel): Links from the item

 Gets all the links associated with the item in the menu model.
 

```
"""
const GMenuModelClass = _GMenuModelClass

"""
    g_menu_attribute_iter_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GType g_menu_attribute_iter_get_type (void) G_GNUC_CONST;
```
"""
function g_menu_attribute_iter_get_type()
    @ccall libaravis.g_menu_attribute_iter_get_type()::GType
end

const _GMenuAttributeIterPrivate = Cvoid

const GMenuAttributeIterPrivate = _GMenuAttributeIterPrivate

struct _GMenuAttributeIter
    parent_instance::GObject
    priv::Ptr{GMenuAttributeIterPrivate}
end

const GMenuAttributeIter = _GMenuAttributeIter

struct _GMenuAttributeIterClass
    parent_class::GObjectClass
    get_next::Ptr{Cvoid}
end

const GMenuAttributeIterClass = _GMenuAttributeIterClass

"""
    g_menu_link_iter_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GType g_menu_link_iter_get_type (void) G_GNUC_CONST;
```
"""
function g_menu_link_iter_get_type()
    @ccall libaravis.g_menu_link_iter_get_type()::GType
end

const _GMenuLinkIterPrivate = Cvoid

const GMenuLinkIterPrivate = _GMenuLinkIterPrivate

struct _GMenuLinkIter
    parent_instance::GObject
    priv::Ptr{GMenuLinkIterPrivate}
end

const GMenuLinkIter = _GMenuLinkIter

struct _GMenuLinkIterClass
    parent_class::GObjectClass
    get_next::Ptr{Cvoid}
end

const GMenuLinkIterClass = _GMenuLinkIterClass

"""
    g_menu_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GType g_menu_get_type (void) G_GNUC_CONST;
```
"""
function g_menu_get_type()
    @ccall libaravis.g_menu_get_type()::GType
end

const _GMenu = Cvoid

const GMenu = _GMenu

"""
    g_menu_item_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GType g_menu_item_get_type (void) G_GNUC_CONST;
```
"""
function g_menu_item_get_type()
    @ccall libaravis.g_menu_item_get_type()::GType
end

const _GMenuItem = Cvoid

const GMenuItem = _GMenuItem

"""
    g_mount_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_mount_get_type (void) G_GNUC_CONST;
```
"""
function g_mount_get_type()
    @ccall libaravis.g_mount_get_type()::GType
end

const _GMount = Cvoid

const GMount = _GMount

"""
    _GMountIface

[`GMountIface`](@ref): \\_iface: The parent interface. : Changed signal that is emitted when the mount's state has changed. : The unmounted signal that is emitted when the #[`GMount`](@ref) have been unmounted. If the recipient is holding references to the object they should release them so the object can be finalized.

\\pre \\_unmount: The ::pre-unmount signal that is emitted when the #[`GMount`](@ref) will soon be emitted. If the recipient is somehow holding the mount open by keeping an open file on it it should close the file. \\_root: Gets a #[`GFile`](@ref) to the root directory of the #[`GMount`](@ref). \\_name: Gets a string containing the name of the #[`GMount`](@ref). \\_icon: Gets a #[`GIcon`](@ref) for the #[`GMount`](@ref). \\_uuid: Gets the UUID for the #[`GMount`](@ref). The reference is typically based on the file system UUID for the mount in question and should be considered an opaque string. Returns NULL if there is no UUID available. \\_volume: Gets a #[`GVolume`](@ref) the mount is located on. Returns NULL if the #[`GMount`](@ref) is not associated with a #[`GVolume`](@ref). \\_drive: Gets a #[`GDrive`](@ref) the volume of the mount is located on. Returns NULL if the #[`GMount`](@ref) is not associated with a #[`GDrive`](@ref) or a #[`GVolume`](@ref). This is convenience method for getting the #[`GVolume`](@ref) and using that to get the #[`GDrive`](@ref). \\_unmount: Checks if a #[`GMount`](@ref) can be unmounted. \\_eject: Checks if a #[`GMount`](@ref) can be ejected. : Starts unmounting a #[`GMount`](@ref). \\_finish: Finishes an unmounting operation. : Starts ejecting a #[`GMount`](@ref). \\_finish: Finishes an eject operation. : Starts remounting a #[`GMount`](@ref). \\_finish: Finishes a remounting operation. \\_content\\_type: Starts guessing the type of the content of a #[`GMount`](@ref). See [`g_mount_guess_content_type`](@ref)() for more information on content type guessing. This operation was added in 2.18. \\_content\\_type\\_finish: Finishes a content type guessing operation. Added in 2.18. \\_content\\_type\\_sync: Synchronous variant of \\_content\\_type. Added in 2.18 \\_with\\_operation: Starts unmounting a #[`GMount`](@ref) using a #[`GMountOperation`](@ref). Since 2.22. \\_with\\_operation\\_finish: Finishes an unmounting operation using a #[`GMountOperation`](@ref). Since 2.22. \\_with\\_operation: Starts ejecting a #[`GMount`](@ref) using a #[`GMountOperation`](@ref). Since 2.22. \\_with\\_operation\\_finish: Finishes an eject operation using a #[`GMountOperation`](@ref). Since 2.22. \\_default\\_location: Gets a #[`GFile`](@ref) indication a start location that can be use as the entry point for this mount. Since 2.24. \\_sort\\_key: Gets a key used for sorting #[`GMount`](@ref) instance or NULL if no such key exists. Since 2.32. \\_symbolic\\_icon: Gets a symbolic #[`GIcon`](@ref) for the #[`GMount`](@ref). Since 2.34.

Interface for implementing operations for mounts.
"""
struct _GMountIface
    g_iface::GTypeInterface
    changed::Ptr{Cvoid}
    unmounted::Ptr{Cvoid}
    get_root::Ptr{Cvoid}
    get_name::Ptr{Cvoid}
    get_icon::Ptr{Cvoid}
    get_uuid::Ptr{Cvoid}
    get_volume::Ptr{Cvoid}
    get_drive::Ptr{Cvoid}
    can_unmount::Ptr{Cvoid}
    can_eject::Ptr{Cvoid}
    unmount::Ptr{Cvoid}
    unmount_finish::Ptr{Cvoid}
    eject::Ptr{Cvoid}
    eject_finish::Ptr{Cvoid}
    remount::Ptr{Cvoid}
    remount_finish::Ptr{Cvoid}
    guess_content_type::Ptr{Cvoid}
    guess_content_type_finish::Ptr{Cvoid}
    guess_content_type_sync::Ptr{Cvoid}
    pre_unmount::Ptr{Cvoid}
    unmount_with_operation::Ptr{Cvoid}
    unmount_with_operation_finish::Ptr{Cvoid}
    eject_with_operation::Ptr{Cvoid}
    eject_with_operation_finish::Ptr{Cvoid}
    get_default_location::Ptr{Cvoid}
    get_sort_key::Ptr{Cvoid}
    get_symbolic_icon::Ptr{Cvoid}
end

"""
[`GMountIface`](@ref): \\_iface: The parent interface. : Changed signal that is emitted when the mount's state has changed. : The unmounted signal that is emitted when the #[`GMount`](@ref) have been unmounted. If the recipient is holding references to the object they should release them so the object can be finalized.

\\pre \\_unmount: The ::pre-unmount signal that is emitted when the #[`GMount`](@ref) will soon be emitted. If the recipient is somehow holding the mount open by keeping an open file on it it should close the file. \\_root: Gets a #[`GFile`](@ref) to the root directory of the #[`GMount`](@ref). \\_name: Gets a string containing the name of the #[`GMount`](@ref). \\_icon: Gets a #[`GIcon`](@ref) for the #[`GMount`](@ref). \\_uuid: Gets the UUID for the #[`GMount`](@ref). The reference is typically based on the file system UUID for the mount in question and should be considered an opaque string. Returns NULL if there is no UUID available. \\_volume: Gets a #[`GVolume`](@ref) the mount is located on. Returns NULL if the #[`GMount`](@ref) is not associated with a #[`GVolume`](@ref). \\_drive: Gets a #[`GDrive`](@ref) the volume of the mount is located on. Returns NULL if the #[`GMount`](@ref) is not associated with a #[`GDrive`](@ref) or a #[`GVolume`](@ref). This is convenience method for getting the #[`GVolume`](@ref) and using that to get the #[`GDrive`](@ref). \\_unmount: Checks if a #[`GMount`](@ref) can be unmounted. \\_eject: Checks if a #[`GMount`](@ref) can be ejected. : Starts unmounting a #[`GMount`](@ref). \\_finish: Finishes an unmounting operation. : Starts ejecting a #[`GMount`](@ref). \\_finish: Finishes an eject operation. : Starts remounting a #[`GMount`](@ref). \\_finish: Finishes a remounting operation. \\_content\\_type: Starts guessing the type of the content of a #[`GMount`](@ref). See [`g_mount_guess_content_type`](@ref)() for more information on content type guessing. This operation was added in 2.18. \\_content\\_type\\_finish: Finishes a content type guessing operation. Added in 2.18. \\_content\\_type\\_sync: Synchronous variant of \\_content\\_type. Added in 2.18 \\_with\\_operation: Starts unmounting a #[`GMount`](@ref) using a #[`GMountOperation`](@ref). Since 2.22. \\_with\\_operation\\_finish: Finishes an unmounting operation using a #[`GMountOperation`](@ref). Since 2.22. \\_with\\_operation: Starts ejecting a #[`GMount`](@ref) using a #[`GMountOperation`](@ref). Since 2.22. \\_with\\_operation\\_finish: Finishes an eject operation using a #[`GMountOperation`](@ref). Since 2.22. \\_default\\_location: Gets a #[`GFile`](@ref) indication a start location that can be use as the entry point for this mount. Since 2.24. \\_sort\\_key: Gets a key used for sorting #[`GMount`](@ref) instance or NULL if no such key exists. Since 2.32. \\_symbolic\\_icon: Gets a symbolic #[`GIcon`](@ref) for the #[`GMount`](@ref). Since 2.34.

Interface for implementing operations for mounts.
"""
const GMountIface = _GMountIface

"""
    g_mount_operation_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_mount_operation_get_type (void) G_GNUC_CONST;
```
"""
function g_mount_operation_get_type()
    @ccall libaravis.g_mount_operation_get_type()::GType
end

const _GMountOperationPrivate = Cvoid

const GMountOperationPrivate = _GMountOperationPrivate

struct _GMountOperation
    parent_instance::GObject
    priv::Ptr{GMountOperationPrivate}
end

const GMountOperation = _GMountOperation

struct _GMountOperationClass
    parent_class::GObjectClass
    ask_password::Ptr{Cvoid}
    ask_question::Ptr{Cvoid}
    reply::Ptr{Cvoid}
    aborted::Ptr{Cvoid}
    show_processes::Ptr{Cvoid}
    show_unmount_progress::Ptr{Cvoid}
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
    _g_reserved4::Ptr{Cvoid}
    _g_reserved5::Ptr{Cvoid}
    _g_reserved6::Ptr{Cvoid}
    _g_reserved7::Ptr{Cvoid}
    _g_reserved8::Ptr{Cvoid}
    _g_reserved9::Ptr{Cvoid}
end

const GMountOperationClass = _GMountOperationClass

"""
    g_native_socket_address_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_46 GType g_native_socket_address_get_type (void) G_GNUC_CONST;
```
"""
function g_native_socket_address_get_type()
    @ccall libaravis.g_native_socket_address_get_type()::GType
end

const _GNativeSocketAddressPrivate = Cvoid

const GNativeSocketAddressPrivate = _GNativeSocketAddressPrivate

struct _GNativeSocketAddress
    parent_instance::GSocketAddress
    priv::Ptr{GNativeSocketAddressPrivate}
end

const GNativeSocketAddress = _GNativeSocketAddress

struct _GNativeSocketAddressClass
    parent_class::GSocketAddressClass
end

const GNativeSocketAddressClass = _GNativeSocketAddressClass

"""
    g_volume_monitor_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_volume_monitor_get_type (void) G_GNUC_CONST;
```
"""
function g_volume_monitor_get_type()
    @ccall libaravis.g_volume_monitor_get_type()::GType
end

struct _GVolumeMonitor
    parent_instance::GObject
    priv::gpointer
end

const GVolumeMonitor = _GVolumeMonitor

struct _GVolumeMonitorClass
    parent_class::GObjectClass
    volume_added::Ptr{Cvoid}
    volume_removed::Ptr{Cvoid}
    volume_changed::Ptr{Cvoid}
    mount_added::Ptr{Cvoid}
    mount_removed::Ptr{Cvoid}
    mount_pre_unmount::Ptr{Cvoid}
    mount_changed::Ptr{Cvoid}
    drive_connected::Ptr{Cvoid}
    drive_disconnected::Ptr{Cvoid}
    drive_changed::Ptr{Cvoid}
    is_supported::Ptr{Cvoid}
    get_connected_drives::Ptr{Cvoid}
    get_volumes::Ptr{Cvoid}
    get_mounts::Ptr{Cvoid}
    get_volume_for_uuid::Ptr{Cvoid}
    get_mount_for_uuid::Ptr{Cvoid}
    adopt_orphan_mount::Ptr{Cvoid}
    drive_eject_button::Ptr{Cvoid}
    drive_stop_button::Ptr{Cvoid}
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
    _g_reserved4::Ptr{Cvoid}
    _g_reserved5::Ptr{Cvoid}
    _g_reserved6::Ptr{Cvoid}
end

const GVolumeMonitorClass = _GVolumeMonitorClass

"""
    g_native_volume_monitor_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_native_volume_monitor_get_type (void) G_GNUC_CONST;
```
"""
function g_native_volume_monitor_get_type()
    @ccall libaravis.g_native_volume_monitor_get_type()::GType
end

struct _GNativeVolumeMonitor
    parent_instance::GVolumeMonitor
end

const GNativeVolumeMonitor = _GNativeVolumeMonitor

struct _GNativeVolumeMonitorClass
    parent_class::GVolumeMonitorClass
    get_mount_for_mount_path::Ptr{Cvoid}
end

const GNativeVolumeMonitorClass = _GNativeVolumeMonitorClass

"""
    g_network_address_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_network_address_get_type (void) G_GNUC_CONST;
```
"""
function g_network_address_get_type()
    @ccall libaravis.g_network_address_get_type()::GType
end

const _GNetworkAddressPrivate = Cvoid

const GNetworkAddressPrivate = _GNetworkAddressPrivate

struct _GNetworkAddress
    parent_instance::GObject
    priv::Ptr{GNetworkAddressPrivate}
end

const GNetworkAddress = _GNetworkAddress

struct _GNetworkAddressClass
    parent_class::GObjectClass
end

const GNetworkAddressClass = _GNetworkAddressClass

"""
    g_network_monitor_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GType g_network_monitor_get_type (void) G_GNUC_CONST;
```
"""
function g_network_monitor_get_type()
    @ccall libaravis.g_network_monitor_get_type()::GType
end

const _GNetworkMonitor = Cvoid

const GNetworkMonitor = _GNetworkMonitor

struct _GNetworkMonitorInterface
    g_iface::GTypeInterface
    network_changed::Ptr{Cvoid}
    can_reach::Ptr{Cvoid}
    can_reach_async::Ptr{Cvoid}
    can_reach_finish::Ptr{Cvoid}
end

const GNetworkMonitorInterface = _GNetworkMonitorInterface

"""
    g_network_service_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_network_service_get_type (void) G_GNUC_CONST;
```
"""
function g_network_service_get_type()
    @ccall libaravis.g_network_service_get_type()::GType
end

const _GNetworkServicePrivate = Cvoid

const GNetworkServicePrivate = _GNetworkServicePrivate

struct _GNetworkService
    parent_instance::GObject
    priv::Ptr{GNetworkServicePrivate}
end

const GNetworkService = _GNetworkService

struct _GNetworkServiceClass
    parent_class::GObjectClass
end

const GNetworkServiceClass = _GNetworkServiceClass

"""
    g_notification_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_40 GType g_notification_get_type (void) G_GNUC_CONST;
```
"""
function g_notification_get_type()
    @ccall libaravis.g_notification_get_type()::GType
end

const _GNotification = Cvoid

const GNotification = _GNotification

"""
    g_permission_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_permission_get_type (void);
```
"""
function g_permission_get_type()
    @ccall libaravis.g_permission_get_type()::GType
end

const _GPermissionPrivate = Cvoid

const GPermissionPrivate = _GPermissionPrivate

struct _GPermission
    parent_instance::GObject
    priv::Ptr{GPermissionPrivate}
end

const GPermission = _GPermission

struct _GPermissionClass
    parent_class::GObjectClass
    acquire::Ptr{Cvoid}
    acquire_async::Ptr{Cvoid}
    acquire_finish::Ptr{Cvoid}
    release::Ptr{Cvoid}
    release_async::Ptr{Cvoid}
    release_finish::Ptr{Cvoid}
    reserved::NTuple{16, gpointer}
end

const GPermissionClass = _GPermissionClass

"""
    g_pollable_input_stream_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_pollable_input_stream_get_type (void) G_GNUC_CONST;
```
"""
function g_pollable_input_stream_get_type()
    @ccall libaravis.g_pollable_input_stream_get_type()::GType
end

const _GPollableInputStream = Cvoid

const GPollableInputStream = _GPollableInputStream

"""
    _GPollableInputStreamInterface

[`GPollableInputStreamInterface`](@ref): \\_iface: The parent interface. \\_poll: Checks if the #[`GPollableInputStream`](@ref) instance is actually pollable

`_readable: Checks if the stream is readable`

\\_source: Creates a #[`GSource`](@ref) to poll the stream \\_nonblocking: Does a non-blocking read or returns G\\_IO\\_ERROR\\_WOULD\\_BLOCK

The interface for pollable input streams.

The default implementation of \\_poll always returns TRUE.

The default implementation of \\_nonblocking calls [`g_pollable_input_stream_is_readable`](@ref)(), and then calls [`g_input_stream_read`](@ref)() if it returns TRUE. This means you only need to override it if it is possible that your

`_readable`

implementation may return TRUE when the stream is not actually readable.

Since: 2.28
"""
struct _GPollableInputStreamInterface
    g_iface::GTypeInterface
    can_poll::Ptr{Cvoid}
    is_readable::Ptr{Cvoid}
    create_source::Ptr{Cvoid}
    read_nonblocking::Ptr{Cvoid}
end

"""
[`GPollableInputStreamInterface`](@ref): \\_iface: The parent interface. \\_poll: Checks if the #[`GPollableInputStream`](@ref) instance is actually pollable

`_readable: Checks if the stream is readable`

\\_source: Creates a #[`GSource`](@ref) to poll the stream \\_nonblocking: Does a non-blocking read or returns G\\_IO\\_ERROR\\_WOULD\\_BLOCK

The interface for pollable input streams.

The default implementation of \\_poll always returns TRUE.

The default implementation of \\_nonblocking calls [`g_pollable_input_stream_is_readable`](@ref)(), and then calls [`g_input_stream_read`](@ref)() if it returns TRUE. This means you only need to override it if it is possible that your

`_readable`

implementation may return TRUE when the stream is not actually readable.

Since: 2.28
"""
const GPollableInputStreamInterface = _GPollableInputStreamInterface

"""
    g_pollable_output_stream_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_pollable_output_stream_get_type (void) G_GNUC_CONST;
```
"""
function g_pollable_output_stream_get_type()
    @ccall libaravis.g_pollable_output_stream_get_type()::GType
end

const _GPollableOutputStream = Cvoid

const GPollableOutputStream = _GPollableOutputStream

"""
    _GPollableOutputStreamInterface

[`GPollableOutputStreamInterface`](@ref): \\_iface: The parent interface. \\_poll: Checks if the #[`GPollableOutputStream`](@ref) instance is actually pollable

`_writable: Checks if the stream is writable`

\\_source: Creates a #[`GSource`](@ref) to poll the stream \\_nonblocking: Does a non-blocking write or returns G\\_IO\\_ERROR\\_WOULD\\_BLOCK \\_nonblocking: Does a vectored non-blocking write, or returns G\\_POLLABLE\\_RETURN\\_WOULD\\_BLOCK

The interface for pollable output streams.

The default implementation of \\_poll always returns TRUE.

The default implementation of \\_nonblocking calls [`g_pollable_output_stream_is_writable`](@ref)(), and then calls [`g_output_stream_write`](@ref)() if it returns TRUE. This means you only need to override it if it is possible that your

`_writable`

implementation may return TRUE when the stream is not actually writable.

The default implementation of \\_nonblocking calls [`g_pollable_output_stream_write_nonblocking`](@ref)() for each vector, and converts its return value and error (if set) to a #[`GPollableReturn`](@ref). You should override this where possible to avoid having to allocate a #[`GError`](@ref) to return G\\_IO\\_ERROR\\_WOULD\\_BLOCK.

Since: 2.28
"""
struct _GPollableOutputStreamInterface
    g_iface::GTypeInterface
    can_poll::Ptr{Cvoid}
    is_writable::Ptr{Cvoid}
    create_source::Ptr{Cvoid}
    write_nonblocking::Ptr{Cvoid}
    writev_nonblocking::Ptr{Cvoid}
end

"""
[`GPollableOutputStreamInterface`](@ref): \\_iface: The parent interface. \\_poll: Checks if the #[`GPollableOutputStream`](@ref) instance is actually pollable

`_writable: Checks if the stream is writable`

\\_source: Creates a #[`GSource`](@ref) to poll the stream \\_nonblocking: Does a non-blocking write or returns G\\_IO\\_ERROR\\_WOULD\\_BLOCK \\_nonblocking: Does a vectored non-blocking write, or returns G\\_POLLABLE\\_RETURN\\_WOULD\\_BLOCK

The interface for pollable output streams.

The default implementation of \\_poll always returns TRUE.

The default implementation of \\_nonblocking calls [`g_pollable_output_stream_is_writable`](@ref)(), and then calls [`g_output_stream_write`](@ref)() if it returns TRUE. This means you only need to override it if it is possible that your

`_writable`

implementation may return TRUE when the stream is not actually writable.

The default implementation of \\_nonblocking calls [`g_pollable_output_stream_write_nonblocking`](@ref)() for each vector, and converts its return value and error (if set) to a #[`GPollableReturn`](@ref). You should override this where possible to avoid having to allocate a #[`GError`](@ref) to return G\\_IO\\_ERROR\\_WOULD\\_BLOCK.

Since: 2.28
"""
const GPollableOutputStreamInterface = _GPollableOutputStreamInterface

"""
    g_power_profile_monitor_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_70 G_DECLARE_INTERFACE (GPowerProfileMonitor, g_power_profile_monitor, g, power_profile_monitor, GObject);
```
"""
function g_power_profile_monitor_get_type()
    @ccall libaravis.g_power_profile_monitor_get_type()::GType
end

const _GPowerProfileMonitor = Cvoid

const GPowerProfileMonitor = _GPowerProfileMonitor

struct _GPowerProfileMonitorInterface
    g_iface::GTypeInterface
end

const GPowerProfileMonitorInterface = _GPowerProfileMonitorInterface

"""
    g_property_action_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_38 GType g_property_action_get_type (void) G_GNUC_CONST;
```
"""
function g_property_action_get_type()
    @ccall libaravis.g_property_action_get_type()::GType
end

const _GPropertyAction = Cvoid

const GPropertyAction = _GPropertyAction

"""
    g_proxy_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_proxy_get_type (void) G_GNUC_CONST;
```
"""
function g_proxy_get_type()
    @ccall libaravis.g_proxy_get_type()::GType
end

const _GProxy = Cvoid

const GProxy = _GProxy

"""
    _GProxyInterface

[`GProxyInterface`](@ref): \\_iface: The parent interface. : Connect to proxy server and wrap (if required) the #connection to handle payload. \\_async: Same as connect() but asynchronous. \\_finish: Returns the result of connect\\_async() \\_hostname: Returns whether the proxy supports hostname lookups.

Provides an interface for handling proxy connection and payload.

Since: 2.26
"""
struct _GProxyInterface
    g_iface::GTypeInterface
    connect::Ptr{Cvoid}
    connect_async::Ptr{Cvoid}
    connect_finish::Ptr{Cvoid}
    supports_hostname::Ptr{Cvoid}
end

"""
[`GProxyInterface`](@ref): \\_iface: The parent interface. : Connect to proxy server and wrap (if required) the #connection to handle payload. \\_async: Same as connect() but asynchronous. \\_finish: Returns the result of connect\\_async() \\_hostname: Returns whether the proxy supports hostname lookups.

Provides an interface for handling proxy connection and payload.

Since: 2.26
"""
const GProxyInterface = _GProxyInterface

"""
    g_proxy_address_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_proxy_address_get_type (void) G_GNUC_CONST;
```
"""
function g_proxy_address_get_type()
    @ccall libaravis.g_proxy_address_get_type()::GType
end

const _GProxyAddressPrivate = Cvoid

const GProxyAddressPrivate = _GProxyAddressPrivate

struct _GProxyAddress
    parent_instance::GInetSocketAddress
    priv::Ptr{GProxyAddressPrivate}
end

const GProxyAddress = _GProxyAddress

struct _GProxyAddressClass
    parent_class::GInetSocketAddressClass
end

const GProxyAddressClass = _GProxyAddressClass

"""
    g_socket_address_enumerator_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_socket_address_enumerator_get_type (void) G_GNUC_CONST;
```
"""
function g_socket_address_enumerator_get_type()
    @ccall libaravis.g_socket_address_enumerator_get_type()::GType
end

struct _GSocketAddressEnumerator
    parent_instance::GObject
end

const GSocketAddressEnumerator = _GSocketAddressEnumerator

"""
    _GSocketAddressEnumeratorClass

[`GSocketAddressEnumeratorClass`](@ref): : Virtual method for [`g_socket_address_enumerator_next`](@ref)(). \\_async: Virtual method for [`g_socket_address_enumerator_next_async`](@ref)(). \\_finish: Virtual method for [`g_socket_address_enumerator_next_finish`](@ref)().

Class structure for #[`GSocketAddressEnumerator`](@ref).
"""
struct _GSocketAddressEnumeratorClass
    parent_class::GObjectClass
    next::Ptr{Cvoid}
    next_async::Ptr{Cvoid}
    next_finish::Ptr{Cvoid}
end

"""
[`GSocketAddressEnumeratorClass`](@ref): : Virtual method for [`g_socket_address_enumerator_next`](@ref)(). \\_async: Virtual method for [`g_socket_address_enumerator_next_async`](@ref)(). \\_finish: Virtual method for [`g_socket_address_enumerator_next_finish`](@ref)().

Class structure for #[`GSocketAddressEnumerator`](@ref).
"""
const GSocketAddressEnumeratorClass = _GSocketAddressEnumeratorClass

"""
    g_proxy_address_enumerator_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_proxy_address_enumerator_get_type (void) G_GNUC_CONST;
```
"""
function g_proxy_address_enumerator_get_type()
    @ccall libaravis.g_proxy_address_enumerator_get_type()::GType
end

const _GProxyAddressEnumeratorPrivate = Cvoid

const GProxyAddressEnumeratorPrivate = _GProxyAddressEnumeratorPrivate

struct _GProxyAddressEnumerator
    parent_instance::GSocketAddressEnumerator
    priv::Ptr{GProxyAddressEnumeratorPrivate}
end

const GProxyAddressEnumerator = _GProxyAddressEnumerator

"""
    _GProxyAddressEnumeratorClass

[`GProxyAddressEnumeratorClass`](@ref):

Class structure for #[`GProxyAddressEnumerator`](@ref).
"""
struct _GProxyAddressEnumeratorClass
    parent_class::GSocketAddressEnumeratorClass
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
    _g_reserved4::Ptr{Cvoid}
    _g_reserved5::Ptr{Cvoid}
    _g_reserved6::Ptr{Cvoid}
    _g_reserved7::Ptr{Cvoid}
end

"""
[`GProxyAddressEnumeratorClass`](@ref):

Class structure for #[`GProxyAddressEnumerator`](@ref).
"""
const GProxyAddressEnumeratorClass = _GProxyAddressEnumeratorClass

"""
    g_proxy_resolver_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_proxy_resolver_get_type (void) G_GNUC_CONST;
```
"""
function g_proxy_resolver_get_type()
    @ccall libaravis.g_proxy_resolver_get_type()::GType
end

const _GProxyResolver = Cvoid

const GProxyResolver = _GProxyResolver

struct _GProxyResolverInterface
    g_iface::GTypeInterface
    is_supported::Ptr{Cvoid}
    lookup::Ptr{Cvoid}
    lookup_async::Ptr{Cvoid}
    lookup_finish::Ptr{Cvoid}
end

const GProxyResolverInterface = _GProxyResolverInterface

"""
    g_remote_action_group_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GType g_remote_action_group_get_type (void) G_GNUC_CONST;
```
"""
function g_remote_action_group_get_type()
    @ccall libaravis.g_remote_action_group_get_type()::GType
end

const _GRemoteActionGroup = Cvoid

const GRemoteActionGroup = _GRemoteActionGroup

struct _GRemoteActionGroupInterface
    g_iface::GTypeInterface
    activate_action_full::Ptr{Cvoid}
    change_action_state_full::Ptr{Cvoid}
end

const GRemoteActionGroupInterface = _GRemoteActionGroupInterface

"""
    g_resolver_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_resolver_get_type (void) G_GNUC_CONST;
```
"""
function g_resolver_get_type()
    @ccall libaravis.g_resolver_get_type()::GType
end

const _GResolverPrivate = Cvoid

const GResolverPrivate = _GResolverPrivate

struct _GResolver
    parent_instance::GObject
    priv::Ptr{GResolverPrivate}
end

const GResolver = _GResolver

struct _GResolverClass
    parent_class::GObjectClass
    reload::Ptr{Cvoid}
    lookup_by_name::Ptr{Cvoid}
    lookup_by_name_async::Ptr{Cvoid}
    lookup_by_name_finish::Ptr{Cvoid}
    lookup_by_address::Ptr{Cvoid}
    lookup_by_address_async::Ptr{Cvoid}
    lookup_by_address_finish::Ptr{Cvoid}
    lookup_service::Ptr{Cvoid}
    lookup_service_async::Ptr{Cvoid}
    lookup_service_finish::Ptr{Cvoid}
    lookup_records::Ptr{Cvoid}
    lookup_records_async::Ptr{Cvoid}
    lookup_records_finish::Ptr{Cvoid}
    lookup_by_name_with_flags_async::Ptr{Cvoid}
    lookup_by_name_with_flags_finish::Ptr{Cvoid}
    lookup_by_name_with_flags::Ptr{Cvoid}
end

const GResolverClass = _GResolverClass

"""
    g_resolver_error_quark()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GQuark g_resolver_error_quark (void);
```
"""
function g_resolver_error_quark()
    @ccall libaravis.g_resolver_error_quark()::GQuark
end

"""
    g_resource_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GType g_resource_get_type (void) G_GNUC_CONST;
```
"""
function g_resource_get_type()
    @ccall libaravis.g_resource_get_type()::GType
end

"""
    g_resource_error_quark()

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GQuark g_resource_error_quark (void);
```
"""
function g_resource_error_quark()
    @ccall libaravis.g_resource_error_quark()::GQuark
end

"""
    g_seekable_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_seekable_get_type (void) G_GNUC_CONST;
```
"""
function g_seekable_get_type()
    @ccall libaravis.g_seekable_get_type()::GType
end

const _GSeekable = Cvoid

const GSeekable = _GSeekable

"""
    _GSeekableIface

[`GSeekableIface`](@ref): \\_iface: The parent interface. : Tells the current location within a stream. \\_seek: Checks if seeking is supported by the stream.

Provides an interface for implementing seekable functionality on I/O Streams.

# See also
: Seeks to a location within a stream. \\_truncate: Checks if truncation is supported by the stream. \\_fn: Truncates a stream.
"""
struct _GSeekableIface
    g_iface::GTypeInterface
    tell::Ptr{Cvoid}
    can_seek::Ptr{Cvoid}
    seek::Ptr{Cvoid}
    can_truncate::Ptr{Cvoid}
    truncate_fn::Ptr{Cvoid}
end

"""
[`GSeekableIface`](@ref): \\_iface: The parent interface. : Tells the current location within a stream. \\_seek: Checks if seeking is supported by the stream.

Provides an interface for implementing seekable functionality on I/O Streams.

# See also
: Seeks to a location within a stream. \\_truncate: Checks if truncation is supported by the stream. \\_fn: Truncates a stream.
"""
const GSeekableIface = _GSeekableIface

"""
    g_settings_schema_source_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GType g_settings_schema_source_get_type (void) G_GNUC_CONST;
```
"""
function g_settings_schema_source_get_type()
    @ccall libaravis.g_settings_schema_source_get_type()::GType
end

"""
    g_settings_schema_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GType g_settings_schema_get_type (void) G_GNUC_CONST;
```
"""
function g_settings_schema_get_type()
    @ccall libaravis.g_settings_schema_get_type()::GType
end

"""
    g_settings_schema_key_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_40 GType g_settings_schema_key_get_type (void) G_GNUC_CONST;
```
"""
function g_settings_schema_key_get_type()
    @ccall libaravis.g_settings_schema_key_get_type()::GType
end

"""
    g_settings_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_settings_get_type (void);
```
"""
function g_settings_get_type()
    @ccall libaravis.g_settings_get_type()::GType
end

const _GSettingsPrivate = Cvoid

const GSettingsPrivate = _GSettingsPrivate

struct _GSettings
    parent_instance::GObject
    priv::Ptr{GSettingsPrivate}
end

const GSettings = _GSettings

struct _GSettingsClass
    parent_class::GObjectClass
    writable_changed::Ptr{Cvoid}
    changed::Ptr{Cvoid}
    writable_change_event::Ptr{Cvoid}
    change_event::Ptr{Cvoid}
    padding::NTuple{20, gpointer}
end

const GSettingsClass = _GSettingsClass

"""
    g_simple_action_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_simple_action_get_type (void) G_GNUC_CONST;
```
"""
function g_simple_action_get_type()
    @ccall libaravis.g_simple_action_get_type()::GType
end

const _GSimpleAction = Cvoid

const GSimpleAction = _GSimpleAction

"""
    g_simple_action_group_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_simple_action_group_get_type (void) G_GNUC_CONST;
```
"""
function g_simple_action_group_get_type()
    @ccall libaravis.g_simple_action_group_get_type()::GType
end

const _GSimpleActionGroupPrivate = Cvoid

const GSimpleActionGroupPrivate = _GSimpleActionGroupPrivate

struct _GSimpleActionGroup
    parent_instance::GObject
    priv::Ptr{GSimpleActionGroupPrivate}
end

const GSimpleActionGroup = _GSimpleActionGroup

struct _GSimpleActionGroupClass
    parent_class::GObjectClass
    padding::NTuple{12, gpointer}
end

const GSimpleActionGroupClass = _GSimpleActionGroupClass

"""
    g_simple_async_result_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_simple_async_result_get_type (void) G_GNUC_CONST;
```
"""
function g_simple_async_result_get_type()
    @ccall libaravis.g_simple_async_result_get_type()::GType
end

const _GSimpleAsyncResult = Cvoid

const GSimpleAsyncResult = _GSimpleAsyncResult

const _GSimpleAsyncResultClass = Cvoid

const GSimpleAsyncResultClass = _GSimpleAsyncResultClass

"""
    g_simple_io_stream_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_44 GType g_simple_io_stream_get_type (void) G_GNUC_CONST;
```
"""
function g_simple_io_stream_get_type()
    @ccall libaravis.g_simple_io_stream_get_type()::GType
end

const _GSimpleIOStream = Cvoid

const GSimpleIOStream = _GSimpleIOStream

"""
    g_simple_permission_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_simple_permission_get_type (void);
```
"""
function g_simple_permission_get_type()
    @ccall libaravis.g_simple_permission_get_type()::GType
end

const _GSimplePermission = Cvoid

const GSimplePermission = _GSimplePermission

"""
    g_simple_proxy_resolver_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_36 GType g_simple_proxy_resolver_get_type (void) G_GNUC_CONST;
```
"""
function g_simple_proxy_resolver_get_type()
    @ccall libaravis.g_simple_proxy_resolver_get_type()::GType
end

const _GSimpleProxyResolverPrivate = Cvoid

const GSimpleProxyResolverPrivate = _GSimpleProxyResolverPrivate

struct _GSimpleProxyResolver
    parent_instance::GObject
    priv::Ptr{GSimpleProxyResolverPrivate}
end

const GSimpleProxyResolver = _GSimpleProxyResolver

struct _GSimpleProxyResolverClass
    parent_class::GObjectClass
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
    _g_reserved4::Ptr{Cvoid}
    _g_reserved5::Ptr{Cvoid}
end

const GSimpleProxyResolverClass = _GSimpleProxyResolverClass

"""
    g_socket_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_socket_get_type (void) G_GNUC_CONST;
```
"""
function g_socket_get_type()
    @ccall libaravis.g_socket_get_type()::GType
end

const _GSocketPrivate = Cvoid

const GSocketPrivate = _GSocketPrivate

struct _GSocket
    parent_instance::GObject
    priv::Ptr{GSocketPrivate}
end

const GSocket = _GSocket

struct _GSocketClass
    parent_class::GObjectClass
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
    _g_reserved4::Ptr{Cvoid}
    _g_reserved5::Ptr{Cvoid}
    _g_reserved6::Ptr{Cvoid}
    _g_reserved7::Ptr{Cvoid}
    _g_reserved8::Ptr{Cvoid}
    _g_reserved9::Ptr{Cvoid}
    _g_reserved10::Ptr{Cvoid}
end

const GSocketClass = _GSocketClass

"""
    g_socket_client_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_socket_client_get_type (void) G_GNUC_CONST;
```
"""
function g_socket_client_get_type()
    @ccall libaravis.g_socket_client_get_type()::GType
end

const _GSocketClientPrivate = Cvoid

const GSocketClientPrivate = _GSocketClientPrivate

struct _GSocketClient
    parent_instance::GObject
    priv::Ptr{GSocketClientPrivate}
end

const GSocketClient = _GSocketClient

struct _GSocketClientClass
    parent_class::GObjectClass
    event::Ptr{Cvoid}
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
    _g_reserved4::Ptr{Cvoid}
end

const GSocketClientClass = _GSocketClientClass

"""
    g_socket_connectable_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_socket_connectable_get_type (void) G_GNUC_CONST;
```
"""
function g_socket_connectable_get_type()
    @ccall libaravis.g_socket_connectable_get_type()::GType
end

const _GSocketConnectable = Cvoid

const GSocketConnectable = _GSocketConnectable

"""
    _GSocketConnectableIface

[`GSocketConnectableIface`](@ref): \\_iface: The parent interface. : Creates a #[`GSocketAddressEnumerator`](@ref) \\_enumerate: Creates a #[`GProxyAddressEnumerator`](@ref) \\_string: Format the connectables address as a string for debugging. Implementing this is optional. (Since: 2.48)

Provides an interface for returning a #[`GSocketAddressEnumerator`](@ref) and #[`GProxyAddressEnumerator`](@ref)
"""
struct _GSocketConnectableIface
    g_iface::GTypeInterface
    enumerate::Ptr{Cvoid}
    proxy_enumerate::Ptr{Cvoid}
    to_string::Ptr{Cvoid}
end

"""
[`GSocketConnectableIface`](@ref): \\_iface: The parent interface. : Creates a #[`GSocketAddressEnumerator`](@ref) \\_enumerate: Creates a #[`GProxyAddressEnumerator`](@ref) \\_string: Format the connectables address as a string for debugging. Implementing this is optional. (Since: 2.48)

Provides an interface for returning a #[`GSocketAddressEnumerator`](@ref) and #[`GProxyAddressEnumerator`](@ref)
"""
const GSocketConnectableIface = _GSocketConnectableIface

"""
    g_socket_connection_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_socket_connection_get_type (void) G_GNUC_CONST;
```
"""
function g_socket_connection_get_type()
    @ccall libaravis.g_socket_connection_get_type()::GType
end

const _GSocketConnectionPrivate = Cvoid

const GSocketConnectionPrivate = _GSocketConnectionPrivate

struct _GSocketConnection
    parent_instance::GIOStream
    priv::Ptr{GSocketConnectionPrivate}
end

const GSocketConnection = _GSocketConnection

struct _GSocketConnectionClass
    parent_class::GIOStreamClass
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
    _g_reserved4::Ptr{Cvoid}
    _g_reserved5::Ptr{Cvoid}
    _g_reserved6::Ptr{Cvoid}
end

const GSocketConnectionClass = _GSocketConnectionClass

"""
    g_socket_control_message_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_socket_control_message_get_type (void) G_GNUC_CONST;
```
"""
function g_socket_control_message_get_type()
    @ccall libaravis.g_socket_control_message_get_type()::GType
end

const _GSocketControlMessagePrivate = Cvoid

const GSocketControlMessagePrivate = _GSocketControlMessagePrivate

struct _GSocketControlMessage
    parent_instance::GObject
    priv::Ptr{GSocketControlMessagePrivate}
end

const GSocketControlMessage = _GSocketControlMessage

"""
    _GSocketControlMessageClass

[`GSocketControlMessageClass`](@ref): \\_size: gets the size of the message. \\_level: gets the protocol of the message. \\_type: gets the protocol specific type of the message. : Writes out the message data. : Tries to deserialize a message.

Class structure for #[`GSocketControlMessage`](@ref).
"""
struct _GSocketControlMessageClass
    parent_class::GObjectClass
    get_size::Ptr{Cvoid}
    get_level::Ptr{Cvoid}
    get_type::Ptr{Cvoid}
    serialize::Ptr{Cvoid}
    deserialize::Ptr{Cvoid}
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
    _g_reserved4::Ptr{Cvoid}
    _g_reserved5::Ptr{Cvoid}
end

"""
[`GSocketControlMessageClass`](@ref): \\_size: gets the size of the message. \\_level: gets the protocol of the message. \\_type: gets the protocol specific type of the message. : Writes out the message data. : Tries to deserialize a message.

Class structure for #[`GSocketControlMessage`](@ref).
"""
const GSocketControlMessageClass = _GSocketControlMessageClass

"""
    g_socket_listener_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_socket_listener_get_type (void) G_GNUC_CONST;
```
"""
function g_socket_listener_get_type()
    @ccall libaravis.g_socket_listener_get_type()::GType
end

const _GSocketListenerPrivate = Cvoid

const GSocketListenerPrivate = _GSocketListenerPrivate

struct _GSocketListener
    parent_instance::GObject
    priv::Ptr{GSocketListenerPrivate}
end

const GSocketListener = _GSocketListener

"""
    _GSocketListenerClass

[`GSocketListenerClass`](@ref): : virtual method called when the set of socket listened to changes

Class structure for #[`GSocketListener`](@ref).
"""
struct _GSocketListenerClass
    parent_class::GObjectClass
    changed::Ptr{Cvoid}
    event::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
    _g_reserved4::Ptr{Cvoid}
    _g_reserved5::Ptr{Cvoid}
    _g_reserved6::Ptr{Cvoid}
end

"""
[`GSocketListenerClass`](@ref): : virtual method called when the set of socket listened to changes

Class structure for #[`GSocketListener`](@ref).
"""
const GSocketListenerClass = _GSocketListenerClass

"""
    g_socket_service_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_socket_service_get_type (void);
```
"""
function g_socket_service_get_type()
    @ccall libaravis.g_socket_service_get_type()::GType
end

const _GSocketServicePrivate = Cvoid

const GSocketServicePrivate = _GSocketServicePrivate

struct _GSocketService
    parent_instance::GSocketListener
    priv::Ptr{GSocketServicePrivate}
end

const GSocketService = _GSocketService

"""
    _GSocketServiceClass

[`GSocketServiceClass`](@ref): : signal emitted when new connections are accepted

Class structure for #[`GSocketService`](@ref).
"""
struct _GSocketServiceClass
    parent_class::GSocketListenerClass
    incoming::Ptr{Cvoid}
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
    _g_reserved4::Ptr{Cvoid}
    _g_reserved5::Ptr{Cvoid}
    _g_reserved6::Ptr{Cvoid}
end

"""
[`GSocketServiceClass`](@ref): : signal emitted when new connections are accepted

Class structure for #[`GSocketService`](@ref).
"""
const GSocketServiceClass = _GSocketServiceClass

"""
    g_srv_target_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_srv_target_get_type (void) G_GNUC_CONST;
```
"""
function g_srv_target_get_type()
    @ccall libaravis.g_srv_target_get_type()::GType
end

"""
    g_subprocess_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_40 GType g_subprocess_get_type (void) G_GNUC_CONST;
```
"""
function g_subprocess_get_type()
    @ccall libaravis.g_subprocess_get_type()::GType
end

const _GSubprocess = Cvoid

const GSubprocess = _GSubprocess

"""
    g_subprocess_launcher_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_40 GType g_subprocess_launcher_get_type (void) G_GNUC_CONST;
```
"""
function g_subprocess_launcher_get_type()
    @ccall libaravis.g_subprocess_launcher_get_type()::GType
end

const _GSubprocessLauncher = Cvoid

const GSubprocessLauncher = _GSubprocessLauncher

"""
    g_task_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_36 GType g_task_get_type (void) G_GNUC_CONST;
```
"""
function g_task_get_type()
    @ccall libaravis.g_task_get_type()::GType
end

const _GTask = Cvoid

const GTask = _GTask

const _GTaskClass = Cvoid

const GTaskClass = _GTaskClass

"""
    g_task_get_name(task)

### Prototype
```c
GIO_AVAILABLE_IN_2_60 const gchar *g_task_get_name (GTask *task);
```
"""
function g_task_get_name(task)
    @ccall libaravis.g_task_get_name(task::Ptr{GTask})::Ptr{gchar}
end

"""
    g_task_set_static_name(task, name)

### Prototype
```c
GIO_AVAILABLE_IN_2_76 void g_task_set_static_name (GTask *task, const gchar *name);
```
"""
function g_task_set_static_name(task, name)
    @ccall libaravis.g_task_set_static_name(task::Ptr{GTask}, name::Ptr{gchar})::Cvoid
end

"""
    g_tcp_connection_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_tcp_connection_get_type (void) G_GNUC_CONST;
```
"""
function g_tcp_connection_get_type()
    @ccall libaravis.g_tcp_connection_get_type()::GType
end

const _GTcpConnectionPrivate = Cvoid

const GTcpConnectionPrivate = _GTcpConnectionPrivate

struct _GTcpConnection
    parent_instance::GSocketConnection
    priv::Ptr{GTcpConnectionPrivate}
end

const GTcpConnection = _GTcpConnection

struct _GTcpConnectionClass
    parent_class::GSocketConnectionClass
end

const GTcpConnectionClass = _GTcpConnectionClass

"""
    g_tcp_wrapper_connection_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_tcp_wrapper_connection_get_type (void) G_GNUC_CONST;
```
"""
function g_tcp_wrapper_connection_get_type()
    @ccall libaravis.g_tcp_wrapper_connection_get_type()::GType
end

const _GTcpWrapperConnectionPrivate = Cvoid

const GTcpWrapperConnectionPrivate = _GTcpWrapperConnectionPrivate

struct _GTcpWrapperConnection
    parent_instance::GTcpConnection
    priv::Ptr{GTcpWrapperConnectionPrivate}
end

const GTcpWrapperConnection = _GTcpWrapperConnection

struct _GTcpWrapperConnectionClass
    parent_class::GTcpConnectionClass
end

const GTcpWrapperConnectionClass = _GTcpWrapperConnectionClass

"""
    g_test_dbus_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_2_34 GType g_test_dbus_get_type (void) G_GNUC_CONST;
```
"""
function g_test_dbus_get_type()
    @ccall libaravis.g_test_dbus_get_type()::GType
end

const _GTestDBus = Cvoid

const GTestDBus = _GTestDBus

"""
    g_themed_icon_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_themed_icon_get_type (void) G_GNUC_CONST;
```
"""
function g_themed_icon_get_type()
    @ccall libaravis.g_themed_icon_get_type()::GType
end

const _GThemedIcon = Cvoid

const GThemedIcon = _GThemedIcon

const _GThemedIconClass = Cvoid

const GThemedIconClass = _GThemedIconClass

"""
    g_threaded_socket_service_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_threaded_socket_service_get_type (void);
```
"""
function g_threaded_socket_service_get_type()
    @ccall libaravis.g_threaded_socket_service_get_type()::GType
end

const _GThreadedSocketServicePrivate = Cvoid

const GThreadedSocketServicePrivate = _GThreadedSocketServicePrivate

struct _GThreadedSocketService
    parent_instance::GSocketService
    priv::Ptr{GThreadedSocketServicePrivate}
end

const GThreadedSocketService = _GThreadedSocketService

struct _GThreadedSocketServiceClass
    parent_class::GSocketServiceClass
    run::Ptr{Cvoid}
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
    _g_reserved4::Ptr{Cvoid}
    _g_reserved5::Ptr{Cvoid}
end

const GThreadedSocketServiceClass = _GThreadedSocketServiceClass

"""
    g_tls_backend_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_tls_backend_get_type (void) G_GNUC_CONST;
```
"""
function g_tls_backend_get_type()
    @ccall libaravis.g_tls_backend_get_type()::GType
end

const _GTlsBackend = Cvoid

const GTlsBackend = _GTlsBackend

"""
    _GTlsBackendInterface

[`GTlsBackendInterface`](@ref): \\_iface: The parent interface. \\_tls: returns whether the backend supports TLS. \\_dtls: returns whether the backend supports DTLS \\_default\\_database: returns a default #[`GTlsDatabase`](@ref) instance. \\_certificate\\_type: returns the #[`GTlsCertificate`](@ref) implementation type \\_client\\_connection\\_type: returns the #[`GTlsClientConnection`](@ref) implementation type \\_server\\_connection\\_type: returns the #[`GTlsServerConnection`](@ref) implementation type \\_file\\_database\\_type: returns the #[`GTlsFileDatabase`](@ref) implementation type. \\_dtls\\_client\\_connection\\_type: returns the #[`GDtlsClientConnection`](@ref) implementation type \\_dtls\\_server\\_connection\\_type: returns the #[`GDtlsServerConnection`](@ref) implementation type

Provides an interface for describing TLS-related types.

Since: 2.28
"""
struct _GTlsBackendInterface
    g_iface::GTypeInterface
    supports_tls::Ptr{Cvoid}
    get_certificate_type::Ptr{Cvoid}
    get_client_connection_type::Ptr{Cvoid}
    get_server_connection_type::Ptr{Cvoid}
    get_file_database_type::Ptr{Cvoid}
    get_default_database::Ptr{Cvoid}
    supports_dtls::Ptr{Cvoid}
    get_dtls_client_connection_type::Ptr{Cvoid}
    get_dtls_server_connection_type::Ptr{Cvoid}
end

"""
[`GTlsBackendInterface`](@ref): \\_iface: The parent interface. \\_tls: returns whether the backend supports TLS. \\_dtls: returns whether the backend supports DTLS \\_default\\_database: returns a default #[`GTlsDatabase`](@ref) instance. \\_certificate\\_type: returns the #[`GTlsCertificate`](@ref) implementation type \\_client\\_connection\\_type: returns the #[`GTlsClientConnection`](@ref) implementation type \\_server\\_connection\\_type: returns the #[`GTlsServerConnection`](@ref) implementation type \\_file\\_database\\_type: returns the #[`GTlsFileDatabase`](@ref) implementation type. \\_dtls\\_client\\_connection\\_type: returns the #[`GDtlsClientConnection`](@ref) implementation type \\_dtls\\_server\\_connection\\_type: returns the #[`GDtlsServerConnection`](@ref) implementation type

Provides an interface for describing TLS-related types.

Since: 2.28
"""
const GTlsBackendInterface = _GTlsBackendInterface

"""
    g_tls_certificate_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_tls_certificate_get_type (void) G_GNUC_CONST;
```
"""
function g_tls_certificate_get_type()
    @ccall libaravis.g_tls_certificate_get_type()::GType
end

const _GTlsCertificatePrivate = Cvoid

const GTlsCertificatePrivate = _GTlsCertificatePrivate

struct _GTlsCertificate
    parent_instance::GObject
    priv::Ptr{GTlsCertificatePrivate}
end

const GTlsCertificate = _GTlsCertificate

struct _GTlsCertificateClass
    parent_class::GObjectClass
    verify::Ptr{Cvoid}
    padding::NTuple{8, gpointer}
end

const GTlsCertificateClass = _GTlsCertificateClass

"""
    g_tls_connection_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_tls_connection_get_type (void) G_GNUC_CONST;
```
"""
function g_tls_connection_get_type()
    @ccall libaravis.g_tls_connection_get_type()::GType
end

const _GTlsConnectionPrivate = Cvoid

const GTlsConnectionPrivate = _GTlsConnectionPrivate

struct _GTlsConnection
    parent_instance::GIOStream
    priv::Ptr{GTlsConnectionPrivate}
end

const GTlsConnection = _GTlsConnection

"""
    _GTlsConnectionClass

[`GTlsConnectionClass`](@ref): \\_class: The parent class. \\_certificate: Check whether to accept a certificate. : Perform a handshake operation. \\_async: Start an asynchronous handshake operation. \\_finish: Finish an asynchronous handshake operation. \\_binding\\_data: Retrieve TLS channel binding data (Since: 2.66) \\_negotiated\\_protocol: Get ALPN-negotiated protocol (Since: 2.70)

The class structure for the #[`GTlsConnection`](@ref) type.

Since: 2.28
"""
struct _GTlsConnectionClass
    parent_class::GIOStreamClass
    accept_certificate::Ptr{Cvoid}
    handshake::Ptr{Cvoid}
    handshake_async::Ptr{Cvoid}
    handshake_finish::Ptr{Cvoid}
    get_binding_data::Ptr{Cvoid}
    get_negotiated_protocol::Ptr{Cvoid}
    padding::NTuple{6, gpointer}
end

"""
[`GTlsConnectionClass`](@ref): \\_class: The parent class. \\_certificate: Check whether to accept a certificate. : Perform a handshake operation. \\_async: Start an asynchronous handshake operation. \\_finish: Finish an asynchronous handshake operation. \\_binding\\_data: Retrieve TLS channel binding data (Since: 2.66) \\_negotiated\\_protocol: Get ALPN-negotiated protocol (Since: 2.70)

The class structure for the #[`GTlsConnection`](@ref) type.

Since: 2.28
"""
const GTlsConnectionClass = _GTlsConnectionClass

"""
    g_tls_error_quark()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GQuark g_tls_error_quark (void);
```
"""
function g_tls_error_quark()
    @ccall libaravis.g_tls_error_quark()::GQuark
end

"""
    g_tls_channel_binding_error_quark()

### Prototype
```c
GIO_AVAILABLE_IN_2_66 GQuark g_tls_channel_binding_error_quark (void);
```
"""
function g_tls_channel_binding_error_quark()
    @ccall libaravis.g_tls_channel_binding_error_quark()::GQuark
end

"""
    g_tls_client_connection_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_tls_client_connection_get_type (void) G_GNUC_CONST;
```
"""
function g_tls_client_connection_get_type()
    @ccall libaravis.g_tls_client_connection_get_type()::GType
end

const _GTlsClientConnection = Cvoid

const GTlsClientConnection = _GTlsClientConnection

"""
    _GTlsClientConnectionInterface

[`GTlsClientConnectionInterface`](@ref): \\_iface: The parent interface. \\_session\\_state: Copies session state from one #[`GTlsClientConnection`](@ref) to another.

vtable for a #[`GTlsClientConnection`](@ref) implementation.

Since: 2.26
"""
struct _GTlsClientConnectionInterface
    g_iface::GTypeInterface
    copy_session_state::Ptr{Cvoid}
end

"""
[`GTlsClientConnectionInterface`](@ref): \\_iface: The parent interface. \\_session\\_state: Copies session state from one #[`GTlsClientConnection`](@ref) to another.

vtable for a #[`GTlsClientConnection`](@ref) implementation.

Since: 2.26
"""
const GTlsClientConnectionInterface = _GTlsClientConnectionInterface

"""
    g_tls_database_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_tls_database_get_type (void) G_GNUC_CONST;
```
"""
function g_tls_database_get_type()
    @ccall libaravis.g_tls_database_get_type()::GType
end

const _GTlsDatabasePrivate = Cvoid

const GTlsDatabasePrivate = _GTlsDatabasePrivate

struct _GTlsDatabase
    parent_instance::GObject
    priv::Ptr{GTlsDatabasePrivate}
end

const GTlsDatabase = _GTlsDatabase

struct _GTlsDatabaseClass
    parent_class::GObjectClass
    verify_chain::Ptr{Cvoid}
    verify_chain_async::Ptr{Cvoid}
    verify_chain_finish::Ptr{Cvoid}
    create_certificate_handle::Ptr{Cvoid}
    lookup_certificate_for_handle::Ptr{Cvoid}
    lookup_certificate_for_handle_async::Ptr{Cvoid}
    lookup_certificate_for_handle_finish::Ptr{Cvoid}
    lookup_certificate_issuer::Ptr{Cvoid}
    lookup_certificate_issuer_async::Ptr{Cvoid}
    lookup_certificate_issuer_finish::Ptr{Cvoid}
    lookup_certificates_issued_by::Ptr{Cvoid}
    lookup_certificates_issued_by_async::Ptr{Cvoid}
    lookup_certificates_issued_by_finish::Ptr{Cvoid}
    padding::NTuple{16, gpointer}
end

const GTlsDatabaseClass = _GTlsDatabaseClass

"""
    g_tls_file_database_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_tls_file_database_get_type (void) G_GNUC_CONST;
```
"""
function g_tls_file_database_get_type()
    @ccall libaravis.g_tls_file_database_get_type()::GType
end

const _GTlsFileDatabase = Cvoid

const GTlsFileDatabase = _GTlsFileDatabase

"""
    _GTlsFileDatabaseInterface

[`GTlsFileDatabaseInterface`](@ref): \\_iface: The parent interface.

Provides an interface for #[`GTlsFileDatabase`](@ref) implementations.
"""
struct _GTlsFileDatabaseInterface
    g_iface::GTypeInterface
    padding::NTuple{8, gpointer}
end

"""
[`GTlsFileDatabaseInterface`](@ref): \\_iface: The parent interface.

Provides an interface for #[`GTlsFileDatabase`](@ref) implementations.
"""
const GTlsFileDatabaseInterface = _GTlsFileDatabaseInterface

"""
    g_tls_interaction_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_tls_interaction_get_type (void) G_GNUC_CONST;
```
"""
function g_tls_interaction_get_type()
    @ccall libaravis.g_tls_interaction_get_type()::GType
end

const _GTlsInteractionPrivate = Cvoid

const GTlsInteractionPrivate = _GTlsInteractionPrivate

struct _GTlsInteraction
    parent_instance::GObject
    priv::Ptr{GTlsInteractionPrivate}
end

const GTlsInteraction = _GTlsInteraction

struct _GTlsInteractionClass
    parent_class::GObjectClass
    ask_password::Ptr{Cvoid}
    ask_password_async::Ptr{Cvoid}
    ask_password_finish::Ptr{Cvoid}
    request_certificate::Ptr{Cvoid}
    request_certificate_async::Ptr{Cvoid}
    request_certificate_finish::Ptr{Cvoid}
    padding::NTuple{21, gpointer}
end

const GTlsInteractionClass = _GTlsInteractionClass

"""
    g_tls_password_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_tls_password_get_type (void) G_GNUC_CONST;
```
"""
function g_tls_password_get_type()
    @ccall libaravis.g_tls_password_get_type()::GType
end

const _GTlsPasswordPrivate = Cvoid

const GTlsPasswordPrivate = _GTlsPasswordPrivate

struct _GTlsPassword
    parent_instance::GObject
    priv::Ptr{GTlsPasswordPrivate}
end

const GTlsPassword = _GTlsPassword

"""
    _GTlsPasswordClass

[`GTlsPasswordClass`](@ref): \\_value: virtual method for [`g_tls_password_get_value`](@ref)()

Class structure for #[`GTlsPassword`](@ref).

# See also
\\_value: virtual method for [`g_tls_password_set_value`](@ref)() \\_default\\_warning: virtual method for [`g_tls_password_get_warning`](@ref)() if no value has been set using [`g_tls_password_set_warning`](@ref)()
"""
struct _GTlsPasswordClass
    parent_class::GObjectClass
    get_value::Ptr{Cvoid}
    set_value::Ptr{Cvoid}
    get_default_warning::Ptr{Cvoid}
    padding::NTuple{4, gpointer}
end

"""
[`GTlsPasswordClass`](@ref): \\_value: virtual method for [`g_tls_password_get_value`](@ref)()

Class structure for #[`GTlsPassword`](@ref).

# See also
\\_value: virtual method for [`g_tls_password_set_value`](@ref)() \\_default\\_warning: virtual method for [`g_tls_password_get_warning`](@ref)() if no value has been set using [`g_tls_password_set_warning`](@ref)()
"""
const GTlsPasswordClass = _GTlsPasswordClass

"""
    g_tls_server_connection_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_tls_server_connection_get_type (void) G_GNUC_CONST;
```
"""
function g_tls_server_connection_get_type()
    @ccall libaravis.g_tls_server_connection_get_type()::GType
end

const _GTlsServerConnection = Cvoid

const GTlsServerConnection = _GTlsServerConnection

"""
    _GTlsServerConnectionInterface

[`GTlsServerConnectionInterface`](@ref): \\_iface: The parent interface.

vtable for a #[`GTlsServerConnection`](@ref) implementation.

Since: 2.26
"""
struct _GTlsServerConnectionInterface
    g_iface::GTypeInterface
end

"""
[`GTlsServerConnectionInterface`](@ref): \\_iface: The parent interface.

vtable for a #[`GTlsServerConnection`](@ref) implementation.

Since: 2.26
"""
const GTlsServerConnectionInterface = _GTlsServerConnectionInterface

"""
    g_unix_connection_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_unix_connection_get_type (void);
```
"""
function g_unix_connection_get_type()
    @ccall libaravis.g_unix_connection_get_type()::GType
end

const _GUnixConnectionPrivate = Cvoid

const GUnixConnectionPrivate = _GUnixConnectionPrivate

struct _GUnixConnection
    parent_instance::GSocketConnection
    priv::Ptr{GUnixConnectionPrivate}
end

const GUnixConnection = _GUnixConnection

struct _GUnixConnectionClass
    parent_class::GSocketConnectionClass
end

const GUnixConnectionClass = _GUnixConnectionClass

"""
    g_unix_credentials_message_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_unix_credentials_message_get_type (void) G_GNUC_CONST;
```
"""
function g_unix_credentials_message_get_type()
    @ccall libaravis.g_unix_credentials_message_get_type()::GType
end

const _GUnixCredentialsMessagePrivate = Cvoid

const GUnixCredentialsMessagePrivate = _GUnixCredentialsMessagePrivate

struct _GUnixCredentialsMessage
    parent_instance::GSocketControlMessage
    priv::Ptr{GUnixCredentialsMessagePrivate}
end

const GUnixCredentialsMessage = _GUnixCredentialsMessage

"""
    _GUnixCredentialsMessageClass

[`GUnixCredentialsMessageClass`](@ref):

Class structure for #[`GUnixCredentialsMessage`](@ref).

Since: 2.26
"""
struct _GUnixCredentialsMessageClass
    parent_class::GSocketControlMessageClass
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
end

"""
[`GUnixCredentialsMessageClass`](@ref):

Class structure for #[`GUnixCredentialsMessage`](@ref).

Since: 2.26
"""
const GUnixCredentialsMessageClass = _GUnixCredentialsMessageClass

"""
    g_unix_fd_list_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_unix_fd_list_get_type (void) G_GNUC_CONST;
```
"""
function g_unix_fd_list_get_type()
    @ccall libaravis.g_unix_fd_list_get_type()::GType
end

const _GUnixFDListPrivate = Cvoid

const GUnixFDListPrivate = _GUnixFDListPrivate

struct _GUnixFDList
    parent_instance::GObject
    priv::Ptr{GUnixFDListPrivate}
end

const GUnixFDList = _GUnixFDList

struct _GUnixFDListClass
    parent_class::GObjectClass
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
    _g_reserved4::Ptr{Cvoid}
    _g_reserved5::Ptr{Cvoid}
end

const GUnixFDListClass = _GUnixFDListClass

"""
    g_unix_socket_address_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_unix_socket_address_get_type (void) G_GNUC_CONST;
```
"""
function g_unix_socket_address_get_type()
    @ccall libaravis.g_unix_socket_address_get_type()::GType
end

const _GUnixSocketAddressPrivate = Cvoid

const GUnixSocketAddressPrivate = _GUnixSocketAddressPrivate

struct _GUnixSocketAddress
    parent_instance::GSocketAddress
    priv::Ptr{GUnixSocketAddressPrivate}
end

const GUnixSocketAddress = _GUnixSocketAddress

struct _GUnixSocketAddressClass
    parent_class::GSocketAddressClass
end

const GUnixSocketAddressClass = _GUnixSocketAddressClass

"""
    g_vfs_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_vfs_get_type (void) G_GNUC_CONST;
```
"""
function g_vfs_get_type()
    @ccall libaravis.g_vfs_get_type()::GType
end

struct _GVfs
    parent_instance::GObject
end

const GVfs = _GVfs

struct _GVfsClass
    parent_class::GObjectClass
    is_active::Ptr{Cvoid}
    get_file_for_path::Ptr{Cvoid}
    get_file_for_uri::Ptr{Cvoid}
    get_supported_uri_schemes::Ptr{Cvoid}
    parse_name::Ptr{Cvoid}
    local_file_add_info::Ptr{Cvoid}
    add_writable_namespaces::Ptr{Cvoid}
    local_file_set_attributes::Ptr{Cvoid}
    local_file_removed::Ptr{Cvoid}
    local_file_moved::Ptr{Cvoid}
    deserialize_icon::Ptr{Cvoid}
    _g_reserved1::Ptr{Cvoid}
    _g_reserved2::Ptr{Cvoid}
    _g_reserved3::Ptr{Cvoid}
    _g_reserved4::Ptr{Cvoid}
    _g_reserved5::Ptr{Cvoid}
    _g_reserved6::Ptr{Cvoid}
end

const GVfsClass = _GVfsClass

"""
    g_volume_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_volume_get_type (void) G_GNUC_CONST;
```
"""
function g_volume_get_type()
    @ccall libaravis.g_volume_get_type()::GType
end

const _GVolume = Cvoid

const GVolume = _GVolume

struct _GVolumeIface
    g_iface::GTypeInterface
    changed::Ptr{Cvoid}
    removed::Ptr{Cvoid}
    get_name::Ptr{Cvoid}
    get_icon::Ptr{Cvoid}
    get_uuid::Ptr{Cvoid}
    get_drive::Ptr{Cvoid}
    get_mount::Ptr{Cvoid}
    can_mount::Ptr{Cvoid}
    can_eject::Ptr{Cvoid}
    mount_fn::Ptr{Cvoid}
    mount_finish::Ptr{Cvoid}
    eject::Ptr{Cvoid}
    eject_finish::Ptr{Cvoid}
    get_identifier::Ptr{Cvoid}
    enumerate_identifiers::Ptr{Cvoid}
    should_automount::Ptr{Cvoid}
    get_activation_root::Ptr{Cvoid}
    eject_with_operation::Ptr{Cvoid}
    eject_with_operation_finish::Ptr{Cvoid}
    get_sort_key::Ptr{Cvoid}
    get_symbolic_icon::Ptr{Cvoid}
end

"""
[`GVolumeIface`](@ref): \\_iface: The parent interface. : Changed signal that is emitted when the volume's state has changed. : The removed signal that is emitted when the #[`GVolume`](@ref) have been removed. If the recipient is holding references to the object they should release them so the object can be finalized. \\_name: Gets a string containing the name of the #[`GVolume`](@ref). \\_icon: Gets a #[`GIcon`](@ref) for the #[`GVolume`](@ref). \\_uuid: Gets the UUID for the #[`GVolume`](@ref). The reference is typically based on the file system UUID for the mount in question and should be considered an opaque string. Returns NULL if there is no UUID available. \\_drive: Gets a #[`GDrive`](@ref) the volume is located on. Returns NULL if the #[`GVolume`](@ref) is not associated with a #[`GDrive`](@ref). \\_mount: Gets a #[`GMount`](@ref) representing the mounted volume. Returns NULL if the #[`GVolume`](@ref) is not mounted. \\_mount: Returns TRUE if the #[`GVolume`](@ref) can be mounted. \\_eject: Checks if a #[`GVolume`](@ref) can be ejected. \\_fn: Mounts a given #[`GVolume`](@ref).  #[`GVolume`](@ref) implementations must emit the #[`GMountOperation`](@ref)::aborted  signal before completing a mount operation that is aborted while  awaiting input from the user through a #[`GMountOperation`](@ref) instance. \\_finish: Finishes a mount operation. : Ejects a given #[`GVolume`](@ref). \\_finish: Finishes an eject operation. \\_identifier: Returns the [identifier](#volume-identifiers) of the given kind, or NULL if the #[`GVolume`](@ref) doesn't have one. \\_identifiers: Returns an array strings listing the kinds of [identifiers](#volume-identifiers) which the #[`GVolume`](@ref) has. \\_automount: Returns TRUE if the #[`GVolume`](@ref) should be automatically mounted. \\_activation\\_root: Returns the activation root for the #[`GVolume`](@ref) if it is known in advance or NULL if it is not known. \\_with\\_operation: Starts ejecting a #[`GVolume`](@ref) using a #[`GMountOperation`](@ref). Since 2.22. \\_with\\_operation\\_finish: Finishes an eject operation using a #[`GMountOperation`](@ref). Since 2.22. \\_sort\\_key: Gets a key used for sorting #[`GVolume`](@ref) instance or NULL if no such key exists. Since 2.32. \\_symbolic\\_icon: Gets a symbolic #[`GIcon`](@ref) for the #[`GVolume`](@ref). Since 2.34.

Interface for implementing operations for mountable volumes.
"""
const GVolumeIface = _GVolumeIface

"""
    g_zlib_compressor_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_zlib_compressor_get_type (void) G_GNUC_CONST;
```
"""
function g_zlib_compressor_get_type()
    @ccall libaravis.g_zlib_compressor_get_type()::GType
end

const _GZlibCompressor = Cvoid

const GZlibCompressor = _GZlibCompressor

struct _GZlibCompressorClass
    parent_class::GObjectClass
end

const GZlibCompressorClass = _GZlibCompressorClass

"""
    g_zlib_decompressor_get_type()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_zlib_decompressor_get_type (void) G_GNUC_CONST;
```
"""
function g_zlib_decompressor_get_type()
    @ccall libaravis.g_zlib_decompressor_get_type()::GType
end

const _GZlibDecompressor = Cvoid

const GZlibDecompressor = _GZlibDecompressor

struct _GZlibDecompressorClass
    parent_class::GObjectClass
end

const GZlibDecompressorClass = _GZlibDecompressorClass

"""
    arv_dom_node_get_type()

### Prototype
```c
ARV_API G_DECLARE_DERIVABLE_TYPE (ArvDomNode, arv_dom_node, ARV, DOM_NODE, GObject);
```
"""
function arv_dom_node_get_type()
    @ccall libaravis.arv_dom_node_get_type()::GType
end

"""
    arv_dom_document_get_type()

### Prototype
```c
ARV_API G_DECLARE_DERIVABLE_TYPE (ArvDomDocument, arv_dom_document, ARV, DOM_DOCUMENT, ArvDomNode);
```
"""
function arv_dom_document_get_type()
    @ccall libaravis.arv_dom_document_get_type()::GType
end

"""
    arv_gc_error_quark()

### Prototype
```c
ARV_API GQuark arv_gc_error_quark (void);
```
"""
function arv_gc_error_quark()
    @ccall libaravis.arv_gc_error_quark()::GQuark
end

"""
    arv_gc_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvGc, arv_gc, ARV, GC, ArvDomDocument);
```
"""
function arv_gc_get_type()
    @ccall libaravis.arv_gc_get_type()::GType
end

"""
    arv_chunk_parser_error_quark()

### Prototype
```c
ARV_API GQuark arv_chunk_parser_error_quark (void);
```
"""
function arv_chunk_parser_error_quark()
    @ccall libaravis.arv_chunk_parser_error_quark()::GQuark
end

"""
    arv_chunk_parser_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvChunkParser, arv_chunk_parser, ARV, CHUNK_PARSER, GObject);
```
"""
function arv_chunk_parser_get_type()
    @ccall libaravis.arv_chunk_parser_get_type()::GType
end

"""
    arv_device_error_quark()

### Prototype
```c
ARV_API GQuark arv_device_error_quark (void);
```
"""
function arv_device_error_quark()
    @ccall libaravis.arv_device_error_quark()::GQuark
end

"""
    arv_device_get_type()

### Prototype
```c
ARV_API G_DECLARE_DERIVABLE_TYPE (ArvDevice, arv_device, ARV, DEVICE, GObject);
```
"""
function arv_device_get_type()
    @ccall libaravis.arv_device_get_type()::GType
end

"""
    arv_gv_device_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvGvDevice, arv_gv_device, ARV, GV_DEVICE, ArvDevice);
```
"""
function arv_gv_device_get_type()
    @ccall libaravis.arv_gv_device_get_type()::GType
end

"""
    arv_camera_get_type()

### Prototype
```c
ARV_API G_DECLARE_DERIVABLE_TYPE (ArvCamera, arv_camera, ARV, CAMERA, GObject);
```
"""
function arv_camera_get_type()
    @ccall libaravis.arv_camera_get_type()::GType
end

"""
    arv_dom_character_data_get_type()

### Prototype
```c
ARV_API G_DECLARE_DERIVABLE_TYPE (ArvDomCharacterData, arv_dom_character_data, ARV, DOM_CHARACTER_DATA, ArvDomNode);
```
"""
function arv_dom_character_data_get_type()
    @ccall libaravis.arv_dom_character_data_get_type()::GType
end

"""
    arv_dom_document_fragment_get_type()

### Prototype
```c
ARV_API G_DECLARE_DERIVABLE_TYPE (ArvDomDocumentFragment, arv_dom_document_fragment, ARV, DOM_DOCUMENT_FRAGMENT, ArvDomNode);
```
"""
function arv_dom_document_fragment_get_type()
    @ccall libaravis.arv_dom_document_fragment_get_type()::GType
end

"""
    arv_dom_element_get_type()

### Prototype
```c
ARV_API G_DECLARE_DERIVABLE_TYPE (ArvDomElement, arv_dom_element, ARV, DOM_ELEMENT, ArvDomNode);
```
"""
function arv_dom_element_get_type()
    @ccall libaravis.arv_dom_element_get_type()::GType
end

"""
    arv_dom_named_node_map_get_type()

### Prototype
```c
ARV_API G_DECLARE_DERIVABLE_TYPE (ArvDomNamedNodeMap, arv_dom_named_node_map, ARV, DOM_NAMED_NODE_MAP, GObject);
```
"""
function arv_dom_named_node_map_get_type()
    @ccall libaravis.arv_dom_named_node_map_get_type()::GType
end

"""
    arv_dom_node_list_get_type()

### Prototype
```c
ARV_API G_DECLARE_DERIVABLE_TYPE (ArvDomNodeList, arv_dom_node_list, ARV, DOM_NODE_LIST, GObject);
```
"""
function arv_dom_node_list_get_type()
    @ccall libaravis.arv_dom_node_list_get_type()::GType
end

"""
    arv_dom_node_child_list_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvDomNodeChildList, arv_dom_node_child_list, ARV, DOM_NODE_CHILD_LIST, ArvDomNodeList);
```
"""
function arv_dom_node_child_list_get_type()
    @ccall libaravis.arv_dom_node_child_list_get_type()::GType
end

"""
    arv_dom_text_get_type()

### Prototype
```c
ARV_API G_DECLARE_DERIVABLE_TYPE (ArvDomText, arv_dom_text, ARV, DOM_TEXT, ArvDomCharacterData);
```
"""
function arv_dom_text_get_type()
    @ccall libaravis.arv_dom_text_get_type()::GType
end

"""
    arv_evaluator_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvEvaluator, arv_evaluator, ARV, EVALUATOR, GObject);
```
"""
function arv_evaluator_get_type()
    @ccall libaravis.arv_evaluator_get_type()::GType
end

"""
    arv_fake_camera_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvFakeCamera, arv_fake_camera, ARV, FAKE_CAMERA, GObject);
```
"""
function arv_fake_camera_get_type()
    @ccall libaravis.arv_fake_camera_get_type()::GType
end

"""
    arv_fake_device_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvFakeDevice, arv_fake_device, ARV, FAKE_DEVICE, ArvDevice);
```
"""
function arv_fake_device_get_type()
    @ccall libaravis.arv_fake_device_get_type()::GType
end

"""
    arv_interface_get_type()

### Prototype
```c
ARV_API G_DECLARE_DERIVABLE_TYPE (ArvInterface, arv_interface, ARV, INTERFACE, GObject);
```
"""
function arv_interface_get_type()
    @ccall libaravis.arv_interface_get_type()::GType
end

"""
    arv_fake_interface_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvFakeInterface, arv_fake_interface, ARV, FAKE_INTERFACE, ArvInterface);
```
"""
function arv_fake_interface_get_type()
    @ccall libaravis.arv_fake_interface_get_type()::GType
end

"""
    arv_fake_stream_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvFakeStream, arv_fake_stream, ARV, FAKE_STREAM, ArvStream);
```
"""
function arv_fake_stream_get_type()
    @ccall libaravis.arv_fake_stream_get_type()::GType
end

"""
    arv_gc_node_get_type()

### Prototype
```c
ARV_API G_DECLARE_DERIVABLE_TYPE (ArvGcNode, arv_gc_node, ARV, GC_NODE, ArvDomElement);
```
"""
function arv_gc_node_get_type()
    @ccall libaravis.arv_gc_node_get_type()::GType
end

"""
    arv_gc_feature_node_get_type()

### Prototype
```c
ARV_API G_DECLARE_DERIVABLE_TYPE (ArvGcFeatureNode, arv_gc_feature_node, ARV, GC_FEATURE_NODE, ArvGcNode);
```
"""
function arv_gc_feature_node_get_type()
    @ccall libaravis.arv_gc_feature_node_get_type()::GType
end

"""
    arv_gc_property_node_get_type()

### Prototype
```c
ARV_API G_DECLARE_DERIVABLE_TYPE (ArvGcPropertyNode, arv_gc_property_node, ARV, GC_PROPERTY_NODE, ArvGcNode);
```
"""
function arv_gc_property_node_get_type()
    @ccall libaravis.arv_gc_property_node_get_type()::GType
end

"""
    arv_gc_boolean_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvGcBoolean, arv_gc_boolean, ARV, GC_BOOLEAN, ArvGcFeatureNode);
```
"""
function arv_gc_boolean_get_type()
    @ccall libaravis.arv_gc_boolean_get_type()::GType
end

"""
    arv_gc_category_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvGcCategory, arv_gc_category, ARV, GC_CATEGORY, ArvGcFeatureNode);
```
"""
function arv_gc_category_get_type()
    @ccall libaravis.arv_gc_category_get_type()::GType
end

"""
    arv_gc_command_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvGcCommand, arv_gc_command, ARV, GC_COMMAND, ArvGcFeatureNode);
```
"""
function arv_gc_command_get_type()
    @ccall libaravis.arv_gc_command_get_type()::GType
end

"""
    arv_gc_converter_get_type()

### Prototype
```c
ARV_API G_DECLARE_DERIVABLE_TYPE (ArvGcConverter, arv_gc_converter, ARV, GC_CONVERTER, ArvGcFeatureNode);
```
"""
function arv_gc_converter_get_type()
    @ccall libaravis.arv_gc_converter_get_type()::GType
end

"""
    arv_gc_converter_node_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvGcConverterNode, arv_gc_converter_node, ARV, GC_CONVERTER_NODE, ArvGcConverter);
```
"""
function arv_gc_converter_node_get_type()
    @ccall libaravis.arv_gc_converter_node_get_type()::GType
end

"""
    arv_gc_enum_entry_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvGcEnumEntry, arv_gc_enum_entry, ARV, GC_ENUM_ENTRY, ArvGcFeatureNode);
```
"""
function arv_gc_enum_entry_get_type()
    @ccall libaravis.arv_gc_enum_entry_get_type()::GType
end

"""
    arv_gc_enumeration_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvGcEnumeration, arv_gc_enumeration, ARV, GC_ENUMERATION, ArvGcFeatureNode);
```
"""
function arv_gc_enumeration_get_type()
    @ccall libaravis.arv_gc_enumeration_get_type()::GType
end

"""
    arv_gc_float_get_type()

### Prototype
```c
ARV_API G_DECLARE_INTERFACE (ArvGcFloat, arv_gc_float, ARV, GC_FLOAT, GObject);
```
"""
function arv_gc_float_get_type()
    @ccall libaravis.arv_gc_float_get_type()::GType
end

"""
    arv_gc_float_node_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvGcFloatNode, arv_gc_float_node, ARV, GC_FLOAT_NODE, ArvGcFeatureNode);
```
"""
function arv_gc_float_node_get_type()
    @ccall libaravis.arv_gc_float_node_get_type()::GType
end

"""
    arv_gc_register_node_get_type()

### Prototype
```c
ARV_API G_DECLARE_DERIVABLE_TYPE (ArvGcRegisterNode, arv_gc_register_node, ARV, GC_REGISTER_NODE, ArvGcFeatureNode);
```
"""
function arv_gc_register_node_get_type()
    @ccall libaravis.arv_gc_register_node_get_type()::GType
end

"""
    arv_gc_float_reg_node_get_type()

### Prototype
```c
ARV_API G_DECLARE_DERIVABLE_TYPE (ArvGcFloatRegNode, arv_gc_float_reg_node, ARV, GC_FLOAT_REG_NODE, ArvGcRegisterNode);
```
"""
function arv_gc_float_reg_node_get_type()
    @ccall libaravis.arv_gc_float_reg_node_get_type()::GType
end

"""
    arv_gc_group_node_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvGcGroupNode, arv_gc_group_node, ARV, GC_GROUP_NODE, ArvGcFeatureNode);
```
"""
function arv_gc_group_node_get_type()
    @ccall libaravis.arv_gc_group_node_get_type()::GType
end

"""
    arv_gc_index_node_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvGcIndexNode, arv_gc_index_node, ARV, GC_INDEX_NODE, ArvGcPropertyNode);
```
"""
function arv_gc_index_node_get_type()
    @ccall libaravis.arv_gc_index_node_get_type()::GType
end

"""
    arv_gc_int_converter_node_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvGcIntConverterNode, arv_gc_int_converter_node, ARV, GC_INT_CONVERTER_NODE, ArvGcConverter);
```
"""
function arv_gc_int_converter_node_get_type()
    @ccall libaravis.arv_gc_int_converter_node_get_type()::GType
end

"""
    arv_gc_integer_get_type()

### Prototype
```c
ARV_API G_DECLARE_INTERFACE (ArvGcInteger, arv_gc_integer, ARV, GC_INTEGER, GObject);
```
"""
function arv_gc_integer_get_type()
    @ccall libaravis.arv_gc_integer_get_type()::GType
end

"""
    arv_gc_integer_node_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvGcIntegerNode, arv_gc_integer_node, ARV, GC_INTEGER_NODE, ArvGcFeatureNode);
```
"""
function arv_gc_integer_node_get_type()
    @ccall libaravis.arv_gc_integer_node_get_type()::GType
end

"""
    arv_gc_int_reg_node_get_type()

### Prototype
```c
ARV_API G_DECLARE_DERIVABLE_TYPE (ArvGcIntRegNode, arv_gc_int_reg_node, ARV, GC_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function arv_gc_int_reg_node_get_type()
    @ccall libaravis.arv_gc_int_reg_node_get_type()::GType
end

"""
    arv_gc_swiss_knife_get_type()

### Prototype
```c
ARV_API G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnife, arv_gc_swiss_knife, ARV, GC_SWISS_KNIFE, ArvGcFeatureNode);
```
"""
function arv_gc_swiss_knife_get_type()
    @ccall libaravis.arv_gc_swiss_knife_get_type()::GType
end

"""
    arv_gc_int_swiss_knife_node_get_type()

### Prototype
```c
ARV_API G_DECLARE_DERIVABLE_TYPE (ArvGcIntSwissKnifeNode, arv_gc_int_swiss_knife_node, ARV, GC_INT_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function arv_gc_int_swiss_knife_node_get_type()
    @ccall libaravis.arv_gc_int_swiss_knife_node_get_type()::GType
end

"""
    arv_gc_invalidator_node_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvGcInvalidatorNode, arv_gc_invalidator_node, ARV, GC_INVALIDATOR_NODE, ArvGcPropertyNode);
```
"""
function arv_gc_invalidator_node_get_type()
    @ccall libaravis.arv_gc_invalidator_node_get_type()::GType
end

"""
    arv_gc_masked_int_reg_node_get_type()

### Prototype
```c
ARV_API G_DECLARE_DERIVABLE_TYPE (ArvGcMaskedIntRegNode, arv_gc_masked_int_reg_node, ARV, GC_MASKED_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function arv_gc_masked_int_reg_node_get_type()
    @ccall libaravis.arv_gc_masked_int_reg_node_get_type()::GType
end

"""
    arv_gc_port_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvGcPort, arv_gc_port, ARV, GC_PORT, ArvGcFeatureNode);
```
"""
function arv_gc_port_get_type()
    @ccall libaravis.arv_gc_port_get_type()::GType
end

"""
    arv_gc_register_description_node_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvGcRegisterDescriptionNode, arv_gc_register_description_node, ARV, GC_REGISTER_DESCRIPTION_NODE, ArvGcFeatureNode);
```
"""
function arv_gc_register_description_node_get_type()
    @ccall libaravis.arv_gc_register_description_node_get_type()::GType
end

"""
    arv_gc_register_get_type()

### Prototype
```c
ARV_API G_DECLARE_INTERFACE (ArvGcRegister, arv_gc_register, ARV, GC_REGISTER, GObject);
```
"""
function arv_gc_register_get_type()
    @ccall libaravis.arv_gc_register_get_type()::GType
end

"""
    arv_gc_selector_get_type()

### Prototype
```c
ARV_API G_DECLARE_INTERFACE (ArvGcSelector, arv_gc_selector, ARV, GC_SELECTOR, GObject);
```
"""
function arv_gc_selector_get_type()
    @ccall libaravis.arv_gc_selector_get_type()::GType
end

"""
    arv_gc_string_get_type()

### Prototype
```c
ARV_API G_DECLARE_INTERFACE (ArvGcString, arv_gc_string, ARV, GC_STRING, GObject);
```
"""
function arv_gc_string_get_type()
    @ccall libaravis.arv_gc_string_get_type()::GType
end

"""
    arv_gc_string_node_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvGcStringNode, arv_gc_string_node, ARV, GC_STRING_NODE, ArvGcFeatureNode);
```
"""
function arv_gc_string_node_get_type()
    @ccall libaravis.arv_gc_string_node_get_type()::GType
end

"""
    arv_gc_string_reg_node_get_type()

### Prototype
```c
ARV_API G_DECLARE_DERIVABLE_TYPE (ArvGcStringRegNode, arv_gc_string_reg_node, ARV, GC_STRING_REG_NODE, ArvGcRegisterNode);
```
"""
function arv_gc_string_reg_node_get_type()
    @ccall libaravis.arv_gc_string_reg_node_get_type()::GType
end

"""
    arv_gc_struct_reg_node_get_type()

### Prototype
```c
ARV_API G_DECLARE_DERIVABLE_TYPE (ArvGcStructRegNode, arv_gc_struct_reg_node, ARV, GC_STRUCT_REG_NODE, ArvGcRegisterNode);
```
"""
function arv_gc_struct_reg_node_get_type()
    @ccall libaravis.arv_gc_struct_reg_node_get_type()::GType
end

"""
    arv_gc_struct_entry_node_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvGcStructEntryNode, arv_gc_struct_entry_node, ARV, GC_STRUCT_ENTRY_NODE, ArvGcFeatureNode);
```
"""
function arv_gc_struct_entry_node_get_type()
    @ccall libaravis.arv_gc_struct_entry_node_get_type()::GType
end

"""
    arv_gc_swiss_knife_node_get_type()

### Prototype
```c
ARV_API G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnifeNode, arv_gc_swiss_knife_node, ARV, GC_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function arv_gc_swiss_knife_node_get_type()
    @ccall libaravis.arv_gc_swiss_knife_node_get_type()::GType
end

"""
    arv_gc_value_indexed_node_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvGcValueIndexedNode, arv_gc_value_indexed_node, ARV, GC_VALUE_INDEXED_NODE, ArvGcPropertyNode);
```
"""
function arv_gc_value_indexed_node_get_type()
    @ccall libaravis.arv_gc_value_indexed_node_get_type()::GType
end

"""
    arv_gv_fake_camera_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvGvFakeCamera, arv_gv_fake_camera, ARV, GV_FAKE_CAMERA, GObject);
```
"""
function arv_gv_fake_camera_get_type()
    @ccall libaravis.arv_gv_fake_camera_get_type()::GType
end

"""
    arv_gv_interface_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvGvInterface, arv_gv_interface, ARV, GV_INTERFACE, ArvInterface);
```
"""
function arv_gv_interface_get_type()
    @ccall libaravis.arv_gv_interface_get_type()::GType
end

"""
    arv_uv_interface_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvUvInterface, arv_uv_interface, ARV, UV_INTERFACE, ArvInterface);
```
"""
function arv_uv_interface_get_type()
    @ccall libaravis.arv_uv_interface_get_type()::GType
end

"""
    arv_uv_device_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvUvDevice, arv_uv_device, ARV, UV_DEVICE, ArvDevice);
```
"""
function arv_uv_device_get_type()
    @ccall libaravis.arv_uv_device_get_type()::GType
end

"""
    arv_uv_stream_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvUvStream, arv_uv_stream, ARV, UV_STREAM, ArvStream);
```
"""
function arv_uv_stream_get_type()
    @ccall libaravis.arv_uv_stream_get_type()::GType
end

"""
    arv_guint32_from_unaligned_le_ptr(ptr, offset)

[`arv_guint32_from_unaligned_le_ptr`](@ref):

\\par : pointer to a little endian 32 bit usigned integer : an offset to add to

\\par 

Here's an excerpt of the ARM documentation:

"Unaligned data access in C and C++ code

It can be necessary to access unaligned data in memory, for example, when porting legacy code from a CISC architecture where instructions are available to directly access unaligned data in memory.

On ARMv4 and ARMv5 architectures, and on the ARMv6 architecture depending on how it is configured, care is required when accessing unaligned data in memory, to avoid unexpected results. For example, when a conventional pointer is used to read a word in C or C++ source code, the ARM compiler generates assembly language code that reads the word using an LDR instruction. This works as expected when the address is a multiple of four, for example if it lies on a word boundary. However, if the address is not a multiple of four, the LDR instruction returns a rotated result rather than performing a true unaligned word load. Generally, this rotation is not what the programmer expects.

On ARMv6 and later architectures, unaligned access is fully supported."

Returns: a [`guint32`](@ref) in machine endianness

### Prototype
```c
static inline guint32 arv_guint32_from_unaligned_le_ptr (const char *ptr, gint32 offset);
```
"""
function arv_guint32_from_unaligned_le_ptr(ptr, offset)
    @ccall libaravis.arv_guint32_from_unaligned_le_ptr(ptr::Cstring, offset::gint32)::guint32
end

"""
    arv_guint16_from_unaligned_le_ptr(ptr, offset)

[`arv_guint16_from_unaligned_le_ptr`](@ref):

\\par : pointer to a little endian 16 bit usigned integer : an offset to add to

\\par 

See

* \\_guint32\\_from\\_unaligned\\_le\\_ptr.

Returns: a [`guint16`](@ref) in machine endianness

### Prototype
```c
static inline guint16 arv_guint16_from_unaligned_le_ptr (const char *ptr, gint16 offset);
```
"""
function arv_guint16_from_unaligned_le_ptr(ptr, offset)
    @ccall libaravis.arv_guint16_from_unaligned_le_ptr(ptr::Cstring, offset::gint16)::guint16
end

"""
    arv_xml_schema_error_quark()

### Prototype
```c
ARV_API GQuark arv_xml_schema_error_quark (void);
```
"""
function arv_xml_schema_error_quark()
    @ccall libaravis.arv_xml_schema_error_quark()::GQuark
end

"""
    arv_xml_schema_get_type()

### Prototype
```c
ARV_API G_DECLARE_FINAL_TYPE (ArvXmlSchema, arv_xml_schema, ARV, XML_SCHEMA, GObject);
```
"""
function arv_xml_schema_get_type()
    @ccall libaravis.arv_xml_schema_get_type()::GType
end

const goffset = gint64

const GPid = Cint

const gshort = Cshort

const gushort = Cushort

# typedef gint ( * GCompareFunc ) ( gconstpointer a , gconstpointer b )
const GCompareFunc = Ptr{Cvoid}

# typedef gint ( * GCompareDataFunc ) ( gconstpointer a , gconstpointer b , gpointer user_data )
const GCompareDataFunc = Ptr{Cvoid}

# typedef gboolean ( * GEqualFunc ) ( gconstpointer a , gconstpointer b )
const GEqualFunc = Ptr{Cvoid}

# typedef gboolean ( * GEqualFuncFull ) ( gconstpointer a , gconstpointer b , gpointer user_data )
"""
[`GEqualFuncFull`](@ref): *:* a value **:** a value to compare with \\_data: user data provided by the caller

Specifies the type of a function used to test two values for equality. The function should return TRUE if both values are equal and FALSE otherwise.

This is a version of #[`GEqualFunc`](@ref) which provides a \\_data closure from the caller.

Returns: TRUE if *=* **;** FALSE otherwise Since: 2.74
"""
const GEqualFuncFull = Ptr{Cvoid}

# typedef void ( * GFunc ) ( gpointer data , gpointer user_data )
const GFunc = Ptr{Cvoid}

# typedef guint ( * GHashFunc ) ( gconstpointer key )
const GHashFunc = Ptr{Cvoid}

# typedef gpointer ( * GCopyFunc ) ( gconstpointer src , gpointer data )
"""
[`GCopyFunc`](@ref): : (not nullable): A pointer to the data which should be copied

\\date : Additional data

A function of this signature is used to copy the node data when doing a deep-copy of a tree.

Returns: (not nullable): A pointer to the copy

Since: 2.4
"""
const GCopyFunc = Ptr{Cvoid}

# typedef void ( * GFreeFunc ) ( gpointer data )
"""
[`GFreeFunc`](@ref):

\\date : a data pointer

Declares a type of function which takes an arbitrary data pointer argument and has no return value. It is not currently used in GLib or GTK.
"""
const GFreeFunc = Ptr{Cvoid}

# typedef const gchar * ( * GTranslateFunc ) ( const gchar * str , gpointer data )
"""
[`GTranslateFunc`](@ref): : the untranslated string

\\date : user data specified when installing the function, e.g. in [`g_option_group_set_translate_func`](@ref)()

The type of functions which are used to translate user-visible strings, for <option>--help</option> output.

Returns: a translation of the string for the current locale. The returned string is owned by GLib and must not be freed.
"""
const GTranslateFunc = Ptr{Cvoid}

struct _GDoubleIEEE754
    data::NTuple{8, UInt8}
end

function Base.getproperty(x::Ptr{_GDoubleIEEE754}, f::Symbol)
    f === :v_double && return Ptr{gdouble}(x + 0)
    f === :mpn && return Ptr{__JL_Ctag_27}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::_GDoubleIEEE754, f::Symbol)
    r = Ref{_GDoubleIEEE754}(x)
    ptr = Base.unsafe_convert(Ptr{_GDoubleIEEE754}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{_GDoubleIEEE754}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::_GDoubleIEEE754, private::Bool = false)
    (:v_double, :mpn, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

const GDoubleIEEE754 = _GDoubleIEEE754

struct _GFloatIEEE754
    data::NTuple{4, UInt8}
end

function Base.getproperty(x::Ptr{_GFloatIEEE754}, f::Symbol)
    f === :v_float && return Ptr{gfloat}(x + 0)
    f === :mpn && return Ptr{__JL_Ctag_25}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::_GFloatIEEE754, f::Symbol)
    r = Ref{_GFloatIEEE754}(x)
    ptr = Base.unsafe_convert(Ptr{_GFloatIEEE754}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{_GFloatIEEE754}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::_GFloatIEEE754, private::Bool = false)
    (:v_float, :mpn, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

const GFloatIEEE754 = _GFloatIEEE754

struct _GTimeVal
    data::NTuple{16, UInt8}
end

function Base.getproperty(x::Ptr{_GTimeVal}, f::Symbol)
    f === :tv_sec && return Ptr{glong}(x + 0)
    f === :tv_usec && return Ptr{glong}(x + 8)
    return getfield(x, f)
end

function Base.getproperty(x::_GTimeVal, f::Symbol)
    r = Ref{_GTimeVal}(x)
    ptr = Base.unsafe_convert(Ptr{_GTimeVal}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{_GTimeVal}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::_GTimeVal, private::Bool = false)
    (:tv_sec, :tv_usec, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

const GTimeVal = _GTimeVal

const grefcount = gint

const gatomicrefcount = gint

const _GBytes = Cvoid

const GBytes = _GBytes

struct _GByteArray
    data::Ptr{guint8}
    len::guint
end

const GByteArray = _GByteArray

struct _GPtrArray
    pdata::Ptr{gpointer}
    len::guint
end

const GPtrArray = _GPtrArray

"""
    g_array_new(zero_terminated, clear_, element_size)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GArray* g_array_new (gboolean zero_terminated, gboolean clear_, guint element_size);
```
"""
function g_array_new(zero_terminated, clear_, element_size)
    @ccall libaravis.g_array_new(zero_terminated::gboolean, clear_::gboolean, element_size::guint)::Ptr{GArray}
end

"""
    g_array_new_take(data, len, clear, element_size)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 GArray* g_array_new_take (gpointer data, gsize len, gboolean clear, gsize element_size);
```
"""
function g_array_new_take(data, len, clear, element_size)
    @ccall libaravis.g_array_new_take(data::gpointer, len::gsize, clear::gboolean, element_size::gsize)::Ptr{GArray}
end

"""
    g_array_new_take_zero_terminated(data, clear, element_size)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 GArray* g_array_new_take_zero_terminated (gpointer data, gboolean clear, gsize element_size);
```
"""
function g_array_new_take_zero_terminated(data, clear, element_size)
    @ccall libaravis.g_array_new_take_zero_terminated(data::gpointer, clear::gboolean, element_size::gsize)::Ptr{GArray}
end

"""
    g_array_steal(array, len)

### Prototype
```c
GLIB_AVAILABLE_IN_2_64 gpointer g_array_steal (GArray *array, gsize *len);
```
"""
function g_array_steal(array, len)
    @ccall libaravis.g_array_steal(array::Ptr{GArray}, len::Ptr{gsize})::gpointer
end

"""
    g_array_sized_new(zero_terminated, clear_, element_size, reserved_size)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GArray* g_array_sized_new (gboolean zero_terminated, gboolean clear_, guint element_size, guint reserved_size);
```
"""
function g_array_sized_new(zero_terminated, clear_, element_size, reserved_size)
    @ccall libaravis.g_array_sized_new(zero_terminated::gboolean, clear_::gboolean, element_size::guint, reserved_size::guint)::Ptr{GArray}
end

"""
    g_array_copy(array)

### Prototype
```c
GLIB_AVAILABLE_IN_2_62 GArray* g_array_copy (GArray *array);
```
"""
function g_array_copy(array)
    @ccall libaravis.g_array_copy(array::Ptr{GArray})::Ptr{GArray}
end

"""
    g_array_free(array, free_segment)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_array_free (GArray *array, gboolean free_segment);
```
"""
function g_array_free(array, free_segment)
    @ccall libaravis.g_array_free(array::Ptr{GArray}, free_segment::gboolean)::Ptr{gchar}
end

"""
    g_array_ref(array)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GArray *g_array_ref (GArray *array);
```
"""
function g_array_ref(array)
    @ccall libaravis.g_array_ref(array::Ptr{GArray})::Ptr{GArray}
end

"""
    g_array_unref(array)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_array_unref (GArray *array);
```
"""
function g_array_unref(array)
    @ccall libaravis.g_array_unref(array::Ptr{GArray})::Cvoid
end

"""
    g_array_get_element_size(array)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_array_get_element_size (GArray *array);
```
"""
function g_array_get_element_size(array)
    @ccall libaravis.g_array_get_element_size(array::Ptr{GArray})::guint
end

"""
    g_array_set_size(array, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GArray* g_array_set_size (GArray *array, guint length);
```
"""
function g_array_set_size(array, length)
    @ccall libaravis.g_array_set_size(array::Ptr{GArray}, length::guint)::Ptr{GArray}
end

"""
    g_array_remove_index(array, index_)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GArray* g_array_remove_index (GArray *array, guint index_);
```
"""
function g_array_remove_index(array, index_)
    @ccall libaravis.g_array_remove_index(array::Ptr{GArray}, index_::guint)::Ptr{GArray}
end

"""
    g_array_remove_index_fast(array, index_)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GArray* g_array_remove_index_fast (GArray *array, guint index_);
```
"""
function g_array_remove_index_fast(array, index_)
    @ccall libaravis.g_array_remove_index_fast(array::Ptr{GArray}, index_::guint)::Ptr{GArray}
end

"""
    g_array_remove_range(array, index_, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GArray* g_array_remove_range (GArray *array, guint index_, guint length);
```
"""
function g_array_remove_range(array, index_, length)
    @ccall libaravis.g_array_remove_range(array::Ptr{GArray}, index_::guint, length::guint)::Ptr{GArray}
end

"""
    g_array_sort(array, compare_func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_array_sort (GArray *array, GCompareFunc compare_func);
```
"""
function g_array_sort(array, compare_func)
    @ccall libaravis.g_array_sort(array::Ptr{GArray}, compare_func::GCompareFunc)::Cvoid
end

"""
    g_array_sort_with_data(array, compare_func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_array_sort_with_data (GArray *array, GCompareDataFunc compare_func, gpointer user_data);
```
"""
function g_array_sort_with_data(array, compare_func, user_data)
    @ccall libaravis.g_array_sort_with_data(array::Ptr{GArray}, compare_func::GCompareDataFunc, user_data::gpointer)::Cvoid
end

"""
    g_array_binary_search(array, target, compare_func, out_match_index)

### Prototype
```c
GLIB_AVAILABLE_IN_2_62 gboolean g_array_binary_search (GArray *array, gconstpointer target, GCompareFunc compare_func, guint *out_match_index);
```
"""
function g_array_binary_search(array, target, compare_func, out_match_index)
    @ccall libaravis.g_array_binary_search(array::Ptr{GArray}, target::gconstpointer, compare_func::GCompareFunc, out_match_index::Ptr{guint})::gboolean
end

"""
    g_array_set_clear_func(array, clear_func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_array_set_clear_func (GArray *array, GDestroyNotify clear_func);
```
"""
function g_array_set_clear_func(array, clear_func)
    @ccall libaravis.g_array_set_clear_func(array::Ptr{GArray}, clear_func::GDestroyNotify)::Cvoid
end

"""
    g_ptr_array_new()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GPtrArray* g_ptr_array_new (void);
```
"""
function g_ptr_array_new()
    @ccall libaravis.g_ptr_array_new()::Ptr{GPtrArray}
end

"""
    g_ptr_array_new_with_free_func(element_free_func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GPtrArray* g_ptr_array_new_with_free_func (GDestroyNotify element_free_func);
```
"""
function g_ptr_array_new_with_free_func(element_free_func)
    @ccall libaravis.g_ptr_array_new_with_free_func(element_free_func::GDestroyNotify)::Ptr{GPtrArray}
end

"""
    g_ptr_array_new_take(data, len, element_free_func)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 GPtrArray* g_ptr_array_new_take (gpointer *data, gsize len, GDestroyNotify element_free_func);
```
"""
function g_ptr_array_new_take(data, len, element_free_func)
    @ccall libaravis.g_ptr_array_new_take(data::Ptr{gpointer}, len::gsize, element_free_func::GDestroyNotify)::Ptr{GPtrArray}
end

"""
    g_ptr_array_new_from_array(data, len, copy_func, copy_func_user_data, element_free_func)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 GPtrArray* g_ptr_array_new_from_array (gpointer *data, gsize len, GCopyFunc copy_func, gpointer copy_func_user_data, GDestroyNotify element_free_func);
```
"""
function g_ptr_array_new_from_array(data, len, copy_func, copy_func_user_data, element_free_func)
    @ccall libaravis.g_ptr_array_new_from_array(data::Ptr{gpointer}, len::gsize, copy_func::GCopyFunc, copy_func_user_data::gpointer, element_free_func::GDestroyNotify)::Ptr{GPtrArray}
end

"""
    g_ptr_array_steal(array, len)

### Prototype
```c
GLIB_AVAILABLE_IN_2_64 gpointer* g_ptr_array_steal (GPtrArray *array, gsize *len);
```
"""
function g_ptr_array_steal(array, len)
    @ccall libaravis.g_ptr_array_steal(array::Ptr{GPtrArray}, len::Ptr{gsize})::Ptr{gpointer}
end

"""
    g_ptr_array_copy(array, func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_2_62 GPtrArray *g_ptr_array_copy (GPtrArray *array, GCopyFunc func, gpointer user_data);
```
"""
function g_ptr_array_copy(array, func, user_data)
    @ccall libaravis.g_ptr_array_copy(array::Ptr{GPtrArray}, func::GCopyFunc, user_data::gpointer)::Ptr{GPtrArray}
end

"""
    g_ptr_array_sized_new(reserved_size)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GPtrArray* g_ptr_array_sized_new (guint reserved_size);
```
"""
function g_ptr_array_sized_new(reserved_size)
    @ccall libaravis.g_ptr_array_sized_new(reserved_size::guint)::Ptr{GPtrArray}
end

"""
    g_ptr_array_new_full(reserved_size, element_free_func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GPtrArray* g_ptr_array_new_full (guint reserved_size, GDestroyNotify element_free_func);
```
"""
function g_ptr_array_new_full(reserved_size, element_free_func)
    @ccall libaravis.g_ptr_array_new_full(reserved_size::guint, element_free_func::GDestroyNotify)::Ptr{GPtrArray}
end

"""
    g_ptr_array_new_null_terminated(reserved_size, element_free_func, null_terminated)

### Prototype
```c
GLIB_AVAILABLE_IN_2_74 GPtrArray* g_ptr_array_new_null_terminated (guint reserved_size, GDestroyNotify element_free_func, gboolean null_terminated);
```
"""
function g_ptr_array_new_null_terminated(reserved_size, element_free_func, null_terminated)
    @ccall libaravis.g_ptr_array_new_null_terminated(reserved_size::guint, element_free_func::GDestroyNotify, null_terminated::gboolean)::Ptr{GPtrArray}
end

"""
    g_ptr_array_new_take_null_terminated(data, element_free_func)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 GPtrArray* g_ptr_array_new_take_null_terminated (gpointer *data, GDestroyNotify element_free_func);
```
"""
function g_ptr_array_new_take_null_terminated(data, element_free_func)
    @ccall libaravis.g_ptr_array_new_take_null_terminated(data::Ptr{gpointer}, element_free_func::GDestroyNotify)::Ptr{GPtrArray}
end

"""
    g_ptr_array_new_from_null_terminated_array(data, copy_func, copy_func_user_data, element_free_func)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 GPtrArray* g_ptr_array_new_from_null_terminated_array (gpointer *data, GCopyFunc copy_func, gpointer copy_func_user_data, GDestroyNotify element_free_func);
```
"""
function g_ptr_array_new_from_null_terminated_array(data, copy_func, copy_func_user_data, element_free_func)
    @ccall libaravis.g_ptr_array_new_from_null_terminated_array(data::Ptr{gpointer}, copy_func::GCopyFunc, copy_func_user_data::gpointer, element_free_func::GDestroyNotify)::Ptr{GPtrArray}
end

"""
    g_ptr_array_free(array, free_segment)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer* g_ptr_array_free (GPtrArray *array, gboolean free_segment);
```
"""
function g_ptr_array_free(array, free_segment)
    @ccall libaravis.g_ptr_array_free(array::Ptr{GPtrArray}, free_segment::gboolean)::Ptr{gpointer}
end

"""
    g_ptr_array_ref(array)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GPtrArray* g_ptr_array_ref (GPtrArray *array);
```
"""
function g_ptr_array_ref(array)
    @ccall libaravis.g_ptr_array_ref(array::Ptr{GPtrArray})::Ptr{GPtrArray}
end

"""
    g_ptr_array_unref(array)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_ptr_array_unref (GPtrArray *array);
```
"""
function g_ptr_array_unref(array)
    @ccall libaravis.g_ptr_array_unref(array::Ptr{GPtrArray})::Cvoid
end

"""
    g_ptr_array_set_free_func(array, element_free_func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_ptr_array_set_free_func (GPtrArray *array, GDestroyNotify element_free_func);
```
"""
function g_ptr_array_set_free_func(array, element_free_func)
    @ccall libaravis.g_ptr_array_set_free_func(array::Ptr{GPtrArray}, element_free_func::GDestroyNotify)::Cvoid
end

"""
    g_ptr_array_set_size(array, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_ptr_array_set_size (GPtrArray *array, gint length);
```
"""
function g_ptr_array_set_size(array, length)
    @ccall libaravis.g_ptr_array_set_size(array::Ptr{GPtrArray}, length::gint)::Cvoid
end

"""
    g_ptr_array_remove_index(array, index_)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_ptr_array_remove_index (GPtrArray *array, guint index_);
```
"""
function g_ptr_array_remove_index(array, index_)
    @ccall libaravis.g_ptr_array_remove_index(array::Ptr{GPtrArray}, index_::guint)::gpointer
end

"""
    g_ptr_array_remove_index_fast(array, index_)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_ptr_array_remove_index_fast (GPtrArray *array, guint index_);
```
"""
function g_ptr_array_remove_index_fast(array, index_)
    @ccall libaravis.g_ptr_array_remove_index_fast(array::Ptr{GPtrArray}, index_::guint)::gpointer
end

"""
    g_ptr_array_steal_index(array, index_)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 gpointer g_ptr_array_steal_index (GPtrArray *array, guint index_);
```
"""
function g_ptr_array_steal_index(array, index_)
    @ccall libaravis.g_ptr_array_steal_index(array::Ptr{GPtrArray}, index_::guint)::gpointer
end

"""
    g_ptr_array_steal_index_fast(array, index_)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 gpointer g_ptr_array_steal_index_fast (GPtrArray *array, guint index_);
```
"""
function g_ptr_array_steal_index_fast(array, index_)
    @ccall libaravis.g_ptr_array_steal_index_fast(array::Ptr{GPtrArray}, index_::guint)::gpointer
end

"""
    g_ptr_array_remove(array, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_ptr_array_remove (GPtrArray *array, gpointer data);
```
"""
function g_ptr_array_remove(array, data)
    @ccall libaravis.g_ptr_array_remove(array::Ptr{GPtrArray}, data::gpointer)::gboolean
end

"""
    g_ptr_array_remove_fast(array, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_ptr_array_remove_fast (GPtrArray *array, gpointer data);
```
"""
function g_ptr_array_remove_fast(array, data)
    @ccall libaravis.g_ptr_array_remove_fast(array::Ptr{GPtrArray}, data::gpointer)::gboolean
end

"""
    g_ptr_array_remove_range(array, index_, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GPtrArray *g_ptr_array_remove_range (GPtrArray *array, guint index_, guint length);
```
"""
function g_ptr_array_remove_range(array, index_, length)
    @ccall libaravis.g_ptr_array_remove_range(array::Ptr{GPtrArray}, index_::guint, length::guint)::Ptr{GPtrArray}
end

"""
    g_ptr_array_add(array, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_ptr_array_add (GPtrArray *array, gpointer data);
```
"""
function g_ptr_array_add(array, data)
    @ccall libaravis.g_ptr_array_add(array::Ptr{GPtrArray}, data::gpointer)::Cvoid
end

"""
    g_ptr_array_extend(array_to_extend, array, func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_2_62 void g_ptr_array_extend (GPtrArray *array_to_extend, GPtrArray *array, GCopyFunc func, gpointer user_data);
```
"""
function g_ptr_array_extend(array_to_extend, array, func, user_data)
    @ccall libaravis.g_ptr_array_extend(array_to_extend::Ptr{GPtrArray}, array::Ptr{GPtrArray}, func::GCopyFunc, user_data::gpointer)::Cvoid
end

"""
    g_ptr_array_extend_and_steal(array_to_extend, array)

### Prototype
```c
GLIB_AVAILABLE_IN_2_62 void g_ptr_array_extend_and_steal (GPtrArray *array_to_extend, GPtrArray *array);
```
"""
function g_ptr_array_extend_and_steal(array_to_extend, array)
    @ccall libaravis.g_ptr_array_extend_and_steal(array_to_extend::Ptr{GPtrArray}, array::Ptr{GPtrArray})::Cvoid
end

"""
    g_ptr_array_insert(array, index_, data)

### Prototype
```c
GLIB_AVAILABLE_IN_2_40 void g_ptr_array_insert (GPtrArray *array, gint index_, gpointer data);
```
"""
function g_ptr_array_insert(array, index_, data)
    @ccall libaravis.g_ptr_array_insert(array::Ptr{GPtrArray}, index_::gint, data::gpointer)::Cvoid
end

"""
    g_ptr_array_sort(array, compare_func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_ptr_array_sort (GPtrArray *array, GCompareFunc compare_func);
```
"""
function g_ptr_array_sort(array, compare_func)
    @ccall libaravis.g_ptr_array_sort(array::Ptr{GPtrArray}, compare_func::GCompareFunc)::Cvoid
end

"""
    g_ptr_array_sort_with_data(array, compare_func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_ptr_array_sort_with_data (GPtrArray *array, GCompareDataFunc compare_func, gpointer user_data);
```
"""
function g_ptr_array_sort_with_data(array, compare_func, user_data)
    @ccall libaravis.g_ptr_array_sort_with_data(array::Ptr{GPtrArray}, compare_func::GCompareDataFunc, user_data::gpointer)::Cvoid
end

"""
    g_ptr_array_sort_values(array, compare_func)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 void g_ptr_array_sort_values (GPtrArray *array, GCompareFunc compare_func);
```
"""
function g_ptr_array_sort_values(array, compare_func)
    @ccall libaravis.g_ptr_array_sort_values(array::Ptr{GPtrArray}, compare_func::GCompareFunc)::Cvoid
end

"""
    g_ptr_array_sort_values_with_data(array, compare_func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 void g_ptr_array_sort_values_with_data (GPtrArray *array, GCompareDataFunc compare_func, gpointer user_data);
```
"""
function g_ptr_array_sort_values_with_data(array, compare_func, user_data)
    @ccall libaravis.g_ptr_array_sort_values_with_data(array::Ptr{GPtrArray}, compare_func::GCompareDataFunc, user_data::gpointer)::Cvoid
end

"""
    g_ptr_array_foreach(array, func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_ptr_array_foreach (GPtrArray *array, GFunc func, gpointer user_data);
```
"""
function g_ptr_array_foreach(array, func, user_data)
    @ccall libaravis.g_ptr_array_foreach(array::Ptr{GPtrArray}, func::GFunc, user_data::gpointer)::Cvoid
end

"""
    g_ptr_array_find(haystack, needle, index_)

### Prototype
```c
GLIB_AVAILABLE_IN_2_54 gboolean g_ptr_array_find (GPtrArray *haystack, gconstpointer needle, guint *index_);
```
"""
function g_ptr_array_find(haystack, needle, index_)
    @ccall libaravis.g_ptr_array_find(haystack::Ptr{GPtrArray}, needle::gconstpointer, index_::Ptr{guint})::gboolean
end

"""
    g_ptr_array_find_with_equal_func(haystack, needle, equal_func, index_)

### Prototype
```c
GLIB_AVAILABLE_IN_2_54 gboolean g_ptr_array_find_with_equal_func (GPtrArray *haystack, gconstpointer needle, GEqualFunc equal_func, guint *index_);
```
"""
function g_ptr_array_find_with_equal_func(haystack, needle, equal_func, index_)
    @ccall libaravis.g_ptr_array_find_with_equal_func(haystack::Ptr{GPtrArray}, needle::gconstpointer, equal_func::GEqualFunc, index_::Ptr{guint})::gboolean
end

"""
    g_ptr_array_is_null_terminated(array)

### Prototype
```c
GLIB_AVAILABLE_IN_2_74 gboolean g_ptr_array_is_null_terminated (GPtrArray *array);
```
"""
function g_ptr_array_is_null_terminated(array)
    @ccall libaravis.g_ptr_array_is_null_terminated(array::Ptr{GPtrArray})::gboolean
end

"""
    g_byte_array_new()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GByteArray* g_byte_array_new (void);
```
"""
function g_byte_array_new()
    @ccall libaravis.g_byte_array_new()::Ptr{GByteArray}
end

"""
    g_byte_array_new_take(data, len)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GByteArray* g_byte_array_new_take (guint8 *data, gsize len);
```
"""
function g_byte_array_new_take(data, len)
    @ccall libaravis.g_byte_array_new_take(data::Ptr{guint8}, len::gsize)::Ptr{GByteArray}
end

"""
    g_byte_array_steal(array, len)

### Prototype
```c
GLIB_AVAILABLE_IN_2_64 guint8* g_byte_array_steal (GByteArray *array, gsize *len);
```
"""
function g_byte_array_steal(array, len)
    @ccall libaravis.g_byte_array_steal(array::Ptr{GByteArray}, len::Ptr{gsize})::Ptr{guint8}
end

"""
    g_byte_array_sized_new(reserved_size)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GByteArray* g_byte_array_sized_new (guint reserved_size);
```
"""
function g_byte_array_sized_new(reserved_size)
    @ccall libaravis.g_byte_array_sized_new(reserved_size::guint)::Ptr{GByteArray}
end

"""
    g_byte_array_free(array, free_segment)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint8* g_byte_array_free (GByteArray *array, gboolean free_segment);
```
"""
function g_byte_array_free(array, free_segment)
    @ccall libaravis.g_byte_array_free(array::Ptr{GByteArray}, free_segment::gboolean)::Ptr{guint8}
end

"""
    g_byte_array_free_to_bytes(array)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GBytes* g_byte_array_free_to_bytes (GByteArray *array);
```
"""
function g_byte_array_free_to_bytes(array)
    @ccall libaravis.g_byte_array_free_to_bytes(array::Ptr{GByteArray})::Ptr{GBytes}
end

"""
    g_byte_array_ref(array)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GByteArray *g_byte_array_ref (GByteArray *array);
```
"""
function g_byte_array_ref(array)
    @ccall libaravis.g_byte_array_ref(array::Ptr{GByteArray})::Ptr{GByteArray}
end

"""
    g_byte_array_unref(array)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_byte_array_unref (GByteArray *array);
```
"""
function g_byte_array_unref(array)
    @ccall libaravis.g_byte_array_unref(array::Ptr{GByteArray})::Cvoid
end

"""
    g_byte_array_append(array, data, len)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GByteArray* g_byte_array_append (GByteArray *array, const guint8 *data, guint len);
```
"""
function g_byte_array_append(array, data, len)
    @ccall libaravis.g_byte_array_append(array::Ptr{GByteArray}, data::Ptr{guint8}, len::guint)::Ptr{GByteArray}
end

"""
    g_byte_array_prepend(array, data, len)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GByteArray* g_byte_array_prepend (GByteArray *array, const guint8 *data, guint len);
```
"""
function g_byte_array_prepend(array, data, len)
    @ccall libaravis.g_byte_array_prepend(array::Ptr{GByteArray}, data::Ptr{guint8}, len::guint)::Ptr{GByteArray}
end

"""
    g_byte_array_set_size(array, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GByteArray* g_byte_array_set_size (GByteArray *array, guint length);
```
"""
function g_byte_array_set_size(array, length)
    @ccall libaravis.g_byte_array_set_size(array::Ptr{GByteArray}, length::guint)::Ptr{GByteArray}
end

"""
    g_byte_array_remove_index(array, index_)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GByteArray* g_byte_array_remove_index (GByteArray *array, guint index_);
```
"""
function g_byte_array_remove_index(array, index_)
    @ccall libaravis.g_byte_array_remove_index(array::Ptr{GByteArray}, index_::guint)::Ptr{GByteArray}
end

"""
    g_byte_array_remove_index_fast(array, index_)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GByteArray* g_byte_array_remove_index_fast (GByteArray *array, guint index_);
```
"""
function g_byte_array_remove_index_fast(array, index_)
    @ccall libaravis.g_byte_array_remove_index_fast(array::Ptr{GByteArray}, index_::guint)::Ptr{GByteArray}
end

"""
    g_byte_array_remove_range(array, index_, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GByteArray* g_byte_array_remove_range (GByteArray *array, guint index_, guint length);
```
"""
function g_byte_array_remove_range(array, index_, length)
    @ccall libaravis.g_byte_array_remove_range(array::Ptr{GByteArray}, index_::guint, length::guint)::Ptr{GByteArray}
end

"""
    g_byte_array_sort(array, compare_func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_byte_array_sort (GByteArray *array, GCompareFunc compare_func);
```
"""
function g_byte_array_sort(array, compare_func)
    @ccall libaravis.g_byte_array_sort(array::Ptr{GByteArray}, compare_func::GCompareFunc)::Cvoid
end

"""
    g_byte_array_sort_with_data(array, compare_func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_byte_array_sort_with_data (GByteArray *array, GCompareDataFunc compare_func, gpointer user_data);
```
"""
function g_byte_array_sort_with_data(array, compare_func, user_data)
    @ccall libaravis.g_byte_array_sort_with_data(array::Ptr{GByteArray}, compare_func::GCompareDataFunc, user_data::gpointer)::Cvoid
end

"""
    g_atomic_int_exchange_and_add(atomic, val)

### Prototype
```c
GLIB_DEPRECATED_IN_2_30_FOR(g_atomic_int_add) gint g_atomic_int_exchange_and_add (volatile gint *atomic, gint val);
```
"""
function g_atomic_int_exchange_and_add(atomic, val)
    @ccall libaravis.g_atomic_int_exchange_and_add(atomic::Ptr{gint}, val::gint)::gint
end

"""
    g_quark_to_string(quark)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_quark_to_string (GQuark quark) G_GNUC_CONST;
```
"""
function g_quark_to_string(quark)
    @ccall libaravis.g_quark_to_string(quark::GQuark)::Ptr{gchar}
end

"""
    g_intern_string(string)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_intern_string (const gchar *string);
```
"""
function g_intern_string(string)
    @ccall libaravis.g_intern_string(string::Ptr{gchar})::Ptr{gchar}
end

"""
    g_error_domain_register(error_type_name, error_type_private_size, error_type_init, error_type_copy, error_type_clear)

### Prototype
```c
GLIB_AVAILABLE_IN_2_68 GQuark g_error_domain_register (const char *error_type_name, gsize error_type_private_size, GErrorInitFunc error_type_init, GErrorCopyFunc error_type_copy, GErrorClearFunc error_type_clear);
```
"""
function g_error_domain_register(error_type_name, error_type_private_size, error_type_init, error_type_copy, error_type_clear)
    @ccall libaravis.g_error_domain_register(error_type_name::Cstring, error_type_private_size::gsize, error_type_init::GErrorInitFunc, error_type_copy::GErrorCopyFunc, error_type_clear::GErrorClearFunc)::GQuark
end

"""
    g_error_new_literal(domain, code, message)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GError* g_error_new_literal (GQuark domain, gint code, const gchar *message);
```
"""
function g_error_new_literal(domain, code, message)
    @ccall libaravis.g_error_new_literal(domain::GQuark, code::gint, message::Ptr{gchar})::Ptr{GError}
end

"""
    g_error_free(error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_error_free (GError *error);
```
"""
function g_error_free(error)
    @ccall libaravis.g_error_free(error::Ptr{GError})::Cvoid
end

"""
    g_error_copy(error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GError* g_error_copy (const GError *error);
```
"""
function g_error_copy(error)
    @ccall libaravis.g_error_copy(error::Ptr{GError})::Ptr{GError}
end

"""
    g_error_matches(error, domain, code)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_error_matches (const GError *error, GQuark domain, gint code);
```
"""
function g_error_matches(error, domain, code)
    @ccall libaravis.g_error_matches(error::Ptr{GError}, domain::GQuark, code::gint)::gboolean
end

"""
    g_set_error_literal(err, domain, code, message)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_set_error_literal (GError **err, GQuark domain, gint code, const gchar *message);
```
"""
function g_set_error_literal(err, domain, code, message)
    @ccall libaravis.g_set_error_literal(err::Ptr{Ptr{GError}}, domain::GQuark, code::gint, message::Ptr{gchar})::Cvoid
end

"""
    g_propagate_error(dest, src)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_propagate_error (GError **dest, GError *src);
```
"""
function g_propagate_error(dest, src)
    @ccall libaravis.g_propagate_error(dest::Ptr{Ptr{GError}}, src::Ptr{GError})::Cvoid
end

"""
    g_clear_error(err)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_clear_error (GError **err);
```
"""
function g_clear_error(err)
    @ccall libaravis.g_clear_error(err::Ptr{Ptr{GError}})::Cvoid
end

"""
    g_prefix_error_literal(err, prefix)

### Prototype
```c
GLIB_AVAILABLE_IN_2_70 void g_prefix_error_literal (GError **err, const gchar *prefix);
```
"""
function g_prefix_error_literal(err, prefix)
    @ccall libaravis.g_prefix_error_literal(err::Ptr{Ptr{GError}}, prefix::Ptr{gchar})::Cvoid
end

"""
    g_get_user_name()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_get_user_name (void);
```
"""
function g_get_user_name()
    @ccall libaravis.g_get_user_name()::Ptr{gchar}
end

"""
    g_get_real_name()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_get_real_name (void);
```
"""
function g_get_real_name()
    @ccall libaravis.g_get_real_name()::Ptr{gchar}
end

"""
    g_get_home_dir()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_get_home_dir (void);
```
"""
function g_get_home_dir()
    @ccall libaravis.g_get_home_dir()::Ptr{gchar}
end

"""
    g_get_tmp_dir()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_get_tmp_dir (void);
```
"""
function g_get_tmp_dir()
    @ccall libaravis.g_get_tmp_dir()::Ptr{gchar}
end

"""
    g_get_host_name()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_get_host_name (void);
```
"""
function g_get_host_name()
    @ccall libaravis.g_get_host_name()::Ptr{gchar}
end

"""
    g_get_prgname()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_get_prgname (void);
```
"""
function g_get_prgname()
    @ccall libaravis.g_get_prgname()::Ptr{gchar}
end

"""
    g_set_prgname(prgname)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_set_prgname (const gchar *prgname);
```
"""
function g_set_prgname(prgname)
    @ccall libaravis.g_set_prgname(prgname::Ptr{gchar})::Cvoid
end

"""
    g_get_application_name()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_get_application_name (void);
```
"""
function g_get_application_name()
    @ccall libaravis.g_get_application_name()::Ptr{gchar}
end

"""
    g_set_application_name(application_name)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_set_application_name (const gchar *application_name);
```
"""
function g_set_application_name(application_name)
    @ccall libaravis.g_set_application_name(application_name::Ptr{gchar})::Cvoid
end

"""
    g_get_os_info(key_name)

### Prototype
```c
GLIB_AVAILABLE_IN_2_64 gchar * g_get_os_info (const gchar *key_name);
```
"""
function g_get_os_info(key_name)
    @ccall libaravis.g_get_os_info(key_name::Ptr{gchar})::Ptr{gchar}
end

"""
    g_reload_user_special_dirs_cache()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_reload_user_special_dirs_cache (void);
```
"""
function g_reload_user_special_dirs_cache()
    @ccall libaravis.g_reload_user_special_dirs_cache()::Cvoid
end

"""
    g_get_user_data_dir()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_get_user_data_dir (void);
```
"""
function g_get_user_data_dir()
    @ccall libaravis.g_get_user_data_dir()::Ptr{gchar}
end

"""
    g_get_user_config_dir()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_get_user_config_dir (void);
```
"""
function g_get_user_config_dir()
    @ccall libaravis.g_get_user_config_dir()::Ptr{gchar}
end

"""
    g_get_user_cache_dir()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_get_user_cache_dir (void);
```
"""
function g_get_user_cache_dir()
    @ccall libaravis.g_get_user_cache_dir()::Ptr{gchar}
end

"""
    g_get_user_state_dir()

### Prototype
```c
GLIB_AVAILABLE_IN_2_72 const gchar * g_get_user_state_dir (void);
```
"""
function g_get_user_state_dir()
    @ccall libaravis.g_get_user_state_dir()::Ptr{gchar}
end

"""
    g_get_system_data_dirs()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * const * g_get_system_data_dirs (void);
```
"""
function g_get_system_data_dirs()
    @ccall libaravis.g_get_system_data_dirs()::Ptr{Ptr{gchar}}
end

"""
    g_get_system_config_dirs()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * const * g_get_system_config_dirs (void);
```
"""
function g_get_system_config_dirs()
    @ccall libaravis.g_get_system_config_dirs()::Ptr{Ptr{gchar}}
end

"""
    g_get_user_runtime_dir()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_get_user_runtime_dir (void);
```
"""
function g_get_user_runtime_dir()
    @ccall libaravis.g_get_user_runtime_dir()::Ptr{gchar}
end

"""
    GUserDirectory

[`GUserDirectory`](@ref): \\_USER\\_DIRECTORY\\_DESKTOP: the user's Desktop directory \\_USER\\_DIRECTORY\\_DOCUMENTS: the user's Documents directory \\_USER\\_DIRECTORY\\_DOWNLOAD: the user's Downloads directory \\_USER\\_DIRECTORY\\_MUSIC: the user's Music directory \\_USER\\_DIRECTORY\\_PICTURES: the user's Pictures directory \\_USER\\_DIRECTORY\\_PUBLIC\\_SHARE: the user's shared directory \\_USER\\_DIRECTORY\\_TEMPLATES: the user's Templates directory \\_USER\\_DIRECTORY\\_VIDEOS: the user's Movies directory \\_USER\\_N\\_DIRECTORIES: the number of enum values

These are logical ids for special directories which are defined depending on the platform used. You should use [`g_get_user_special_dir`](@ref)() to retrieve the full path associated to the logical id.

The #[`GUserDirectory`](@ref) enumeration can be extended at later date. Not every platform has a directory for every logical id in this enumeration.

Since: 2.14
"""
@cenum GUserDirectory::UInt32 begin
    G_USER_DIRECTORY_DESKTOP = 0
    G_USER_DIRECTORY_DOCUMENTS = 1
    G_USER_DIRECTORY_DOWNLOAD = 2
    G_USER_DIRECTORY_MUSIC = 3
    G_USER_DIRECTORY_PICTURES = 4
    G_USER_DIRECTORY_PUBLIC_SHARE = 5
    G_USER_DIRECTORY_TEMPLATES = 6
    G_USER_DIRECTORY_VIDEOS = 7
    G_USER_N_DIRECTORIES = 8
end

"""
    g_get_user_special_dir(directory)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_get_user_special_dir (GUserDirectory directory);
```
"""
function g_get_user_special_dir(directory)
    @ccall libaravis.g_get_user_special_dir(directory::GUserDirectory)::Ptr{gchar}
end

struct _GDebugKey
    key::Ptr{gchar}
    value::guint
end

"""
[`GDebugKey`](@ref): : the string : the flag

Associates a string with a bit flag. Used in [`g_parse_debug_string`](@ref)().
"""
const GDebugKey = _GDebugKey

"""
    g_parse_debug_string(string, keys, nkeys)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_parse_debug_string (const gchar *string, const GDebugKey *keys, guint nkeys);
```
"""
function g_parse_debug_string(string, keys, nkeys)
    @ccall libaravis.g_parse_debug_string(string::Ptr{gchar}, keys::Ptr{GDebugKey}, nkeys::guint)::guint
end

"""
    g_nullify_pointer(nullify_location)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_nullify_pointer (gpointer *nullify_location);
```
"""
function g_nullify_pointer(nullify_location)
    @ccall libaravis.g_nullify_pointer(nullify_location::Ptr{gpointer})::Cvoid
end

@cenum GFormatSizeFlags::UInt32 begin
    G_FORMAT_SIZE_DEFAULT = 0
    G_FORMAT_SIZE_LONG_FORMAT = 1
    G_FORMAT_SIZE_IEC_UNITS = 2
    G_FORMAT_SIZE_BITS = 4
    G_FORMAT_SIZE_ONLY_VALUE = 8
    G_FORMAT_SIZE_ONLY_UNIT = 16
end

"""
    g_format_size_full(size, flags)

### Prototype
```c
GLIB_AVAILABLE_IN_2_30 gchar *g_format_size_full (guint64 size, GFormatSizeFlags flags);
```
"""
function g_format_size_full(size, flags)
    @ccall libaravis.g_format_size_full(size::guint64, flags::GFormatSizeFlags)::Ptr{gchar}
end

"""
    g_format_size(size)

### Prototype
```c
GLIB_AVAILABLE_IN_2_30 gchar *g_format_size (guint64 size);
```
"""
function g_format_size(size)
    @ccall libaravis.g_format_size(size::guint64)::Ptr{gchar}
end

"""
    g_format_size_for_display(size)

### Prototype
```c
GLIB_DEPRECATED_IN_2_30_FOR(g_format_size) gchar *g_format_size_for_display (goffset size);
```
"""
function g_format_size_for_display(size)
    @ccall libaravis.g_format_size_for_display(size::goffset)::Ptr{gchar}
end

# typedef void ( * GVoidFunc ) ( void )
"""
[`GVoidFunc`](@ref):

Declares a type of function which takes no arguments and has no return value. It is used to specify the type function passed to [`g_atexit`](@ref)().
"""
const GVoidFunc = Ptr{Cvoid}

"""
    g_atexit(func)

### Prototype
```c
GLIB_DEPRECATED void g_atexit (GVoidFunc func);
```
"""
function g_atexit(func)
    @ccall libaravis.g_atexit(func::GVoidFunc)::Cvoid
end

"""
    g_find_program_in_path(program)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_find_program_in_path (const gchar *program);
```
"""
function g_find_program_in_path(program)
    @ccall libaravis.g_find_program_in_path(program::Ptr{gchar})::Ptr{gchar}
end

@cenum GThreadError::UInt32 begin
    G_THREAD_ERROR_AGAIN = 0
end

@cenum GThreadPriority::UInt32 begin
    G_THREAD_PRIORITY_LOW = 0
    G_THREAD_PRIORITY_NORMAL = 1
    G_THREAD_PRIORITY_HIGH = 2
    G_THREAD_PRIORITY_URGENT = 3
end

struct _GThread
    func::GThreadFunc
    data::gpointer
    joinable::gboolean
    priority::GThreadPriority
end

const GThread = _GThread

struct _GCond
    p::gpointer
    i::NTuple{2, guint}
end

const GCond = _GCond

struct _GPrivate
    p::gpointer
    notify::GDestroyNotify
    future::NTuple{2, gpointer}
end

const GPrivate = _GPrivate

"""
    g_thread_ref(thread)

### Prototype
```c
GLIB_AVAILABLE_IN_2_32 GThread * g_thread_ref (GThread *thread);
```
"""
function g_thread_ref(thread)
    @ccall libaravis.g_thread_ref(thread::Ptr{GThread})::Ptr{GThread}
end

"""
    g_thread_unref(thread)

### Prototype
```c
GLIB_AVAILABLE_IN_2_32 void g_thread_unref (GThread *thread);
```
"""
function g_thread_unref(thread)
    @ccall libaravis.g_thread_unref(thread::Ptr{GThread})::Cvoid
end

"""
    g_thread_new(name, func, data)

### Prototype
```c
GLIB_AVAILABLE_IN_2_32 GThread * g_thread_new (const gchar *name, GThreadFunc func, gpointer data);
```
"""
function g_thread_new(name, func, data)
    @ccall libaravis.g_thread_new(name::Ptr{gchar}, func::GThreadFunc, data::gpointer)::Ptr{GThread}
end

"""
    g_thread_try_new(name, func, data, error)

### Prototype
```c
GLIB_AVAILABLE_IN_2_32 GThread * g_thread_try_new (const gchar *name, GThreadFunc func, gpointer data, GError **error);
```
"""
function g_thread_try_new(name, func, data, error)
    @ccall libaravis.g_thread_try_new(name::Ptr{gchar}, func::GThreadFunc, data::gpointer, error::Ptr{Ptr{GError}})::Ptr{GThread}
end

"""
    g_thread_self()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GThread * g_thread_self (void);
```
"""
function g_thread_self()
    @ccall libaravis.g_thread_self()::Ptr{GThread}
end

"""
    g_thread_exit(retval)

### Prototype
```c
G_NORETURN GLIB_AVAILABLE_IN_ALL void g_thread_exit (gpointer retval);
```
"""
function g_thread_exit(retval)
    @ccall libaravis.g_thread_exit(retval::gpointer)::Cvoid
end

"""
    g_thread_join(thread)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_thread_join (GThread *thread);
```
"""
function g_thread_join(thread)
    @ccall libaravis.g_thread_join(thread::Ptr{GThread})::gpointer
end

"""
    g_thread_yield()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_thread_yield (void);
```
"""
function g_thread_yield()
    @ccall libaravis.g_thread_yield()::Cvoid
end

"""
    g_thread_get_name(thread)

### Prototype
```c
GLIB_AVAILABLE_IN_2_84 const char * g_thread_get_name (GThread *thread);
```
"""
function g_thread_get_name(thread)
    @ccall libaravis.g_thread_get_name(thread::Ptr{GThread})::Cstring
end

"""
    g_mutex_clear(mutex)

### Prototype
```c
GLIB_AVAILABLE_IN_2_32 void g_mutex_clear (GMutex *mutex);
```
"""
function g_mutex_clear(mutex)
    @ccall libaravis.g_mutex_clear(mutex::Ptr{GMutex})::Cvoid
end

"""
    g_rw_lock_clear(rw_lock)

### Prototype
```c
GLIB_AVAILABLE_IN_2_32 void g_rw_lock_clear (GRWLock *rw_lock);
```
"""
function g_rw_lock_clear(rw_lock)
    @ccall libaravis.g_rw_lock_clear(rw_lock::Ptr{GRWLock})::Cvoid
end

"""
    g_rw_lock_writer_lock(rw_lock)

### Prototype
```c
GLIB_AVAILABLE_IN_2_32 void g_rw_lock_writer_lock (GRWLock *rw_lock);
```
"""
function g_rw_lock_writer_lock(rw_lock)
    @ccall libaravis.g_rw_lock_writer_lock(rw_lock::Ptr{GRWLock})::Cvoid
end

"""
    g_rw_lock_writer_trylock(rw_lock)

### Prototype
```c
GLIB_AVAILABLE_IN_2_32 gboolean g_rw_lock_writer_trylock (GRWLock *rw_lock);
```
"""
function g_rw_lock_writer_trylock(rw_lock)
    @ccall libaravis.g_rw_lock_writer_trylock(rw_lock::Ptr{GRWLock})::gboolean
end

"""
    g_rw_lock_writer_unlock(rw_lock)

### Prototype
```c
GLIB_AVAILABLE_IN_2_32 void g_rw_lock_writer_unlock (GRWLock *rw_lock);
```
"""
function g_rw_lock_writer_unlock(rw_lock)
    @ccall libaravis.g_rw_lock_writer_unlock(rw_lock::Ptr{GRWLock})::Cvoid
end

"""
    g_rw_lock_reader_lock(rw_lock)

### Prototype
```c
GLIB_AVAILABLE_IN_2_32 void g_rw_lock_reader_lock (GRWLock *rw_lock);
```
"""
function g_rw_lock_reader_lock(rw_lock)
    @ccall libaravis.g_rw_lock_reader_lock(rw_lock::Ptr{GRWLock})::Cvoid
end

"""
    g_rw_lock_reader_trylock(rw_lock)

### Prototype
```c
GLIB_AVAILABLE_IN_2_32 gboolean g_rw_lock_reader_trylock (GRWLock *rw_lock);
```
"""
function g_rw_lock_reader_trylock(rw_lock)
    @ccall libaravis.g_rw_lock_reader_trylock(rw_lock::Ptr{GRWLock})::gboolean
end

"""
    g_rw_lock_reader_unlock(rw_lock)

### Prototype
```c
GLIB_AVAILABLE_IN_2_32 void g_rw_lock_reader_unlock (GRWLock *rw_lock);
```
"""
function g_rw_lock_reader_unlock(rw_lock)
    @ccall libaravis.g_rw_lock_reader_unlock(rw_lock::Ptr{GRWLock})::Cvoid
end

"""
    g_rec_mutex_clear(rec_mutex)

### Prototype
```c
GLIB_AVAILABLE_IN_2_32 void g_rec_mutex_clear (GRecMutex *rec_mutex);
```
"""
function g_rec_mutex_clear(rec_mutex)
    @ccall libaravis.g_rec_mutex_clear(rec_mutex::Ptr{GRecMutex})::Cvoid
end

"""
    g_rec_mutex_lock(rec_mutex)

### Prototype
```c
GLIB_AVAILABLE_IN_2_32 void g_rec_mutex_lock (GRecMutex *rec_mutex);
```
"""
function g_rec_mutex_lock(rec_mutex)
    @ccall libaravis.g_rec_mutex_lock(rec_mutex::Ptr{GRecMutex})::Cvoid
end

"""
    g_rec_mutex_trylock(rec_mutex)

### Prototype
```c
GLIB_AVAILABLE_IN_2_32 gboolean g_rec_mutex_trylock (GRecMutex *rec_mutex);
```
"""
function g_rec_mutex_trylock(rec_mutex)
    @ccall libaravis.g_rec_mutex_trylock(rec_mutex::Ptr{GRecMutex})::gboolean
end

"""
    g_rec_mutex_unlock(rec_mutex)

### Prototype
```c
GLIB_AVAILABLE_IN_2_32 void g_rec_mutex_unlock (GRecMutex *rec_mutex);
```
"""
function g_rec_mutex_unlock(rec_mutex)
    @ccall libaravis.g_rec_mutex_unlock(rec_mutex::Ptr{GRecMutex})::Cvoid
end

"""
    g_cond_init(cond)

### Prototype
```c
GLIB_AVAILABLE_IN_2_32 void g_cond_init (GCond *cond);
```
"""
function g_cond_init(cond)
    @ccall libaravis.g_cond_init(cond::Ptr{GCond})::Cvoid
end

"""
    g_cond_clear(cond)

### Prototype
```c
GLIB_AVAILABLE_IN_2_32 void g_cond_clear (GCond *cond);
```
"""
function g_cond_clear(cond)
    @ccall libaravis.g_cond_clear(cond::Ptr{GCond})::Cvoid
end

"""
    g_cond_wait(cond, mutex)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_cond_wait (GCond *cond, GMutex *mutex);
```
"""
function g_cond_wait(cond, mutex)
    @ccall libaravis.g_cond_wait(cond::Ptr{GCond}, mutex::Ptr{GMutex})::Cvoid
end

"""
    g_cond_signal(cond)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_cond_signal (GCond *cond);
```
"""
function g_cond_signal(cond)
    @ccall libaravis.g_cond_signal(cond::Ptr{GCond})::Cvoid
end

"""
    g_cond_broadcast(cond)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_cond_broadcast (GCond *cond);
```
"""
function g_cond_broadcast(cond)
    @ccall libaravis.g_cond_broadcast(cond::Ptr{GCond})::Cvoid
end

"""
    g_cond_wait_until(cond, mutex, end_time)

### Prototype
```c
GLIB_AVAILABLE_IN_2_32 gboolean g_cond_wait_until (GCond *cond, GMutex *mutex, gint64 end_time);
```
"""
function g_cond_wait_until(cond, mutex, end_time)
    @ccall libaravis.g_cond_wait_until(cond::Ptr{GCond}, mutex::Ptr{GMutex}, end_time::gint64)::gboolean
end

"""
    g_private_get(key)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_private_get (GPrivate *key);
```
"""
function g_private_get(key)
    @ccall libaravis.g_private_get(key::Ptr{GPrivate})::gpointer
end

"""
    g_private_set(key, value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_private_set (GPrivate *key, gpointer value);
```
"""
function g_private_set(key, value)
    @ccall libaravis.g_private_set(key::Ptr{GPrivate}, value::gpointer)::Cvoid
end

"""
    g_private_replace(key, value)

### Prototype
```c
GLIB_AVAILABLE_IN_2_32 void g_private_replace (GPrivate *key, gpointer value);
```
"""
function g_private_replace(key, value)
    @ccall libaravis.g_private_replace(key::Ptr{GPrivate}, value::gpointer)::Cvoid
end

"""
    g_get_num_processors()

### Prototype
```c
GLIB_AVAILABLE_IN_2_36 guint g_get_num_processors (void);
```
"""
function g_get_num_processors()
    @ccall libaravis.g_get_num_processors()::guint
end

"""
    g_mutex_locker_free(locker)

[`g_mutex_locker_free`](@ref): : a [`GMutexLocker`](@ref)

Unlock 's mutex. See [`g_mutex_locker_new`](@ref)() for details.

No memory is freed, it is equivalent to a [`g_mutex_unlock`](@ref)() call.

Since: 2.44

### Prototype
```c
static inline void g_mutex_locker_free (GMutexLocker *locker);
```
"""
function g_mutex_locker_free(locker)
    @ccall libaravis.g_mutex_locker_free(locker::Ptr{GMutexLocker})::Cvoid
end

"""
    g_rec_mutex_locker_free(locker)

[`g_rec_mutex_locker_free`](@ref): : a [`GRecMutexLocker`](@ref)

Unlock 's recursive mutex. See [`g_rec_mutex_locker_new`](@ref)() for details.

No memory is freed, it is equivalent to a [`g_rec_mutex_unlock`](@ref)() call.

Since: 2.60

### Prototype
```c
static inline void g_rec_mutex_locker_free (GRecMutexLocker *locker);
```
"""
function g_rec_mutex_locker_free(locker)
    @ccall libaravis.g_rec_mutex_locker_free(locker::Ptr{GRecMutexLocker})::Cvoid
end

"""
    g_rw_lock_writer_locker_free(locker)

[`g_rw_lock_writer_locker_free`](@ref): : a [`GRWLockWriterLocker`](@ref)

Release a write lock on 's read-write lock. See [`g_rw_lock_writer_locker_new`](@ref)() for details.

No memory is freed, it is equivalent to a [`g_rw_lock_writer_unlock`](@ref)() call.

Since: 2.62

### Prototype
```c
static inline void g_rw_lock_writer_locker_free (GRWLockWriterLocker *locker);
```
"""
function g_rw_lock_writer_locker_free(locker)
    @ccall libaravis.g_rw_lock_writer_locker_free(locker::Ptr{GRWLockWriterLocker})::Cvoid
end

"""
    g_rw_lock_reader_locker_free(locker)

[`g_rw_lock_reader_locker_free`](@ref): : a [`GRWLockReaderLocker`](@ref)

Release a read lock on 's read-write lock. See [`g_rw_lock_reader_locker_new`](@ref)() for details.

No memory is freed, it is equivalent to a [`g_rw_lock_reader_unlock`](@ref)() call.

Since: 2.62

### Prototype
```c
static inline void g_rw_lock_reader_locker_free (GRWLockReaderLocker *locker);
```
"""
function g_rw_lock_reader_locker_free(locker)
    @ccall libaravis.g_rw_lock_reader_locker_free(locker::Ptr{GRWLockReaderLocker})::Cvoid
end

const _GAsyncQueue = Cvoid

const GAsyncQueue = _GAsyncQueue

"""
    g_async_queue_new()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GAsyncQueue *g_async_queue_new (void);
```
"""
function g_async_queue_new()
    @ccall libaravis.g_async_queue_new()::Ptr{GAsyncQueue}
end

"""
    g_async_queue_new_full(item_free_func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GAsyncQueue *g_async_queue_new_full (GDestroyNotify item_free_func);
```
"""
function g_async_queue_new_full(item_free_func)
    @ccall libaravis.g_async_queue_new_full(item_free_func::GDestroyNotify)::Ptr{GAsyncQueue}
end

"""
    g_async_queue_lock(queue)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_async_queue_lock (GAsyncQueue *queue);
```
"""
function g_async_queue_lock(queue)
    @ccall libaravis.g_async_queue_lock(queue::Ptr{GAsyncQueue})::Cvoid
end

"""
    g_async_queue_unlock(queue)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_async_queue_unlock (GAsyncQueue *queue);
```
"""
function g_async_queue_unlock(queue)
    @ccall libaravis.g_async_queue_unlock(queue::Ptr{GAsyncQueue})::Cvoid
end

"""
    g_async_queue_ref(queue)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GAsyncQueue *g_async_queue_ref (GAsyncQueue *queue);
```
"""
function g_async_queue_ref(queue)
    @ccall libaravis.g_async_queue_ref(queue::Ptr{GAsyncQueue})::Ptr{GAsyncQueue}
end

"""
    g_async_queue_unref(queue)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_async_queue_unref (GAsyncQueue *queue);
```
"""
function g_async_queue_unref(queue)
    @ccall libaravis.g_async_queue_unref(queue::Ptr{GAsyncQueue})::Cvoid
end

"""
    g_async_queue_ref_unlocked(queue)

### Prototype
```c
GLIB_DEPRECATED_FOR(g_async_queue_ref) void g_async_queue_ref_unlocked (GAsyncQueue *queue);
```
"""
function g_async_queue_ref_unlocked(queue)
    @ccall libaravis.g_async_queue_ref_unlocked(queue::Ptr{GAsyncQueue})::Cvoid
end

"""
    g_async_queue_unref_and_unlock(queue)

### Prototype
```c
GLIB_DEPRECATED_FOR(g_async_queue_unref) void g_async_queue_unref_and_unlock (GAsyncQueue *queue);
```
"""
function g_async_queue_unref_and_unlock(queue)
    @ccall libaravis.g_async_queue_unref_and_unlock(queue::Ptr{GAsyncQueue})::Cvoid
end

"""
    g_async_queue_push(queue, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_async_queue_push (GAsyncQueue *queue, gpointer data);
```
"""
function g_async_queue_push(queue, data)
    @ccall libaravis.g_async_queue_push(queue::Ptr{GAsyncQueue}, data::gpointer)::Cvoid
end

"""
    g_async_queue_push_unlocked(queue, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_async_queue_push_unlocked (GAsyncQueue *queue, gpointer data);
```
"""
function g_async_queue_push_unlocked(queue, data)
    @ccall libaravis.g_async_queue_push_unlocked(queue::Ptr{GAsyncQueue}, data::gpointer)::Cvoid
end

"""
    g_async_queue_push_sorted(queue, data, func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_async_queue_push_sorted (GAsyncQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data);
```
"""
function g_async_queue_push_sorted(queue, data, func, user_data)
    @ccall libaravis.g_async_queue_push_sorted(queue::Ptr{GAsyncQueue}, data::gpointer, func::GCompareDataFunc, user_data::gpointer)::Cvoid
end

"""
    g_async_queue_push_sorted_unlocked(queue, data, func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_async_queue_push_sorted_unlocked (GAsyncQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data);
```
"""
function g_async_queue_push_sorted_unlocked(queue, data, func, user_data)
    @ccall libaravis.g_async_queue_push_sorted_unlocked(queue::Ptr{GAsyncQueue}, data::gpointer, func::GCompareDataFunc, user_data::gpointer)::Cvoid
end

"""
    g_async_queue_pop(queue)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_async_queue_pop (GAsyncQueue *queue);
```
"""
function g_async_queue_pop(queue)
    @ccall libaravis.g_async_queue_pop(queue::Ptr{GAsyncQueue})::gpointer
end

"""
    g_async_queue_pop_unlocked(queue)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_async_queue_pop_unlocked (GAsyncQueue *queue);
```
"""
function g_async_queue_pop_unlocked(queue)
    @ccall libaravis.g_async_queue_pop_unlocked(queue::Ptr{GAsyncQueue})::gpointer
end

"""
    g_async_queue_try_pop(queue)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_async_queue_try_pop (GAsyncQueue *queue);
```
"""
function g_async_queue_try_pop(queue)
    @ccall libaravis.g_async_queue_try_pop(queue::Ptr{GAsyncQueue})::gpointer
end

"""
    g_async_queue_try_pop_unlocked(queue)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_async_queue_try_pop_unlocked (GAsyncQueue *queue);
```
"""
function g_async_queue_try_pop_unlocked(queue)
    @ccall libaravis.g_async_queue_try_pop_unlocked(queue::Ptr{GAsyncQueue})::gpointer
end

"""
    g_async_queue_timeout_pop(queue, timeout)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_async_queue_timeout_pop (GAsyncQueue *queue, guint64 timeout);
```
"""
function g_async_queue_timeout_pop(queue, timeout)
    @ccall libaravis.g_async_queue_timeout_pop(queue::Ptr{GAsyncQueue}, timeout::guint64)::gpointer
end

"""
    g_async_queue_timeout_pop_unlocked(queue, timeout)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_async_queue_timeout_pop_unlocked (GAsyncQueue *queue, guint64 timeout);
```
"""
function g_async_queue_timeout_pop_unlocked(queue, timeout)
    @ccall libaravis.g_async_queue_timeout_pop_unlocked(queue::Ptr{GAsyncQueue}, timeout::guint64)::gpointer
end

"""
    g_async_queue_length(queue)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_async_queue_length (GAsyncQueue *queue);
```
"""
function g_async_queue_length(queue)
    @ccall libaravis.g_async_queue_length(queue::Ptr{GAsyncQueue})::gint
end

"""
    g_async_queue_length_unlocked(queue)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_async_queue_length_unlocked (GAsyncQueue *queue);
```
"""
function g_async_queue_length_unlocked(queue)
    @ccall libaravis.g_async_queue_length_unlocked(queue::Ptr{GAsyncQueue})::gint
end

"""
    g_async_queue_sort(queue, func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_async_queue_sort (GAsyncQueue *queue, GCompareDataFunc func, gpointer user_data);
```
"""
function g_async_queue_sort(queue, func, user_data)
    @ccall libaravis.g_async_queue_sort(queue::Ptr{GAsyncQueue}, func::GCompareDataFunc, user_data::gpointer)::Cvoid
end

"""
    g_async_queue_sort_unlocked(queue, func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_async_queue_sort_unlocked (GAsyncQueue *queue, GCompareDataFunc func, gpointer user_data);
```
"""
function g_async_queue_sort_unlocked(queue, func, user_data)
    @ccall libaravis.g_async_queue_sort_unlocked(queue::Ptr{GAsyncQueue}, func::GCompareDataFunc, user_data::gpointer)::Cvoid
end

"""
    g_async_queue_remove(queue, item)

### Prototype
```c
GLIB_AVAILABLE_IN_2_46 gboolean g_async_queue_remove (GAsyncQueue *queue, gpointer item);
```
"""
function g_async_queue_remove(queue, item)
    @ccall libaravis.g_async_queue_remove(queue::Ptr{GAsyncQueue}, item::gpointer)::gboolean
end

"""
    g_async_queue_remove_unlocked(queue, item)

### Prototype
```c
GLIB_AVAILABLE_IN_2_46 gboolean g_async_queue_remove_unlocked (GAsyncQueue *queue, gpointer item);
```
"""
function g_async_queue_remove_unlocked(queue, item)
    @ccall libaravis.g_async_queue_remove_unlocked(queue::Ptr{GAsyncQueue}, item::gpointer)::gboolean
end

"""
    g_async_queue_push_front(queue, item)

### Prototype
```c
GLIB_AVAILABLE_IN_2_46 void g_async_queue_push_front (GAsyncQueue *queue, gpointer item);
```
"""
function g_async_queue_push_front(queue, item)
    @ccall libaravis.g_async_queue_push_front(queue::Ptr{GAsyncQueue}, item::gpointer)::Cvoid
end

"""
    g_async_queue_push_front_unlocked(queue, item)

### Prototype
```c
GLIB_AVAILABLE_IN_2_46 void g_async_queue_push_front_unlocked (GAsyncQueue *queue, gpointer item);
```
"""
function g_async_queue_push_front_unlocked(queue, item)
    @ccall libaravis.g_async_queue_push_front_unlocked(queue::Ptr{GAsyncQueue}, item::gpointer)::Cvoid
end

"""
    g_async_queue_timed_pop(queue, end_time)

### Prototype
```c
GLIB_DEPRECATED_FOR(g_async_queue_timeout_pop) gpointer g_async_queue_timed_pop (GAsyncQueue *queue, GTimeVal *end_time);
```
"""
function g_async_queue_timed_pop(queue, end_time)
    @ccall libaravis.g_async_queue_timed_pop(queue::Ptr{GAsyncQueue}, end_time::Ptr{GTimeVal})::gpointer
end

"""
    g_async_queue_timed_pop_unlocked(queue, end_time)

### Prototype
```c
GLIB_DEPRECATED_FOR(g_async_queue_timeout_pop_unlocked) gpointer g_async_queue_timed_pop_unlocked (GAsyncQueue *queue, GTimeVal *end_time);
```
"""
function g_async_queue_timed_pop_unlocked(queue, end_time)
    @ccall libaravis.g_async_queue_timed_pop_unlocked(queue::Ptr{GAsyncQueue}, end_time::Ptr{GTimeVal})::gpointer
end

"""
    g_on_error_query(prg_name)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_on_error_query (const gchar *prg_name);
```
"""
function g_on_error_query(prg_name)
    @ccall libaravis.g_on_error_query(prg_name::Ptr{gchar})::Cvoid
end

"""
    g_on_error_stack_trace(prg_name)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_on_error_stack_trace (const gchar *prg_name);
```
"""
function g_on_error_stack_trace(prg_name)
    @ccall libaravis.g_on_error_stack_trace(prg_name::Ptr{gchar})::Cvoid
end

"""
    g_base64_encode_step(in, len, break_lines, out, state, save)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gsize g_base64_encode_step (const guchar *in, gsize len, gboolean break_lines, gchar *out, gint *state, gint *save);
```
"""
function g_base64_encode_step(in, len, break_lines, out, state, save)
    @ccall libaravis.g_base64_encode_step(in::Ptr{guchar}, len::gsize, break_lines::gboolean, out::Ptr{gchar}, state::Ptr{gint}, save::Ptr{gint})::gsize
end

"""
    g_base64_encode_close(break_lines, out, state, save)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gsize g_base64_encode_close (gboolean break_lines, gchar *out, gint *state, gint *save);
```
"""
function g_base64_encode_close(break_lines, out, state, save)
    @ccall libaravis.g_base64_encode_close(break_lines::gboolean, out::Ptr{gchar}, state::Ptr{gint}, save::Ptr{gint})::gsize
end

"""
    g_base64_encode(data, len)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_base64_encode (const guchar *data, gsize len) G_GNUC_MALLOC;
```
"""
function g_base64_encode(data, len)
    @ccall libaravis.g_base64_encode(data::Ptr{guchar}, len::gsize)::Ptr{gchar}
end

"""
    g_base64_decode_step(in, len, out, state, save)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gsize g_base64_decode_step (const gchar *in, gsize len, guchar *out, gint *state, guint *save);
```
"""
function g_base64_decode_step(in, len, out, state, save)
    @ccall libaravis.g_base64_decode_step(in::Ptr{gchar}, len::gsize, out::Ptr{guchar}, state::Ptr{gint}, save::Ptr{guint})::gsize
end

"""
    g_base64_decode(text, out_len)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guchar *g_base64_decode (const gchar *text, gsize *out_len) G_GNUC_MALLOC;
```
"""
function g_base64_decode(text, out_len)
    @ccall libaravis.g_base64_decode(text::Ptr{gchar}, out_len::Ptr{gsize})::Ptr{guchar}
end

"""
    g_base64_decode_inplace(text, out_len)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guchar *g_base64_decode_inplace (gchar *text, gsize *out_len);
```
"""
function g_base64_decode_inplace(text, out_len)
    @ccall libaravis.g_base64_decode_inplace(text::Ptr{gchar}, out_len::Ptr{gsize})::Ptr{guchar}
end

"""
    g_bit_lock(address, lock_bit)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_bit_lock (volatile gint *address, gint lock_bit);
```
"""
function g_bit_lock(address, lock_bit)
    @ccall libaravis.g_bit_lock(address::Ptr{gint}, lock_bit::gint)::Cvoid
end

"""
    g_bit_lock_and_get(address, lock_bit, out_val)

### Prototype
```c
GLIB_AVAILABLE_IN_2_86 void g_bit_lock_and_get (gint *address, guint lock_bit, gint *out_val);
```
"""
function g_bit_lock_and_get(address, lock_bit, out_val)
    @ccall libaravis.g_bit_lock_and_get(address::Ptr{gint}, lock_bit::guint, out_val::Ptr{gint})::Cvoid
end

"""
    g_bit_trylock(address, lock_bit)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_bit_trylock (volatile gint *address, gint lock_bit);
```
"""
function g_bit_trylock(address, lock_bit)
    @ccall libaravis.g_bit_trylock(address::Ptr{gint}, lock_bit::gint)::gboolean
end

"""
    g_bit_unlock(address, lock_bit)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_bit_unlock (volatile gint *address, gint lock_bit);
```
"""
function g_bit_unlock(address, lock_bit)
    @ccall libaravis.g_bit_unlock(address::Ptr{gint}, lock_bit::gint)::Cvoid
end

"""
    g_bit_unlock_and_set(address, lock_bit, new_val, preserve_mask)

### Prototype
```c
GLIB_AVAILABLE_IN_2_86 void g_bit_unlock_and_set (gint *address, guint lock_bit, gint new_val, gint preserve_mask);
```
"""
function g_bit_unlock_and_set(address, lock_bit, new_val, preserve_mask)
    @ccall libaravis.g_bit_unlock_and_set(address::Ptr{gint}, lock_bit::guint, new_val::gint, preserve_mask::gint)::Cvoid
end

"""
    g_pointer_bit_lock_mask_ptr(ptr, lock_bit, set, preserve_mask, preserve_ptr)

### Prototype
```c
GLIB_AVAILABLE_IN_2_80 gpointer g_pointer_bit_lock_mask_ptr (gpointer ptr, guint lock_bit, gboolean set, guintptr preserve_mask, gpointer preserve_ptr);
```
"""
function g_pointer_bit_lock_mask_ptr(ptr, lock_bit, set, preserve_mask, preserve_ptr)
    @ccall libaravis.g_pointer_bit_lock_mask_ptr(ptr::gpointer, lock_bit::guint, set::gboolean, preserve_mask::guintptr, preserve_ptr::gpointer)::gpointer
end

const _GTimeZone = Cvoid

const GTimeZone = _GTimeZone

"""
    GTimeType

[`GTimeType`](@ref): \\_TIME\\_TYPE\\_STANDARD: the time is in local standard time \\_TIME\\_TYPE\\_DAYLIGHT: the time is in local daylight time \\_TIME\\_TYPE\\_UNIVERSAL: the time is in UTC

Disambiguates a given time in two ways.

First, specifies if the given time is in universal or local time.

Second, if the time is in local time, specifies if it is local standard time or local daylight time. This is important for the case where the same local time occurs twice (during daylight savings time transitions, for example).
"""
@cenum GTimeType::UInt32 begin
    G_TIME_TYPE_STANDARD = 0
    G_TIME_TYPE_DAYLIGHT = 1
    G_TIME_TYPE_UNIVERSAL = 2
end

"""
    g_time_zone_new(identifier)

### Prototype
```c
GLIB_DEPRECATED_IN_2_68_FOR (g_time_zone_new_identifier) GTimeZone * g_time_zone_new (const gchar *identifier);
```
"""
function g_time_zone_new(identifier)
    @ccall libaravis.g_time_zone_new(identifier::Ptr{gchar})::Ptr{GTimeZone}
end

"""
    g_time_zone_new_identifier(identifier)

### Prototype
```c
GLIB_AVAILABLE_IN_2_68 GTimeZone * g_time_zone_new_identifier (const gchar *identifier);
```
"""
function g_time_zone_new_identifier(identifier)
    @ccall libaravis.g_time_zone_new_identifier(identifier::Ptr{gchar})::Ptr{GTimeZone}
end

"""
    g_time_zone_new_utc()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GTimeZone * g_time_zone_new_utc (void);
```
"""
function g_time_zone_new_utc()
    @ccall libaravis.g_time_zone_new_utc()::Ptr{GTimeZone}
end

"""
    g_time_zone_new_local()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GTimeZone * g_time_zone_new_local (void);
```
"""
function g_time_zone_new_local()
    @ccall libaravis.g_time_zone_new_local()::Ptr{GTimeZone}
end

"""
    g_time_zone_new_offset(seconds)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 GTimeZone * g_time_zone_new_offset (gint32 seconds);
```
"""
function g_time_zone_new_offset(seconds)
    @ccall libaravis.g_time_zone_new_offset(seconds::gint32)::Ptr{GTimeZone}
end

"""
    g_time_zone_ref(tz)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GTimeZone * g_time_zone_ref (GTimeZone *tz);
```
"""
function g_time_zone_ref(tz)
    @ccall libaravis.g_time_zone_ref(tz::Ptr{GTimeZone})::Ptr{GTimeZone}
end

"""
    g_time_zone_unref(tz)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_time_zone_unref (GTimeZone *tz);
```
"""
function g_time_zone_unref(tz)
    @ccall libaravis.g_time_zone_unref(tz::Ptr{GTimeZone})::Cvoid
end

"""
    g_time_zone_find_interval(tz, type, time_)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_time_zone_find_interval (GTimeZone *tz, GTimeType type, gint64 time_);
```
"""
function g_time_zone_find_interval(tz, type, time_)
    @ccall libaravis.g_time_zone_find_interval(tz::Ptr{GTimeZone}, type::GTimeType, time_::gint64)::gint
end

"""
    g_time_zone_adjust_time(tz, type, time_)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_time_zone_adjust_time (GTimeZone *tz, GTimeType type, gint64 *time_);
```
"""
function g_time_zone_adjust_time(tz, type, time_)
    @ccall libaravis.g_time_zone_adjust_time(tz::Ptr{GTimeZone}, type::GTimeType, time_::Ptr{gint64})::gint
end

"""
    g_time_zone_get_abbreviation(tz, interval)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_time_zone_get_abbreviation (GTimeZone *tz, gint interval);
```
"""
function g_time_zone_get_abbreviation(tz, interval)
    @ccall libaravis.g_time_zone_get_abbreviation(tz::Ptr{GTimeZone}, interval::gint)::Ptr{gchar}
end

"""
    g_time_zone_get_offset(tz, interval)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint32 g_time_zone_get_offset (GTimeZone *tz, gint interval);
```
"""
function g_time_zone_get_offset(tz, interval)
    @ccall libaravis.g_time_zone_get_offset(tz::Ptr{GTimeZone}, interval::gint)::gint32
end

"""
    g_time_zone_is_dst(tz, interval)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_time_zone_is_dst (GTimeZone *tz, gint interval);
```
"""
function g_time_zone_is_dst(tz, interval)
    @ccall libaravis.g_time_zone_is_dst(tz::Ptr{GTimeZone}, interval::gint)::gboolean
end

"""
    g_time_zone_get_identifier(tz)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 const gchar * g_time_zone_get_identifier (GTimeZone *tz);
```
"""
function g_time_zone_get_identifier(tz)
    @ccall libaravis.g_time_zone_get_identifier(tz::Ptr{GTimeZone})::Ptr{gchar}
end

"""
[`GTimeSpan`](@ref):

A value representing an interval of time, in microseconds.

Since: 2.26
"""
const GTimeSpan = gint64

const _GDateTime = Cvoid

"""
[`GDateTime`](@ref):

[`GDateTime`](@ref) is a structure that combines a Gregorian date and time into a single structure.

[`GDateTime`](@ref) provides many conversion and methods to manipulate dates and times. Time precision is provided down to microseconds and the time can range (proleptically) from 0001-01-01 00:00:00 to 9999-12-31 23:59:59.999999. [`GDateTime`](@ref) follows POSIX time in the sense that it is oblivious to leap seconds.

[`GDateTime`](@ref) is an immutable object; once it has been created it cannot be modified further. All modifiers will create a new [`GDateTime`](@ref). Nearly all such functions can fail due to the date or time going out of range, in which case NULL will be returned.

[`GDateTime`](@ref) is reference counted: the reference count is increased by calling [method.DateTime.ref] and decreased by calling [method.DateTime.unref]. When the reference count drops to 0, the resources allocated by the [`GDateTime`](@ref) structure are released.

Many parts of the API may produce non-obvious results. As an example, adding two months to January 31st will yield March 31st whereas adding one month and then one month again will yield either March 28th or March 29th. Also note that adding 24 hours is not always the same as adding one day (since days containing daylight savings time transitions are either 23 or 25 hours in length).

Since: 2.26
"""
const GDateTime = _GDateTime

"""
    g_date_time_unref(datetime)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_date_time_unref (GDateTime *datetime);
```
"""
function g_date_time_unref(datetime)
    @ccall libaravis.g_date_time_unref(datetime::Ptr{GDateTime})::Cvoid
end

"""
    g_date_time_ref(datetime)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GDateTime * g_date_time_ref (GDateTime *datetime);
```
"""
function g_date_time_ref(datetime)
    @ccall libaravis.g_date_time_ref(datetime::Ptr{GDateTime})::Ptr{GDateTime}
end

"""
    g_date_time_new_now(tz)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GDateTime * g_date_time_new_now (GTimeZone *tz);
```
"""
function g_date_time_new_now(tz)
    @ccall libaravis.g_date_time_new_now(tz::Ptr{GTimeZone})::Ptr{GDateTime}
end

"""
    g_date_time_new_now_local()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GDateTime * g_date_time_new_now_local (void);
```
"""
function g_date_time_new_now_local()
    @ccall libaravis.g_date_time_new_now_local()::Ptr{GDateTime}
end

"""
    g_date_time_new_now_utc()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GDateTime * g_date_time_new_now_utc (void);
```
"""
function g_date_time_new_now_utc()
    @ccall libaravis.g_date_time_new_now_utc()::Ptr{GDateTime}
end

"""
    g_date_time_new_from_unix_local(t)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GDateTime * g_date_time_new_from_unix_local (gint64 t);
```
"""
function g_date_time_new_from_unix_local(t)
    @ccall libaravis.g_date_time_new_from_unix_local(t::gint64)::Ptr{GDateTime}
end

"""
    g_date_time_new_from_unix_utc(t)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GDateTime * g_date_time_new_from_unix_utc (gint64 t);
```
"""
function g_date_time_new_from_unix_utc(t)
    @ccall libaravis.g_date_time_new_from_unix_utc(t::gint64)::Ptr{GDateTime}
end

"""
    g_date_time_new_from_unix_local_usec(usecs)

### Prototype
```c
GLIB_AVAILABLE_IN_2_80 GDateTime * g_date_time_new_from_unix_local_usec (gint64 usecs);
```
"""
function g_date_time_new_from_unix_local_usec(usecs)
    @ccall libaravis.g_date_time_new_from_unix_local_usec(usecs::gint64)::Ptr{GDateTime}
end

"""
    g_date_time_new_from_unix_utc_usec(usecs)

### Prototype
```c
GLIB_AVAILABLE_IN_2_80 GDateTime * g_date_time_new_from_unix_utc_usec (gint64 usecs);
```
"""
function g_date_time_new_from_unix_utc_usec(usecs)
    @ccall libaravis.g_date_time_new_from_unix_utc_usec(usecs::gint64)::Ptr{GDateTime}
end

"""
    g_date_time_new_from_timeval_local(tv)

### Prototype
```c
GLIB_DEPRECATED_IN_2_62_FOR(g_date_time_new_from_unix_local) GDateTime * g_date_time_new_from_timeval_local (const GTimeVal *tv);
```
"""
function g_date_time_new_from_timeval_local(tv)
    @ccall libaravis.g_date_time_new_from_timeval_local(tv::Ptr{GTimeVal})::Ptr{GDateTime}
end

"""
    g_date_time_new_from_timeval_utc(tv)

### Prototype
```c
GLIB_DEPRECATED_IN_2_62_FOR(g_date_time_new_from_unix_utc) GDateTime * g_date_time_new_from_timeval_utc (const GTimeVal *tv);
```
"""
function g_date_time_new_from_timeval_utc(tv)
    @ccall libaravis.g_date_time_new_from_timeval_utc(tv::Ptr{GTimeVal})::Ptr{GDateTime}
end

"""
    g_date_time_new_from_iso8601(text, default_tz)

### Prototype
```c
GLIB_AVAILABLE_IN_2_56 GDateTime * g_date_time_new_from_iso8601 (const gchar *text, GTimeZone *default_tz);
```
"""
function g_date_time_new_from_iso8601(text, default_tz)
    @ccall libaravis.g_date_time_new_from_iso8601(text::Ptr{gchar}, default_tz::Ptr{GTimeZone})::Ptr{GDateTime}
end

"""
    g_date_time_new(tz, year, month, day, hour, minute, seconds)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GDateTime * g_date_time_new (GTimeZone *tz, gint year, gint month, gint day, gint hour, gint minute, gdouble seconds);
```
"""
function g_date_time_new(tz, year, month, day, hour, minute, seconds)
    @ccall libaravis.g_date_time_new(tz::Ptr{GTimeZone}, year::gint, month::gint, day::gint, hour::gint, minute::gint, seconds::gdouble)::Ptr{GDateTime}
end

"""
    g_date_time_new_local(year, month, day, hour, minute, seconds)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GDateTime * g_date_time_new_local (gint year, gint month, gint day, gint hour, gint minute, gdouble seconds);
```
"""
function g_date_time_new_local(year, month, day, hour, minute, seconds)
    @ccall libaravis.g_date_time_new_local(year::gint, month::gint, day::gint, hour::gint, minute::gint, seconds::gdouble)::Ptr{GDateTime}
end

"""
    g_date_time_new_utc(year, month, day, hour, minute, seconds)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GDateTime * g_date_time_new_utc (gint year, gint month, gint day, gint hour, gint minute, gdouble seconds);
```
"""
function g_date_time_new_utc(year, month, day, hour, minute, seconds)
    @ccall libaravis.g_date_time_new_utc(year::gint, month::gint, day::gint, hour::gint, minute::gint, seconds::gdouble)::Ptr{GDateTime}
end

"""
    g_date_time_add(datetime, timespan)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL G_GNUC_WARN_UNUSED_RESULT GDateTime * g_date_time_add (GDateTime *datetime, GTimeSpan timespan);
```
"""
function g_date_time_add(datetime, timespan)
    @ccall libaravis.g_date_time_add(datetime::Ptr{GDateTime}, timespan::GTimeSpan)::Ptr{GDateTime}
end

"""
    g_date_time_add_years(datetime, years)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL G_GNUC_WARN_UNUSED_RESULT GDateTime * g_date_time_add_years (GDateTime *datetime, gint years);
```
"""
function g_date_time_add_years(datetime, years)
    @ccall libaravis.g_date_time_add_years(datetime::Ptr{GDateTime}, years::gint)::Ptr{GDateTime}
end

"""
    g_date_time_add_months(datetime, months)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL G_GNUC_WARN_UNUSED_RESULT GDateTime * g_date_time_add_months (GDateTime *datetime, gint months);
```
"""
function g_date_time_add_months(datetime, months)
    @ccall libaravis.g_date_time_add_months(datetime::Ptr{GDateTime}, months::gint)::Ptr{GDateTime}
end

"""
    g_date_time_add_weeks(datetime, weeks)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL G_GNUC_WARN_UNUSED_RESULT GDateTime * g_date_time_add_weeks (GDateTime *datetime, gint weeks);
```
"""
function g_date_time_add_weeks(datetime, weeks)
    @ccall libaravis.g_date_time_add_weeks(datetime::Ptr{GDateTime}, weeks::gint)::Ptr{GDateTime}
end

"""
    g_date_time_add_days(datetime, days)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL G_GNUC_WARN_UNUSED_RESULT GDateTime * g_date_time_add_days (GDateTime *datetime, gint days);
```
"""
function g_date_time_add_days(datetime, days)
    @ccall libaravis.g_date_time_add_days(datetime::Ptr{GDateTime}, days::gint)::Ptr{GDateTime}
end

"""
    g_date_time_add_hours(datetime, hours)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL G_GNUC_WARN_UNUSED_RESULT GDateTime * g_date_time_add_hours (GDateTime *datetime, gint hours);
```
"""
function g_date_time_add_hours(datetime, hours)
    @ccall libaravis.g_date_time_add_hours(datetime::Ptr{GDateTime}, hours::gint)::Ptr{GDateTime}
end

"""
    g_date_time_add_minutes(datetime, minutes)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL G_GNUC_WARN_UNUSED_RESULT GDateTime * g_date_time_add_minutes (GDateTime *datetime, gint minutes);
```
"""
function g_date_time_add_minutes(datetime, minutes)
    @ccall libaravis.g_date_time_add_minutes(datetime::Ptr{GDateTime}, minutes::gint)::Ptr{GDateTime}
end

"""
    g_date_time_add_seconds(datetime, seconds)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL G_GNUC_WARN_UNUSED_RESULT GDateTime * g_date_time_add_seconds (GDateTime *datetime, gdouble seconds);
```
"""
function g_date_time_add_seconds(datetime, seconds)
    @ccall libaravis.g_date_time_add_seconds(datetime::Ptr{GDateTime}, seconds::gdouble)::Ptr{GDateTime}
end

"""
    g_date_time_add_full(datetime, years, months, days, hours, minutes, seconds)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL G_GNUC_WARN_UNUSED_RESULT GDateTime * g_date_time_add_full (GDateTime *datetime, gint years, gint months, gint days, gint hours, gint minutes, gdouble seconds);
```
"""
function g_date_time_add_full(datetime, years, months, days, hours, minutes, seconds)
    @ccall libaravis.g_date_time_add_full(datetime::Ptr{GDateTime}, years::gint, months::gint, days::gint, hours::gint, minutes::gint, seconds::gdouble)::Ptr{GDateTime}
end

"""
    g_date_time_compare(dt1, dt2)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_date_time_compare (gconstpointer dt1, gconstpointer dt2);
```
"""
function g_date_time_compare(dt1, dt2)
    @ccall libaravis.g_date_time_compare(dt1::gconstpointer, dt2::gconstpointer)::gint
end

"""
    g_date_time_difference(_end, _begin)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GTimeSpan g_date_time_difference (GDateTime *end, GDateTime *begin);
```
"""
function g_date_time_difference(_end, _begin)
    @ccall libaravis.g_date_time_difference(_end::Ptr{GDateTime}, _begin::Ptr{GDateTime})::GTimeSpan
end

"""
    g_date_time_hash(datetime)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_date_time_hash (gconstpointer datetime);
```
"""
function g_date_time_hash(datetime)
    @ccall libaravis.g_date_time_hash(datetime::gconstpointer)::guint
end

"""
    g_date_time_equal(dt1, dt2)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_date_time_equal (gconstpointer dt1, gconstpointer dt2);
```
"""
function g_date_time_equal(dt1, dt2)
    @ccall libaravis.g_date_time_equal(dt1::gconstpointer, dt2::gconstpointer)::gboolean
end

"""
    g_date_time_get_ymd(datetime, year, month, day)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_date_time_get_ymd (GDateTime *datetime, gint *year, gint *month, gint *day);
```
"""
function g_date_time_get_ymd(datetime, year, month, day)
    @ccall libaravis.g_date_time_get_ymd(datetime::Ptr{GDateTime}, year::Ptr{gint}, month::Ptr{gint}, day::Ptr{gint})::Cvoid
end

"""
    g_date_time_get_year(datetime)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_date_time_get_year (GDateTime *datetime);
```
"""
function g_date_time_get_year(datetime)
    @ccall libaravis.g_date_time_get_year(datetime::Ptr{GDateTime})::gint
end

"""
    g_date_time_get_month(datetime)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_date_time_get_month (GDateTime *datetime);
```
"""
function g_date_time_get_month(datetime)
    @ccall libaravis.g_date_time_get_month(datetime::Ptr{GDateTime})::gint
end

"""
    g_date_time_get_day_of_month(datetime)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_date_time_get_day_of_month (GDateTime *datetime);
```
"""
function g_date_time_get_day_of_month(datetime)
    @ccall libaravis.g_date_time_get_day_of_month(datetime::Ptr{GDateTime})::gint
end

"""
    g_date_time_get_week_numbering_year(datetime)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_date_time_get_week_numbering_year (GDateTime *datetime);
```
"""
function g_date_time_get_week_numbering_year(datetime)
    @ccall libaravis.g_date_time_get_week_numbering_year(datetime::Ptr{GDateTime})::gint
end

"""
    g_date_time_get_week_of_year(datetime)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_date_time_get_week_of_year (GDateTime *datetime);
```
"""
function g_date_time_get_week_of_year(datetime)
    @ccall libaravis.g_date_time_get_week_of_year(datetime::Ptr{GDateTime})::gint
end

"""
    g_date_time_get_day_of_week(datetime)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_date_time_get_day_of_week (GDateTime *datetime);
```
"""
function g_date_time_get_day_of_week(datetime)
    @ccall libaravis.g_date_time_get_day_of_week(datetime::Ptr{GDateTime})::gint
end

"""
    g_date_time_get_day_of_year(datetime)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_date_time_get_day_of_year (GDateTime *datetime);
```
"""
function g_date_time_get_day_of_year(datetime)
    @ccall libaravis.g_date_time_get_day_of_year(datetime::Ptr{GDateTime})::gint
end

"""
    g_date_time_get_hour(datetime)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_date_time_get_hour (GDateTime *datetime);
```
"""
function g_date_time_get_hour(datetime)
    @ccall libaravis.g_date_time_get_hour(datetime::Ptr{GDateTime})::gint
end

"""
    g_date_time_get_minute(datetime)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_date_time_get_minute (GDateTime *datetime);
```
"""
function g_date_time_get_minute(datetime)
    @ccall libaravis.g_date_time_get_minute(datetime::Ptr{GDateTime})::gint
end

"""
    g_date_time_get_second(datetime)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_date_time_get_second (GDateTime *datetime);
```
"""
function g_date_time_get_second(datetime)
    @ccall libaravis.g_date_time_get_second(datetime::Ptr{GDateTime})::gint
end

"""
    g_date_time_get_microsecond(datetime)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_date_time_get_microsecond (GDateTime *datetime);
```
"""
function g_date_time_get_microsecond(datetime)
    @ccall libaravis.g_date_time_get_microsecond(datetime::Ptr{GDateTime})::gint
end

"""
    g_date_time_get_seconds(datetime)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gdouble g_date_time_get_seconds (GDateTime *datetime);
```
"""
function g_date_time_get_seconds(datetime)
    @ccall libaravis.g_date_time_get_seconds(datetime::Ptr{GDateTime})::gdouble
end

"""
    g_date_time_to_unix(datetime)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint64 g_date_time_to_unix (GDateTime *datetime);
```
"""
function g_date_time_to_unix(datetime)
    @ccall libaravis.g_date_time_to_unix(datetime::Ptr{GDateTime})::gint64
end

"""
    g_date_time_to_unix_usec(datetime)

### Prototype
```c
GLIB_AVAILABLE_IN_2_80 gint64 g_date_time_to_unix_usec (GDateTime *datetime);
```
"""
function g_date_time_to_unix_usec(datetime)
    @ccall libaravis.g_date_time_to_unix_usec(datetime::Ptr{GDateTime})::gint64
end

"""
    g_date_time_to_timeval(datetime, tv)

### Prototype
```c
GLIB_DEPRECATED_IN_2_62_FOR(g_date_time_to_unix) gboolean g_date_time_to_timeval (GDateTime *datetime, GTimeVal *tv);
```
"""
function g_date_time_to_timeval(datetime, tv)
    @ccall libaravis.g_date_time_to_timeval(datetime::Ptr{GDateTime}, tv::Ptr{GTimeVal})::gboolean
end

"""
    g_date_time_get_utc_offset(datetime)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GTimeSpan g_date_time_get_utc_offset (GDateTime *datetime);
```
"""
function g_date_time_get_utc_offset(datetime)
    @ccall libaravis.g_date_time_get_utc_offset(datetime::Ptr{GDateTime})::GTimeSpan
end

"""
    g_date_time_get_timezone(datetime)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 GTimeZone * g_date_time_get_timezone (GDateTime *datetime);
```
"""
function g_date_time_get_timezone(datetime)
    @ccall libaravis.g_date_time_get_timezone(datetime::Ptr{GDateTime})::Ptr{GTimeZone}
end

"""
    g_date_time_get_timezone_abbreviation(datetime)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_date_time_get_timezone_abbreviation (GDateTime *datetime);
```
"""
function g_date_time_get_timezone_abbreviation(datetime)
    @ccall libaravis.g_date_time_get_timezone_abbreviation(datetime::Ptr{GDateTime})::Ptr{gchar}
end

"""
    g_date_time_is_daylight_savings(datetime)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_date_time_is_daylight_savings (GDateTime *datetime);
```
"""
function g_date_time_is_daylight_savings(datetime)
    @ccall libaravis.g_date_time_is_daylight_savings(datetime::Ptr{GDateTime})::gboolean
end

"""
    g_date_time_to_timezone(datetime, tz)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GDateTime * g_date_time_to_timezone (GDateTime *datetime, GTimeZone *tz);
```
"""
function g_date_time_to_timezone(datetime, tz)
    @ccall libaravis.g_date_time_to_timezone(datetime::Ptr{GDateTime}, tz::Ptr{GTimeZone})::Ptr{GDateTime}
end

"""
    g_date_time_to_local(datetime)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GDateTime * g_date_time_to_local (GDateTime *datetime);
```
"""
function g_date_time_to_local(datetime)
    @ccall libaravis.g_date_time_to_local(datetime::Ptr{GDateTime})::Ptr{GDateTime}
end

"""
    g_date_time_to_utc(datetime)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GDateTime * g_date_time_to_utc (GDateTime *datetime);
```
"""
function g_date_time_to_utc(datetime)
    @ccall libaravis.g_date_time_to_utc(datetime::Ptr{GDateTime})::Ptr{GDateTime}
end

"""
    g_date_time_format(datetime, format)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar * g_date_time_format (GDateTime *datetime, const gchar *format) G_GNUC_MALLOC;
```
"""
function g_date_time_format(datetime, format)
    @ccall libaravis.g_date_time_format(datetime::Ptr{GDateTime}, format::Ptr{gchar})::Ptr{gchar}
end

"""
    g_date_time_format_iso8601(datetime)

### Prototype
```c
GLIB_AVAILABLE_IN_2_62 gchar * g_date_time_format_iso8601 (GDateTime *datetime) G_GNUC_MALLOC;
```
"""
function g_date_time_format_iso8601(datetime)
    @ccall libaravis.g_date_time_format_iso8601(datetime::Ptr{GDateTime})::Ptr{gchar}
end

"""
    GBookmarkFileError

[`GBookmarkFileError`](@ref): \\_BOOKMARK\\_FILE\\_ERROR\\_INVALID\\_URI: URI was ill-formed \\_BOOKMARK\\_FILE\\_ERROR\\_INVALID\\_VALUE: a requested field was not found \\_BOOKMARK\\_FILE\\_ERROR\\_APP\\_NOT\\_REGISTERED: a requested application did not register a bookmark \\_BOOKMARK\\_FILE\\_ERROR\\_URI\\_NOT\\_FOUND: a requested URI was not found \\_BOOKMARK\\_FILE\\_ERROR\\_READ: document was ill formed \\_BOOKMARK\\_FILE\\_ERROR\\_UNKNOWN\\_ENCODING: the text being parsed was in an unknown encoding \\_BOOKMARK\\_FILE\\_ERROR\\_WRITE: an error occurred while writing \\_BOOKMARK\\_FILE\\_ERROR\\_FILE\\_NOT\\_FOUND: requested file was not found

Error codes returned by bookmark file parsing.
"""
@cenum GBookmarkFileError::UInt32 begin
    G_BOOKMARK_FILE_ERROR_INVALID_URI = 0
    G_BOOKMARK_FILE_ERROR_INVALID_VALUE = 1
    G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED = 2
    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND = 3
    G_BOOKMARK_FILE_ERROR_READ = 4
    G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING = 5
    G_BOOKMARK_FILE_ERROR_WRITE = 6
    G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND = 7
end

const _GBookmarkFile = Cvoid

"""
[`GBookmarkFile`](@ref):

[`GBookmarkFile`](@ref) lets you parse, edit or create files containing bookmarks.

Bookmarks refer to a URI, along with some meta-data about the resource pointed by the URI like its MIME type, the application that is registering the bookmark and the icon that should be used to represent the bookmark. The data is stored using the [Desktop Bookmark Specification](https://www.freedesktop.org/wiki/Specifications/desktop-bookmark-spec/).

The syntax of the bookmark files is described in detail inside the Desktop Bookmark Specification, here is a quick summary: bookmark files use a sub-class of the XML Bookmark Exchange Language specification, consisting of valid UTF-8 encoded XML, under the `<xbel>` root element; each bookmark is stored inside a `<bookmark>` element, using its URI: no relative paths can be used inside a bookmark file. The bookmark may have a user defined title and description, to be used instead of the URI. Under the `<metadata>` element, with its owner attribute set to `http://freedesktop.org`, is stored the meta-data about a resource pointed by its URI. The meta-data consists of the resource's MIME type; the applications that have registered a bookmark; the groups to which a bookmark belongs to; a visibility flag, used to set the bookmark as "private" to the applications and groups that has it registered; the URI and MIME type of an icon, to be used when displaying the bookmark inside a GUI.

Here is an example of a bookmark file: [bookmarks.xbel](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/glib/tests/bookmarks.xbel)

A bookmark file might contain more than one bookmark; each bookmark is accessed through its URI.

The important caveat of bookmark files is that when you add a new bookmark you must also add the application that is registering it, using [method.BookmarkFile.add\\_application] or [method.BookmarkFile.set\\_application\\_info]. If a bookmark has no applications then it won't be dumped when creating the on disk representation, using [method.BookmarkFile.to\\_data] or [method.BookmarkFile.to\\_file].

Since: 2.12
"""
const GBookmarkFile = _GBookmarkFile

"""
    g_bookmark_file_new()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GBookmarkFile *g_bookmark_file_new (void);
```
"""
function g_bookmark_file_new()
    @ccall libaravis.g_bookmark_file_new()::Ptr{GBookmarkFile}
end

"""
    g_bookmark_file_free(bookmark)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_bookmark_file_free (GBookmarkFile *bookmark);
```
"""
function g_bookmark_file_free(bookmark)
    @ccall libaravis.g_bookmark_file_free(bookmark::Ptr{GBookmarkFile})::Cvoid
end

"""
    g_bookmark_file_copy(bookmark)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 GBookmarkFile *g_bookmark_file_copy (GBookmarkFile *bookmark);
```
"""
function g_bookmark_file_copy(bookmark)
    @ccall libaravis.g_bookmark_file_copy(bookmark::Ptr{GBookmarkFile})::Ptr{GBookmarkFile}
end

"""
    g_bookmark_file_load_from_file(bookmark, filename, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_bookmark_file_load_from_file (GBookmarkFile *bookmark, const gchar *filename, GError **error);
```
"""
function g_bookmark_file_load_from_file(bookmark, filename, error)
    @ccall libaravis.g_bookmark_file_load_from_file(bookmark::Ptr{GBookmarkFile}, filename::Ptr{gchar}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_bookmark_file_load_from_data(bookmark, data, length, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_bookmark_file_load_from_data (GBookmarkFile *bookmark, const gchar *data, gsize length, GError **error);
```
"""
function g_bookmark_file_load_from_data(bookmark, data, length, error)
    @ccall libaravis.g_bookmark_file_load_from_data(bookmark::Ptr{GBookmarkFile}, data::Ptr{gchar}, length::gsize, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_bookmark_file_load_from_data_dirs(bookmark, file, full_path, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_bookmark_file_load_from_data_dirs (GBookmarkFile *bookmark, const gchar *file, gchar **full_path, GError **error);
```
"""
function g_bookmark_file_load_from_data_dirs(bookmark, file, full_path, error)
    @ccall libaravis.g_bookmark_file_load_from_data_dirs(bookmark::Ptr{GBookmarkFile}, file::Ptr{gchar}, full_path::Ptr{Ptr{gchar}}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_bookmark_file_to_data(bookmark, length, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar * g_bookmark_file_to_data (GBookmarkFile *bookmark, gsize *length, GError **error) G_GNUC_MALLOC;
```
"""
function g_bookmark_file_to_data(bookmark, length, error)
    @ccall libaravis.g_bookmark_file_to_data(bookmark::Ptr{GBookmarkFile}, length::Ptr{gsize}, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_bookmark_file_to_file(bookmark, filename, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_bookmark_file_to_file (GBookmarkFile *bookmark, const gchar *filename, GError **error);
```
"""
function g_bookmark_file_to_file(bookmark, filename, error)
    @ccall libaravis.g_bookmark_file_to_file(bookmark::Ptr{GBookmarkFile}, filename::Ptr{gchar}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_bookmark_file_set_title(bookmark, uri, title)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_bookmark_file_set_title (GBookmarkFile *bookmark, const gchar *uri, const gchar *title);
```
"""
function g_bookmark_file_set_title(bookmark, uri, title)
    @ccall libaravis.g_bookmark_file_set_title(bookmark::Ptr{GBookmarkFile}, uri::Ptr{gchar}, title::Ptr{gchar})::Cvoid
end

"""
    g_bookmark_file_get_title(bookmark, uri, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar * g_bookmark_file_get_title (GBookmarkFile *bookmark, const gchar *uri, GError **error) G_GNUC_MALLOC;
```
"""
function g_bookmark_file_get_title(bookmark, uri, error)
    @ccall libaravis.g_bookmark_file_get_title(bookmark::Ptr{GBookmarkFile}, uri::Ptr{gchar}, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_bookmark_file_set_description(bookmark, uri, description)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_bookmark_file_set_description (GBookmarkFile *bookmark, const gchar *uri, const gchar *description);
```
"""
function g_bookmark_file_set_description(bookmark, uri, description)
    @ccall libaravis.g_bookmark_file_set_description(bookmark::Ptr{GBookmarkFile}, uri::Ptr{gchar}, description::Ptr{gchar})::Cvoid
end

"""
    g_bookmark_file_get_description(bookmark, uri, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar * g_bookmark_file_get_description (GBookmarkFile *bookmark, const gchar *uri, GError **error) G_GNUC_MALLOC;
```
"""
function g_bookmark_file_get_description(bookmark, uri, error)
    @ccall libaravis.g_bookmark_file_get_description(bookmark::Ptr{GBookmarkFile}, uri::Ptr{gchar}, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_bookmark_file_set_mime_type(bookmark, uri, mime_type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_bookmark_file_set_mime_type (GBookmarkFile *bookmark, const gchar *uri, const gchar *mime_type);
```
"""
function g_bookmark_file_set_mime_type(bookmark, uri, mime_type)
    @ccall libaravis.g_bookmark_file_set_mime_type(bookmark::Ptr{GBookmarkFile}, uri::Ptr{gchar}, mime_type::Ptr{gchar})::Cvoid
end

"""
    g_bookmark_file_get_mime_type(bookmark, uri, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar * g_bookmark_file_get_mime_type (GBookmarkFile *bookmark, const gchar *uri, GError **error) G_GNUC_MALLOC;
```
"""
function g_bookmark_file_get_mime_type(bookmark, uri, error)
    @ccall libaravis.g_bookmark_file_get_mime_type(bookmark::Ptr{GBookmarkFile}, uri::Ptr{gchar}, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_bookmark_file_set_groups(bookmark, uri, groups, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_bookmark_file_set_groups (GBookmarkFile *bookmark, const gchar *uri, const gchar **groups, gsize length);
```
"""
function g_bookmark_file_set_groups(bookmark, uri, groups, length)
    @ccall libaravis.g_bookmark_file_set_groups(bookmark::Ptr{GBookmarkFile}, uri::Ptr{gchar}, groups::Ptr{Ptr{gchar}}, length::gsize)::Cvoid
end

"""
    g_bookmark_file_add_group(bookmark, uri, group)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_bookmark_file_add_group (GBookmarkFile *bookmark, const gchar *uri, const gchar *group);
```
"""
function g_bookmark_file_add_group(bookmark, uri, group)
    @ccall libaravis.g_bookmark_file_add_group(bookmark::Ptr{GBookmarkFile}, uri::Ptr{gchar}, group::Ptr{gchar})::Cvoid
end

"""
    g_bookmark_file_has_group(bookmark, uri, group, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_bookmark_file_has_group (GBookmarkFile *bookmark, const gchar *uri, const gchar *group, GError **error);
```
"""
function g_bookmark_file_has_group(bookmark, uri, group, error)
    @ccall libaravis.g_bookmark_file_has_group(bookmark::Ptr{GBookmarkFile}, uri::Ptr{gchar}, group::Ptr{gchar}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_bookmark_file_get_groups(bookmark, uri, length, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar ** g_bookmark_file_get_groups (GBookmarkFile *bookmark, const gchar *uri, gsize *length, GError **error);
```
"""
function g_bookmark_file_get_groups(bookmark, uri, length, error)
    @ccall libaravis.g_bookmark_file_get_groups(bookmark::Ptr{GBookmarkFile}, uri::Ptr{gchar}, length::Ptr{gsize}, error::Ptr{Ptr{GError}})::Ptr{Ptr{gchar}}
end

"""
    g_bookmark_file_add_application(bookmark, uri, name, exec)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_bookmark_file_add_application (GBookmarkFile *bookmark, const gchar *uri, const gchar *name, const gchar *exec);
```
"""
function g_bookmark_file_add_application(bookmark, uri, name, exec)
    @ccall libaravis.g_bookmark_file_add_application(bookmark::Ptr{GBookmarkFile}, uri::Ptr{gchar}, name::Ptr{gchar}, exec::Ptr{gchar})::Cvoid
end

"""
    g_bookmark_file_has_application(bookmark, uri, name, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_bookmark_file_has_application (GBookmarkFile *bookmark, const gchar *uri, const gchar *name, GError **error);
```
"""
function g_bookmark_file_has_application(bookmark, uri, name, error)
    @ccall libaravis.g_bookmark_file_has_application(bookmark::Ptr{GBookmarkFile}, uri::Ptr{gchar}, name::Ptr{gchar}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_bookmark_file_get_applications(bookmark, uri, length, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar ** g_bookmark_file_get_applications (GBookmarkFile *bookmark, const gchar *uri, gsize *length, GError **error);
```
"""
function g_bookmark_file_get_applications(bookmark, uri, length, error)
    @ccall libaravis.g_bookmark_file_get_applications(bookmark::Ptr{GBookmarkFile}, uri::Ptr{gchar}, length::Ptr{gsize}, error::Ptr{Ptr{GError}})::Ptr{Ptr{gchar}}
end

"""
    g_bookmark_file_set_app_info(bookmark, uri, name, exec, count, stamp, error)

### Prototype
```c
GLIB_DEPRECATED_IN_2_66_FOR(g_bookmark_file_set_application_info) gboolean g_bookmark_file_set_app_info (GBookmarkFile *bookmark, const gchar *uri, const gchar *name, const gchar *exec, gint count, time_t stamp, GError **error);
```
"""
function g_bookmark_file_set_app_info(bookmark, uri, name, exec, count, stamp, error)
    @ccall libaravis.g_bookmark_file_set_app_info(bookmark::Ptr{GBookmarkFile}, uri::Ptr{gchar}, name::Ptr{gchar}, exec::Ptr{gchar}, count::gint, stamp::time_t, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_bookmark_file_set_application_info(bookmark, uri, name, exec, count, stamp, error)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 gboolean g_bookmark_file_set_application_info (GBookmarkFile *bookmark, const char *uri, const char *name, const char *exec, int count, GDateTime *stamp, GError **error);
```
"""
function g_bookmark_file_set_application_info(bookmark, uri, name, exec, count, stamp, error)
    @ccall libaravis.g_bookmark_file_set_application_info(bookmark::Ptr{GBookmarkFile}, uri::Cstring, name::Cstring, exec::Cstring, count::Cint, stamp::Ptr{GDateTime}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_bookmark_file_get_app_info(bookmark, uri, name, exec, count, stamp, error)

### Prototype
```c
GLIB_DEPRECATED_IN_2_66_FOR(g_bookmark_file_get_application_info) gboolean g_bookmark_file_get_app_info (GBookmarkFile *bookmark, const gchar *uri, const gchar *name, gchar **exec, guint *count, time_t *stamp, GError **error);
```
"""
function g_bookmark_file_get_app_info(bookmark, uri, name, exec, count, stamp, error)
    @ccall libaravis.g_bookmark_file_get_app_info(bookmark::Ptr{GBookmarkFile}, uri::Ptr{gchar}, name::Ptr{gchar}, exec::Ptr{Ptr{gchar}}, count::Ptr{guint}, stamp::Ptr{time_t}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_bookmark_file_get_application_info(bookmark, uri, name, exec, count, stamp, error)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 gboolean g_bookmark_file_get_application_info (GBookmarkFile *bookmark, const char *uri, const char *name, char **exec, unsigned int *count, GDateTime **stamp, GError **error);
```
"""
function g_bookmark_file_get_application_info(bookmark, uri, name, exec, count, stamp, error)
    @ccall libaravis.g_bookmark_file_get_application_info(bookmark::Ptr{GBookmarkFile}, uri::Cstring, name::Cstring, exec::Ptr{Cstring}, count::Ptr{Cuint}, stamp::Ptr{Ptr{GDateTime}}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_bookmark_file_set_is_private(bookmark, uri, is_private)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_bookmark_file_set_is_private (GBookmarkFile *bookmark, const gchar *uri, gboolean is_private);
```
"""
function g_bookmark_file_set_is_private(bookmark, uri, is_private)
    @ccall libaravis.g_bookmark_file_set_is_private(bookmark::Ptr{GBookmarkFile}, uri::Ptr{gchar}, is_private::gboolean)::Cvoid
end

"""
    g_bookmark_file_get_is_private(bookmark, uri, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_bookmark_file_get_is_private (GBookmarkFile *bookmark, const gchar *uri, GError **error);
```
"""
function g_bookmark_file_get_is_private(bookmark, uri, error)
    @ccall libaravis.g_bookmark_file_get_is_private(bookmark::Ptr{GBookmarkFile}, uri::Ptr{gchar}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_bookmark_file_set_icon(bookmark, uri, href, mime_type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_bookmark_file_set_icon (GBookmarkFile *bookmark, const gchar *uri, const gchar *href, const gchar *mime_type);
```
"""
function g_bookmark_file_set_icon(bookmark, uri, href, mime_type)
    @ccall libaravis.g_bookmark_file_set_icon(bookmark::Ptr{GBookmarkFile}, uri::Ptr{gchar}, href::Ptr{gchar}, mime_type::Ptr{gchar})::Cvoid
end

"""
    g_bookmark_file_get_icon(bookmark, uri, href, mime_type, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_bookmark_file_get_icon (GBookmarkFile *bookmark, const gchar *uri, gchar **href, gchar **mime_type, GError **error);
```
"""
function g_bookmark_file_get_icon(bookmark, uri, href, mime_type, error)
    @ccall libaravis.g_bookmark_file_get_icon(bookmark::Ptr{GBookmarkFile}, uri::Ptr{gchar}, href::Ptr{Ptr{gchar}}, mime_type::Ptr{Ptr{gchar}}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_bookmark_file_set_added(bookmark, uri, added)

### Prototype
```c
GLIB_DEPRECATED_IN_2_66_FOR(g_bookmark_file_set_added_date_time) void g_bookmark_file_set_added (GBookmarkFile *bookmark, const gchar *uri, time_t added);
```
"""
function g_bookmark_file_set_added(bookmark, uri, added)
    @ccall libaravis.g_bookmark_file_set_added(bookmark::Ptr{GBookmarkFile}, uri::Ptr{gchar}, added::time_t)::Cvoid
end

"""
    g_bookmark_file_set_added_date_time(bookmark, uri, added)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 void g_bookmark_file_set_added_date_time (GBookmarkFile *bookmark, const char *uri, GDateTime *added);
```
"""
function g_bookmark_file_set_added_date_time(bookmark, uri, added)
    @ccall libaravis.g_bookmark_file_set_added_date_time(bookmark::Ptr{GBookmarkFile}, uri::Cstring, added::Ptr{GDateTime})::Cvoid
end

"""
    g_bookmark_file_get_added(bookmark, uri, error)

### Prototype
```c
GLIB_DEPRECATED_IN_2_66_FOR(g_bookmark_file_get_added_date_time) time_t g_bookmark_file_get_added (GBookmarkFile *bookmark, const gchar *uri, GError **error);
```
"""
function g_bookmark_file_get_added(bookmark, uri, error)
    @ccall libaravis.g_bookmark_file_get_added(bookmark::Ptr{GBookmarkFile}, uri::Ptr{gchar}, error::Ptr{Ptr{GError}})::time_t
end

"""
    g_bookmark_file_get_added_date_time(bookmark, uri, error)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 GDateTime *g_bookmark_file_get_added_date_time (GBookmarkFile *bookmark, const char *uri, GError **error);
```
"""
function g_bookmark_file_get_added_date_time(bookmark, uri, error)
    @ccall libaravis.g_bookmark_file_get_added_date_time(bookmark::Ptr{GBookmarkFile}, uri::Cstring, error::Ptr{Ptr{GError}})::Ptr{GDateTime}
end

"""
    g_bookmark_file_set_modified(bookmark, uri, modified)

### Prototype
```c
GLIB_DEPRECATED_IN_2_66_FOR(g_bookmark_file_set_modified_date_time) void g_bookmark_file_set_modified (GBookmarkFile *bookmark, const gchar *uri, time_t modified);
```
"""
function g_bookmark_file_set_modified(bookmark, uri, modified)
    @ccall libaravis.g_bookmark_file_set_modified(bookmark::Ptr{GBookmarkFile}, uri::Ptr{gchar}, modified::time_t)::Cvoid
end

"""
    g_bookmark_file_set_modified_date_time(bookmark, uri, modified)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 void g_bookmark_file_set_modified_date_time (GBookmarkFile *bookmark, const char *uri, GDateTime *modified);
```
"""
function g_bookmark_file_set_modified_date_time(bookmark, uri, modified)
    @ccall libaravis.g_bookmark_file_set_modified_date_time(bookmark::Ptr{GBookmarkFile}, uri::Cstring, modified::Ptr{GDateTime})::Cvoid
end

"""
    g_bookmark_file_get_modified(bookmark, uri, error)

### Prototype
```c
GLIB_DEPRECATED_IN_2_66_FOR(g_bookmark_file_get_modified_date_time) time_t g_bookmark_file_get_modified (GBookmarkFile *bookmark, const gchar *uri, GError **error);
```
"""
function g_bookmark_file_get_modified(bookmark, uri, error)
    @ccall libaravis.g_bookmark_file_get_modified(bookmark::Ptr{GBookmarkFile}, uri::Ptr{gchar}, error::Ptr{Ptr{GError}})::time_t
end

"""
    g_bookmark_file_get_modified_date_time(bookmark, uri, error)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 GDateTime *g_bookmark_file_get_modified_date_time (GBookmarkFile *bookmark, const char *uri, GError **error);
```
"""
function g_bookmark_file_get_modified_date_time(bookmark, uri, error)
    @ccall libaravis.g_bookmark_file_get_modified_date_time(bookmark::Ptr{GBookmarkFile}, uri::Cstring, error::Ptr{Ptr{GError}})::Ptr{GDateTime}
end

"""
    g_bookmark_file_set_visited(bookmark, uri, visited)

### Prototype
```c
GLIB_DEPRECATED_IN_2_66_FOR(g_bookmark_file_set_visited_date_time) void g_bookmark_file_set_visited (GBookmarkFile *bookmark, const gchar *uri, time_t visited);
```
"""
function g_bookmark_file_set_visited(bookmark, uri, visited)
    @ccall libaravis.g_bookmark_file_set_visited(bookmark::Ptr{GBookmarkFile}, uri::Ptr{gchar}, visited::time_t)::Cvoid
end

"""
    g_bookmark_file_set_visited_date_time(bookmark, uri, visited)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 void g_bookmark_file_set_visited_date_time (GBookmarkFile *bookmark, const char *uri, GDateTime *visited);
```
"""
function g_bookmark_file_set_visited_date_time(bookmark, uri, visited)
    @ccall libaravis.g_bookmark_file_set_visited_date_time(bookmark::Ptr{GBookmarkFile}, uri::Cstring, visited::Ptr{GDateTime})::Cvoid
end

"""
    g_bookmark_file_get_visited(bookmark, uri, error)

### Prototype
```c
GLIB_DEPRECATED_IN_2_66_FOR(g_bookmark_file_get_visited_date_time) time_t g_bookmark_file_get_visited (GBookmarkFile *bookmark, const gchar *uri, GError **error);
```
"""
function g_bookmark_file_get_visited(bookmark, uri, error)
    @ccall libaravis.g_bookmark_file_get_visited(bookmark::Ptr{GBookmarkFile}, uri::Ptr{gchar}, error::Ptr{Ptr{GError}})::time_t
end

"""
    g_bookmark_file_get_visited_date_time(bookmark, uri, error)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 GDateTime *g_bookmark_file_get_visited_date_time (GBookmarkFile *bookmark, const char *uri, GError **error);
```
"""
function g_bookmark_file_get_visited_date_time(bookmark, uri, error)
    @ccall libaravis.g_bookmark_file_get_visited_date_time(bookmark::Ptr{GBookmarkFile}, uri::Cstring, error::Ptr{Ptr{GError}})::Ptr{GDateTime}
end

"""
    g_bookmark_file_has_item(bookmark, uri)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_bookmark_file_has_item (GBookmarkFile *bookmark, const gchar *uri);
```
"""
function g_bookmark_file_has_item(bookmark, uri)
    @ccall libaravis.g_bookmark_file_has_item(bookmark::Ptr{GBookmarkFile}, uri::Ptr{gchar})::gboolean
end

"""
    g_bookmark_file_get_size(bookmark)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_bookmark_file_get_size (GBookmarkFile *bookmark);
```
"""
function g_bookmark_file_get_size(bookmark)
    @ccall libaravis.g_bookmark_file_get_size(bookmark::Ptr{GBookmarkFile})::gint
end

"""
    g_bookmark_file_get_uris(bookmark, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar ** g_bookmark_file_get_uris (GBookmarkFile *bookmark, gsize *length);
```
"""
function g_bookmark_file_get_uris(bookmark, length)
    @ccall libaravis.g_bookmark_file_get_uris(bookmark::Ptr{GBookmarkFile}, length::Ptr{gsize})::Ptr{Ptr{gchar}}
end

"""
    g_bookmark_file_remove_group(bookmark, uri, group, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_bookmark_file_remove_group (GBookmarkFile *bookmark, const gchar *uri, const gchar *group, GError **error);
```
"""
function g_bookmark_file_remove_group(bookmark, uri, group, error)
    @ccall libaravis.g_bookmark_file_remove_group(bookmark::Ptr{GBookmarkFile}, uri::Ptr{gchar}, group::Ptr{gchar}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_bookmark_file_remove_application(bookmark, uri, name, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_bookmark_file_remove_application (GBookmarkFile *bookmark, const gchar *uri, const gchar *name, GError **error);
```
"""
function g_bookmark_file_remove_application(bookmark, uri, name, error)
    @ccall libaravis.g_bookmark_file_remove_application(bookmark::Ptr{GBookmarkFile}, uri::Ptr{gchar}, name::Ptr{gchar}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_bookmark_file_remove_item(bookmark, uri, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_bookmark_file_remove_item (GBookmarkFile *bookmark, const gchar *uri, GError **error);
```
"""
function g_bookmark_file_remove_item(bookmark, uri, error)
    @ccall libaravis.g_bookmark_file_remove_item(bookmark::Ptr{GBookmarkFile}, uri::Ptr{gchar}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_bookmark_file_move_item(bookmark, old_uri, new_uri, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_bookmark_file_move_item (GBookmarkFile *bookmark, const gchar *old_uri, const gchar *new_uri, GError **error);
```
"""
function g_bookmark_file_move_item(bookmark, old_uri, new_uri, error)
    @ccall libaravis.g_bookmark_file_move_item(bookmark::Ptr{GBookmarkFile}, old_uri::Ptr{gchar}, new_uri::Ptr{gchar}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_bytes_new(data, size)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GBytes * g_bytes_new (gconstpointer data, gsize size);
```
"""
function g_bytes_new(data, size)
    @ccall libaravis.g_bytes_new(data::gconstpointer, size::gsize)::Ptr{GBytes}
end

"""
    g_bytes_new_take(data, size)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GBytes * g_bytes_new_take (gpointer data, gsize size);
```
"""
function g_bytes_new_take(data, size)
    @ccall libaravis.g_bytes_new_take(data::gpointer, size::gsize)::Ptr{GBytes}
end

"""
    g_bytes_new_static(data, size)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GBytes * g_bytes_new_static (gconstpointer data, gsize size);
```
"""
function g_bytes_new_static(data, size)
    @ccall libaravis.g_bytes_new_static(data::gconstpointer, size::gsize)::Ptr{GBytes}
end

"""
    g_bytes_new_with_free_func(data, size, free_func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GBytes * g_bytes_new_with_free_func (gconstpointer data, gsize size, GDestroyNotify free_func, gpointer user_data);
```
"""
function g_bytes_new_with_free_func(data, size, free_func, user_data)
    @ccall libaravis.g_bytes_new_with_free_func(data::gconstpointer, size::gsize, free_func::GDestroyNotify, user_data::gpointer)::Ptr{GBytes}
end

"""
    g_bytes_new_from_bytes(bytes, offset, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GBytes * g_bytes_new_from_bytes (GBytes *bytes, gsize offset, gsize length);
```
"""
function g_bytes_new_from_bytes(bytes, offset, length)
    @ccall libaravis.g_bytes_new_from_bytes(bytes::Ptr{GBytes}, offset::gsize, length::gsize)::Ptr{GBytes}
end

"""
    g_bytes_get_data(bytes, size)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gconstpointer g_bytes_get_data (GBytes *bytes, gsize *size);
```
"""
function g_bytes_get_data(bytes, size)
    @ccall libaravis.g_bytes_get_data(bytes::Ptr{GBytes}, size::Ptr{gsize})::gconstpointer
end

"""
    g_bytes_get_size(bytes)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gsize g_bytes_get_size (GBytes *bytes);
```
"""
function g_bytes_get_size(bytes)
    @ccall libaravis.g_bytes_get_size(bytes::Ptr{GBytes})::gsize
end

"""
    g_bytes_ref(bytes)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GBytes * g_bytes_ref (GBytes *bytes);
```
"""
function g_bytes_ref(bytes)
    @ccall libaravis.g_bytes_ref(bytes::Ptr{GBytes})::Ptr{GBytes}
end

"""
    g_bytes_unref(bytes)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_bytes_unref (GBytes *bytes);
```
"""
function g_bytes_unref(bytes)
    @ccall libaravis.g_bytes_unref(bytes::Ptr{GBytes})::Cvoid
end

"""
    g_bytes_unref_to_data(bytes, size)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_bytes_unref_to_data (GBytes *bytes, gsize *size);
```
"""
function g_bytes_unref_to_data(bytes, size)
    @ccall libaravis.g_bytes_unref_to_data(bytes::Ptr{GBytes}, size::Ptr{gsize})::gpointer
end

"""
    g_bytes_unref_to_array(bytes)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GByteArray * g_bytes_unref_to_array (GBytes *bytes);
```
"""
function g_bytes_unref_to_array(bytes)
    @ccall libaravis.g_bytes_unref_to_array(bytes::Ptr{GBytes})::Ptr{GByteArray}
end

"""
    g_bytes_hash(bytes)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_bytes_hash (gconstpointer bytes);
```
"""
function g_bytes_hash(bytes)
    @ccall libaravis.g_bytes_hash(bytes::gconstpointer)::guint
end

"""
    g_bytes_equal(bytes1, bytes2)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_bytes_equal (gconstpointer bytes1, gconstpointer bytes2);
```
"""
function g_bytes_equal(bytes1, bytes2)
    @ccall libaravis.g_bytes_equal(bytes1::gconstpointer, bytes2::gconstpointer)::gboolean
end

"""
    g_bytes_compare(bytes1, bytes2)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_bytes_compare (gconstpointer bytes1, gconstpointer bytes2);
```
"""
function g_bytes_compare(bytes1, bytes2)
    @ccall libaravis.g_bytes_compare(bytes1::gconstpointer, bytes2::gconstpointer)::gint
end

"""
    g_bytes_get_region(bytes, element_size, offset, n_elements)

### Prototype
```c
GLIB_AVAILABLE_IN_2_70 gconstpointer g_bytes_get_region (GBytes *bytes, gsize element_size, gsize offset, gsize n_elements);
```
"""
function g_bytes_get_region(bytes, element_size, offset, n_elements)
    @ccall libaravis.g_bytes_get_region(bytes::Ptr{GBytes}, element_size::gsize, offset::gsize, n_elements::gsize)::gconstpointer
end

"""
    g_get_charset(charset)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_get_charset (const char **charset);
```
"""
function g_get_charset(charset)
    @ccall libaravis.g_get_charset(charset::Ptr{Cstring})::gboolean
end

"""
    g_get_codeset()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar * g_get_codeset (void);
```
"""
function g_get_codeset()
    @ccall libaravis.g_get_codeset()::Ptr{gchar}
end

"""
    g_get_console_charset(charset)

### Prototype
```c
GLIB_AVAILABLE_IN_2_62 gboolean g_get_console_charset (const char **charset);
```
"""
function g_get_console_charset(charset)
    @ccall libaravis.g_get_console_charset(charset::Ptr{Cstring})::gboolean
end

"""
    g_get_language_names()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * const * g_get_language_names (void);
```
"""
function g_get_language_names()
    @ccall libaravis.g_get_language_names()::Ptr{Ptr{gchar}}
end

"""
    g_get_language_names_with_category(category_name)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 const gchar * const * g_get_language_names_with_category (const gchar *category_name);
```
"""
function g_get_language_names_with_category(category_name)
    @ccall libaravis.g_get_language_names_with_category(category_name::Ptr{gchar})::Ptr{Ptr{gchar}}
end

"""
    g_get_locale_variants(locale)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar ** g_get_locale_variants (const gchar *locale);
```
"""
function g_get_locale_variants(locale)
    @ccall libaravis.g_get_locale_variants(locale::Ptr{gchar})::Ptr{Ptr{gchar}}
end

"""
    GChecksumType

[`GChecksumType`](@ref): \\_CHECKSUM\\_MD5: Use the MD5 hashing algorithm \\_CHECKSUM\\_SHA1: Use the SHA-1 hashing algorithm \\_CHECKSUM\\_SHA256: Use the SHA-256 hashing algorithm \\_CHECKSUM\\_SHA384: Use the SHA-384 hashing algorithm (Since: 2.51) \\_CHECKSUM\\_SHA512: Use the SHA-512 hashing algorithm (Since: 2.36)

The hashing algorithm to be used by #[`GChecksum`](@ref) when performing the digest of some data.

Note that the #[`GChecksumType`](@ref) enumeration may be extended at a later date to include new hashing algorithm types.

Since: 2.16
"""
@cenum GChecksumType::UInt32 begin
    G_CHECKSUM_MD5 = 0
    G_CHECKSUM_SHA1 = 1
    G_CHECKSUM_SHA256 = 2
    G_CHECKSUM_SHA512 = 3
    G_CHECKSUM_SHA384 = 4
end

const _GChecksum = Cvoid

const GChecksum = _GChecksum

"""
    g_checksum_type_get_length(checksum_type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gssize g_checksum_type_get_length (GChecksumType checksum_type);
```
"""
function g_checksum_type_get_length(checksum_type)
    @ccall libaravis.g_checksum_type_get_length(checksum_type::GChecksumType)::gssize
end

"""
    g_checksum_new(checksum_type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GChecksum * g_checksum_new (GChecksumType checksum_type);
```
"""
function g_checksum_new(checksum_type)
    @ccall libaravis.g_checksum_new(checksum_type::GChecksumType)::Ptr{GChecksum}
end

"""
    g_checksum_reset(checksum)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_checksum_reset (GChecksum *checksum);
```
"""
function g_checksum_reset(checksum)
    @ccall libaravis.g_checksum_reset(checksum::Ptr{GChecksum})::Cvoid
end

"""
    g_checksum_copy(checksum)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GChecksum * g_checksum_copy (const GChecksum *checksum);
```
"""
function g_checksum_copy(checksum)
    @ccall libaravis.g_checksum_copy(checksum::Ptr{GChecksum})::Ptr{GChecksum}
end

"""
    g_checksum_free(checksum)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_checksum_free (GChecksum *checksum);
```
"""
function g_checksum_free(checksum)
    @ccall libaravis.g_checksum_free(checksum::Ptr{GChecksum})::Cvoid
end

"""
    g_checksum_update(checksum, data, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_checksum_update (GChecksum *checksum, const guchar *data, gssize length);
```
"""
function g_checksum_update(checksum, data, length)
    @ccall libaravis.g_checksum_update(checksum::Ptr{GChecksum}, data::Ptr{guchar}, length::gssize)::Cvoid
end

"""
    g_checksum_get_string(checksum)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_checksum_get_string (GChecksum *checksum);
```
"""
function g_checksum_get_string(checksum)
    @ccall libaravis.g_checksum_get_string(checksum::Ptr{GChecksum})::Ptr{gchar}
end

"""
    g_checksum_get_digest(checksum, buffer, digest_len)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_checksum_get_digest (GChecksum *checksum, guint8 *buffer, gsize *digest_len);
```
"""
function g_checksum_get_digest(checksum, buffer, digest_len)
    @ccall libaravis.g_checksum_get_digest(checksum::Ptr{GChecksum}, buffer::Ptr{guint8}, digest_len::Ptr{gsize})::Cvoid
end

"""
    g_compute_checksum_for_data(checksum_type, data, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_compute_checksum_for_data (GChecksumType checksum_type, const guchar *data, gsize length);
```
"""
function g_compute_checksum_for_data(checksum_type, data, length)
    @ccall libaravis.g_compute_checksum_for_data(checksum_type::GChecksumType, data::Ptr{guchar}, length::gsize)::Ptr{gchar}
end

"""
    g_compute_checksum_for_string(checksum_type, str, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_compute_checksum_for_string (GChecksumType checksum_type, const gchar *str, gssize length);
```
"""
function g_compute_checksum_for_string(checksum_type, str, length)
    @ccall libaravis.g_compute_checksum_for_string(checksum_type::GChecksumType, str::Ptr{gchar}, length::gssize)::Ptr{gchar}
end

"""
    g_compute_checksum_for_bytes(checksum_type, data)

### Prototype
```c
GLIB_AVAILABLE_IN_2_34 gchar *g_compute_checksum_for_bytes (GChecksumType checksum_type, GBytes *data);
```
"""
function g_compute_checksum_for_bytes(checksum_type, data)
    @ccall libaravis.g_compute_checksum_for_bytes(checksum_type::GChecksumType, data::Ptr{GBytes})::Ptr{gchar}
end

"""
    GConvertError

[`GConvertError`](@ref): \\_CONVERT\\_ERROR\\_NO\\_CONVERSION: Conversion between the requested character sets is not supported. \\_CONVERT\\_ERROR\\_ILLEGAL\\_SEQUENCE: Invalid byte sequence in conversion input; or the character sequence could not be represented in the target character set. \\_CONVERT\\_ERROR\\_FAILED: Conversion failed for some reason. \\_CONVERT\\_ERROR\\_PARTIAL\\_INPUT: Partial character sequence at end of input. \\_CONVERT\\_ERROR\\_BAD\\_URI: URI is invalid. \\_CONVERT\\_ERROR\\_NOT\\_ABSOLUTE\\_PATH: Pathname is not an absolute path. \\_CONVERT\\_ERROR\\_NO\\_MEMORY: No memory available. Since: 2.40 \\_CONVERT\\_ERROR\\_EMBEDDED\\_NUL: An embedded NUL character is present in conversion output where a NUL-terminated string is expected. Since: 2.56

Error codes returned by character set conversion routines.
"""
@cenum GConvertError::UInt32 begin
    G_CONVERT_ERROR_NO_CONVERSION = 0
    G_CONVERT_ERROR_ILLEGAL_SEQUENCE = 1
    G_CONVERT_ERROR_FAILED = 2
    G_CONVERT_ERROR_PARTIAL_INPUT = 3
    G_CONVERT_ERROR_BAD_URI = 4
    G_CONVERT_ERROR_NOT_ABSOLUTE_PATH = 5
    G_CONVERT_ERROR_NO_MEMORY = 6
    G_CONVERT_ERROR_EMBEDDED_NUL = 7
end

const _GIConv = Cvoid

"""
[`GIConv`](@ref): (skip)

The [`GIConv`](@ref) struct wraps an iconv() conversion descriptor. It contains private data and should only be accessed using the following functions.
"""
const GIConv = Ptr{_GIConv}

"""
    g_iconv_open(to_codeset, from_codeset)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GIConv g_iconv_open (const gchar *to_codeset, const gchar *from_codeset);
```
"""
function g_iconv_open(to_codeset, from_codeset)
    @ccall libaravis.g_iconv_open(to_codeset::Ptr{gchar}, from_codeset::Ptr{gchar})::GIConv
end

"""
    g_iconv(converter, inbuf, inbytes_left, outbuf, outbytes_left)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gsize g_iconv (GIConv converter, gchar **inbuf, gsize *inbytes_left, gchar **outbuf, gsize *outbytes_left);
```
"""
function g_iconv(converter, inbuf, inbytes_left, outbuf, outbytes_left)
    @ccall libaravis.g_iconv(converter::GIConv, inbuf::Ptr{Ptr{gchar}}, inbytes_left::Ptr{gsize}, outbuf::Ptr{Ptr{gchar}}, outbytes_left::Ptr{gsize})::gsize
end

"""
    g_iconv_close(converter)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_iconv_close (GIConv converter);
```
"""
function g_iconv_close(converter)
    @ccall libaravis.g_iconv_close(converter::GIConv)::gint
end

"""
    g_convert(str, len, to_codeset, from_codeset, bytes_read, bytes_written, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_convert (const gchar *str, gssize len, const gchar *to_codeset, const gchar *from_codeset, gsize *bytes_read, gsize *bytes_written, GError **error) G_GNUC_MALLOC;
```
"""
function g_convert(str, len, to_codeset, from_codeset, bytes_read, bytes_written, error)
    @ccall libaravis.g_convert(str::Ptr{gchar}, len::gssize, to_codeset::Ptr{gchar}, from_codeset::Ptr{gchar}, bytes_read::Ptr{gsize}, bytes_written::Ptr{gsize}, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_convert_with_iconv(str, len, converter, bytes_read, bytes_written, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_convert_with_iconv (const gchar *str, gssize len, GIConv converter, gsize *bytes_read, gsize *bytes_written, GError **error) G_GNUC_MALLOC;
```
"""
function g_convert_with_iconv(str, len, converter, bytes_read, bytes_written, error)
    @ccall libaravis.g_convert_with_iconv(str::Ptr{gchar}, len::gssize, converter::GIConv, bytes_read::Ptr{gsize}, bytes_written::Ptr{gsize}, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_convert_with_fallback(str, len, to_codeset, from_codeset, fallback, bytes_read, bytes_written, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_convert_with_fallback (const gchar *str, gssize len, const gchar *to_codeset, const gchar *from_codeset, const gchar *fallback, gsize *bytes_read, gsize *bytes_written, GError **error) G_GNUC_MALLOC;
```
"""
function g_convert_with_fallback(str, len, to_codeset, from_codeset, fallback, bytes_read, bytes_written, error)
    @ccall libaravis.g_convert_with_fallback(str::Ptr{gchar}, len::gssize, to_codeset::Ptr{gchar}, from_codeset::Ptr{gchar}, fallback::Ptr{gchar}, bytes_read::Ptr{gsize}, bytes_written::Ptr{gsize}, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_locale_to_utf8(opsysstring, len, bytes_read, bytes_written, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_locale_to_utf8 (const gchar *opsysstring, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error) G_GNUC_MALLOC;
```
"""
function g_locale_to_utf8(opsysstring, len, bytes_read, bytes_written, error)
    @ccall libaravis.g_locale_to_utf8(opsysstring::Ptr{gchar}, len::gssize, bytes_read::Ptr{gsize}, bytes_written::Ptr{gsize}, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_locale_from_utf8(utf8string, len, bytes_read, bytes_written, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_locale_from_utf8 (const gchar *utf8string, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error) G_GNUC_MALLOC;
```
"""
function g_locale_from_utf8(utf8string, len, bytes_read, bytes_written, error)
    @ccall libaravis.g_locale_from_utf8(utf8string::Ptr{gchar}, len::gssize, bytes_read::Ptr{gsize}, bytes_written::Ptr{gsize}, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_filename_to_utf8(opsysstring, len, bytes_read, bytes_written, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_filename_to_utf8 (const gchar *opsysstring, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error) G_GNUC_MALLOC;
```
"""
function g_filename_to_utf8(opsysstring, len, bytes_read, bytes_written, error)
    @ccall libaravis.g_filename_to_utf8(opsysstring::Ptr{gchar}, len::gssize, bytes_read::Ptr{gsize}, bytes_written::Ptr{gsize}, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_filename_from_utf8(utf8string, len, bytes_read, bytes_written, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_filename_from_utf8 (const gchar *utf8string, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error) G_GNUC_MALLOC;
```
"""
function g_filename_from_utf8(utf8string, len, bytes_read, bytes_written, error)
    @ccall libaravis.g_filename_from_utf8(utf8string::Ptr{gchar}, len::gssize, bytes_read::Ptr{gsize}, bytes_written::Ptr{gsize}, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_filename_from_uri(uri, hostname, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_filename_from_uri (const gchar *uri, gchar **hostname, GError **error) G_GNUC_MALLOC;
```
"""
function g_filename_from_uri(uri, hostname, error)
    @ccall libaravis.g_filename_from_uri(uri::Ptr{gchar}, hostname::Ptr{Ptr{gchar}}, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_filename_to_uri(filename, hostname, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_filename_to_uri (const gchar *filename, const gchar *hostname, GError **error) G_GNUC_MALLOC;
```
"""
function g_filename_to_uri(filename, hostname, error)
    @ccall libaravis.g_filename_to_uri(filename::Ptr{gchar}, hostname::Ptr{gchar}, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_filename_display_name(filename)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_filename_display_name (const gchar *filename) G_GNUC_MALLOC;
```
"""
function g_filename_display_name(filename)
    @ccall libaravis.g_filename_display_name(filename::Ptr{gchar})::Ptr{gchar}
end

"""
    g_get_filename_charsets(filename_charsets)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_get_filename_charsets (const gchar ***filename_charsets);
```
"""
function g_get_filename_charsets(filename_charsets)
    @ccall libaravis.g_get_filename_charsets(filename_charsets::Ptr{Ptr{Ptr{gchar}}})::gboolean
end

"""
    g_filename_display_basename(filename)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_filename_display_basename (const gchar *filename) G_GNUC_MALLOC;
```
"""
function g_filename_display_basename(filename)
    @ccall libaravis.g_filename_display_basename(filename::Ptr{gchar})::Ptr{gchar}
end

"""
    g_uri_list_extract_uris(uri_list)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar **g_uri_list_extract_uris (const gchar *uri_list);
```
"""
function g_uri_list_extract_uris(uri_list)
    @ccall libaravis.g_uri_list_extract_uris(uri_list::Ptr{gchar})::Ptr{Ptr{gchar}}
end

# typedef void ( * GDataForeachFunc ) ( GQuark key_id , gpointer data , gpointer user_data )
const GDataForeachFunc = Ptr{Cvoid}

"""
    g_datalist_init(datalist)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_datalist_init (GData **datalist);
```
"""
function g_datalist_init(datalist)
    @ccall libaravis.g_datalist_init(datalist::Ptr{Ptr{GData}})::Cvoid
end

"""
    g_datalist_clear(datalist)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_datalist_clear (GData **datalist);
```
"""
function g_datalist_clear(datalist)
    @ccall libaravis.g_datalist_clear(datalist::Ptr{Ptr{GData}})::Cvoid
end

"""
    g_datalist_id_get_data(datalist, key_id)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_datalist_id_get_data (GData **datalist, GQuark key_id);
```
"""
function g_datalist_id_get_data(datalist, key_id)
    @ccall libaravis.g_datalist_id_get_data(datalist::Ptr{Ptr{GData}}, key_id::GQuark)::gpointer
end

"""
    g_datalist_id_remove_multiple(datalist, keys, n_keys)

### Prototype
```c
GLIB_AVAILABLE_IN_2_74 void g_datalist_id_remove_multiple (GData **datalist, GQuark *keys, gsize n_keys);
```
"""
function g_datalist_id_remove_multiple(datalist, keys, n_keys)
    @ccall libaravis.g_datalist_id_remove_multiple(datalist::Ptr{Ptr{GData}}, keys::Ptr{GQuark}, n_keys::gsize)::Cvoid
end

# typedef gpointer ( * GDuplicateFunc ) ( gpointer data , gpointer user_data )
const GDuplicateFunc = Ptr{Cvoid}

"""
    g_datalist_id_dup_data(datalist, key_id, dup_func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_2_34 gpointer g_datalist_id_dup_data (GData **datalist, GQuark key_id, GDuplicateFunc dup_func, gpointer user_data);
```
"""
function g_datalist_id_dup_data(datalist, key_id, dup_func, user_data)
    @ccall libaravis.g_datalist_id_dup_data(datalist::Ptr{Ptr{GData}}, key_id::GQuark, dup_func::GDuplicateFunc, user_data::gpointer)::gpointer
end

"""
    g_datalist_id_replace_data(datalist, key_id, oldval, newval, destroy, old_destroy)

### Prototype
```c
GLIB_AVAILABLE_IN_2_34 gboolean g_datalist_id_replace_data (GData **datalist, GQuark key_id, gpointer oldval, gpointer newval, GDestroyNotify destroy, GDestroyNotify *old_destroy);
```
"""
function g_datalist_id_replace_data(datalist, key_id, oldval, newval, destroy, old_destroy)
    @ccall libaravis.g_datalist_id_replace_data(datalist::Ptr{Ptr{GData}}, key_id::GQuark, oldval::gpointer, newval::gpointer, destroy::GDestroyNotify, old_destroy::Ptr{GDestroyNotify})::gboolean
end

"""
    g_datalist_foreach(datalist, func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_datalist_foreach (GData **datalist, GDataForeachFunc func, gpointer user_data);
```
"""
function g_datalist_foreach(datalist, func, user_data)
    @ccall libaravis.g_datalist_foreach(datalist::Ptr{Ptr{GData}}, func::GDataForeachFunc, user_data::gpointer)::Cvoid
end

"""
    g_datalist_set_flags(datalist, flags)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_datalist_set_flags (GData **datalist, guint flags);
```
"""
function g_datalist_set_flags(datalist, flags)
    @ccall libaravis.g_datalist_set_flags(datalist::Ptr{Ptr{GData}}, flags::guint)::Cvoid
end

"""
    g_datalist_unset_flags(datalist, flags)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_datalist_unset_flags (GData **datalist, guint flags);
```
"""
function g_datalist_unset_flags(datalist, flags)
    @ccall libaravis.g_datalist_unset_flags(datalist::Ptr{Ptr{GData}}, flags::guint)::Cvoid
end

"""
    g_datalist_get_flags(datalist)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_datalist_get_flags (GData **datalist);
```
"""
function g_datalist_get_flags(datalist)
    @ccall libaravis.g_datalist_get_flags(datalist::Ptr{Ptr{GData}})::guint
end

"""
    g_dataset_destroy(dataset_location)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_dataset_destroy (gconstpointer dataset_location);
```
"""
function g_dataset_destroy(dataset_location)
    @ccall libaravis.g_dataset_destroy(dataset_location::gconstpointer)::Cvoid
end

"""
    g_datalist_get_data(datalist, key)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_datalist_get_data (GData **datalist, const gchar *key);
```
"""
function g_datalist_get_data(datalist, key)
    @ccall libaravis.g_datalist_get_data(datalist::Ptr{Ptr{GData}}, key::Ptr{gchar})::gpointer
end

"""
    g_dataset_foreach(dataset_location, func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_dataset_foreach (gconstpointer dataset_location, GDataForeachFunc func, gpointer user_data);
```
"""
function g_dataset_foreach(dataset_location, func, user_data)
    @ccall libaravis.g_dataset_foreach(dataset_location::gconstpointer, func::GDataForeachFunc, user_data::gpointer)::Cvoid
end

const GTime = gint32

@cenum GDateDMY::UInt32 begin
    G_DATE_DAY = 0
    G_DATE_MONTH = 1
    G_DATE_YEAR = 2
end

"""
    g_date_new()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GDate* g_date_new (void);
```
"""
function g_date_new()
    @ccall libaravis.g_date_new()::Ptr{GDate}
end

"""
    g_date_new_dmy(day, month, year)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GDate* g_date_new_dmy (GDateDay day, GDateMonth month, GDateYear year);
```
"""
function g_date_new_dmy(day, month, year)
    @ccall libaravis.g_date_new_dmy(day::GDateDay, month::GDateMonth, year::GDateYear)::Ptr{GDate}
end

"""
    g_date_new_julian(julian_day)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GDate* g_date_new_julian (guint32 julian_day);
```
"""
function g_date_new_julian(julian_day)
    @ccall libaravis.g_date_new_julian(julian_day::guint32)::Ptr{GDate}
end

"""
    g_date_free(date)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_date_free (GDate *date);
```
"""
function g_date_free(date)
    @ccall libaravis.g_date_free(date::Ptr{GDate})::Cvoid
end

"""
    g_date_copy(date)

### Prototype
```c
GLIB_AVAILABLE_IN_2_56 GDate* g_date_copy (const GDate *date);
```
"""
function g_date_copy(date)
    @ccall libaravis.g_date_copy(date::Ptr{GDate})::Ptr{GDate}
end

"""
    g_date_valid(date)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_date_valid (const GDate *date);
```
"""
function g_date_valid(date)
    @ccall libaravis.g_date_valid(date::Ptr{GDate})::gboolean
end

"""
    g_date_valid_day(day)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_date_valid_day (GDateDay day) G_GNUC_CONST;
```
"""
function g_date_valid_day(day)
    @ccall libaravis.g_date_valid_day(day::GDateDay)::gboolean
end

"""
    g_date_valid_month(month)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_date_valid_month (GDateMonth month) G_GNUC_CONST;
```
"""
function g_date_valid_month(month)
    @ccall libaravis.g_date_valid_month(month::GDateMonth)::gboolean
end

"""
    g_date_valid_year(year)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_date_valid_year (GDateYear year) G_GNUC_CONST;
```
"""
function g_date_valid_year(year)
    @ccall libaravis.g_date_valid_year(year::GDateYear)::gboolean
end

"""
    g_date_valid_weekday(weekday)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_date_valid_weekday (GDateWeekday weekday) G_GNUC_CONST;
```
"""
function g_date_valid_weekday(weekday)
    @ccall libaravis.g_date_valid_weekday(weekday::GDateWeekday)::gboolean
end

"""
    g_date_valid_julian(julian_date)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_date_valid_julian (guint32 julian_date) G_GNUC_CONST;
```
"""
function g_date_valid_julian(julian_date)
    @ccall libaravis.g_date_valid_julian(julian_date::guint32)::gboolean
end

"""
    g_date_valid_dmy(day, month, year)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_date_valid_dmy (GDateDay day, GDateMonth month, GDateYear year) G_GNUC_CONST;
```
"""
function g_date_valid_dmy(day, month, year)
    @ccall libaravis.g_date_valid_dmy(day::GDateDay, month::GDateMonth, year::GDateYear)::gboolean
end

"""
    g_date_get_week_of_year(date, first_day_of_week)

### Prototype
```c
GLIB_AVAILABLE_IN_2_86 guint g_date_get_week_of_year (const GDate *date, GDateWeekday first_day_of_week);
```
"""
function g_date_get_week_of_year(date, first_day_of_week)
    @ccall libaravis.g_date_get_week_of_year(date::Ptr{GDate}, first_day_of_week::GDateWeekday)::guint
end

"""
    g_date_get_iso8601_week_of_year(date)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_date_get_iso8601_week_of_year (const GDate *date);
```
"""
function g_date_get_iso8601_week_of_year(date)
    @ccall libaravis.g_date_get_iso8601_week_of_year(date::Ptr{GDate})::guint
end

"""
    g_date_clear(date, n_dates)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_date_clear (GDate *date, guint n_dates);
```
"""
function g_date_clear(date, n_dates)
    @ccall libaravis.g_date_clear(date::Ptr{GDate}, n_dates::guint)::Cvoid
end

"""
    g_date_set_parse(date, str)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_date_set_parse (GDate *date, const gchar *str);
```
"""
function g_date_set_parse(date, str)
    @ccall libaravis.g_date_set_parse(date::Ptr{GDate}, str::Ptr{gchar})::Cvoid
end

"""
    g_date_set_time_t(date, timet)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_date_set_time_t (GDate *date, time_t timet);
```
"""
function g_date_set_time_t(date, timet)
    @ccall libaravis.g_date_set_time_t(date::Ptr{GDate}, timet::time_t)::Cvoid
end

"""
    g_date_set_time_val(date, timeval)

### Prototype
```c
GLIB_DEPRECATED_IN_2_62_FOR(g_date_set_time_t) void g_date_set_time_val (GDate *date, GTimeVal *timeval);
```
"""
function g_date_set_time_val(date, timeval)
    @ccall libaravis.g_date_set_time_val(date::Ptr{GDate}, timeval::Ptr{GTimeVal})::Cvoid
end

"""
    g_date_set_time(date, time_)

### Prototype
```c
GLIB_DEPRECATED_FOR(g_date_set_time_t) void g_date_set_time (GDate *date, GTime time_);
```
"""
function g_date_set_time(date, time_)
    @ccall libaravis.g_date_set_time(date::Ptr{GDate}, time_::GTime)::Cvoid
end

"""
    g_date_set_month(date, month)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_date_set_month (GDate *date, GDateMonth month);
```
"""
function g_date_set_month(date, month)
    @ccall libaravis.g_date_set_month(date::Ptr{GDate}, month::GDateMonth)::Cvoid
end

"""
    g_date_set_day(date, day)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_date_set_day (GDate *date, GDateDay day);
```
"""
function g_date_set_day(date, day)
    @ccall libaravis.g_date_set_day(date::Ptr{GDate}, day::GDateDay)::Cvoid
end

"""
    g_date_set_year(date, year)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_date_set_year (GDate *date, GDateYear year);
```
"""
function g_date_set_year(date, year)
    @ccall libaravis.g_date_set_year(date::Ptr{GDate}, year::GDateYear)::Cvoid
end

"""
    g_date_set_dmy(date, day, month, y)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_date_set_dmy (GDate *date, GDateDay day, GDateMonth month, GDateYear y);
```
"""
function g_date_set_dmy(date, day, month, y)
    @ccall libaravis.g_date_set_dmy(date::Ptr{GDate}, day::GDateDay, month::GDateMonth, y::GDateYear)::Cvoid
end

"""
    g_date_set_julian(date, julian_date)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_date_set_julian (GDate *date, guint32 julian_date);
```
"""
function g_date_set_julian(date, julian_date)
    @ccall libaravis.g_date_set_julian(date::Ptr{GDate}, julian_date::guint32)::Cvoid
end

"""
    g_date_is_first_of_month(date)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_date_is_first_of_month (const GDate *date);
```
"""
function g_date_is_first_of_month(date)
    @ccall libaravis.g_date_is_first_of_month(date::Ptr{GDate})::gboolean
end

"""
    g_date_is_last_of_month(date)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_date_is_last_of_month (const GDate *date);
```
"""
function g_date_is_last_of_month(date)
    @ccall libaravis.g_date_is_last_of_month(date::Ptr{GDate})::gboolean
end

"""
    g_date_add_days(date, n_days)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_date_add_days (GDate *date, guint n_days);
```
"""
function g_date_add_days(date, n_days)
    @ccall libaravis.g_date_add_days(date::Ptr{GDate}, n_days::guint)::Cvoid
end

"""
    g_date_subtract_days(date, n_days)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_date_subtract_days (GDate *date, guint n_days);
```
"""
function g_date_subtract_days(date, n_days)
    @ccall libaravis.g_date_subtract_days(date::Ptr{GDate}, n_days::guint)::Cvoid
end

"""
    g_date_add_months(date, n_months)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_date_add_months (GDate *date, guint n_months);
```
"""
function g_date_add_months(date, n_months)
    @ccall libaravis.g_date_add_months(date::Ptr{GDate}, n_months::guint)::Cvoid
end

"""
    g_date_subtract_months(date, n_months)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_date_subtract_months (GDate *date, guint n_months);
```
"""
function g_date_subtract_months(date, n_months)
    @ccall libaravis.g_date_subtract_months(date::Ptr{GDate}, n_months::guint)::Cvoid
end

"""
    g_date_add_years(date, n_years)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_date_add_years (GDate *date, guint n_years);
```
"""
function g_date_add_years(date, n_years)
    @ccall libaravis.g_date_add_years(date::Ptr{GDate}, n_years::guint)::Cvoid
end

"""
    g_date_subtract_years(date, n_years)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_date_subtract_years (GDate *date, guint n_years);
```
"""
function g_date_subtract_years(date, n_years)
    @ccall libaravis.g_date_subtract_years(date::Ptr{GDate}, n_years::guint)::Cvoid
end

"""
    g_date_is_leap_year(year)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_date_is_leap_year (GDateYear year) G_GNUC_CONST;
```
"""
function g_date_is_leap_year(year)
    @ccall libaravis.g_date_is_leap_year(year::GDateYear)::gboolean
end

"""
    g_date_get_weeks_in_year(year, first_day_of_week)

### Prototype
```c
GLIB_AVAILABLE_IN_2_86 guint8 g_date_get_weeks_in_year (GDateYear year, GDateWeekday first_day_of_week) G_GNUC_CONST;
```
"""
function g_date_get_weeks_in_year(year, first_day_of_week)
    @ccall libaravis.g_date_get_weeks_in_year(year::GDateYear, first_day_of_week::GDateWeekday)::guint8
end

"""
    g_date_days_between(date1, date2)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_date_days_between (const GDate *date1, const GDate *date2);
```
"""
function g_date_days_between(date1, date2)
    @ccall libaravis.g_date_days_between(date1::Ptr{GDate}, date2::Ptr{GDate})::gint
end

"""
    g_date_compare(lhs, rhs)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_date_compare (const GDate *lhs, const GDate *rhs);
```
"""
function g_date_compare(lhs, rhs)
    @ccall libaravis.g_date_compare(lhs::Ptr{GDate}, rhs::Ptr{GDate})::gint
end

"""
    g_date_to_struct_tm(date, tm)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_date_to_struct_tm (const GDate *date, struct tm *tm);
```
"""
function g_date_to_struct_tm(date, tm)
    @ccall libaravis.g_date_to_struct_tm(date::Ptr{GDate}, tm::Ptr{Cvoid})::Cvoid
end

"""
    g_date_clamp(date, min_date, max_date)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_date_clamp (GDate *date, const GDate *min_date, const GDate *max_date);
```
"""
function g_date_clamp(date, min_date, max_date)
    @ccall libaravis.g_date_clamp(date::Ptr{GDate}, min_date::Ptr{GDate}, max_date::Ptr{GDate})::Cvoid
end

"""
    g_date_order(date1, date2)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_date_order (GDate *date1, GDate *date2);
```
"""
function g_date_order(date1, date2)
    @ccall libaravis.g_date_order(date1::Ptr{GDate}, date2::Ptr{GDate})::Cvoid
end

"""
    g_date_strftime(s, slen, format, date)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gsize g_date_strftime (gchar *s, gsize slen, const gchar *format, const GDate *date);
```
"""
function g_date_strftime(s, slen, format, date)
    @ccall libaravis.g_date_strftime(s::Ptr{gchar}, slen::gsize, format::Ptr{gchar}, date::Ptr{GDate})::gsize
end

const _GDir = Cvoid

const GDir = _GDir

"""
    g_dir_open(path, flags, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GDir * g_dir_open (const gchar *path, guint flags, GError **error);
```
"""
function g_dir_open(path, flags, error)
    @ccall libaravis.g_dir_open(path::Ptr{gchar}, flags::guint, error::Ptr{Ptr{GError}})::Ptr{GDir}
end

"""
    g_dir_read_name(dir)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_dir_read_name (GDir *dir);
```
"""
function g_dir_read_name(dir)
    @ccall libaravis.g_dir_read_name(dir::Ptr{GDir})::Ptr{gchar}
end

"""
    g_dir_rewind(dir)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_dir_rewind (GDir *dir);
```
"""
function g_dir_rewind(dir)
    @ccall libaravis.g_dir_rewind(dir::Ptr{GDir})::Cvoid
end

"""
    g_dir_close(dir)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_dir_close (GDir *dir);
```
"""
function g_dir_close(dir)
    @ccall libaravis.g_dir_close(dir::Ptr{GDir})::Cvoid
end

"""
    g_dir_ref(dir)

### Prototype
```c
GLIB_AVAILABLE_IN_2_80 GDir * g_dir_ref (GDir *dir);
```
"""
function g_dir_ref(dir)
    @ccall libaravis.g_dir_ref(dir::Ptr{GDir})::Ptr{GDir}
end

"""
    g_dir_unref(dir)

### Prototype
```c
GLIB_AVAILABLE_IN_2_80 void g_dir_unref (GDir *dir);
```
"""
function g_dir_unref(dir)
    @ccall libaravis.g_dir_unref(dir::Ptr{GDir})::Cvoid
end

"""
    g_getenv(variable)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_getenv (const gchar *variable);
```
"""
function g_getenv(variable)
    @ccall libaravis.g_getenv(variable::Ptr{gchar})::Ptr{gchar}
end

"""
    g_setenv(variable, value, overwrite)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_setenv (const gchar *variable, const gchar *value, gboolean overwrite);
```
"""
function g_setenv(variable, value, overwrite)
    @ccall libaravis.g_setenv(variable::Ptr{gchar}, value::Ptr{gchar}, overwrite::gboolean)::gboolean
end

"""
    g_unsetenv(variable)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_unsetenv (const gchar *variable);
```
"""
function g_unsetenv(variable)
    @ccall libaravis.g_unsetenv(variable::Ptr{gchar})::Cvoid
end

"""
    g_listenv()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar ** g_listenv (void);
```
"""
function g_listenv()
    @ccall libaravis.g_listenv()::Ptr{Ptr{gchar}}
end

"""
    g_get_environ()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar ** g_get_environ (void);
```
"""
function g_get_environ()
    @ccall libaravis.g_get_environ()::Ptr{Ptr{gchar}}
end

"""
    g_environ_getenv(envp, variable)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_environ_getenv (gchar **envp, const gchar *variable);
```
"""
function g_environ_getenv(envp, variable)
    @ccall libaravis.g_environ_getenv(envp::Ptr{Ptr{gchar}}, variable::Ptr{gchar})::Ptr{gchar}
end

"""
    g_environ_setenv(envp, variable, value, overwrite)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar ** g_environ_setenv (gchar **envp, const gchar *variable, const gchar *value, gboolean overwrite) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_environ_setenv(envp, variable, value, overwrite)
    @ccall libaravis.g_environ_setenv(envp::Ptr{Ptr{gchar}}, variable::Ptr{gchar}, value::Ptr{gchar}, overwrite::gboolean)::Ptr{Ptr{gchar}}
end

"""
    g_environ_unsetenv(envp, variable)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar ** g_environ_unsetenv (gchar **envp, const gchar *variable) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_environ_unsetenv(envp, variable)
    @ccall libaravis.g_environ_unsetenv(envp::Ptr{Ptr{gchar}}, variable::Ptr{gchar})::Ptr{Ptr{gchar}}
end

@cenum GFileError::UInt32 begin
    G_FILE_ERROR_EXIST = 0
    G_FILE_ERROR_ISDIR = 1
    G_FILE_ERROR_ACCES = 2
    G_FILE_ERROR_NAMETOOLONG = 3
    G_FILE_ERROR_NOENT = 4
    G_FILE_ERROR_NOTDIR = 5
    G_FILE_ERROR_NXIO = 6
    G_FILE_ERROR_NODEV = 7
    G_FILE_ERROR_ROFS = 8
    G_FILE_ERROR_TXTBSY = 9
    G_FILE_ERROR_FAULT = 10
    G_FILE_ERROR_LOOP = 11
    G_FILE_ERROR_NOSPC = 12
    G_FILE_ERROR_NOMEM = 13
    G_FILE_ERROR_MFILE = 14
    G_FILE_ERROR_NFILE = 15
    G_FILE_ERROR_BADF = 16
    G_FILE_ERROR_INVAL = 17
    G_FILE_ERROR_PIPE = 18
    G_FILE_ERROR_AGAIN = 19
    G_FILE_ERROR_INTR = 20
    G_FILE_ERROR_IO = 21
    G_FILE_ERROR_PERM = 22
    G_FILE_ERROR_NOSYS = 23
    G_FILE_ERROR_FAILED = 24
end

@cenum GFileTest::UInt32 begin
    G_FILE_TEST_IS_REGULAR = 1
    G_FILE_TEST_IS_SYMLINK = 2
    G_FILE_TEST_IS_DIR = 4
    G_FILE_TEST_IS_EXECUTABLE = 8
    G_FILE_TEST_EXISTS = 16
end

"""
    GFileSetContentsFlags

[`GFileSetContentsFlags`](@ref): \\_FILE\\_SET\\_CONTENTS\\_NONE: No guarantees about file consistency or durability. The most dangerous setting, which is slightly faster than other settings. \\_FILE\\_SET\\_CONTENTS\\_CONSISTENT: Guarantee file consistency: after a crash, either the old version of the file or the new version of the file will be available, but not a mixture. On Unix systems this equates to an `fsync()` on the file and use of an atomic `rename()` of the new version of the file over the old. \\_FILE\\_SET\\_CONTENTS\\_DURABLE: Guarantee file durability: after a crash, the new version of the file will be available. On Unix systems this equates to an `fsync()` on the file (if G\\_FILE\\_SET\\_CONTENTS\\_CONSISTENT is unset), or the effects of G\\_FILE\\_SET\\_CONTENTS\\_CONSISTENT plus an `fsync()` on the directory containing the file after calling `rename()`. \\_FILE\\_SET\\_CONTENTS\\_ONLY\\_EXISTING: Only apply consistency and durability guarantees if the file already exists. This may speed up file operations if the file doesnt currently exist, but may result in a corrupted version of the new file if the system crashes while writing it.

Flags to pass to [`g_file_set_contents_full`](@ref)() to affect its safety and performance.

Since: 2.66
"""
@cenum GFileSetContentsFlags::UInt32 begin
    G_FILE_SET_CONTENTS_NONE = 0
    G_FILE_SET_CONTENTS_CONSISTENT = 1
    G_FILE_SET_CONTENTS_DURABLE = 2
    G_FILE_SET_CONTENTS_ONLY_EXISTING = 4
end

"""
    g_file_error_from_errno(err_no)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GFileError g_file_error_from_errno (gint err_no);
```
"""
function g_file_error_from_errno(err_no)
    @ccall libaravis.g_file_error_from_errno(err_no::gint)::GFileError
end

"""
    g_file_test(filename, test)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_file_test (const gchar *filename, GFileTest test);
```
"""
function g_file_test(filename, test)
    @ccall libaravis.g_file_test(filename::Ptr{gchar}, test::GFileTest)::gboolean
end

"""
    g_file_get_contents(filename, contents, length, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_file_get_contents (const gchar *filename, gchar **contents, gsize *length, GError **error);
```
"""
function g_file_get_contents(filename, contents, length, error)
    @ccall libaravis.g_file_get_contents(filename::Ptr{gchar}, contents::Ptr{Ptr{gchar}}, length::Ptr{gsize}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_set_contents(filename, contents, length, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_file_set_contents (const gchar *filename, const gchar *contents, gssize length, GError **error);
```
"""
function g_file_set_contents(filename, contents, length, error)
    @ccall libaravis.g_file_set_contents(filename::Ptr{gchar}, contents::Ptr{gchar}, length::gssize, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_set_contents_full(filename, contents, length, flags, mode, error)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 gboolean g_file_set_contents_full (const gchar *filename, const gchar *contents, gssize length, GFileSetContentsFlags flags, int mode, GError **error);
```
"""
function g_file_set_contents_full(filename, contents, length, flags, mode, error)
    @ccall libaravis.g_file_set_contents_full(filename::Ptr{gchar}, contents::Ptr{gchar}, length::gssize, flags::GFileSetContentsFlags, mode::Cint, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_read_link(filename, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_file_read_link (const gchar *filename, GError **error);
```
"""
function g_file_read_link(filename, error)
    @ccall libaravis.g_file_read_link(filename::Ptr{gchar}, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_mkdtemp(tmpl)

### Prototype
```c
GLIB_AVAILABLE_IN_2_30 gchar *g_mkdtemp (gchar *tmpl);
```
"""
function g_mkdtemp(tmpl)
    @ccall libaravis.g_mkdtemp(tmpl::Ptr{gchar})::Ptr{gchar}
end

"""
    g_mkdtemp_full(tmpl, mode)

### Prototype
```c
GLIB_AVAILABLE_IN_2_30 gchar *g_mkdtemp_full (gchar *tmpl, gint mode);
```
"""
function g_mkdtemp_full(tmpl, mode)
    @ccall libaravis.g_mkdtemp_full(tmpl::Ptr{gchar}, mode::gint)::Ptr{gchar}
end

"""
    g_mkstemp(tmpl)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_mkstemp (gchar *tmpl);
```
"""
function g_mkstemp(tmpl)
    @ccall libaravis.g_mkstemp(tmpl::Ptr{gchar})::gint
end

"""
    g_mkstemp_full(tmpl, flags, mode)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_mkstemp_full (gchar *tmpl, gint flags, gint mode);
```
"""
function g_mkstemp_full(tmpl, flags, mode)
    @ccall libaravis.g_mkstemp_full(tmpl::Ptr{gchar}, flags::gint, mode::gint)::gint
end

"""
    g_file_open_tmp(tmpl, name_used, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_file_open_tmp (const gchar *tmpl, gchar **name_used, GError **error);
```
"""
function g_file_open_tmp(tmpl, name_used, error)
    @ccall libaravis.g_file_open_tmp(tmpl::Ptr{gchar}, name_used::Ptr{Ptr{gchar}}, error::Ptr{Ptr{GError}})::gint
end

"""
    g_dir_make_tmp(tmpl, error)

### Prototype
```c
GLIB_AVAILABLE_IN_2_30 gchar *g_dir_make_tmp (const gchar *tmpl, GError **error);
```
"""
function g_dir_make_tmp(tmpl, error)
    @ccall libaravis.g_dir_make_tmp(tmpl::Ptr{gchar}, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_build_pathv(separator, args)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_build_pathv (const gchar *separator, gchar **args) G_GNUC_MALLOC;
```
"""
function g_build_pathv(separator, args)
    @ccall libaravis.g_build_pathv(separator::Ptr{gchar}, args::Ptr{Ptr{gchar}})::Ptr{gchar}
end

"""
    g_build_filenamev(args)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_build_filenamev (gchar **args) G_GNUC_MALLOC;
```
"""
function g_build_filenamev(args)
    @ccall libaravis.g_build_filenamev(args::Ptr{Ptr{gchar}})::Ptr{gchar}
end

"""
    g_mkdir_with_parents(pathname, mode)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_mkdir_with_parents (const gchar *pathname, gint mode);
```
"""
function g_mkdir_with_parents(pathname, mode)
    @ccall libaravis.g_mkdir_with_parents(pathname::Ptr{gchar}, mode::gint)::gint
end

"""
    g_path_is_absolute(file_name)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_path_is_absolute (const gchar *file_name);
```
"""
function g_path_is_absolute(file_name)
    @ccall libaravis.g_path_is_absolute(file_name::Ptr{gchar})::gboolean
end

"""
    g_path_skip_root(file_name)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar *g_path_skip_root (const gchar *file_name);
```
"""
function g_path_skip_root(file_name)
    @ccall libaravis.g_path_skip_root(file_name::Ptr{gchar})::Ptr{gchar}
end

"""
    g_basename(file_name)

### Prototype
```c
GLIB_DEPRECATED_FOR(g_path_get_basename) const gchar *g_basename (const gchar *file_name);
```
"""
function g_basename(file_name)
    @ccall libaravis.g_basename(file_name::Ptr{gchar})::Ptr{gchar}
end

"""
    g_get_current_dir()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_get_current_dir (void);
```
"""
function g_get_current_dir()
    @ccall libaravis.g_get_current_dir()::Ptr{gchar}
end

"""
    g_path_get_basename(file_name)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_path_get_basename (const gchar *file_name) G_GNUC_MALLOC;
```
"""
function g_path_get_basename(file_name)
    @ccall libaravis.g_path_get_basename(file_name::Ptr{gchar})::Ptr{gchar}
end

"""
    g_canonicalize_filename(filename, relative_to)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 gchar *g_canonicalize_filename (const gchar *filename, const gchar *relative_to) G_GNUC_MALLOC;
```
"""
function g_canonicalize_filename(filename, relative_to)
    @ccall libaravis.g_canonicalize_filename(filename::Ptr{gchar}, relative_to::Ptr{gchar})::Ptr{gchar}
end

"""
    g_strip_context(msgid, msgval)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar *g_strip_context (const gchar *msgid, const gchar *msgval) G_GNUC_FORMAT(1);
```
"""
function g_strip_context(msgid, msgval)
    @ccall libaravis.g_strip_context(msgid::Ptr{gchar}, msgval::Ptr{gchar})::Ptr{gchar}
end

"""
    g_dgettext(domain, msgid)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar *g_dgettext (const gchar *domain, const gchar *msgid) G_GNUC_FORMAT(2);
```
"""
function g_dgettext(domain, msgid)
    @ccall libaravis.g_dgettext(domain::Ptr{gchar}, msgid::Ptr{gchar})::Ptr{gchar}
end

"""
    g_dcgettext(domain, msgid, category)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar *g_dcgettext (const gchar *domain, const gchar *msgid, gint category) G_GNUC_FORMAT(2);
```
"""
function g_dcgettext(domain, msgid, category)
    @ccall libaravis.g_dcgettext(domain::Ptr{gchar}, msgid::Ptr{gchar}, category::gint)::Ptr{gchar}
end

"""
    g_dngettext(domain, msgid, msgid_plural, n)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar *g_dngettext (const gchar *domain, const gchar *msgid, const gchar *msgid_plural, gulong n) G_GNUC_FORMAT(3);
```
"""
function g_dngettext(domain, msgid, msgid_plural, n)
    @ccall libaravis.g_dngettext(domain::Ptr{gchar}, msgid::Ptr{gchar}, msgid_plural::Ptr{gchar}, n::gulong)::Ptr{gchar}
end

"""
    g_dpgettext(domain, msgctxtid, msgidoffset)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar *g_dpgettext (const gchar *domain, const gchar *msgctxtid, gsize msgidoffset) G_GNUC_FORMAT(2);
```
"""
function g_dpgettext(domain, msgctxtid, msgidoffset)
    @ccall libaravis.g_dpgettext(domain::Ptr{gchar}, msgctxtid::Ptr{gchar}, msgidoffset::gsize)::Ptr{gchar}
end

"""
    g_dpgettext2(domain, context, msgid)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar *g_dpgettext2 (const gchar *domain, const gchar *context, const gchar *msgid) G_GNUC_FORMAT(3);
```
"""
function g_dpgettext2(domain, context, msgid)
    @ccall libaravis.g_dpgettext2(domain::Ptr{gchar}, context::Ptr{gchar}, msgid::Ptr{gchar})::Ptr{gchar}
end

struct _GMemVTable
    malloc::Ptr{Cvoid}
    realloc::Ptr{Cvoid}
    free::Ptr{Cvoid}
    calloc::Ptr{Cvoid}
    try_malloc::Ptr{Cvoid}
    try_realloc::Ptr{Cvoid}
end

"""
[`GMemVTable`](@ref): : function to use for allocating memory. : function to use for reallocating memory. : function to use to free memory. : function to use for allocating zero-filled memory. \\_malloc: function to use for allocating memory without a default error handler. \\_realloc: function to use for reallocating memory without a default error handler.

A set of functions used to perform memory allocation. The same #[`GMemVTable`](@ref) must be used for all allocations in the same program; a call to [`g_mem_set_vtable`](@ref)(), if it exists, should be prior to any use of GLib.

This functions related to this has been deprecated in 2.46, and no longer work.
"""
const GMemVTable = _GMemVTable

"""
    g_free_sized(mem, size)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 void g_free_sized (gpointer mem, size_t size);
```
"""
function g_free_sized(mem, size)
    @ccall libaravis.g_free_sized(mem::gpointer, size::Csize_t)::Cvoid
end

"""
    g_malloc(n_bytes)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_malloc (gsize n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
```
"""
function g_malloc(n_bytes)
    @ccall libaravis.g_malloc(n_bytes::gsize)::gpointer
end

"""
    g_malloc0(n_bytes)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_malloc0 (gsize n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
```
"""
function g_malloc0(n_bytes)
    @ccall libaravis.g_malloc0(n_bytes::gsize)::gpointer
end

"""
    g_realloc(mem, n_bytes)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_realloc (gpointer mem, gsize n_bytes) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_realloc(mem, n_bytes)
    @ccall libaravis.g_realloc(mem::gpointer, n_bytes::gsize)::gpointer
end

"""
    g_try_malloc(n_bytes)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_try_malloc (gsize n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
```
"""
function g_try_malloc(n_bytes)
    @ccall libaravis.g_try_malloc(n_bytes::gsize)::gpointer
end

"""
    g_try_malloc0(n_bytes)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_try_malloc0 (gsize n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
```
"""
function g_try_malloc0(n_bytes)
    @ccall libaravis.g_try_malloc0(n_bytes::gsize)::gpointer
end

"""
    g_try_realloc(mem, n_bytes)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_try_realloc (gpointer mem, gsize n_bytes) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_try_realloc(mem, n_bytes)
    @ccall libaravis.g_try_realloc(mem::gpointer, n_bytes::gsize)::gpointer
end

"""
    g_malloc_n(n_blocks, n_block_bytes)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_malloc_n (gsize n_blocks, gsize n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);
```
"""
function g_malloc_n(n_blocks, n_block_bytes)
    @ccall libaravis.g_malloc_n(n_blocks::gsize, n_block_bytes::gsize)::gpointer
end

"""
    g_malloc0_n(n_blocks, n_block_bytes)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_malloc0_n (gsize n_blocks, gsize n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);
```
"""
function g_malloc0_n(n_blocks, n_block_bytes)
    @ccall libaravis.g_malloc0_n(n_blocks::gsize, n_block_bytes::gsize)::gpointer
end

"""
    g_realloc_n(mem, n_blocks, n_block_bytes)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_realloc_n (gpointer mem, gsize n_blocks, gsize n_block_bytes) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_realloc_n(mem, n_blocks, n_block_bytes)
    @ccall libaravis.g_realloc_n(mem::gpointer, n_blocks::gsize, n_block_bytes::gsize)::gpointer
end

"""
    g_try_malloc_n(n_blocks, n_block_bytes)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_try_malloc_n (gsize n_blocks, gsize n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);
```
"""
function g_try_malloc_n(n_blocks, n_block_bytes)
    @ccall libaravis.g_try_malloc_n(n_blocks::gsize, n_block_bytes::gsize)::gpointer
end

"""
    g_try_malloc0_n(n_blocks, n_block_bytes)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_try_malloc0_n (gsize n_blocks, gsize n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);
```
"""
function g_try_malloc0_n(n_blocks, n_block_bytes)
    @ccall libaravis.g_try_malloc0_n(n_blocks::gsize, n_block_bytes::gsize)::gpointer
end

"""
    g_try_realloc_n(mem, n_blocks, n_block_bytes)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_try_realloc_n (gpointer mem, gsize n_blocks, gsize n_block_bytes) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_try_realloc_n(mem, n_blocks, n_block_bytes)
    @ccall libaravis.g_try_realloc_n(mem::gpointer, n_blocks::gsize, n_block_bytes::gsize)::gpointer
end

"""
    g_aligned_alloc(n_blocks, n_block_bytes, alignment)

### Prototype
```c
GLIB_AVAILABLE_IN_2_72 gpointer g_aligned_alloc (gsize n_blocks, gsize n_block_bytes, gsize alignment) G_GNUC_WARN_UNUSED_RESULT G_GNUC_ALLOC_SIZE2(1,2);
```
"""
function g_aligned_alloc(n_blocks, n_block_bytes, alignment)
    @ccall libaravis.g_aligned_alloc(n_blocks::gsize, n_block_bytes::gsize, alignment::gsize)::gpointer
end

"""
    g_aligned_alloc0(n_blocks, n_block_bytes, alignment)

### Prototype
```c
GLIB_AVAILABLE_IN_2_72 gpointer g_aligned_alloc0 (gsize n_blocks, gsize n_block_bytes, gsize alignment) G_GNUC_WARN_UNUSED_RESULT G_GNUC_ALLOC_SIZE2(1,2);
```
"""
function g_aligned_alloc0(n_blocks, n_block_bytes, alignment)
    @ccall libaravis.g_aligned_alloc0(n_blocks::gsize, n_block_bytes::gsize, alignment::gsize)::gpointer
end

"""
    g_aligned_free(mem)

### Prototype
```c
GLIB_AVAILABLE_IN_2_72 void g_aligned_free (gpointer mem);
```
"""
function g_aligned_free(mem)
    @ccall libaravis.g_aligned_free(mem::gpointer)::Cvoid
end

"""
    g_aligned_free_sized(mem, alignment, size)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 void g_aligned_free_sized (gpointer mem, size_t alignment, size_t size);
```
"""
function g_aligned_free_sized(mem, alignment, size)
    @ccall libaravis.g_aligned_free_sized(mem::gpointer, alignment::Csize_t, size::Csize_t)::Cvoid
end

"""
    g_mem_set_vtable(vtable)

### Prototype
```c
GLIB_DEPRECATED_IN_2_46 void g_mem_set_vtable (GMemVTable *vtable);
```
"""
function g_mem_set_vtable(vtable)
    @ccall libaravis.g_mem_set_vtable(vtable::Ptr{GMemVTable})::Cvoid
end

"""
    g_mem_is_system_malloc()

### Prototype
```c
GLIB_DEPRECATED_IN_2_46 gboolean g_mem_is_system_malloc (void);
```
"""
function g_mem_is_system_malloc()
    @ccall libaravis.g_mem_is_system_malloc()::gboolean
end

"""
    g_mem_profile()

### Prototype
```c
GLIB_DEPRECATED_IN_2_46 void g_mem_profile (void);
```
"""
function g_mem_profile()
    @ccall libaravis.g_mem_profile()::Cvoid
end

@cenum GTraverseFlags::UInt32 begin
    G_TRAVERSE_LEAVES = 1
    G_TRAVERSE_NON_LEAVES = 2
    G_TRAVERSE_ALL = 3
    G_TRAVERSE_MASK = 3
    G_TRAVERSE_LEAFS = 1
    G_TRAVERSE_NON_LEAFS = 2
end

@cenum GTraverseType::UInt32 begin
    G_IN_ORDER = 0
    G_PRE_ORDER = 1
    G_POST_ORDER = 2
    G_LEVEL_ORDER = 3
end

# typedef gboolean ( * GNodeTraverseFunc ) ( GNode * node , gpointer data )
const GNodeTraverseFunc = Ptr{Cvoid}

# typedef void ( * GNodeForeachFunc ) ( GNode * node , gpointer data )
const GNodeForeachFunc = Ptr{Cvoid}

"""
    g_node_destroy(root)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_node_destroy (GNode *root);
```
"""
function g_node_destroy(root)
    @ccall libaravis.g_node_destroy(root::Ptr{GNode})::Cvoid
end

"""
    g_node_unlink(node)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_node_unlink (GNode *node);
```
"""
function g_node_unlink(node)
    @ccall libaravis.g_node_unlink(node::Ptr{GNode})::Cvoid
end

"""
    g_node_copy_deep(node, copy_func, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GNode* g_node_copy_deep (GNode *node, GCopyFunc copy_func, gpointer data);
```
"""
function g_node_copy_deep(node, copy_func, data)
    @ccall libaravis.g_node_copy_deep(node::Ptr{GNode}, copy_func::GCopyFunc, data::gpointer)::Ptr{GNode}
end

"""
    g_node_copy(node)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GNode* g_node_copy (GNode *node);
```
"""
function g_node_copy(node)
    @ccall libaravis.g_node_copy(node::Ptr{GNode})::Ptr{GNode}
end

"""
    g_node_n_nodes(root, flags)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_node_n_nodes (GNode *root, GTraverseFlags flags);
```
"""
function g_node_n_nodes(root, flags)
    @ccall libaravis.g_node_n_nodes(root::Ptr{GNode}, flags::GTraverseFlags)::guint
end

"""
    g_node_get_root(node)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GNode* g_node_get_root (GNode *node);
```
"""
function g_node_get_root(node)
    @ccall libaravis.g_node_get_root(node::Ptr{GNode})::Ptr{GNode}
end

"""
    g_node_is_ancestor(node, descendant)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_node_is_ancestor (GNode *node, GNode *descendant);
```
"""
function g_node_is_ancestor(node, descendant)
    @ccall libaravis.g_node_is_ancestor(node::Ptr{GNode}, descendant::Ptr{GNode})::gboolean
end

"""
    g_node_depth(node)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_node_depth (GNode *node);
```
"""
function g_node_depth(node)
    @ccall libaravis.g_node_depth(node::Ptr{GNode})::guint
end

"""
    g_node_find(root, order, flags, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GNode* g_node_find (GNode *root, GTraverseType order, GTraverseFlags flags, gpointer data);
```
"""
function g_node_find(root, order, flags, data)
    @ccall libaravis.g_node_find(root::Ptr{GNode}, order::GTraverseType, flags::GTraverseFlags, data::gpointer)::Ptr{GNode}
end

"""
    g_node_traverse(root, order, flags, max_depth, func, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_node_traverse (GNode *root, GTraverseType order, GTraverseFlags flags, gint max_depth, GNodeTraverseFunc func, gpointer data);
```
"""
function g_node_traverse(root, order, flags, max_depth, func, data)
    @ccall libaravis.g_node_traverse(root::Ptr{GNode}, order::GTraverseType, flags::GTraverseFlags, max_depth::gint, func::GNodeTraverseFunc, data::gpointer)::Cvoid
end

"""
    g_node_max_height(root)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_node_max_height (GNode *root);
```
"""
function g_node_max_height(root)
    @ccall libaravis.g_node_max_height(root::Ptr{GNode})::guint
end

"""
    g_node_children_foreach(node, flags, func, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_node_children_foreach (GNode *node, GTraverseFlags flags, GNodeForeachFunc func, gpointer data);
```
"""
function g_node_children_foreach(node, flags, func, data)
    @ccall libaravis.g_node_children_foreach(node::Ptr{GNode}, flags::GTraverseFlags, func::GNodeForeachFunc, data::gpointer)::Cvoid
end

"""
    g_node_reverse_children(node)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_node_reverse_children (GNode *node);
```
"""
function g_node_reverse_children(node)
    @ccall libaravis.g_node_reverse_children(node::Ptr{GNode})::Cvoid
end

"""
    g_node_n_children(node)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_node_n_children (GNode *node);
```
"""
function g_node_n_children(node)
    @ccall libaravis.g_node_n_children(node::Ptr{GNode})::guint
end

"""
    g_node_nth_child(node, n)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GNode* g_node_nth_child (GNode *node, guint n);
```
"""
function g_node_nth_child(node, n)
    @ccall libaravis.g_node_nth_child(node::Ptr{GNode}, n::guint)::Ptr{GNode}
end

"""
    g_node_last_child(node)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GNode* g_node_last_child (GNode *node);
```
"""
function g_node_last_child(node)
    @ccall libaravis.g_node_last_child(node::Ptr{GNode})::Ptr{GNode}
end

"""
    g_node_find_child(node, flags, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GNode* g_node_find_child (GNode *node, GTraverseFlags flags, gpointer data);
```
"""
function g_node_find_child(node, flags, data)
    @ccall libaravis.g_node_find_child(node::Ptr{GNode}, flags::GTraverseFlags, data::gpointer)::Ptr{GNode}
end

"""
    g_node_child_position(node, child)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_node_child_position (GNode *node, GNode *child);
```
"""
function g_node_child_position(node, child)
    @ccall libaravis.g_node_child_position(node::Ptr{GNode}, child::Ptr{GNode})::gint
end

"""
    g_node_child_index(node, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_node_child_index (GNode *node, gpointer data);
```
"""
function g_node_child_index(node, data)
    @ccall libaravis.g_node_child_index(node::Ptr{GNode}, data::gpointer)::gint
end

"""
    g_node_first_sibling(node)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GNode* g_node_first_sibling (GNode *node);
```
"""
function g_node_first_sibling(node)
    @ccall libaravis.g_node_first_sibling(node::Ptr{GNode})::Ptr{GNode}
end

"""
    g_node_last_sibling(node)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GNode* g_node_last_sibling (GNode *node);
```
"""
function g_node_last_sibling(node)
    @ccall libaravis.g_node_last_sibling(node::Ptr{GNode})::Ptr{GNode}
end

"""
    g_list_alloc()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList* g_list_alloc (void) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_list_alloc()
    @ccall libaravis.g_list_alloc()::Ptr{GList}
end

"""
    g_list_append(list, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList* g_list_append (GList *list, gpointer data) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_list_append(list, data)
    @ccall libaravis.g_list_append(list::Ptr{GList}, data::gpointer)::Ptr{GList}
end

"""
    g_list_prepend(list, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList* g_list_prepend (GList *list, gpointer data) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_list_prepend(list, data)
    @ccall libaravis.g_list_prepend(list::Ptr{GList}, data::gpointer)::Ptr{GList}
end

"""
    g_list_insert(list, data, position)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList* g_list_insert (GList *list, gpointer data, gint position) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_list_insert(list, data, position)
    @ccall libaravis.g_list_insert(list::Ptr{GList}, data::gpointer, position::gint)::Ptr{GList}
end

"""
    g_list_insert_sorted(list, data, func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList* g_list_insert_sorted (GList *list, gpointer data, GCompareFunc func) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_list_insert_sorted(list, data, func)
    @ccall libaravis.g_list_insert_sorted(list::Ptr{GList}, data::gpointer, func::GCompareFunc)::Ptr{GList}
end

"""
    g_list_insert_sorted_with_data(list, data, func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList* g_list_insert_sorted_with_data (GList *list, gpointer data, GCompareDataFunc func, gpointer user_data) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_list_insert_sorted_with_data(list, data, func, user_data)
    @ccall libaravis.g_list_insert_sorted_with_data(list::Ptr{GList}, data::gpointer, func::GCompareDataFunc, user_data::gpointer)::Ptr{GList}
end

"""
    g_list_insert_before(list, sibling, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList* g_list_insert_before (GList *list, GList *sibling, gpointer data) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_list_insert_before(list, sibling, data)
    @ccall libaravis.g_list_insert_before(list::Ptr{GList}, sibling::Ptr{GList}, data::gpointer)::Ptr{GList}
end

"""
    g_list_insert_before_link(list, sibling, link_)

### Prototype
```c
GLIB_AVAILABLE_IN_2_62 GList* g_list_insert_before_link (GList *list, GList *sibling, GList *link_) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_list_insert_before_link(list, sibling, link_)
    @ccall libaravis.g_list_insert_before_link(list::Ptr{GList}, sibling::Ptr{GList}, link_::Ptr{GList})::Ptr{GList}
end

"""
    g_list_concat(list1, list2)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList* g_list_concat (GList *list1, GList *list2) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_list_concat(list1, list2)
    @ccall libaravis.g_list_concat(list1::Ptr{GList}, list2::Ptr{GList})::Ptr{GList}
end

"""
    g_list_remove(list, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList* g_list_remove (GList *list, gconstpointer data) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_list_remove(list, data)
    @ccall libaravis.g_list_remove(list::Ptr{GList}, data::gconstpointer)::Ptr{GList}
end

"""
    g_list_remove_all(list, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList* g_list_remove_all (GList *list, gconstpointer data) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_list_remove_all(list, data)
    @ccall libaravis.g_list_remove_all(list::Ptr{GList}, data::gconstpointer)::Ptr{GList}
end

"""
    g_list_remove_link(list, llink)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList* g_list_remove_link (GList *list, GList *llink) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_list_remove_link(list, llink)
    @ccall libaravis.g_list_remove_link(list::Ptr{GList}, llink::Ptr{GList})::Ptr{GList}
end

"""
    g_list_delete_link(list, link_)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList* g_list_delete_link (GList *list, GList *link_) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_list_delete_link(list, link_)
    @ccall libaravis.g_list_delete_link(list::Ptr{GList}, link_::Ptr{GList})::Ptr{GList}
end

"""
    g_list_reverse(list)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList* g_list_reverse (GList *list) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_list_reverse(list)
    @ccall libaravis.g_list_reverse(list::Ptr{GList})::Ptr{GList}
end

"""
    g_list_copy(list)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList* g_list_copy (GList *list) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_list_copy(list)
    @ccall libaravis.g_list_copy(list::Ptr{GList})::Ptr{GList}
end

"""
    g_list_copy_deep(list, func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_2_34 GList* g_list_copy_deep (GList *list, GCopyFunc func, gpointer user_data) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_list_copy_deep(list, func, user_data)
    @ccall libaravis.g_list_copy_deep(list::Ptr{GList}, func::GCopyFunc, user_data::gpointer)::Ptr{GList}
end

"""
    g_list_nth(list, n)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList* g_list_nth (GList *list, guint n);
```
"""
function g_list_nth(list, n)
    @ccall libaravis.g_list_nth(list::Ptr{GList}, n::guint)::Ptr{GList}
end

"""
    g_list_nth_prev(list, n)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList* g_list_nth_prev (GList *list, guint n);
```
"""
function g_list_nth_prev(list, n)
    @ccall libaravis.g_list_nth_prev(list::Ptr{GList}, n::guint)::Ptr{GList}
end

"""
    g_list_find(list, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList* g_list_find (GList *list, gconstpointer data);
```
"""
function g_list_find(list, data)
    @ccall libaravis.g_list_find(list::Ptr{GList}, data::gconstpointer)::Ptr{GList}
end

"""
    g_list_find_custom(list, data, func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList* g_list_find_custom (GList *list, gconstpointer data, GCompareFunc func);
```
"""
function g_list_find_custom(list, data, func)
    @ccall libaravis.g_list_find_custom(list::Ptr{GList}, data::gconstpointer, func::GCompareFunc)::Ptr{GList}
end

"""
    g_list_position(list, llink)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_list_position (GList *list, GList *llink);
```
"""
function g_list_position(list, llink)
    @ccall libaravis.g_list_position(list::Ptr{GList}, llink::Ptr{GList})::gint
end

"""
    g_list_index(list, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_list_index (GList *list, gconstpointer data);
```
"""
function g_list_index(list, data)
    @ccall libaravis.g_list_index(list::Ptr{GList}, data::gconstpointer)::gint
end

"""
    g_list_last(list)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList* g_list_last (GList *list);
```
"""
function g_list_last(list)
    @ccall libaravis.g_list_last(list::Ptr{GList})::Ptr{GList}
end

"""
    g_list_first(list)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList* g_list_first (GList *list);
```
"""
function g_list_first(list)
    @ccall libaravis.g_list_first(list::Ptr{GList})::Ptr{GList}
end

"""
    g_list_length(list)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_list_length (GList *list);
```
"""
function g_list_length(list)
    @ccall libaravis.g_list_length(list::Ptr{GList})::guint
end

"""
    g_list_foreach(list, func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_list_foreach (GList *list, GFunc func, gpointer user_data);
```
"""
function g_list_foreach(list, func, user_data)
    @ccall libaravis.g_list_foreach(list::Ptr{GList}, func::GFunc, user_data::gpointer)::Cvoid
end

"""
    g_list_sort(list, compare_func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList* g_list_sort (GList *list, GCompareFunc compare_func) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_list_sort(list, compare_func)
    @ccall libaravis.g_list_sort(list::Ptr{GList}, compare_func::GCompareFunc)::Ptr{GList}
end

"""
    g_list_sort_with_data(list, compare_func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList* g_list_sort_with_data (GList *list, GCompareDataFunc compare_func, gpointer user_data) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_list_sort_with_data(list, compare_func, user_data)
    @ccall libaravis.g_list_sort_with_data(list::Ptr{GList}, compare_func::GCompareDataFunc, user_data::gpointer)::Ptr{GList}
end

"""
    g_list_nth_data(list, n)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_list_nth_data (GList *list, guint n);
```
"""
function g_list_nth_data(list, n)
    @ccall libaravis.g_list_nth_data(list::Ptr{GList}, n::guint)::gpointer
end

# typedef gboolean ( * GHRFunc ) ( gpointer key , gpointer value , gpointer user_data )
const GHRFunc = Ptr{Cvoid}

struct _GHashTableIter
    dummy1::gpointer
    dummy2::gpointer
    dummy3::gpointer
    dummy4::Cint
    dummy5::gboolean
    dummy6::gpointer
end

const GHashTableIter = _GHashTableIter

"""
    g_hash_table_new(hash_func, key_equal_func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GHashTable* g_hash_table_new (GHashFunc hash_func, GEqualFunc key_equal_func);
```
"""
function g_hash_table_new(hash_func, key_equal_func)
    @ccall libaravis.g_hash_table_new(hash_func::GHashFunc, key_equal_func::GEqualFunc)::Ptr{GHashTable}
end

"""
    g_hash_table_new_full(hash_func, key_equal_func, key_destroy_func, value_destroy_func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GHashTable* g_hash_table_new_full (GHashFunc hash_func, GEqualFunc key_equal_func, GDestroyNotify key_destroy_func, GDestroyNotify value_destroy_func);
```
"""
function g_hash_table_new_full(hash_func, key_equal_func, key_destroy_func, value_destroy_func)
    @ccall libaravis.g_hash_table_new_full(hash_func::GHashFunc, key_equal_func::GEqualFunc, key_destroy_func::GDestroyNotify, value_destroy_func::GDestroyNotify)::Ptr{GHashTable}
end

"""
    g_hash_table_new_similar(other_hash_table)

### Prototype
```c
GLIB_AVAILABLE_IN_2_72 GHashTable *g_hash_table_new_similar (GHashTable *other_hash_table);
```
"""
function g_hash_table_new_similar(other_hash_table)
    @ccall libaravis.g_hash_table_new_similar(other_hash_table::Ptr{GHashTable})::Ptr{GHashTable}
end

"""
    g_hash_table_destroy(hash_table)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_hash_table_destroy (GHashTable *hash_table);
```
"""
function g_hash_table_destroy(hash_table)
    @ccall libaravis.g_hash_table_destroy(hash_table::Ptr{GHashTable})::Cvoid
end

"""
    g_hash_table_insert(hash_table, key, value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_hash_table_insert (GHashTable *hash_table, gpointer key, gpointer value);
```
"""
function g_hash_table_insert(hash_table, key, value)
    @ccall libaravis.g_hash_table_insert(hash_table::Ptr{GHashTable}, key::gpointer, value::gpointer)::gboolean
end

"""
    g_hash_table_replace(hash_table, key, value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_hash_table_replace (GHashTable *hash_table, gpointer key, gpointer value);
```
"""
function g_hash_table_replace(hash_table, key, value)
    @ccall libaravis.g_hash_table_replace(hash_table::Ptr{GHashTable}, key::gpointer, value::gpointer)::gboolean
end

"""
    g_hash_table_add(hash_table, key)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_hash_table_add (GHashTable *hash_table, gpointer key);
```
"""
function g_hash_table_add(hash_table, key)
    @ccall libaravis.g_hash_table_add(hash_table::Ptr{GHashTable}, key::gpointer)::gboolean
end

"""
    g_hash_table_remove(hash_table, key)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_hash_table_remove (GHashTable *hash_table, gconstpointer key);
```
"""
function g_hash_table_remove(hash_table, key)
    @ccall libaravis.g_hash_table_remove(hash_table::Ptr{GHashTable}, key::gconstpointer)::gboolean
end

"""
    g_hash_table_remove_all(hash_table)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_hash_table_remove_all (GHashTable *hash_table);
```
"""
function g_hash_table_remove_all(hash_table)
    @ccall libaravis.g_hash_table_remove_all(hash_table::Ptr{GHashTable})::Cvoid
end

"""
    g_hash_table_steal(hash_table, key)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_hash_table_steal (GHashTable *hash_table, gconstpointer key);
```
"""
function g_hash_table_steal(hash_table, key)
    @ccall libaravis.g_hash_table_steal(hash_table::Ptr{GHashTable}, key::gconstpointer)::gboolean
end

"""
    g_hash_table_steal_extended(hash_table, lookup_key, stolen_key, stolen_value)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 gboolean g_hash_table_steal_extended (GHashTable *hash_table, gconstpointer lookup_key, gpointer *stolen_key, gpointer *stolen_value);
```
"""
function g_hash_table_steal_extended(hash_table, lookup_key, stolen_key, stolen_value)
    @ccall libaravis.g_hash_table_steal_extended(hash_table::Ptr{GHashTable}, lookup_key::gconstpointer, stolen_key::Ptr{gpointer}, stolen_value::Ptr{gpointer})::gboolean
end

"""
    g_hash_table_steal_all(hash_table)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_hash_table_steal_all (GHashTable *hash_table);
```
"""
function g_hash_table_steal_all(hash_table)
    @ccall libaravis.g_hash_table_steal_all(hash_table::Ptr{GHashTable})::Cvoid
end

"""
    g_hash_table_steal_all_keys(hash_table)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 GPtrArray * g_hash_table_steal_all_keys (GHashTable *hash_table);
```
"""
function g_hash_table_steal_all_keys(hash_table)
    @ccall libaravis.g_hash_table_steal_all_keys(hash_table::Ptr{GHashTable})::Ptr{GPtrArray}
end

"""
    g_hash_table_steal_all_values(hash_table)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 GPtrArray * g_hash_table_steal_all_values (GHashTable *hash_table);
```
"""
function g_hash_table_steal_all_values(hash_table)
    @ccall libaravis.g_hash_table_steal_all_values(hash_table::Ptr{GHashTable})::Ptr{GPtrArray}
end

"""
    g_hash_table_lookup(hash_table, key)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_hash_table_lookup (GHashTable *hash_table, gconstpointer key);
```
"""
function g_hash_table_lookup(hash_table, key)
    @ccall libaravis.g_hash_table_lookup(hash_table::Ptr{GHashTable}, key::gconstpointer)::gpointer
end

"""
    g_hash_table_contains(hash_table, key)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_hash_table_contains (GHashTable *hash_table, gconstpointer key);
```
"""
function g_hash_table_contains(hash_table, key)
    @ccall libaravis.g_hash_table_contains(hash_table::Ptr{GHashTable}, key::gconstpointer)::gboolean
end

"""
    g_hash_table_lookup_extended(hash_table, lookup_key, orig_key, value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_hash_table_lookup_extended (GHashTable *hash_table, gconstpointer lookup_key, gpointer *orig_key, gpointer *value);
```
"""
function g_hash_table_lookup_extended(hash_table, lookup_key, orig_key, value)
    @ccall libaravis.g_hash_table_lookup_extended(hash_table::Ptr{GHashTable}, lookup_key::gconstpointer, orig_key::Ptr{gpointer}, value::Ptr{gpointer})::gboolean
end

"""
    g_hash_table_foreach(hash_table, func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_hash_table_foreach (GHashTable *hash_table, GHFunc func, gpointer user_data);
```
"""
function g_hash_table_foreach(hash_table, func, user_data)
    @ccall libaravis.g_hash_table_foreach(hash_table::Ptr{GHashTable}, func::GHFunc, user_data::gpointer)::Cvoid
end

"""
    g_hash_table_find(hash_table, predicate, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_hash_table_find (GHashTable *hash_table, GHRFunc predicate, gpointer user_data);
```
"""
function g_hash_table_find(hash_table, predicate, user_data)
    @ccall libaravis.g_hash_table_find(hash_table::Ptr{GHashTable}, predicate::GHRFunc, user_data::gpointer)::gpointer
end

"""
    g_hash_table_foreach_remove(hash_table, func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_hash_table_foreach_remove (GHashTable *hash_table, GHRFunc func, gpointer user_data);
```
"""
function g_hash_table_foreach_remove(hash_table, func, user_data)
    @ccall libaravis.g_hash_table_foreach_remove(hash_table::Ptr{GHashTable}, func::GHRFunc, user_data::gpointer)::guint
end

"""
    g_hash_table_foreach_steal(hash_table, func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_hash_table_foreach_steal (GHashTable *hash_table, GHRFunc func, gpointer user_data);
```
"""
function g_hash_table_foreach_steal(hash_table, func, user_data)
    @ccall libaravis.g_hash_table_foreach_steal(hash_table::Ptr{GHashTable}, func::GHRFunc, user_data::gpointer)::guint
end

"""
    g_hash_table_size(hash_table)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_hash_table_size (GHashTable *hash_table);
```
"""
function g_hash_table_size(hash_table)
    @ccall libaravis.g_hash_table_size(hash_table::Ptr{GHashTable})::guint
end

"""
    g_hash_table_get_keys(hash_table)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList * g_hash_table_get_keys (GHashTable *hash_table);
```
"""
function g_hash_table_get_keys(hash_table)
    @ccall libaravis.g_hash_table_get_keys(hash_table::Ptr{GHashTable})::Ptr{GList}
end

"""
    g_hash_table_get_values(hash_table)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList * g_hash_table_get_values (GHashTable *hash_table);
```
"""
function g_hash_table_get_values(hash_table)
    @ccall libaravis.g_hash_table_get_values(hash_table::Ptr{GHashTable})::Ptr{GList}
end

"""
    g_hash_table_get_keys_as_array(hash_table, length)

### Prototype
```c
GLIB_AVAILABLE_IN_2_40 gpointer * g_hash_table_get_keys_as_array (GHashTable *hash_table, guint *length);
```
"""
function g_hash_table_get_keys_as_array(hash_table, length)
    @ccall libaravis.g_hash_table_get_keys_as_array(hash_table::Ptr{GHashTable}, length::Ptr{guint})::Ptr{gpointer}
end

"""
    g_hash_table_get_keys_as_ptr_array(hash_table)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 GPtrArray * g_hash_table_get_keys_as_ptr_array (GHashTable *hash_table);
```
"""
function g_hash_table_get_keys_as_ptr_array(hash_table)
    @ccall libaravis.g_hash_table_get_keys_as_ptr_array(hash_table::Ptr{GHashTable})::Ptr{GPtrArray}
end

"""
    g_hash_table_get_values_as_ptr_array(hash_table)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 GPtrArray * g_hash_table_get_values_as_ptr_array (GHashTable *hash_table);
```
"""
function g_hash_table_get_values_as_ptr_array(hash_table)
    @ccall libaravis.g_hash_table_get_values_as_ptr_array(hash_table::Ptr{GHashTable})::Ptr{GPtrArray}
end

"""
    g_hash_table_iter_init(iter, hash_table)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_hash_table_iter_init (GHashTableIter *iter, GHashTable *hash_table);
```
"""
function g_hash_table_iter_init(iter, hash_table)
    @ccall libaravis.g_hash_table_iter_init(iter::Ptr{GHashTableIter}, hash_table::Ptr{GHashTable})::Cvoid
end

"""
    g_hash_table_iter_next(iter, key, value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_hash_table_iter_next (GHashTableIter *iter, gpointer *key, gpointer *value);
```
"""
function g_hash_table_iter_next(iter, key, value)
    @ccall libaravis.g_hash_table_iter_next(iter::Ptr{GHashTableIter}, key::Ptr{gpointer}, value::Ptr{gpointer})::gboolean
end

"""
    g_hash_table_iter_get_hash_table(iter)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GHashTable* g_hash_table_iter_get_hash_table (GHashTableIter *iter);
```
"""
function g_hash_table_iter_get_hash_table(iter)
    @ccall libaravis.g_hash_table_iter_get_hash_table(iter::Ptr{GHashTableIter})::Ptr{GHashTable}
end

"""
    g_hash_table_iter_remove(iter)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_hash_table_iter_remove (GHashTableIter *iter);
```
"""
function g_hash_table_iter_remove(iter)
    @ccall libaravis.g_hash_table_iter_remove(iter::Ptr{GHashTableIter})::Cvoid
end

"""
    g_hash_table_iter_replace(iter, value)

### Prototype
```c
GLIB_AVAILABLE_IN_2_30 void g_hash_table_iter_replace (GHashTableIter *iter, gpointer value);
```
"""
function g_hash_table_iter_replace(iter, value)
    @ccall libaravis.g_hash_table_iter_replace(iter::Ptr{GHashTableIter}, value::gpointer)::Cvoid
end

"""
    g_hash_table_iter_steal(iter)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_hash_table_iter_steal (GHashTableIter *iter);
```
"""
function g_hash_table_iter_steal(iter)
    @ccall libaravis.g_hash_table_iter_steal(iter::Ptr{GHashTableIter})::Cvoid
end

"""
    g_hash_table_ref(hash_table)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GHashTable* g_hash_table_ref (GHashTable *hash_table);
```
"""
function g_hash_table_ref(hash_table)
    @ccall libaravis.g_hash_table_ref(hash_table::Ptr{GHashTable})::Ptr{GHashTable}
end

"""
    g_hash_table_unref(hash_table)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_hash_table_unref (GHashTable *hash_table);
```
"""
function g_hash_table_unref(hash_table)
    @ccall libaravis.g_hash_table_unref(hash_table::Ptr{GHashTable})::Cvoid
end

"""
    g_str_hash(v)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_str_hash (gconstpointer v);
```
"""
function g_str_hash(v)
    @ccall libaravis.g_str_hash(v::gconstpointer)::guint
end

"""
    g_int_equal(v1, v2)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_int_equal (gconstpointer v1, gconstpointer v2);
```
"""
function g_int_equal(v1, v2)
    @ccall libaravis.g_int_equal(v1::gconstpointer, v2::gconstpointer)::gboolean
end

"""
    g_int_hash(v)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_int_hash (gconstpointer v);
```
"""
function g_int_hash(v)
    @ccall libaravis.g_int_hash(v::gconstpointer)::guint
end

"""
    g_int64_equal(v1, v2)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_int64_equal (gconstpointer v1, gconstpointer v2);
```
"""
function g_int64_equal(v1, v2)
    @ccall libaravis.g_int64_equal(v1::gconstpointer, v2::gconstpointer)::gboolean
end

"""
    g_int64_hash(v)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_int64_hash (gconstpointer v);
```
"""
function g_int64_hash(v)
    @ccall libaravis.g_int64_hash(v::gconstpointer)::guint
end

"""
    g_double_equal(v1, v2)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_double_equal (gconstpointer v1, gconstpointer v2);
```
"""
function g_double_equal(v1, v2)
    @ccall libaravis.g_double_equal(v1::gconstpointer, v2::gconstpointer)::gboolean
end

"""
    g_double_hash(v)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_double_hash (gconstpointer v);
```
"""
function g_double_hash(v)
    @ccall libaravis.g_double_hash(v::gconstpointer)::guint
end

"""
    g_direct_hash(v)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_direct_hash (gconstpointer v) G_GNUC_CONST;
```
"""
function g_direct_hash(v)
    @ccall libaravis.g_direct_hash(v::gconstpointer)::guint
end

"""
    g_direct_equal(v1, v2)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_direct_equal (gconstpointer v1, gconstpointer v2) G_GNUC_CONST;
```
"""
function g_direct_equal(v1, v2)
    @ccall libaravis.g_direct_equal(v1::gconstpointer, v2::gconstpointer)::gboolean
end

const _GHmac = Cvoid

const GHmac = _GHmac

"""
    g_hmac_new(digest_type, key, key_len)

### Prototype
```c
GLIB_AVAILABLE_IN_2_30 GHmac * g_hmac_new (GChecksumType digest_type, const guchar *key, gsize key_len);
```
"""
function g_hmac_new(digest_type, key, key_len)
    @ccall libaravis.g_hmac_new(digest_type::GChecksumType, key::Ptr{guchar}, key_len::gsize)::Ptr{GHmac}
end

"""
    g_hmac_copy(hmac)

### Prototype
```c
GLIB_AVAILABLE_IN_2_30 GHmac * g_hmac_copy (const GHmac *hmac);
```
"""
function g_hmac_copy(hmac)
    @ccall libaravis.g_hmac_copy(hmac::Ptr{GHmac})::Ptr{GHmac}
end

"""
    g_hmac_ref(hmac)

### Prototype
```c
GLIB_AVAILABLE_IN_2_30 GHmac * g_hmac_ref (GHmac *hmac);
```
"""
function g_hmac_ref(hmac)
    @ccall libaravis.g_hmac_ref(hmac::Ptr{GHmac})::Ptr{GHmac}
end

"""
    g_hmac_unref(hmac)

### Prototype
```c
GLIB_AVAILABLE_IN_2_30 void g_hmac_unref (GHmac *hmac);
```
"""
function g_hmac_unref(hmac)
    @ccall libaravis.g_hmac_unref(hmac::Ptr{GHmac})::Cvoid
end

"""
    g_hmac_update(hmac, data, length)

### Prototype
```c
GLIB_AVAILABLE_IN_2_30 void g_hmac_update (GHmac *hmac, const guchar *data, gssize length);
```
"""
function g_hmac_update(hmac, data, length)
    @ccall libaravis.g_hmac_update(hmac::Ptr{GHmac}, data::Ptr{guchar}, length::gssize)::Cvoid
end

"""
    g_hmac_get_string(hmac)

### Prototype
```c
GLIB_AVAILABLE_IN_2_30 const gchar * g_hmac_get_string (GHmac *hmac);
```
"""
function g_hmac_get_string(hmac)
    @ccall libaravis.g_hmac_get_string(hmac::Ptr{GHmac})::Ptr{gchar}
end

"""
    g_hmac_get_digest(hmac, buffer, digest_len)

### Prototype
```c
GLIB_AVAILABLE_IN_2_30 void g_hmac_get_digest (GHmac *hmac, guint8 *buffer, gsize *digest_len);
```
"""
function g_hmac_get_digest(hmac, buffer, digest_len)
    @ccall libaravis.g_hmac_get_digest(hmac::Ptr{GHmac}, buffer::Ptr{guint8}, digest_len::Ptr{gsize})::Cvoid
end

"""
    g_compute_hmac_for_data(digest_type, key, key_len, data, length)

### Prototype
```c
GLIB_AVAILABLE_IN_2_30 gchar *g_compute_hmac_for_data (GChecksumType digest_type, const guchar *key, gsize key_len, const guchar *data, gsize length);
```
"""
function g_compute_hmac_for_data(digest_type, key, key_len, data, length)
    @ccall libaravis.g_compute_hmac_for_data(digest_type::GChecksumType, key::Ptr{guchar}, key_len::gsize, data::Ptr{guchar}, length::gsize)::Ptr{gchar}
end

"""
    g_compute_hmac_for_string(digest_type, key, key_len, str, length)

### Prototype
```c
GLIB_AVAILABLE_IN_2_30 gchar *g_compute_hmac_for_string (GChecksumType digest_type, const guchar *key, gsize key_len, const gchar *str, gssize length);
```
"""
function g_compute_hmac_for_string(digest_type, key, key_len, str, length)
    @ccall libaravis.g_compute_hmac_for_string(digest_type::GChecksumType, key::Ptr{guchar}, key_len::gsize, str::Ptr{gchar}, length::gssize)::Ptr{gchar}
end

"""
    g_compute_hmac_for_bytes(digest_type, key, data)

### Prototype
```c
GLIB_AVAILABLE_IN_2_50 gchar *g_compute_hmac_for_bytes (GChecksumType digest_type, GBytes *key, GBytes *data);
```
"""
function g_compute_hmac_for_bytes(digest_type, key, data)
    @ccall libaravis.g_compute_hmac_for_bytes(digest_type::GChecksumType, key::Ptr{GBytes}, data::Ptr{GBytes})::Ptr{gchar}
end

# typedef gint ( * GHookCompareFunc ) ( GHook * new_hook , GHook * sibling )
const GHookCompareFunc = Ptr{Cvoid}

# typedef gboolean ( * GHookFindFunc ) ( GHook * hook , gpointer data )
const GHookFindFunc = Ptr{Cvoid}

# typedef void ( * GHookMarshaller ) ( GHook * hook , gpointer marshal_data )
const GHookMarshaller = Ptr{Cvoid}

# typedef gboolean ( * GHookCheckMarshaller ) ( GHook * hook , gpointer marshal_data )
const GHookCheckMarshaller = Ptr{Cvoid}

# typedef void ( * GHookFunc ) ( gpointer data )
const GHookFunc = Ptr{Cvoid}

# typedef gboolean ( * GHookCheckFunc ) ( gpointer data )
const GHookCheckFunc = Ptr{Cvoid}

@cenum GHookFlagMask::UInt32 begin
    G_HOOK_FLAG_ACTIVE = 1
    G_HOOK_FLAG_IN_CALL = 2
    G_HOOK_FLAG_MASK = 15
end

"""
    g_hook_list_init(hook_list, hook_size)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_hook_list_init (GHookList *hook_list, guint hook_size);
```
"""
function g_hook_list_init(hook_list, hook_size)
    @ccall libaravis.g_hook_list_init(hook_list::Ptr{GHookList}, hook_size::guint)::Cvoid
end

"""
    g_hook_list_clear(hook_list)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_hook_list_clear (GHookList *hook_list);
```
"""
function g_hook_list_clear(hook_list)
    @ccall libaravis.g_hook_list_clear(hook_list::Ptr{GHookList})::Cvoid
end

"""
    g_hook_alloc(hook_list)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GHook* g_hook_alloc (GHookList *hook_list);
```
"""
function g_hook_alloc(hook_list)
    @ccall libaravis.g_hook_alloc(hook_list::Ptr{GHookList})::Ptr{GHook}
end

"""
    g_hook_free(hook_list, hook)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_hook_free (GHookList *hook_list, GHook *hook);
```
"""
function g_hook_free(hook_list, hook)
    @ccall libaravis.g_hook_free(hook_list::Ptr{GHookList}, hook::Ptr{GHook})::Cvoid
end

"""
    g_hook_ref(hook_list, hook)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GHook * g_hook_ref (GHookList *hook_list, GHook *hook);
```
"""
function g_hook_ref(hook_list, hook)
    @ccall libaravis.g_hook_ref(hook_list::Ptr{GHookList}, hook::Ptr{GHook})::Ptr{GHook}
end

"""
    g_hook_unref(hook_list, hook)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_hook_unref (GHookList *hook_list, GHook *hook);
```
"""
function g_hook_unref(hook_list, hook)
    @ccall libaravis.g_hook_unref(hook_list::Ptr{GHookList}, hook::Ptr{GHook})::Cvoid
end

"""
    g_hook_destroy(hook_list, hook_id)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_hook_destroy (GHookList *hook_list, gulong hook_id);
```
"""
function g_hook_destroy(hook_list, hook_id)
    @ccall libaravis.g_hook_destroy(hook_list::Ptr{GHookList}, hook_id::gulong)::gboolean
end

"""
    g_hook_destroy_link(hook_list, hook)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_hook_destroy_link (GHookList *hook_list, GHook *hook);
```
"""
function g_hook_destroy_link(hook_list, hook)
    @ccall libaravis.g_hook_destroy_link(hook_list::Ptr{GHookList}, hook::Ptr{GHook})::Cvoid
end

"""
    g_hook_prepend(hook_list, hook)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_hook_prepend (GHookList *hook_list, GHook *hook);
```
"""
function g_hook_prepend(hook_list, hook)
    @ccall libaravis.g_hook_prepend(hook_list::Ptr{GHookList}, hook::Ptr{GHook})::Cvoid
end

"""
    g_hook_insert_sorted(hook_list, hook, func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_hook_insert_sorted (GHookList *hook_list, GHook *hook, GHookCompareFunc func);
```
"""
function g_hook_insert_sorted(hook_list, hook, func)
    @ccall libaravis.g_hook_insert_sorted(hook_list::Ptr{GHookList}, hook::Ptr{GHook}, func::GHookCompareFunc)::Cvoid
end

"""
    g_hook_get(hook_list, hook_id)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GHook* g_hook_get (GHookList *hook_list, gulong hook_id);
```
"""
function g_hook_get(hook_list, hook_id)
    @ccall libaravis.g_hook_get(hook_list::Ptr{GHookList}, hook_id::gulong)::Ptr{GHook}
end

"""
    g_hook_find(hook_list, need_valids, func, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GHook* g_hook_find (GHookList *hook_list, gboolean need_valids, GHookFindFunc func, gpointer data);
```
"""
function g_hook_find(hook_list, need_valids, func, data)
    @ccall libaravis.g_hook_find(hook_list::Ptr{GHookList}, need_valids::gboolean, func::GHookFindFunc, data::gpointer)::Ptr{GHook}
end

"""
    g_hook_find_data(hook_list, need_valids, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GHook* g_hook_find_data (GHookList *hook_list, gboolean need_valids, gpointer data);
```
"""
function g_hook_find_data(hook_list, need_valids, data)
    @ccall libaravis.g_hook_find_data(hook_list::Ptr{GHookList}, need_valids::gboolean, data::gpointer)::Ptr{GHook}
end

"""
    g_hook_find_func(hook_list, need_valids, func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GHook* g_hook_find_func (GHookList *hook_list, gboolean need_valids, gpointer func);
```
"""
function g_hook_find_func(hook_list, need_valids, func)
    @ccall libaravis.g_hook_find_func(hook_list::Ptr{GHookList}, need_valids::gboolean, func::gpointer)::Ptr{GHook}
end

"""
    g_hook_find_func_data(hook_list, need_valids, func, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GHook* g_hook_find_func_data (GHookList *hook_list, gboolean need_valids, gpointer func, gpointer data);
```
"""
function g_hook_find_func_data(hook_list, need_valids, func, data)
    @ccall libaravis.g_hook_find_func_data(hook_list::Ptr{GHookList}, need_valids::gboolean, func::gpointer, data::gpointer)::Ptr{GHook}
end

"""
    g_hook_first_valid(hook_list, may_be_in_call)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GHook* g_hook_first_valid (GHookList *hook_list, gboolean may_be_in_call);
```
"""
function g_hook_first_valid(hook_list, may_be_in_call)
    @ccall libaravis.g_hook_first_valid(hook_list::Ptr{GHookList}, may_be_in_call::gboolean)::Ptr{GHook}
end

"""
    g_hook_next_valid(hook_list, hook, may_be_in_call)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GHook* g_hook_next_valid (GHookList *hook_list, GHook *hook, gboolean may_be_in_call);
```
"""
function g_hook_next_valid(hook_list, hook, may_be_in_call)
    @ccall libaravis.g_hook_next_valid(hook_list::Ptr{GHookList}, hook::Ptr{GHook}, may_be_in_call::gboolean)::Ptr{GHook}
end

"""
    g_hook_compare_ids(new_hook, sibling)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_hook_compare_ids (GHook *new_hook, GHook *sibling);
```
"""
function g_hook_compare_ids(new_hook, sibling)
    @ccall libaravis.g_hook_compare_ids(new_hook::Ptr{GHook}, sibling::Ptr{GHook})::gint
end

"""
    g_hook_list_invoke(hook_list, may_recurse)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_hook_list_invoke (GHookList *hook_list, gboolean may_recurse);
```
"""
function g_hook_list_invoke(hook_list, may_recurse)
    @ccall libaravis.g_hook_list_invoke(hook_list::Ptr{GHookList}, may_recurse::gboolean)::Cvoid
end

"""
    g_hook_list_invoke_check(hook_list, may_recurse)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_hook_list_invoke_check (GHookList *hook_list, gboolean may_recurse);
```
"""
function g_hook_list_invoke_check(hook_list, may_recurse)
    @ccall libaravis.g_hook_list_invoke_check(hook_list::Ptr{GHookList}, may_recurse::gboolean)::Cvoid
end

"""
    g_hook_list_marshal(hook_list, may_recurse, marshaller, marshal_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_hook_list_marshal (GHookList *hook_list, gboolean may_recurse, GHookMarshaller marshaller, gpointer marshal_data);
```
"""
function g_hook_list_marshal(hook_list, may_recurse, marshaller, marshal_data)
    @ccall libaravis.g_hook_list_marshal(hook_list::Ptr{GHookList}, may_recurse::gboolean, marshaller::GHookMarshaller, marshal_data::gpointer)::Cvoid
end

"""
    g_hook_list_marshal_check(hook_list, may_recurse, marshaller, marshal_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_hook_list_marshal_check (GHookList *hook_list, gboolean may_recurse, GHookCheckMarshaller marshaller, gpointer marshal_data);
```
"""
function g_hook_list_marshal_check(hook_list, may_recurse, marshaller, marshal_data)
    @ccall libaravis.g_hook_list_marshal_check(hook_list::Ptr{GHookList}, may_recurse::gboolean, marshaller::GHookCheckMarshaller, marshal_data::gpointer)::Cvoid
end

"""
    g_hostname_is_non_ascii(hostname)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_hostname_is_non_ascii (const gchar *hostname);
```
"""
function g_hostname_is_non_ascii(hostname)
    @ccall libaravis.g_hostname_is_non_ascii(hostname::Ptr{gchar})::gboolean
end

"""
    g_hostname_is_ascii_encoded(hostname)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_hostname_is_ascii_encoded (const gchar *hostname);
```
"""
function g_hostname_is_ascii_encoded(hostname)
    @ccall libaravis.g_hostname_is_ascii_encoded(hostname::Ptr{gchar})::gboolean
end

"""
    g_hostname_is_ip_address(hostname)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_hostname_is_ip_address (const gchar *hostname);
```
"""
function g_hostname_is_ip_address(hostname)
    @ccall libaravis.g_hostname_is_ip_address(hostname::Ptr{gchar})::gboolean
end

"""
    g_hostname_to_ascii(hostname)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_hostname_to_ascii (const gchar *hostname);
```
"""
function g_hostname_to_ascii(hostname)
    @ccall libaravis.g_hostname_to_ascii(hostname::Ptr{gchar})::Ptr{gchar}
end

"""
    g_hostname_to_unicode(hostname)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_hostname_to_unicode (const gchar *hostname);
```
"""
function g_hostname_to_unicode(hostname)
    @ccall libaravis.g_hostname_to_unicode(hostname::Ptr{gchar})::Ptr{gchar}
end

"""
    _GPollFD

[`GPollFD`](@ref): : the file descriptor to poll (or a HANDLE on Win32) : a bitwise combination from #[`GIOCondition`](@ref), specifying which events should be polled for. Typically for reading from a file descriptor you would use G\\_IO\\_IN | G\\_IO\\_HUP | G\\_IO\\_ERR, and for writing you would use G\\_IO\\_OUT | G\\_IO\\_ERR. : a bitwise combination of flags from #[`GIOCondition`](@ref), returned from the poll() function to indicate which events occurred.

Represents a file descriptor, which events to poll for, and which events occurred.
"""
struct _GPollFD
    fd::gint
    events::gushort
    revents::gushort
end

"""
[`GPollFD`](@ref): : the file descriptor to poll (or a HANDLE on Win32) : a bitwise combination from #[`GIOCondition`](@ref), specifying which events should be polled for. Typically for reading from a file descriptor you would use G\\_IO\\_IN | G\\_IO\\_HUP | G\\_IO\\_ERR, and for writing you would use G\\_IO\\_OUT | G\\_IO\\_ERR. : a bitwise combination of flags from #[`GIOCondition`](@ref), returned from the poll() function to indicate which events occurred.

Represents a file descriptor, which events to poll for, and which events occurred.
"""
const GPollFD = _GPollFD

"""
    g_poll(fds, nfds, timeout)

[`G_POLLFD_FORMAT`](@ref):

A format specifier that can be used in printf()-style format strings when printing the  member of a #[`GPollFD`](@ref).

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_poll (GPollFD *fds, guint nfds, gint timeout);
```
"""
function g_poll(fds, nfds, timeout)
    @ccall libaravis.g_poll(fds::Ptr{GPollFD}, nfds::guint, timeout::gint)::gint
end

"""
    g_slist_alloc()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSList* g_slist_alloc (void) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_slist_alloc()
    @ccall libaravis.g_slist_alloc()::Ptr{GSList}
end

"""
    g_slist_append(list, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSList* g_slist_append (GSList *list, gpointer data) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_slist_append(list, data)
    @ccall libaravis.g_slist_append(list::Ptr{GSList}, data::gpointer)::Ptr{GSList}
end

"""
    g_slist_prepend(list, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSList* g_slist_prepend (GSList *list, gpointer data) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_slist_prepend(list, data)
    @ccall libaravis.g_slist_prepend(list::Ptr{GSList}, data::gpointer)::Ptr{GSList}
end

"""
    g_slist_insert(list, data, position)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSList* g_slist_insert (GSList *list, gpointer data, gint position) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_slist_insert(list, data, position)
    @ccall libaravis.g_slist_insert(list::Ptr{GSList}, data::gpointer, position::gint)::Ptr{GSList}
end

"""
    g_slist_insert_sorted(list, data, func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSList* g_slist_insert_sorted (GSList *list, gpointer data, GCompareFunc func) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_slist_insert_sorted(list, data, func)
    @ccall libaravis.g_slist_insert_sorted(list::Ptr{GSList}, data::gpointer, func::GCompareFunc)::Ptr{GSList}
end

"""
    g_slist_insert_sorted_with_data(list, data, func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSList* g_slist_insert_sorted_with_data (GSList *list, gpointer data, GCompareDataFunc func, gpointer user_data) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_slist_insert_sorted_with_data(list, data, func, user_data)
    @ccall libaravis.g_slist_insert_sorted_with_data(list::Ptr{GSList}, data::gpointer, func::GCompareDataFunc, user_data::gpointer)::Ptr{GSList}
end

"""
    g_slist_insert_before(slist, sibling, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSList* g_slist_insert_before (GSList *slist, GSList *sibling, gpointer data) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_slist_insert_before(slist, sibling, data)
    @ccall libaravis.g_slist_insert_before(slist::Ptr{GSList}, sibling::Ptr{GSList}, data::gpointer)::Ptr{GSList}
end

"""
    g_slist_concat(list1, list2)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSList* g_slist_concat (GSList *list1, GSList *list2) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_slist_concat(list1, list2)
    @ccall libaravis.g_slist_concat(list1::Ptr{GSList}, list2::Ptr{GSList})::Ptr{GSList}
end

"""
    g_slist_remove(list, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSList* g_slist_remove (GSList *list, gconstpointer data) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_slist_remove(list, data)
    @ccall libaravis.g_slist_remove(list::Ptr{GSList}, data::gconstpointer)::Ptr{GSList}
end

"""
    g_slist_remove_all(list, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSList* g_slist_remove_all (GSList *list, gconstpointer data) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_slist_remove_all(list, data)
    @ccall libaravis.g_slist_remove_all(list::Ptr{GSList}, data::gconstpointer)::Ptr{GSList}
end

"""
    g_slist_remove_link(list, link_)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSList* g_slist_remove_link (GSList *list, GSList *link_) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_slist_remove_link(list, link_)
    @ccall libaravis.g_slist_remove_link(list::Ptr{GSList}, link_::Ptr{GSList})::Ptr{GSList}
end

"""
    g_slist_delete_link(list, link_)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSList* g_slist_delete_link (GSList *list, GSList *link_) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_slist_delete_link(list, link_)
    @ccall libaravis.g_slist_delete_link(list::Ptr{GSList}, link_::Ptr{GSList})::Ptr{GSList}
end

"""
    g_slist_reverse(list)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSList* g_slist_reverse (GSList *list) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_slist_reverse(list)
    @ccall libaravis.g_slist_reverse(list::Ptr{GSList})::Ptr{GSList}
end

"""
    g_slist_copy(list)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSList* g_slist_copy (GSList *list) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_slist_copy(list)
    @ccall libaravis.g_slist_copy(list::Ptr{GSList})::Ptr{GSList}
end

"""
    g_slist_copy_deep(list, func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_2_34 GSList* g_slist_copy_deep (GSList *list, GCopyFunc func, gpointer user_data) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_slist_copy_deep(list, func, user_data)
    @ccall libaravis.g_slist_copy_deep(list::Ptr{GSList}, func::GCopyFunc, user_data::gpointer)::Ptr{GSList}
end

"""
    g_slist_nth(list, n)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSList* g_slist_nth (GSList *list, guint n);
```
"""
function g_slist_nth(list, n)
    @ccall libaravis.g_slist_nth(list::Ptr{GSList}, n::guint)::Ptr{GSList}
end

"""
    g_slist_find(list, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSList* g_slist_find (GSList *list, gconstpointer data);
```
"""
function g_slist_find(list, data)
    @ccall libaravis.g_slist_find(list::Ptr{GSList}, data::gconstpointer)::Ptr{GSList}
end

"""
    g_slist_find_custom(list, data, func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSList* g_slist_find_custom (GSList *list, gconstpointer data, GCompareFunc func);
```
"""
function g_slist_find_custom(list, data, func)
    @ccall libaravis.g_slist_find_custom(list::Ptr{GSList}, data::gconstpointer, func::GCompareFunc)::Ptr{GSList}
end

"""
    g_slist_position(list, llink)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_slist_position (GSList *list, GSList *llink);
```
"""
function g_slist_position(list, llink)
    @ccall libaravis.g_slist_position(list::Ptr{GSList}, llink::Ptr{GSList})::gint
end

"""
    g_slist_index(list, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_slist_index (GSList *list, gconstpointer data);
```
"""
function g_slist_index(list, data)
    @ccall libaravis.g_slist_index(list::Ptr{GSList}, data::gconstpointer)::gint
end

"""
    g_slist_last(list)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSList* g_slist_last (GSList *list);
```
"""
function g_slist_last(list)
    @ccall libaravis.g_slist_last(list::Ptr{GSList})::Ptr{GSList}
end

"""
    g_slist_length(list)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_slist_length (GSList *list);
```
"""
function g_slist_length(list)
    @ccall libaravis.g_slist_length(list::Ptr{GSList})::guint
end

"""
    g_slist_foreach(list, func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_slist_foreach (GSList *list, GFunc func, gpointer user_data);
```
"""
function g_slist_foreach(list, func, user_data)
    @ccall libaravis.g_slist_foreach(list::Ptr{GSList}, func::GFunc, user_data::gpointer)::Cvoid
end

"""
    g_slist_sort(list, compare_func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSList* g_slist_sort (GSList *list, GCompareFunc compare_func) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_slist_sort(list, compare_func)
    @ccall libaravis.g_slist_sort(list::Ptr{GSList}, compare_func::GCompareFunc)::Ptr{GSList}
end

"""
    g_slist_sort_with_data(list, compare_func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSList* g_slist_sort_with_data (GSList *list, GCompareDataFunc compare_func, gpointer user_data) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_slist_sort_with_data(list, compare_func, user_data)
    @ccall libaravis.g_slist_sort_with_data(list::Ptr{GSList}, compare_func::GCompareDataFunc, user_data::gpointer)::Ptr{GSList}
end

"""
    g_slist_nth_data(list, n)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_slist_nth_data (GSList *list, guint n);
```
"""
function g_slist_nth_data(list, n)
    @ccall libaravis.g_slist_nth_data(list::Ptr{GSList}, n::guint)::gpointer
end

@cenum GIOCondition::UInt32 begin
    G_IO_IN = 1
    G_IO_OUT = 4
    G_IO_PRI = 2
    G_IO_ERR = 8
    G_IO_HUP = 16
    G_IO_NVAL = 32
end

"""
    GMainContextFlags

[`GMainContextFlags`](@ref): \\_MAIN\\_CONTEXT\\_FLAGS\\_NONE: Default behaviour. \\_MAIN\\_CONTEXT\\_FLAGS\\_OWNERLESS\\_POLLING: Assume that polling for events will free the thread to process other jobs. That's useful if you're using `g\\_main\\_context\\_{prepare,query,check,dispatch}` to integrate [`GMainContext`](@ref) in other event loops.

Flags to pass to [ctor.MainContext.new\\_with\\_flags] which affect the behaviour of a [struct.MainContext].

Since: 2.72
"""
@cenum GMainContextFlags::UInt32 begin
    G_MAIN_CONTEXT_FLAGS_NONE = 0
    G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING = 1
end

struct _GSourceCallbackFuncs
    ref::Ptr{Cvoid}
    unref::Ptr{Cvoid}
    get::Ptr{Cvoid}
end

"""
[`GSourceCallbackFuncs`](@ref): : Called when a reference is added to the callback object : Called when a reference to the callback object is dropped : Called to extract the callback function and data from the callback object.

The [`GSourceCallbackFuncs`](@ref) struct contains functions for managing callback objects.
"""
const GSourceCallbackFuncs = _GSourceCallbackFuncs

# typedef gboolean ( * GSourceFuncsPrepareFunc ) ( GSource * source , gint * timeout_ )
"""
[`GSourceFuncsPrepareFunc`](@ref): : The #[`GSource`](@ref) \\_: (out) (optional): the maximum timeout (in milliseconds) which should be passed to the poll call

Checks the source for readiness.

Called before all the file descriptors are polled. If the source can determine that it is ready here (without waiting for the results of the poll call) it should return TRUE. It can also return a \\_ value which should be the maximum timeout (in milliseconds) which should be passed to the poll call. The actual timeout used will be `-1` if all sources returned `-1`, or it will be the minimum of all the \\_ values returned which were greater than or equal to `0`. If the prepare function returns a timeout and the source also has a ready time set, then the lower of the two will be used.

Since 2.36 this may be `NULL`, in which case the effect is as if the function always returns [`FALSE`](@ref) with a timeout of `-1`.

Returns: TRUE if the source is ready, FALSE otherwise

Since: 2.82
"""
const GSourceFuncsPrepareFunc = Ptr{Cvoid}

# typedef gboolean ( * GSourceFuncsCheckFunc ) ( GSource * source )
"""
[`GSourceFuncsCheckFunc`](@ref): : The #[`GSource`](@ref)

Checks if the source is ready to be dispatched.

Called after all the file descriptors are polled. The source should return TRUE if it is ready to be dispatched. Note that some time may have passed since the previous prepare function was called, so the source should be checked again here.

Since 2.36 this may be `NULL`, in which case the effect is as if the function always returns [`FALSE`](@ref).

Returns: TRUE if ready to be dispatched, FALSE otherwise

Since: 2.82
"""
const GSourceFuncsCheckFunc = Ptr{Cvoid}

# typedef gboolean ( * GSourceFuncsDispatchFunc ) ( GSource * source , GSourceFunc callback , gpointer user_data )
"""
[`GSourceFuncsDispatchFunc`](@ref): : The #[`GSource`](@ref)

`: (nullable): The #GSourceFunc to call`

\\_data: (nullable): data to pass to

``

Dispatches the source callback.

Called to dispatch the event source, after it has returned [`TRUE`](@ref) in either its prepare or its check function, or if a ready time has been reached. The dispatch function receives a callback function and user data. The callback function may be `NULL` if the source was never connected to a callback using [method.Source.set\\_callback]. The dispatch function should call the callback function with \\_data and whatever additional parameters are needed for this type of event source. The return value of the dispatch function should be [const.SOURCE\\_REMOVE] if the source should be removed or [const.SOURCE\\_CONTINUE] to keep it.

Returns: [const.SOURCE\\_REMOVE] if the source should be removed, [const.SOURCE\\_CONTINUE] otherwise.

Since: 2.82
"""
const GSourceFuncsDispatchFunc = Ptr{Cvoid}

# typedef void ( * GSourceFuncsFinalizeFunc ) ( GSource * source )
"""
[`GSourceFuncsFinalizeFunc`](@ref): : The #[`GSource`](@ref)

Finalizes the source.

Called when the source is finalized. At this point, the source will have been destroyed, had its callback cleared, and have been removed from its [type.MainContext], but it will still have its final reference count, so methods can be called on it from within this function.

Since: 2.82
"""
const GSourceFuncsFinalizeFunc = Ptr{Cvoid}

# typedef void ( * GSourceDummyMarshal ) ( void )
"""
[`GSourceDummyMarshal`](@ref):

This is just a placeholder for #[`GClosureMarshal`](@ref), which cannot be used here for dependency reasons.
"""
const GSourceDummyMarshal = Ptr{Cvoid}

struct _GSourceFuncs
    prepare::GSourceFuncsPrepareFunc
    check::GSourceFuncsCheckFunc
    dispatch::GSourceFuncsDispatchFunc
    finalize::GSourceFuncsFinalizeFunc
    closure_callback::GSourceFunc
    closure_marshal::GSourceDummyMarshal
end

"""
[`GSourceFuncs`](@ref): : (nullable): Called before all the file descriptors are polled. If the source can determine that it is ready here (without waiting for the results of the poll() call) it should return TRUE. It can also return a \\_ value which should be the maximum timeout (in milliseconds) which should be passed to the poll() call. The actual timeout used will be -1 if all sources returned -1, or it will be the minimum of all the \\_ values returned which were >= 0. Since 2.36 this may be NULL, in which case the effect is as if the function always returns FALSE with a timeout of -1. If  returns a timeout and the source also has a ready time set, then the lower of the two will be used. : (nullable): Called after all the file descriptors are polled. The source should return TRUE if it is ready to be dispatched. Note that some time may have passed since the previous prepare function was called, so the source should be checked again here. Since 2.36 this may be NULL, in which case the effect is as if the function always returns FALSE. : Called to dispatch the event source, after it has returned TRUE in either its  or its  function, or if a ready time has been reached. The  function receives a callback function and user data. The callback function may be NULL if the source was never connected to a callback using [method.Source.set\\_callback]. The  function should call the callback function with \\_data and whatever additional parameters are needed for this type of event source. The return value of the  function should be [const.SOURCE\\_REMOVE] if the source should be removed or [const.SOURCE\\_CONTINUE] to keep it. : (nullable): Called when the source is finalized. At this point, the source will have been destroyed, had its callback cleared, and have been removed from its [struct.MainContext], but it will still have its final reference count, so methods can be called on it from within this function. This may be NULL, in which case the effect is as if the function does nothing and returns.

The [`GSourceFuncs`](@ref) struct contains a table of functions used to handle event sources in a generic manner.

For idle sources, the prepare and check functions always return TRUE to indicate that the source is always ready to be processed. The prepare function also returns a timeout value of 0 to ensure that the poll() call doesn't block (since that would be time wasted which could have been spent running the idle function).

For timeout sources, the prepare and check functions both return TRUE if the timeout interval has expired. The prepare function also returns a timeout value to ensure that the poll() call doesn't block too long and miss the next timeout.

For file descriptor sources, the prepare function typically returns FALSE, since it must wait until poll() has been called before it knows whether any events need to be processed. It sets the returned timeout to -1 to indicate that it doesn't mind how long the poll() call blocks. In the check function, it tests the results of the poll() call to see if the required condition has been met, and returns TRUE if so.
"""
const GSourceFuncs = _GSourceFuncs

const _GSourcePrivate = Cvoid

const GSourcePrivate = _GSourcePrivate

struct _GSource
    callback_data::gpointer
    callback_funcs::Ptr{GSourceCallbackFuncs}
    source_funcs::Ptr{GSourceFuncs}
    ref_count::guint
    context::Ptr{GMainContext}
    priority::gint
    flags::guint
    source_id::guint
    poll_fds::Ptr{GSList}
    prev::Ptr{Cvoid} # prev::Ptr{GSource}
    next::Ptr{Cvoid} # next::Ptr{GSource}
    name::Cstring
    priv::Ptr{GSourcePrivate}
end

function Base.getproperty(x::_GSource, f::Symbol)
    f === :prev && return Ptr{GSource}(getfield(x, f))
    f === :next && return Ptr{GSource}(getfield(x, f))
    return getfield(x, f)
end

"""
[`GSource`](@ref):

The [`GSource`](@ref) struct is an opaque data type representing an event source.
"""
const GSource = _GSource

# typedef void ( * GSourceOnceFunc ) ( gpointer user_data )
"""
[`GSourceOnceFunc`](@ref): \\_data: data passed to the function, set when the source was created

A source function that is only called once before being removed from the main context automatically.

See: [func.idle\\_add\\_once], [func.timeout\\_add\\_once]

Since: 2.74
"""
const GSourceOnceFunc = Ptr{Cvoid}

# typedef void ( * GChildWatchFunc ) ( GPid pid , gint wait_status , gpointer user_data )
"""
[`GChildWatchFunc`](@ref): : the process id of the child process \\_status: Status information about the child process, encoded in a platform-specific manner \\_data: user data passed to [func.child\\_watch\\_add]

Prototype of a #GChildWatchSource callback, called when a child process has exited.

To interpret \\_status, see the documentation for [func.spawn\\_check\\_wait\\_status]. In particular, on Unix platforms, note that it is usually not equal to the integer passed to `exit()` or returned from `main()`.
"""
const GChildWatchFunc = Ptr{Cvoid}

# typedef void ( * GSourceDisposeFunc ) ( GSource * source )
"""
[`GSourceDisposeFunc`](@ref): : #[`GSource`](@ref) that is currently being disposed

Dispose function for . See [method.Source.set\\_dispose\\_function] for details.

Since: 2.64
"""
const GSourceDisposeFunc = Ptr{Cvoid}

"""
    g_main_context_new()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GMainContext *g_main_context_new (void);
```
"""
function g_main_context_new()
    @ccall libaravis.g_main_context_new()::Ptr{GMainContext}
end

"""
    g_main_context_new_with_flags(flags)

### Prototype
```c
GLIB_AVAILABLE_IN_2_72 GMainContext *g_main_context_new_with_flags (GMainContextFlags flags);
```
"""
function g_main_context_new_with_flags(flags)
    @ccall libaravis.g_main_context_new_with_flags(flags::GMainContextFlags)::Ptr{GMainContext}
end

"""
    g_main_context_ref(context)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GMainContext *g_main_context_ref (GMainContext *context);
```
"""
function g_main_context_ref(context)
    @ccall libaravis.g_main_context_ref(context::Ptr{GMainContext})::Ptr{GMainContext}
end

"""
    g_main_context_unref(context)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_main_context_unref (GMainContext *context);
```
"""
function g_main_context_unref(context)
    @ccall libaravis.g_main_context_unref(context::Ptr{GMainContext})::Cvoid
end

"""
    g_main_context_default()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GMainContext *g_main_context_default (void);
```
"""
function g_main_context_default()
    @ccall libaravis.g_main_context_default()::Ptr{GMainContext}
end

"""
    g_main_context_find_source_by_id(context, source_id)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSource *g_main_context_find_source_by_id (GMainContext *context, guint source_id);
```
"""
function g_main_context_find_source_by_id(context, source_id)
    @ccall libaravis.g_main_context_find_source_by_id(context::Ptr{GMainContext}, source_id::guint)::Ptr{GSource}
end

"""
    g_main_context_find_source_by_user_data(context, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSource *g_main_context_find_source_by_user_data (GMainContext *context, gpointer user_data);
```
"""
function g_main_context_find_source_by_user_data(context, user_data)
    @ccall libaravis.g_main_context_find_source_by_user_data(context::Ptr{GMainContext}, user_data::gpointer)::Ptr{GSource}
end

"""
    g_main_context_find_source_by_funcs_user_data(context, funcs, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSource *g_main_context_find_source_by_funcs_user_data (GMainContext *context, GSourceFuncs *funcs, gpointer user_data);
```
"""
function g_main_context_find_source_by_funcs_user_data(context, funcs, user_data)
    @ccall libaravis.g_main_context_find_source_by_funcs_user_data(context::Ptr{GMainContext}, funcs::Ptr{GSourceFuncs}, user_data::gpointer)::Ptr{GSource}
end

"""
    g_main_context_wakeup(context)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_main_context_wakeup (GMainContext *context);
```
"""
function g_main_context_wakeup(context)
    @ccall libaravis.g_main_context_wakeup(context::Ptr{GMainContext})::Cvoid
end

"""
    g_main_context_acquire(context)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_main_context_acquire (GMainContext *context);
```
"""
function g_main_context_acquire(context)
    @ccall libaravis.g_main_context_acquire(context::Ptr{GMainContext})::gboolean
end

"""
    g_main_context_release(context)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_main_context_release (GMainContext *context);
```
"""
function g_main_context_release(context)
    @ccall libaravis.g_main_context_release(context::Ptr{GMainContext})::Cvoid
end

"""
    g_main_context_is_owner(context)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_main_context_is_owner (GMainContext *context);
```
"""
function g_main_context_is_owner(context)
    @ccall libaravis.g_main_context_is_owner(context::Ptr{GMainContext})::gboolean
end

"""
    g_main_context_wait(context, cond, mutex)

### Prototype
```c
GLIB_DEPRECATED_IN_2_58_FOR(g_main_context_is_owner) gboolean g_main_context_wait (GMainContext *context, GCond *cond, GMutex *mutex);
```
"""
function g_main_context_wait(context, cond, mutex)
    @ccall libaravis.g_main_context_wait(context::Ptr{GMainContext}, cond::Ptr{GCond}, mutex::Ptr{GMutex})::gboolean
end

"""
    g_main_context_prepare(context, priority)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_main_context_prepare (GMainContext *context, gint *priority);
```
"""
function g_main_context_prepare(context, priority)
    @ccall libaravis.g_main_context_prepare(context::Ptr{GMainContext}, priority::Ptr{gint})::gboolean
end

"""
    g_main_context_query(context, max_priority, timeout_, fds, n_fds)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_main_context_query (GMainContext *context, gint max_priority, gint *timeout_, GPollFD *fds, gint n_fds);
```
"""
function g_main_context_query(context, max_priority, timeout_, fds, n_fds)
    @ccall libaravis.g_main_context_query(context::Ptr{GMainContext}, max_priority::gint, timeout_::Ptr{gint}, fds::Ptr{GPollFD}, n_fds::gint)::gint
end

"""
    g_main_context_check(context, max_priority, fds, n_fds)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_main_context_check (GMainContext *context, gint max_priority, GPollFD *fds, gint n_fds);
```
"""
function g_main_context_check(context, max_priority, fds, n_fds)
    @ccall libaravis.g_main_context_check(context::Ptr{GMainContext}, max_priority::gint, fds::Ptr{GPollFD}, n_fds::gint)::gboolean
end

"""
    g_main_context_dispatch(context)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_main_context_dispatch (GMainContext *context);
```
"""
function g_main_context_dispatch(context)
    @ccall libaravis.g_main_context_dispatch(context::Ptr{GMainContext})::Cvoid
end

"""
    g_main_context_get_poll_func(context)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GPollFunc g_main_context_get_poll_func (GMainContext *context);
```
"""
function g_main_context_get_poll_func(context)
    @ccall libaravis.g_main_context_get_poll_func(context::Ptr{GMainContext})::GPollFunc
end

"""
    g_main_context_add_poll(context, fd, priority)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_main_context_add_poll (GMainContext *context, GPollFD *fd, gint priority);
```
"""
function g_main_context_add_poll(context, fd, priority)
    @ccall libaravis.g_main_context_add_poll(context::Ptr{GMainContext}, fd::Ptr{GPollFD}, priority::gint)::Cvoid
end

"""
    g_main_context_remove_poll(context, fd)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_main_context_remove_poll (GMainContext *context, GPollFD *fd);
```
"""
function g_main_context_remove_poll(context, fd)
    @ccall libaravis.g_main_context_remove_poll(context::Ptr{GMainContext}, fd::Ptr{GPollFD})::Cvoid
end

"""
    g_main_depth()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_main_depth (void);
```
"""
function g_main_depth()
    @ccall libaravis.g_main_depth()::gint
end

"""
    g_main_current_source()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSource *g_main_current_source (void);
```
"""
function g_main_current_source()
    @ccall libaravis.g_main_current_source()::Ptr{GSource}
end

"""
    g_main_context_push_thread_default(context)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_main_context_push_thread_default (GMainContext *context);
```
"""
function g_main_context_push_thread_default(context)
    @ccall libaravis.g_main_context_push_thread_default(context::Ptr{GMainContext})::Cvoid
end

"""
    g_main_context_pop_thread_default(context)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_main_context_pop_thread_default (GMainContext *context);
```
"""
function g_main_context_pop_thread_default(context)
    @ccall libaravis.g_main_context_pop_thread_default(context::Ptr{GMainContext})::Cvoid
end

"""
    g_main_context_get_thread_default()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GMainContext *g_main_context_get_thread_default (void);
```
"""
function g_main_context_get_thread_default()
    @ccall libaravis.g_main_context_get_thread_default()::Ptr{GMainContext}
end

"""
    g_main_context_ref_thread_default()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GMainContext *g_main_context_ref_thread_default (void);
```
"""
function g_main_context_ref_thread_default()
    @ccall libaravis.g_main_context_ref_thread_default()::Ptr{GMainContext}
end

"""
[`GMainContextPusher`](@ref):

Opaque type. See [`g_main_context_pusher_new`](@ref)() for details.

Since: 2.64
"""
const GMainContextPusher = Cvoid

"""
    g_main_context_pusher_new(main_context)

[`g_main_context_pusher_new`](@ref): \\_context: (transfer none): a main context to push

Push \\_context as the new thread-default main context for the current thread, using [method.MainContext.push\\_thread\\_default], and return a new [alias.MainContextPusher]. Pop with [`g_main_context_pusher_free`](@ref)(). Using [method.MainContext.pop\\_thread\\_default] on \\_context while a [alias.MainContextPusher] exists for it can lead to undefined behaviour.

Using two [alias.MainContextPusher]s in the same scope is not allowed, as it leads to an undefined pop order.

This is intended to be used with [`g_autoptr`](@ref)(). Note that [`g_autoptr`](@ref)() is only available when using GCC or clang, so the following example will only work with those compilers: |[ typedef struct { ... [`GMainContext`](@ref) *context; ... } MyObject;

static void my\\_object\\_do\\_stuff (MyObject *self) { [`g_autoptr`](@ref)([`GMainContextPusher`](@ref)) pusher = [`g_main_context_pusher_new`](@ref) (self->context);

// Code with main context as the thread default here

if (cond) // No need to pop return;

// Optionally early pop [`g_clear_pointer`](@ref) (&pusher, [`g_main_context_pusher_free`](@ref));

// Code with main context no longer the thread default here } ]|

Returns: (transfer full): a #[`GMainContextPusher`](@ref) Since: 2.64

### Prototype
```c
static inline GMainContextPusher *g_main_context_pusher_new (GMainContext *main_context);
```
"""
function g_main_context_pusher_new(main_context)
    @ccall libaravis.g_main_context_pusher_new(main_context::Ptr{GMainContext})::Ptr{GMainContextPusher}
end

"""
    g_main_context_pusher_free(pusher)

[`g_main_context_pusher_free`](@ref): : (transfer full): a #[`GMainContextPusher`](@ref)

Pop s main context as the thread default main context. See [`g_main_context_pusher_new`](@ref)() for details.

This will pop the [struct.MainContext] as the current thread-default main context, but will not call [method.MainContext.unref] on it.

Since: 2.64

### Prototype
```c
static inline void g_main_context_pusher_free (GMainContextPusher *pusher);
```
"""
function g_main_context_pusher_free(pusher)
    @ccall libaravis.g_main_context_pusher_free(pusher::Ptr{GMainContextPusher})::Cvoid
end

"""
    g_main_loop_ref(loop)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GMainLoop *g_main_loop_ref (GMainLoop *loop);
```
"""
function g_main_loop_ref(loop)
    @ccall libaravis.g_main_loop_ref(loop::Ptr{GMainLoop})::Ptr{GMainLoop}
end

"""
    g_main_loop_get_context(loop)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GMainContext *g_main_loop_get_context (GMainLoop *loop);
```
"""
function g_main_loop_get_context(loop)
    @ccall libaravis.g_main_loop_get_context(loop::Ptr{GMainLoop})::Ptr{GMainContext}
end

"""
    g_source_new(source_funcs, struct_size)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSource *g_source_new (GSourceFuncs *source_funcs, guint struct_size);
```
"""
function g_source_new(source_funcs, struct_size)
    @ccall libaravis.g_source_new(source_funcs::Ptr{GSourceFuncs}, struct_size::guint)::Ptr{GSource}
end

"""
    g_source_set_dispose_function(source, dispose)

### Prototype
```c
GLIB_AVAILABLE_IN_2_64 void g_source_set_dispose_function (GSource *source, GSourceDisposeFunc dispose);
```
"""
function g_source_set_dispose_function(source, dispose)
    @ccall libaravis.g_source_set_dispose_function(source::Ptr{GSource}, dispose::GSourceDisposeFunc)::Cvoid
end

"""
    g_source_ref(source)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSource *g_source_ref (GSource *source);
```
"""
function g_source_ref(source)
    @ccall libaravis.g_source_ref(source::Ptr{GSource})::Ptr{GSource}
end

"""
    g_source_unref(source)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_source_unref (GSource *source);
```
"""
function g_source_unref(source)
    @ccall libaravis.g_source_unref(source::Ptr{GSource})::Cvoid
end

"""
    g_source_attach(source, context)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_source_attach (GSource *source, GMainContext *context);
```
"""
function g_source_attach(source, context)
    @ccall libaravis.g_source_attach(source::Ptr{GSource}, context::Ptr{GMainContext})::guint
end

"""
    g_source_destroy(source)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_source_destroy (GSource *source);
```
"""
function g_source_destroy(source)
    @ccall libaravis.g_source_destroy(source::Ptr{GSource})::Cvoid
end

"""
    g_source_set_priority(source, priority)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_source_set_priority (GSource *source, gint priority);
```
"""
function g_source_set_priority(source, priority)
    @ccall libaravis.g_source_set_priority(source::Ptr{GSource}, priority::gint)::Cvoid
end

"""
    g_source_get_priority(source)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_source_get_priority (GSource *source);
```
"""
function g_source_get_priority(source)
    @ccall libaravis.g_source_get_priority(source::Ptr{GSource})::gint
end

"""
    g_source_set_can_recurse(source, can_recurse)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_source_set_can_recurse (GSource *source, gboolean can_recurse);
```
"""
function g_source_set_can_recurse(source, can_recurse)
    @ccall libaravis.g_source_set_can_recurse(source::Ptr{GSource}, can_recurse::gboolean)::Cvoid
end

"""
    g_source_get_can_recurse(source)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_source_get_can_recurse (GSource *source);
```
"""
function g_source_get_can_recurse(source)
    @ccall libaravis.g_source_get_can_recurse(source::Ptr{GSource})::gboolean
end

"""
    g_source_get_id(source)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_source_get_id (GSource *source);
```
"""
function g_source_get_id(source)
    @ccall libaravis.g_source_get_id(source::Ptr{GSource})::guint
end

"""
    g_source_get_context(source)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GMainContext *g_source_get_context (GSource *source);
```
"""
function g_source_get_context(source)
    @ccall libaravis.g_source_get_context(source::Ptr{GSource})::Ptr{GMainContext}
end

"""
    g_source_dup_context(source)

### Prototype
```c
GLIB_AVAILABLE_IN_2_86 GMainContext *g_source_dup_context (GSource *source);
```
"""
function g_source_dup_context(source)
    @ccall libaravis.g_source_dup_context(source::Ptr{GSource})::Ptr{GMainContext}
end

"""
    g_source_set_callback(source, func, data, notify)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_source_set_callback (GSource *source, GSourceFunc func, gpointer data, GDestroyNotify notify);
```
"""
function g_source_set_callback(source, func, data, notify)
    @ccall libaravis.g_source_set_callback(source::Ptr{GSource}, func::GSourceFunc, data::gpointer, notify::GDestroyNotify)::Cvoid
end

"""
    g_source_set_funcs(source, funcs)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_source_set_funcs (GSource *source, GSourceFuncs *funcs);
```
"""
function g_source_set_funcs(source, funcs)
    @ccall libaravis.g_source_set_funcs(source::Ptr{GSource}, funcs::Ptr{GSourceFuncs})::Cvoid
end

"""
    g_source_is_destroyed(source)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_source_is_destroyed (GSource *source);
```
"""
function g_source_is_destroyed(source)
    @ccall libaravis.g_source_is_destroyed(source::Ptr{GSource})::gboolean
end

"""
    g_source_set_name(source, name)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_source_set_name (GSource *source, const char *name);
```
"""
function g_source_set_name(source, name)
    @ccall libaravis.g_source_set_name(source::Ptr{GSource}, name::Cstring)::Cvoid
end

"""
    g_source_set_static_name(source, name)

### Prototype
```c
GLIB_AVAILABLE_IN_2_70 void g_source_set_static_name (GSource *source, const char *name);
```
"""
function g_source_set_static_name(source, name)
    @ccall libaravis.g_source_set_static_name(source::Ptr{GSource}, name::Cstring)::Cvoid
end

"""
    g_source_get_name(source)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const char * g_source_get_name (GSource *source);
```
"""
function g_source_get_name(source)
    @ccall libaravis.g_source_get_name(source::Ptr{GSource})::Cstring
end

"""
    g_source_set_name_by_id(tag, name)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_source_set_name_by_id (guint tag, const char *name);
```
"""
function g_source_set_name_by_id(tag, name)
    @ccall libaravis.g_source_set_name_by_id(tag::guint, name::Cstring)::Cvoid
end

"""
    g_source_set_ready_time(source, ready_time)

### Prototype
```c
GLIB_AVAILABLE_IN_2_36 void g_source_set_ready_time (GSource *source, gint64 ready_time);
```
"""
function g_source_set_ready_time(source, ready_time)
    @ccall libaravis.g_source_set_ready_time(source::Ptr{GSource}, ready_time::gint64)::Cvoid
end

"""
    g_source_get_ready_time(source)

### Prototype
```c
GLIB_AVAILABLE_IN_2_36 gint64 g_source_get_ready_time (GSource *source);
```
"""
function g_source_get_ready_time(source)
    @ccall libaravis.g_source_get_ready_time(source::Ptr{GSource})::gint64
end

"""
    g_source_add_unix_fd(source, fd, events)

### Prototype
```c
GLIB_AVAILABLE_IN_2_36 gpointer g_source_add_unix_fd (GSource *source, gint fd, GIOCondition events);
```
"""
function g_source_add_unix_fd(source, fd, events)
    @ccall libaravis.g_source_add_unix_fd(source::Ptr{GSource}, fd::gint, events::GIOCondition)::gpointer
end

"""
    g_source_modify_unix_fd(source, tag, new_events)

### Prototype
```c
GLIB_AVAILABLE_IN_2_36 void g_source_modify_unix_fd (GSource *source, gpointer tag, GIOCondition new_events);
```
"""
function g_source_modify_unix_fd(source, tag, new_events)
    @ccall libaravis.g_source_modify_unix_fd(source::Ptr{GSource}, tag::gpointer, new_events::GIOCondition)::Cvoid
end

"""
    g_source_remove_unix_fd(source, tag)

### Prototype
```c
GLIB_AVAILABLE_IN_2_36 void g_source_remove_unix_fd (GSource *source, gpointer tag);
```
"""
function g_source_remove_unix_fd(source, tag)
    @ccall libaravis.g_source_remove_unix_fd(source::Ptr{GSource}, tag::gpointer)::Cvoid
end

"""
    g_source_query_unix_fd(source, tag)

### Prototype
```c
GLIB_AVAILABLE_IN_2_36 GIOCondition g_source_query_unix_fd (GSource *source, gpointer tag);
```
"""
function g_source_query_unix_fd(source, tag)
    @ccall libaravis.g_source_query_unix_fd(source::Ptr{GSource}, tag::gpointer)::GIOCondition
end

"""
    g_source_set_callback_indirect(source, callback_data, callback_funcs)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_source_set_callback_indirect (GSource *source, gpointer callback_data, GSourceCallbackFuncs *callback_funcs);
```
"""
function g_source_set_callback_indirect(source, callback_data, callback_funcs)
    @ccall libaravis.g_source_set_callback_indirect(source::Ptr{GSource}, callback_data::gpointer, callback_funcs::Ptr{GSourceCallbackFuncs})::Cvoid
end

"""
    g_source_add_poll(source, fd)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_source_add_poll (GSource *source, GPollFD *fd);
```
"""
function g_source_add_poll(source, fd)
    @ccall libaravis.g_source_add_poll(source::Ptr{GSource}, fd::Ptr{GPollFD})::Cvoid
end

"""
    g_source_remove_poll(source, fd)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_source_remove_poll (GSource *source, GPollFD *fd);
```
"""
function g_source_remove_poll(source, fd)
    @ccall libaravis.g_source_remove_poll(source::Ptr{GSource}, fd::Ptr{GPollFD})::Cvoid
end

"""
    g_source_add_child_source(source, child_source)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_source_add_child_source (GSource *source, GSource *child_source);
```
"""
function g_source_add_child_source(source, child_source)
    @ccall libaravis.g_source_add_child_source(source::Ptr{GSource}, child_source::Ptr{GSource})::Cvoid
end

"""
    g_source_remove_child_source(source, child_source)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_source_remove_child_source (GSource *source, GSource *child_source);
```
"""
function g_source_remove_child_source(source, child_source)
    @ccall libaravis.g_source_remove_child_source(source::Ptr{GSource}, child_source::Ptr{GSource})::Cvoid
end

"""
    g_source_get_current_time(source, timeval)

### Prototype
```c
GLIB_DEPRECATED_IN_2_28_FOR(g_source_get_time) void g_source_get_current_time (GSource *source, GTimeVal *timeval);
```
"""
function g_source_get_current_time(source, timeval)
    @ccall libaravis.g_source_get_current_time(source::Ptr{GSource}, timeval::Ptr{GTimeVal})::Cvoid
end

"""
    g_source_get_time(source)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint64 g_source_get_time (GSource *source);
```
"""
function g_source_get_time(source)
    @ccall libaravis.g_source_get_time(source::Ptr{GSource})::gint64
end

"""
    g_idle_source_new()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSource *g_idle_source_new (void);
```
"""
function g_idle_source_new()
    @ccall libaravis.g_idle_source_new()::Ptr{GSource}
end

"""
    g_child_watch_source_new(pid)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSource *g_child_watch_source_new (GPid pid);
```
"""
function g_child_watch_source_new(pid)
    @ccall libaravis.g_child_watch_source_new(pid::GPid)::Ptr{GSource}
end

"""
    g_timeout_source_new(interval)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSource *g_timeout_source_new (guint interval);
```
"""
function g_timeout_source_new(interval)
    @ccall libaravis.g_timeout_source_new(interval::guint)::Ptr{GSource}
end

"""
    g_timeout_source_new_seconds(interval)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSource *g_timeout_source_new_seconds (guint interval);
```
"""
function g_timeout_source_new_seconds(interval)
    @ccall libaravis.g_timeout_source_new_seconds(interval::guint)::Ptr{GSource}
end

"""
    g_get_current_time(result)

### Prototype
```c
GLIB_DEPRECATED_IN_2_62_FOR(g_get_real_time) void g_get_current_time (GTimeVal *result);
```
"""
function g_get_current_time(result)
    @ccall libaravis.g_get_current_time(result::Ptr{GTimeVal})::Cvoid
end

"""
    g_get_real_time()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint64 g_get_real_time (void);
```
"""
function g_get_real_time()
    @ccall libaravis.g_get_real_time()::gint64
end

"""
    g_source_remove(tag)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_source_remove (guint tag);
```
"""
function g_source_remove(tag)
    @ccall libaravis.g_source_remove(tag::guint)::gboolean
end

"""
    g_source_remove_by_user_data(user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_source_remove_by_user_data (gpointer user_data);
```
"""
function g_source_remove_by_user_data(user_data)
    @ccall libaravis.g_source_remove_by_user_data(user_data::gpointer)::gboolean
end

"""
    g_source_remove_by_funcs_user_data(funcs, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_source_remove_by_funcs_user_data (GSourceFuncs *funcs, gpointer user_data);
```
"""
function g_source_remove_by_funcs_user_data(funcs, user_data)
    @ccall libaravis.g_source_remove_by_funcs_user_data(funcs::Ptr{GSourceFuncs}, user_data::gpointer)::gboolean
end

# typedef void ( * GClearHandleFunc ) ( guint handle_id )
"""
[`GClearHandleFunc`](@ref): \\_id: the handle ID to clear

Specifies the type of function passed to [func.clear\\_handle\\_id] The implementation is expected to free the resource identified by \\_id; for instance, if \\_id is a [struct.Source] ID, [func.Source.remove] can be used.

Since: 2.56
"""
const GClearHandleFunc = Ptr{Cvoid}

"""
    g_steal_handle_id(handle_pointer)

[`g_steal_handle_id`](@ref): \\_pointer: (inout) (not optional): a pointer to a handle ID

Sets \\_pointer to `0`, returning the value that was there before.

Conceptually, this transfers the ownership of the handle ID from the referenced variable to the caller of the macro (ie: steals the handle ID).

This can be very useful to make ownership transfer explicit, or to prevent a handle from being released multiple times. For example:

```c void maybe\\_unsubscribe\\_signal (ContextStruct *data) { if (some\\_complex\\_logic (data)) { [`g_dbus_connection_signal_unsubscribe`](@ref) (data->connection, [`g_steal_handle_id`](@ref) (&data->subscription\\_id)); // now data->subscription\\_id isnt a dangling handle } } ```

While [func.clear\\_handle\\_id] can be used in many of the same situations as `[`g_steal_handle_id`](@ref)()`, this is one situation where it cannot be used, as there is no way to pass the [`GDBusConnection`](@ref) to a [type.ClearHandleFunc].

Since: 2.84

### Prototype
```c
static inline unsigned int g_steal_handle_id (unsigned int *handle_pointer);
```
"""
function g_steal_handle_id(handle_pointer)
    @ccall libaravis.g_steal_handle_id(handle_pointer::Ptr{Cuint})::Cuint
end

"""
    g_timeout_add_full(priority, interval, _function, data, notify)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_timeout_add_full (gint priority, guint interval, GSourceFunc function, gpointer data, GDestroyNotify notify);
```
"""
function g_timeout_add_full(priority, interval, _function, data, notify)
    @ccall libaravis.g_timeout_add_full(priority::gint, interval::guint, _function::GSourceFunc, data::gpointer, notify::GDestroyNotify)::guint
end

"""
    g_timeout_add(interval, _function, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_timeout_add (guint interval, GSourceFunc function, gpointer data);
```
"""
function g_timeout_add(interval, _function, data)
    @ccall libaravis.g_timeout_add(interval::guint, _function::GSourceFunc, data::gpointer)::guint
end

"""
    g_timeout_add_once(interval, _function, data)

### Prototype
```c
GLIB_AVAILABLE_IN_2_74 guint g_timeout_add_once (guint interval, GSourceOnceFunc function, gpointer data);
```
"""
function g_timeout_add_once(interval, _function, data)
    @ccall libaravis.g_timeout_add_once(interval::guint, _function::GSourceOnceFunc, data::gpointer)::guint
end

"""
    g_timeout_add_seconds_full(priority, interval, _function, data, notify)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_timeout_add_seconds_full (gint priority, guint interval, GSourceFunc function, gpointer data, GDestroyNotify notify);
```
"""
function g_timeout_add_seconds_full(priority, interval, _function, data, notify)
    @ccall libaravis.g_timeout_add_seconds_full(priority::gint, interval::guint, _function::GSourceFunc, data::gpointer, notify::GDestroyNotify)::guint
end

"""
    g_timeout_add_seconds(interval, _function, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_timeout_add_seconds (guint interval, GSourceFunc function, gpointer data);
```
"""
function g_timeout_add_seconds(interval, _function, data)
    @ccall libaravis.g_timeout_add_seconds(interval::guint, _function::GSourceFunc, data::gpointer)::guint
end

"""
    g_timeout_add_seconds_once(interval, _function, data)

### Prototype
```c
GLIB_AVAILABLE_IN_2_78 guint g_timeout_add_seconds_once (guint interval, GSourceOnceFunc function, gpointer data);
```
"""
function g_timeout_add_seconds_once(interval, _function, data)
    @ccall libaravis.g_timeout_add_seconds_once(interval::guint, _function::GSourceOnceFunc, data::gpointer)::guint
end

"""
    g_child_watch_add_full(priority, pid, _function, data, notify)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_child_watch_add_full (gint priority, GPid pid, GChildWatchFunc function, gpointer data, GDestroyNotify notify);
```
"""
function g_child_watch_add_full(priority, pid, _function, data, notify)
    @ccall libaravis.g_child_watch_add_full(priority::gint, pid::GPid, _function::GChildWatchFunc, data::gpointer, notify::GDestroyNotify)::guint
end

"""
    g_child_watch_add(pid, _function, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_child_watch_add (GPid pid, GChildWatchFunc function, gpointer data);
```
"""
function g_child_watch_add(pid, _function, data)
    @ccall libaravis.g_child_watch_add(pid::GPid, _function::GChildWatchFunc, data::gpointer)::guint
end

"""
    g_idle_add(_function, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_idle_add (GSourceFunc function, gpointer data);
```
"""
function g_idle_add(_function, data)
    @ccall libaravis.g_idle_add(_function::GSourceFunc, data::gpointer)::guint
end

"""
    g_idle_add_full(priority, _function, data, notify)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_idle_add_full (gint priority, GSourceFunc function, gpointer data, GDestroyNotify notify);
```
"""
function g_idle_add_full(priority, _function, data, notify)
    @ccall libaravis.g_idle_add_full(priority::gint, _function::GSourceFunc, data::gpointer, notify::GDestroyNotify)::guint
end

"""
    g_idle_add_once(_function, data)

### Prototype
```c
GLIB_AVAILABLE_IN_2_74 guint g_idle_add_once (GSourceOnceFunc function, gpointer data);
```
"""
function g_idle_add_once(_function, data)
    @ccall libaravis.g_idle_add_once(_function::GSourceOnceFunc, data::gpointer)::guint
end

"""
    g_idle_remove_by_data(data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_idle_remove_by_data (gpointer data);
```
"""
function g_idle_remove_by_data(data)
    @ccall libaravis.g_idle_remove_by_data(data::gpointer)::gboolean
end

"""
    g_main_context_invoke_full(context, priority, _function, data, notify)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_main_context_invoke_full (GMainContext *context, gint priority, GSourceFunc function, gpointer data, GDestroyNotify notify);
```
"""
function g_main_context_invoke_full(context, priority, _function, data, notify)
    @ccall libaravis.g_main_context_invoke_full(context::Ptr{GMainContext}, priority::gint, _function::GSourceFunc, data::gpointer, notify::GDestroyNotify)::Cvoid
end

"""
    g_main_context_invoke(context, _function, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_main_context_invoke (GMainContext *context, GSourceFunc function, gpointer data);
```
"""
function g_main_context_invoke(context, _function, data)
    @ccall libaravis.g_main_context_invoke(context::Ptr{GMainContext}, _function::GSourceFunc, data::gpointer)::Cvoid
end

"""
    g_steal_fd(fd_ptr)

[`g_steal_fd`](@ref): \\_ptr: (not optional) (inout): A pointer to a file descriptor

Sets \\_ptr to `-1`, returning the value that was there before.

Conceptually, this transfers the ownership of the file descriptor from the referenced variable to the caller of the function (i.e. steals the reference). This is very similar to [func.steal\\_pointer], but for file descriptors.

On POSIX platforms, this function is async-signal safe (see [`signal(7)`](man:signal(7)) and [`signal-safety(7)`](man:signal-safety(7))), making it safe to call from a signal handler or a #[`GSpawnChildSetupFunc`](@ref).

This function preserves the value of `errno`.

Returns: the value that \\_ptr previously had Since: 2.70

### Prototype
```c
static inline int g_steal_fd (int *fd_ptr);
```
"""
function g_steal_fd(fd_ptr)
    @ccall libaravis.g_steal_fd(fd_ptr::Ptr{Cint})::Cint
end

"""
[`gunichar2`](@ref):

A type which can hold any UTF-16 code point<footnote id="utf16\\_surrogate\\_pairs">UTF-16 also has so called <firstterm>surrogate pairs</firstterm> to encode characters beyond the BMP as pairs of 16bit numbers. Surrogate pairs cannot be stored in a single [`gunichar2`](@ref) field, but all GLib functions accepting [`gunichar2`](@ref) arrays will correctly interpret surrogate pairs.</footnote>.

To print/scan values of this type to/from text you need to convert to/from UTF-8, using [`g_utf16_to_utf8`](@ref)()/[`g_utf8_to_utf16`](@ref)().

To print/scan values of this type as integer, use G\\_GINT16\\_MODIFIER and/or G\\_GUINT16\\_FORMAT.
"""
const gunichar2 = guint16

"""
    GUnicodeType

[`GUnicodeType`](@ref): \\_UNICODE\\_CONTROL: General category "Other, Control" (Cc) \\_UNICODE\\_FORMAT: General category "Other, Format" (Cf) \\_UNICODE\\_UNASSIGNED: General category "Other, Not Assigned" (Cn) \\_UNICODE\\_PRIVATE\\_USE: General category "Other, Private Use" (Co) \\_UNICODE\\_SURROGATE: General category "Other, Surrogate" (Cs) \\_UNICODE\\_LOWERCASE\\_LETTER: General category "Letter, Lowercase" (Ll) \\_UNICODE\\_MODIFIER\\_LETTER: General category "Letter, Modifier" (Lm) \\_UNICODE\\_OTHER\\_LETTER: General category "Letter, Other" (Lo) \\_UNICODE\\_TITLECASE\\_LETTER: General category "Letter, Titlecase" (Lt) \\_UNICODE\\_UPPERCASE\\_LETTER: General category "Letter, Uppercase" (Lu) \\_UNICODE\\_SPACING\\_MARK: General category "Mark, Spacing" (Mc) \\_UNICODE\\_ENCLOSING\\_MARK: General category "Mark, Enclosing" (Me) \\_UNICODE\\_NON\\_SPACING\\_MARK: General category "Mark, Nonspacing" (Mn) \\_UNICODE\\_DECIMAL\\_NUMBER: General category "Number, Decimal Digit" (Nd) \\_UNICODE\\_LETTER\\_NUMBER: General category "Number, Letter" (Nl) \\_UNICODE\\_OTHER\\_NUMBER: General category "Number, Other" (No) \\_UNICODE\\_CONNECT\\_PUNCTUATION: General category "Punctuation, Connector" (Pc) \\_UNICODE\\_DASH\\_PUNCTUATION: General category "Punctuation, Dash" (Pd) \\_UNICODE\\_CLOSE\\_PUNCTUATION: General category "Punctuation, Close" (Pe) \\_UNICODE\\_FINAL\\_PUNCTUATION: General category "Punctuation, Final quote" (Pf) \\_UNICODE\\_INITIAL\\_PUNCTUATION: General category "Punctuation, Initial quote" (Pi) \\_UNICODE\\_OTHER\\_PUNCTUATION: General category "Punctuation, Other" (Po) \\_UNICODE\\_OPEN\\_PUNCTUATION: General category "Punctuation, Open" (Ps) \\_UNICODE\\_CURRENCY\\_SYMBOL: General category "Symbol, Currency" (Sc) \\_UNICODE\\_MODIFIER\\_SYMBOL: General category "Symbol, Modifier" (Sk) \\_UNICODE\\_MATH\\_SYMBOL: General category "Symbol, Math" (Sm) \\_UNICODE\\_OTHER\\_SYMBOL: General category "Symbol, Other" (So) \\_UNICODE\\_LINE\\_SEPARATOR: General category "Separator, Line" (Zl) \\_UNICODE\\_PARAGRAPH\\_SEPARATOR: General category "Separator, Paragraph" (Zp) \\_UNICODE\\_SPACE\\_SEPARATOR: General category "Separator, Space" (Zs)

These are the possible character classifications from the Unicode specification. See [Unicode Character Database](http://www.unicode.org/reports/tr44/#General\\_Category\\_Values).
"""
@cenum GUnicodeType::UInt32 begin
    G_UNICODE_CONTROL = 0
    G_UNICODE_FORMAT = 1
    G_UNICODE_UNASSIGNED = 2
    G_UNICODE_PRIVATE_USE = 3
    G_UNICODE_SURROGATE = 4
    G_UNICODE_LOWERCASE_LETTER = 5
    G_UNICODE_MODIFIER_LETTER = 6
    G_UNICODE_OTHER_LETTER = 7
    G_UNICODE_TITLECASE_LETTER = 8
    G_UNICODE_UPPERCASE_LETTER = 9
    G_UNICODE_SPACING_MARK = 10
    G_UNICODE_ENCLOSING_MARK = 11
    G_UNICODE_NON_SPACING_MARK = 12
    G_UNICODE_DECIMAL_NUMBER = 13
    G_UNICODE_LETTER_NUMBER = 14
    G_UNICODE_OTHER_NUMBER = 15
    G_UNICODE_CONNECT_PUNCTUATION = 16
    G_UNICODE_DASH_PUNCTUATION = 17
    G_UNICODE_CLOSE_PUNCTUATION = 18
    G_UNICODE_FINAL_PUNCTUATION = 19
    G_UNICODE_INITIAL_PUNCTUATION = 20
    G_UNICODE_OTHER_PUNCTUATION = 21
    G_UNICODE_OPEN_PUNCTUATION = 22
    G_UNICODE_CURRENCY_SYMBOL = 23
    G_UNICODE_MODIFIER_SYMBOL = 24
    G_UNICODE_MATH_SYMBOL = 25
    G_UNICODE_OTHER_SYMBOL = 26
    G_UNICODE_LINE_SEPARATOR = 27
    G_UNICODE_PARAGRAPH_SEPARATOR = 28
    G_UNICODE_SPACE_SEPARATOR = 29
end

"""
    GUnicodeBreakType

[`GUnicodeBreakType`](@ref): \\_UNICODE\\_BREAK\\_MANDATORY: Mandatory Break (BK) \\_UNICODE\\_BREAK\\_CARRIAGE\\_RETURN: Carriage Return (CR) \\_UNICODE\\_BREAK\\_LINE\\_FEED: Line Feed (LF) \\_UNICODE\\_BREAK\\_COMBINING\\_MARK: Attached Characters and Combining Marks (CM) \\_UNICODE\\_BREAK\\_SURROGATE: Surrogates (SG) \\_UNICODE\\_BREAK\\_ZERO\\_WIDTH\\_SPACE: Zero Width Space (ZW) \\_UNICODE\\_BREAK\\_INSEPARABLE: Inseparable (IN) \\_UNICODE\\_BREAK\\_NON\\_BREAKING\\_GLUE: Non-breaking ("Glue") (GL) \\_UNICODE\\_BREAK\\_CONTINGENT: Contingent Break Opportunity (CB) \\_UNICODE\\_BREAK\\_SPACE: Space (SP) \\_UNICODE\\_BREAK\\_AFTER: Break Opportunity After (BA) \\_UNICODE\\_BREAK\\_BEFORE: Break Opportunity Before (BB) \\_UNICODE\\_BREAK\\_BEFORE\\_AND\\_AFTER: Break Opportunity Before and After (B2) \\_UNICODE\\_BREAK\\_HYPHEN: Hyphen (HY) \\_UNICODE\\_BREAK\\_NON\\_STARTER: Nonstarter (NS) \\_UNICODE\\_BREAK\\_OPEN\\_PUNCTUATION: Opening Punctuation (OP) \\_UNICODE\\_BREAK\\_CLOSE\\_PUNCTUATION: Closing Punctuation (CL) \\_UNICODE\\_BREAK\\_QUOTATION: Ambiguous Quotation (QU) \\_UNICODE\\_BREAK\\_EXCLAMATION: Exclamation/Interrogation (EX) \\_UNICODE\\_BREAK\\_IDEOGRAPHIC: Ideographic (ID) \\_UNICODE\\_BREAK\\_NUMERIC: Numeric (NU) \\_UNICODE\\_BREAK\\_INFIX\\_SEPARATOR: Infix Separator (Numeric) (IS) \\_UNICODE\\_BREAK\\_SYMBOL: Symbols Allowing Break After (SY) \\_UNICODE\\_BREAK\\_ALPHABETIC: Ordinary Alphabetic and Symbol Characters (AL) \\_UNICODE\\_BREAK\\_PREFIX: Prefix (Numeric) (PR) \\_UNICODE\\_BREAK\\_POSTFIX: Postfix (Numeric) (PO) \\_UNICODE\\_BREAK\\_COMPLEX\\_CONTEXT: Complex Content Dependent (South East Asian) (SA) \\_UNICODE\\_BREAK\\_AMBIGUOUS: Ambiguous (Alphabetic or Ideographic) (AI) \\_UNICODE\\_BREAK\\_UNKNOWN: Unknown (XX) \\_UNICODE\\_BREAK\\_NEXT\\_LINE: Next Line (NL) \\_UNICODE\\_BREAK\\_WORD\\_JOINER: Word Joiner (WJ) \\_UNICODE\\_BREAK\\_HANGUL\\_L\\_JAMO: Hangul L Jamo (JL) \\_UNICODE\\_BREAK\\_HANGUL\\_V\\_JAMO: Hangul V Jamo (JV) \\_UNICODE\\_BREAK\\_HANGUL\\_T\\_JAMO: Hangul T Jamo (JT) \\_UNICODE\\_BREAK\\_HANGUL\\_LV\\_SYLLABLE: Hangul LV Syllable (H2) \\_UNICODE\\_BREAK\\_HANGUL\\_LVT\\_SYLLABLE: Hangul LVT Syllable (H3) \\_UNICODE\\_BREAK\\_CLOSE\\_PARANTHESIS: Closing Parenthesis (CP). Since 2.28. Deprecated: 2.70: Use G\\_UNICODE\\_BREAK\\_CLOSE\\_PARENTHESIS instead. \\_UNICODE\\_BREAK\\_CLOSE\\_PARENTHESIS: Closing Parenthesis (CP). Since 2.70 \\_UNICODE\\_BREAK\\_CONDITIONAL\\_JAPANESE\\_STARTER: Conditional Japanese Starter (CJ). Since: 2.32 \\_UNICODE\\_BREAK\\_HEBREW\\_LETTER: Hebrew Letter (HL). Since: 2.32 \\_UNICODE\\_BREAK\\_REGIONAL\\_INDICATOR: Regional Indicator (RI). Since: 2.36 \\_UNICODE\\_BREAK\\_EMOJI\\_BASE: Emoji Base (EB). Since: 2.50 \\_UNICODE\\_BREAK\\_EMOJI\\_MODIFIER: Emoji Modifier (EM). Since: 2.50 \\_UNICODE\\_BREAK\\_ZERO\\_WIDTH\\_JOINER: Zero Width Joiner (ZWJ). Since: 2.50 \\_UNICODE\\_BREAK\\_AKSARA: Aksara (AK). Since: 2.80 \\_UNICODE\\_BREAK\\_AKSARA\\_PRE\\_BASE: Aksara Pre-Base (AP). Since: 2.80 \\_UNICODE\\_BREAK\\_AKSARA\\_START: Aksara Start (AS). Since: 2.80 \\_UNICODE\\_BREAK\\_VIRAMA\\_FINAL: Virama Final (VF). Since: 2.80 \\_UNICODE\\_BREAK\\_VIRAMA: Virama (VI). Since: 2.80

These are the possible line break classifications.

Since new Unicode versions may add new types here, applications should be ready to handle unknown values. They may be regarded as G\\_UNICODE\\_BREAK\\_UNKNOWN.

See [Unicode Line Breaking Algorithm](https://www.unicode.org/reports/tr14/).
"""
@cenum GUnicodeBreakType::UInt32 begin
    G_UNICODE_BREAK_MANDATORY = 0
    G_UNICODE_BREAK_CARRIAGE_RETURN = 1
    G_UNICODE_BREAK_LINE_FEED = 2
    G_UNICODE_BREAK_COMBINING_MARK = 3
    G_UNICODE_BREAK_SURROGATE = 4
    G_UNICODE_BREAK_ZERO_WIDTH_SPACE = 5
    G_UNICODE_BREAK_INSEPARABLE = 6
    G_UNICODE_BREAK_NON_BREAKING_GLUE = 7
    G_UNICODE_BREAK_CONTINGENT = 8
    G_UNICODE_BREAK_SPACE = 9
    G_UNICODE_BREAK_AFTER = 10
    G_UNICODE_BREAK_BEFORE = 11
    G_UNICODE_BREAK_BEFORE_AND_AFTER = 12
    G_UNICODE_BREAK_HYPHEN = 13
    G_UNICODE_BREAK_NON_STARTER = 14
    G_UNICODE_BREAK_OPEN_PUNCTUATION = 15
    G_UNICODE_BREAK_CLOSE_PUNCTUATION = 16
    G_UNICODE_BREAK_QUOTATION = 17
    G_UNICODE_BREAK_EXCLAMATION = 18
    G_UNICODE_BREAK_IDEOGRAPHIC = 19
    G_UNICODE_BREAK_NUMERIC = 20
    G_UNICODE_BREAK_INFIX_SEPARATOR = 21
    G_UNICODE_BREAK_SYMBOL = 22
    G_UNICODE_BREAK_ALPHABETIC = 23
    G_UNICODE_BREAK_PREFIX = 24
    G_UNICODE_BREAK_POSTFIX = 25
    G_UNICODE_BREAK_COMPLEX_CONTEXT = 26
    G_UNICODE_BREAK_AMBIGUOUS = 27
    G_UNICODE_BREAK_UNKNOWN = 28
    G_UNICODE_BREAK_NEXT_LINE = 29
    G_UNICODE_BREAK_WORD_JOINER = 30
    G_UNICODE_BREAK_HANGUL_L_JAMO = 31
    G_UNICODE_BREAK_HANGUL_V_JAMO = 32
    G_UNICODE_BREAK_HANGUL_T_JAMO = 33
    G_UNICODE_BREAK_HANGUL_LV_SYLLABLE = 34
    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE = 35
    G_UNICODE_BREAK_CLOSE_PARANTHESIS = 36
    G_UNICODE_BREAK_CLOSE_PARENTHESIS = 36
    G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER = 37
    G_UNICODE_BREAK_HEBREW_LETTER = 38
    G_UNICODE_BREAK_REGIONAL_INDICATOR = 39
    G_UNICODE_BREAK_EMOJI_BASE = 40
    G_UNICODE_BREAK_EMOJI_MODIFIER = 41
    G_UNICODE_BREAK_ZERO_WIDTH_JOINER = 42
    G_UNICODE_BREAK_AKSARA = 43
    G_UNICODE_BREAK_AKSARA_PRE_BASE = 44
    G_UNICODE_BREAK_AKSARA_START = 45
    G_UNICODE_BREAK_VIRAMA_FINAL = 46
    G_UNICODE_BREAK_VIRAMA = 47
end

"""
    GUnicodeScript

[`GUnicodeScript`](@ref): \\_UNICODE\\_SCRIPT\\_INVALID\\_CODE: a value never returned from [`g_unichar_get_script`](@ref)() \\_UNICODE\\_SCRIPT\\_COMMON: a character used by multiple different scripts \\_UNICODE\\_SCRIPT\\_INHERITED: a mark glyph that takes its script from the base glyph to which it is attached \\_UNICODE\\_SCRIPT\\_ARABIC: Arabic \\_UNICODE\\_SCRIPT\\_ARMENIAN: Armenian \\_UNICODE\\_SCRIPT\\_BENGALI: Bengali \\_UNICODE\\_SCRIPT\\_BOPOMOFO: Bopomofo \\_UNICODE\\_SCRIPT\\_CHEROKEE: Cherokee \\_UNICODE\\_SCRIPT\\_COPTIC: Coptic \\_UNICODE\\_SCRIPT\\_CYRILLIC: Cyrillic \\_UNICODE\\_SCRIPT\\_DESERET: Deseret \\_UNICODE\\_SCRIPT\\_DEVANAGARI: Devanagari \\_UNICODE\\_SCRIPT\\_ETHIOPIC: Ethiopic \\_UNICODE\\_SCRIPT\\_GEORGIAN: Georgian \\_UNICODE\\_SCRIPT\\_GOTHIC: Gothic \\_UNICODE\\_SCRIPT\\_GREEK: Greek \\_UNICODE\\_SCRIPT\\_GUJARATI: Gujarati \\_UNICODE\\_SCRIPT\\_GURMUKHI: Gurmukhi \\_UNICODE\\_SCRIPT\\_HAN: Han \\_UNICODE\\_SCRIPT\\_HANGUL: Hangul \\_UNICODE\\_SCRIPT\\_HEBREW: Hebrew \\_UNICODE\\_SCRIPT\\_HIRAGANA: Hiragana \\_UNICODE\\_SCRIPT\\_KANNADA: Kannada \\_UNICODE\\_SCRIPT\\_KATAKANA: Katakana \\_UNICODE\\_SCRIPT\\_KHMER: Khmer \\_UNICODE\\_SCRIPT\\_LAO: Lao \\_UNICODE\\_SCRIPT\\_LATIN: Latin \\_UNICODE\\_SCRIPT\\_MALAYALAM: Malayalam \\_UNICODE\\_SCRIPT\\_MONGOLIAN: Mongolian \\_UNICODE\\_SCRIPT\\_MYANMAR: Myanmar \\_UNICODE\\_SCRIPT\\_OGHAM: Ogham \\_UNICODE\\_SCRIPT\\_OLD\\_ITALIC: Old Italic \\_UNICODE\\_SCRIPT\\_ORIYA: Oriya \\_UNICODE\\_SCRIPT\\_RUNIC: Runic \\_UNICODE\\_SCRIPT\\_SINHALA: Sinhala \\_UNICODE\\_SCRIPT\\_SYRIAC: Syriac \\_UNICODE\\_SCRIPT\\_TAMIL: Tamil \\_UNICODE\\_SCRIPT\\_TELUGU: Telugu \\_UNICODE\\_SCRIPT\\_THAANA: Thaana \\_UNICODE\\_SCRIPT\\_THAI: Thai \\_UNICODE\\_SCRIPT\\_TIBETAN: Tibetan \\_UNICODE\\_SCRIPT\\_CANADIAN\\_ABORIGINAL: Canadian Aboriginal \\_UNICODE\\_SCRIPT\\_YI: Yi \\_UNICODE\\_SCRIPT\\_TAGALOG: Tagalog \\_UNICODE\\_SCRIPT\\_HANUNOO: Hanunoo \\_UNICODE\\_SCRIPT\\_BUHID: Buhid \\_UNICODE\\_SCRIPT\\_TAGBANWA: Tagbanwa \\_UNICODE\\_SCRIPT\\_BRAILLE: Braille \\_UNICODE\\_SCRIPT\\_CYPRIOT: Cypriot \\_UNICODE\\_SCRIPT\\_LIMBU: Limbu \\_UNICODE\\_SCRIPT\\_OSMANYA: Osmanya \\_UNICODE\\_SCRIPT\\_SHAVIAN: Shavian \\_UNICODE\\_SCRIPT\\_LINEAR\\_B: Linear B \\_UNICODE\\_SCRIPT\\_TAI\\_LE: Tai Le \\_UNICODE\\_SCRIPT\\_UGARITIC: Ugaritic \\_UNICODE\\_SCRIPT\\_NEW\\_TAI\\_LUE: New Tai Lue \\_UNICODE\\_SCRIPT\\_BUGINESE: Buginese \\_UNICODE\\_SCRIPT\\_GLAGOLITIC: Glagolitic \\_UNICODE\\_SCRIPT\\_TIFINAGH: Tifinagh \\_UNICODE\\_SCRIPT\\_SYLOTI\\_NAGRI: Syloti Nagri \\_UNICODE\\_SCRIPT\\_OLD\\_PERSIAN: Old Persian \\_UNICODE\\_SCRIPT\\_KHAROSHTHI: Kharoshthi \\_UNICODE\\_SCRIPT\\_UNKNOWN: an unassigned code point \\_UNICODE\\_SCRIPT\\_BALINESE: Balinese \\_UNICODE\\_SCRIPT\\_CUNEIFORM: Cuneiform \\_UNICODE\\_SCRIPT\\_PHOENICIAN: Phoenician \\_UNICODE\\_SCRIPT\\_PHAGS\\_PA: Phags-pa \\_UNICODE\\_SCRIPT\\_NKO: N'Ko \\_UNICODE\\_SCRIPT\\_KAYAH\\_LI: Kayah Li. Since 2.16.3 \\_UNICODE\\_SCRIPT\\_LEPCHA: Lepcha. Since 2.16.3 \\_UNICODE\\_SCRIPT\\_REJANG: Rejang. Since 2.16.3 \\_UNICODE\\_SCRIPT\\_SUNDANESE: Sundanese. Since 2.16.3 \\_UNICODE\\_SCRIPT\\_SAURASHTRA: Saurashtra. Since 2.16.3 \\_UNICODE\\_SCRIPT\\_CHAM: Cham. Since 2.16.3 \\_UNICODE\\_SCRIPT\\_OL\\_CHIKI: Ol Chiki. Since 2.16.3 \\_UNICODE\\_SCRIPT\\_VAI: Vai. Since 2.16.3 \\_UNICODE\\_SCRIPT\\_CARIAN: Carian. Since 2.16.3 \\_UNICODE\\_SCRIPT\\_LYCIAN: Lycian. Since 2.16.3 \\_UNICODE\\_SCRIPT\\_LYDIAN: Lydian. Since 2.16.3 \\_UNICODE\\_SCRIPT\\_AVESTAN: Avestan. Since 2.26 \\_UNICODE\\_SCRIPT\\_BAMUM: Bamum. Since 2.26 \\_UNICODE\\_SCRIPT\\_EGYPTIAN\\_HIEROGLYPHS: Egyptian Hieroglpyhs. Since 2.26 \\_UNICODE\\_SCRIPT\\_IMPERIAL\\_ARAMAIC: Imperial Aramaic. Since 2.26 \\_UNICODE\\_SCRIPT\\_INSCRIPTIONAL\\_PAHLAVI: Inscriptional Pahlavi. Since 2.26 \\_UNICODE\\_SCRIPT\\_INSCRIPTIONAL\\_PARTHIAN: Inscriptional Parthian. Since 2.26 \\_UNICODE\\_SCRIPT\\_JAVANESE: Javanese. Since 2.26 \\_UNICODE\\_SCRIPT\\_KAITHI: Kaithi. Since 2.26 \\_UNICODE\\_SCRIPT\\_LISU: Lisu. Since 2.26 \\_UNICODE\\_SCRIPT\\_MEETEI\\_MAYEK: Meetei Mayek. Since 2.26 \\_UNICODE\\_SCRIPT\\_OLD\\_SOUTH\\_ARABIAN: Old South Arabian. Since 2.26 \\_UNICODE\\_SCRIPT\\_OLD\\_TURKIC: Old Turkic. Since 2.28 \\_UNICODE\\_SCRIPT\\_SAMARITAN: Samaritan. Since 2.26 \\_UNICODE\\_SCRIPT\\_TAI\\_THAM: Tai Tham. Since 2.26 \\_UNICODE\\_SCRIPT\\_TAI\\_VIET: Tai Viet. Since 2.26 \\_UNICODE\\_SCRIPT\\_BATAK: Batak. Since 2.28 \\_UNICODE\\_SCRIPT\\_BRAHMI: Brahmi. Since 2.28 \\_UNICODE\\_SCRIPT\\_MANDAIC: Mandaic. Since 2.28 \\_UNICODE\\_SCRIPT\\_CHAKMA: Chakma. Since: 2.32 \\_UNICODE\\_SCRIPT\\_MEROITIC\\_CURSIVE: Meroitic Cursive. Since: 2.32 \\_UNICODE\\_SCRIPT\\_MEROITIC\\_HIEROGLYPHS: Meroitic Hieroglyphs. Since: 2.32 \\_UNICODE\\_SCRIPT\\_MIAO: Miao. Since: 2.32 \\_UNICODE\\_SCRIPT\\_SHARADA: Sharada. Since: 2.32 \\_UNICODE\\_SCRIPT\\_SORA\\_SOMPENG: Sora Sompeng. Since: 2.32 \\_UNICODE\\_SCRIPT\\_TAKRI: Takri. Since: 2.32 \\_UNICODE\\_SCRIPT\\_BASSA\\_VAH: Bassa. Since: 2.42 \\_UNICODE\\_SCRIPT\\_CAUCASIAN\\_ALBANIAN: Caucasian Albanian. Since: 2.42 \\_UNICODE\\_SCRIPT\\_DUPLOYAN: Duployan. Since: 2.42 \\_UNICODE\\_SCRIPT\\_ELBASAN: Elbasan. Since: 2.42 \\_UNICODE\\_SCRIPT\\_GRANTHA: Grantha. Since: 2.42 \\_UNICODE\\_SCRIPT\\_KHOJKI: Kjohki. Since: 2.42 \\_UNICODE\\_SCRIPT\\_KHUDAWADI: Khudawadi, Sindhi. Since: 2.42 \\_UNICODE\\_SCRIPT\\_LINEAR\\_A: Linear A. Since: 2.42 \\_UNICODE\\_SCRIPT\\_MAHAJANI: Mahajani. Since: 2.42 \\_UNICODE\\_SCRIPT\\_MANICHAEAN: Manichaean. Since: 2.42 \\_UNICODE\\_SCRIPT\\_MENDE\\_KIKAKUI: Mende Kikakui. Since: 2.42 \\_UNICODE\\_SCRIPT\\_MODI: Modi. Since: 2.42 \\_UNICODE\\_SCRIPT\\_MRO: Mro. Since: 2.42 \\_UNICODE\\_SCRIPT\\_NABATAEAN: Nabataean. Since: 2.42 \\_UNICODE\\_SCRIPT\\_OLD\\_NORTH\\_ARABIAN: Old North Arabian. Since: 2.42 \\_UNICODE\\_SCRIPT\\_OLD\\_PERMIC: Old Permic. Since: 2.42 \\_UNICODE\\_SCRIPT\\_PAHAWH\\_HMONG: Pahawh Hmong. Since: 2.42 \\_UNICODE\\_SCRIPT\\_PALMYRENE: Palmyrene. Since: 2.42 \\_UNICODE\\_SCRIPT\\_PAU\\_CIN\\_HAU: Pau Cin Hau. Since: 2.42 \\_UNICODE\\_SCRIPT\\_PSALTER\\_PAHLAVI: Psalter Pahlavi. Since: 2.42 \\_UNICODE\\_SCRIPT\\_SIDDHAM: Siddham. Since: 2.42 \\_UNICODE\\_SCRIPT\\_TIRHUTA: Tirhuta. Since: 2.42 \\_UNICODE\\_SCRIPT\\_WARANG\\_CITI: Warang Citi. Since: 2.42 \\_UNICODE\\_SCRIPT\\_AHOM: Ahom. Since: 2.48 \\_UNICODE\\_SCRIPT\\_ANATOLIAN\\_HIEROGLYPHS: Anatolian Hieroglyphs. Since: 2.48 \\_UNICODE\\_SCRIPT\\_HATRAN: Hatran. Since: 2.48 \\_UNICODE\\_SCRIPT\\_MULTANI: Multani. Since: 2.48 \\_UNICODE\\_SCRIPT\\_OLD\\_HUNGARIAN: Old Hungarian. Since: 2.48 \\_UNICODE\\_SCRIPT\\_SIGNWRITING: Signwriting. Since: 2.48 \\_UNICODE\\_SCRIPT\\_ADLAM: Adlam. Since: 2.50 \\_UNICODE\\_SCRIPT\\_BHAIKSUKI: Bhaiksuki. Since: 2.50 \\_UNICODE\\_SCRIPT\\_MARCHEN: Marchen. Since: 2.50 \\_UNICODE\\_SCRIPT\\_NEWA: Newa. Since: 2.50 \\_UNICODE\\_SCRIPT\\_OSAGE: Osage. Since: 2.50 \\_UNICODE\\_SCRIPT\\_TANGUT: Tangut. Since: 2.50 \\_UNICODE\\_SCRIPT\\_MASARAM\\_GONDI: Masaram Gondi. Since: 2.54 \\_UNICODE\\_SCRIPT\\_NUSHU: Nushu. Since: 2.54 \\_UNICODE\\_SCRIPT\\_SOYOMBO: Soyombo. Since: 2.54 \\_UNICODE\\_SCRIPT\\_ZANABAZAR\\_SQUARE: Zanabazar Square. Since: 2.54 \\_UNICODE\\_SCRIPT\\_DOGRA: Dogra. Since: 2.58 \\_UNICODE\\_SCRIPT\\_GUNJALA\\_GONDI: Gunjala Gondi. Since: 2.58 \\_UNICODE\\_SCRIPT\\_HANIFI\\_ROHINGYA: Hanifi Rohingya. Since: 2.58 \\_UNICODE\\_SCRIPT\\_MAKASAR: Makasar. Since: 2.58 \\_UNICODE\\_SCRIPT\\_MEDEFAIDRIN: Medefaidrin. Since: 2.58 \\_UNICODE\\_SCRIPT\\_OLD\\_SOGDIAN: Old Sogdian. Since: 2.58 \\_UNICODE\\_SCRIPT\\_SOGDIAN: Sogdian. Since: 2.58 \\_UNICODE\\_SCRIPT\\_ELYMAIC: Elym. Since: 2.62 \\_UNICODE\\_SCRIPT\\_NANDINAGARI: Nand. Since: 2.62 \\_UNICODE\\_SCRIPT\\_NYIAKENG\\_PUACHUE\\_HMONG: Rohg. Since: 2.62 \\_UNICODE\\_SCRIPT\\_WANCHO: Wcho. Since: 2.62 \\_UNICODE\\_SCRIPT\\_CHORASMIAN: Chorasmian. Since: 2.66 \\_UNICODE\\_SCRIPT\\_DIVES\\_AKURU: Dives Akuru. Since: 2.66 \\_UNICODE\\_SCRIPT\\_KHITAN\\_SMALL\\_SCRIPT: Khitan small script. Since: 2.66 \\_UNICODE\\_SCRIPT\\_YEZIDI: Yezidi. Since: 2.66 \\_UNICODE\\_SCRIPT\\_CYPRO\\_MINOAN: Cypro-Minoan. Since: 2.72 \\_UNICODE\\_SCRIPT\\_OLD\\_UYGHUR: Old Uyghur. Since: 2.72 \\_UNICODE\\_SCRIPT\\_TANGSA: Tangsa. Since: 2.72 \\_UNICODE\\_SCRIPT\\_TOTO: Toto. Since: 2.72 \\_UNICODE\\_SCRIPT\\_VITHKUQI: Vithkuqi. Since: 2.72 \\_UNICODE\\_SCRIPT\\_MATH: Mathematical notation. Since: 2.72 \\_UNICODE\\_SCRIPT\\_KAWI: Kawi. Since 2.74 \\_UNICODE\\_SCRIPT\\_NAG\\_MUNDARI: Nag Mundari. Since 2.74 \\_UNICODE\\_SCRIPT\\_TODHRI: Todhri. Since: 2.84 \\_UNICODE\\_SCRIPT\\_GARAY: Garay. Since: 2.84 \\_UNICODE\\_SCRIPT\\_TULU\\_TIGALARI: Tulu-Tigalari. Since: 2.84 \\_UNICODE\\_SCRIPT\\_SUNUWAR: Sunuwar. Since: 2.84 \\_UNICODE\\_SCRIPT\\_GURUNG\\_KHEMA: Gurung Khema. Since: 2.84 \\_UNICODE\\_SCRIPT\\_KIRAT\\_RAI: Kirat Rai. Since: 2.84 \\_UNICODE\\_SCRIPT\\_OL\\_ONAL: Ol Onal. Since: 2.84

The #[`GUnicodeScript`](@ref) enumeration identifies different writing systems. The values correspond to the names as defined in the Unicode standard. The enumeration has been added in GLib 2.14, and is interchangeable with #PangoScript.

Note that new types may be added in the future. Applications should be ready to handle unknown values. See [Unicode Standard Annex #24: Script names](http://www.unicode.org/reports/tr24/).
"""
@cenum GUnicodeScript::Int32 begin
    G_UNICODE_SCRIPT_INVALID_CODE = -1
    G_UNICODE_SCRIPT_COMMON = 0
    G_UNICODE_SCRIPT_INHERITED = 1
    G_UNICODE_SCRIPT_ARABIC = 2
    G_UNICODE_SCRIPT_ARMENIAN = 3
    G_UNICODE_SCRIPT_BENGALI = 4
    G_UNICODE_SCRIPT_BOPOMOFO = 5
    G_UNICODE_SCRIPT_CHEROKEE = 6
    G_UNICODE_SCRIPT_COPTIC = 7
    G_UNICODE_SCRIPT_CYRILLIC = 8
    G_UNICODE_SCRIPT_DESERET = 9
    G_UNICODE_SCRIPT_DEVANAGARI = 10
    G_UNICODE_SCRIPT_ETHIOPIC = 11
    G_UNICODE_SCRIPT_GEORGIAN = 12
    G_UNICODE_SCRIPT_GOTHIC = 13
    G_UNICODE_SCRIPT_GREEK = 14
    G_UNICODE_SCRIPT_GUJARATI = 15
    G_UNICODE_SCRIPT_GURMUKHI = 16
    G_UNICODE_SCRIPT_HAN = 17
    G_UNICODE_SCRIPT_HANGUL = 18
    G_UNICODE_SCRIPT_HEBREW = 19
    G_UNICODE_SCRIPT_HIRAGANA = 20
    G_UNICODE_SCRIPT_KANNADA = 21
    G_UNICODE_SCRIPT_KATAKANA = 22
    G_UNICODE_SCRIPT_KHMER = 23
    G_UNICODE_SCRIPT_LAO = 24
    G_UNICODE_SCRIPT_LATIN = 25
    G_UNICODE_SCRIPT_MALAYALAM = 26
    G_UNICODE_SCRIPT_MONGOLIAN = 27
    G_UNICODE_SCRIPT_MYANMAR = 28
    G_UNICODE_SCRIPT_OGHAM = 29
    G_UNICODE_SCRIPT_OLD_ITALIC = 30
    G_UNICODE_SCRIPT_ORIYA = 31
    G_UNICODE_SCRIPT_RUNIC = 32
    G_UNICODE_SCRIPT_SINHALA = 33
    G_UNICODE_SCRIPT_SYRIAC = 34
    G_UNICODE_SCRIPT_TAMIL = 35
    G_UNICODE_SCRIPT_TELUGU = 36
    G_UNICODE_SCRIPT_THAANA = 37
    G_UNICODE_SCRIPT_THAI = 38
    G_UNICODE_SCRIPT_TIBETAN = 39
    G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL = 40
    G_UNICODE_SCRIPT_YI = 41
    G_UNICODE_SCRIPT_TAGALOG = 42
    G_UNICODE_SCRIPT_HANUNOO = 43
    G_UNICODE_SCRIPT_BUHID = 44
    G_UNICODE_SCRIPT_TAGBANWA = 45
    G_UNICODE_SCRIPT_BRAILLE = 46
    G_UNICODE_SCRIPT_CYPRIOT = 47
    G_UNICODE_SCRIPT_LIMBU = 48
    G_UNICODE_SCRIPT_OSMANYA = 49
    G_UNICODE_SCRIPT_SHAVIAN = 50
    G_UNICODE_SCRIPT_LINEAR_B = 51
    G_UNICODE_SCRIPT_TAI_LE = 52
    G_UNICODE_SCRIPT_UGARITIC = 53
    G_UNICODE_SCRIPT_NEW_TAI_LUE = 54
    G_UNICODE_SCRIPT_BUGINESE = 55
    G_UNICODE_SCRIPT_GLAGOLITIC = 56
    G_UNICODE_SCRIPT_TIFINAGH = 57
    G_UNICODE_SCRIPT_SYLOTI_NAGRI = 58
    G_UNICODE_SCRIPT_OLD_PERSIAN = 59
    G_UNICODE_SCRIPT_KHAROSHTHI = 60
    G_UNICODE_SCRIPT_UNKNOWN = 61
    G_UNICODE_SCRIPT_BALINESE = 62
    G_UNICODE_SCRIPT_CUNEIFORM = 63
    G_UNICODE_SCRIPT_PHOENICIAN = 64
    G_UNICODE_SCRIPT_PHAGS_PA = 65
    G_UNICODE_SCRIPT_NKO = 66
    G_UNICODE_SCRIPT_KAYAH_LI = 67
    G_UNICODE_SCRIPT_LEPCHA = 68
    G_UNICODE_SCRIPT_REJANG = 69
    G_UNICODE_SCRIPT_SUNDANESE = 70
    G_UNICODE_SCRIPT_SAURASHTRA = 71
    G_UNICODE_SCRIPT_CHAM = 72
    G_UNICODE_SCRIPT_OL_CHIKI = 73
    G_UNICODE_SCRIPT_VAI = 74
    G_UNICODE_SCRIPT_CARIAN = 75
    G_UNICODE_SCRIPT_LYCIAN = 76
    G_UNICODE_SCRIPT_LYDIAN = 77
    G_UNICODE_SCRIPT_AVESTAN = 78
    G_UNICODE_SCRIPT_BAMUM = 79
    G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS = 80
    G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC = 81
    G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI = 82
    G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN = 83
    G_UNICODE_SCRIPT_JAVANESE = 84
    G_UNICODE_SCRIPT_KAITHI = 85
    G_UNICODE_SCRIPT_LISU = 86
    G_UNICODE_SCRIPT_MEETEI_MAYEK = 87
    G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN = 88
    G_UNICODE_SCRIPT_OLD_TURKIC = 89
    G_UNICODE_SCRIPT_SAMARITAN = 90
    G_UNICODE_SCRIPT_TAI_THAM = 91
    G_UNICODE_SCRIPT_TAI_VIET = 92
    G_UNICODE_SCRIPT_BATAK = 93
    G_UNICODE_SCRIPT_BRAHMI = 94
    G_UNICODE_SCRIPT_MANDAIC = 95
    G_UNICODE_SCRIPT_CHAKMA = 96
    G_UNICODE_SCRIPT_MEROITIC_CURSIVE = 97
    G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS = 98
    G_UNICODE_SCRIPT_MIAO = 99
    G_UNICODE_SCRIPT_SHARADA = 100
    G_UNICODE_SCRIPT_SORA_SOMPENG = 101
    G_UNICODE_SCRIPT_TAKRI = 102
    G_UNICODE_SCRIPT_BASSA_VAH = 103
    G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN = 104
    G_UNICODE_SCRIPT_DUPLOYAN = 105
    G_UNICODE_SCRIPT_ELBASAN = 106
    G_UNICODE_SCRIPT_GRANTHA = 107
    G_UNICODE_SCRIPT_KHOJKI = 108
    G_UNICODE_SCRIPT_KHUDAWADI = 109
    G_UNICODE_SCRIPT_LINEAR_A = 110
    G_UNICODE_SCRIPT_MAHAJANI = 111
    G_UNICODE_SCRIPT_MANICHAEAN = 112
    G_UNICODE_SCRIPT_MENDE_KIKAKUI = 113
    G_UNICODE_SCRIPT_MODI = 114
    G_UNICODE_SCRIPT_MRO = 115
    G_UNICODE_SCRIPT_NABATAEAN = 116
    G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN = 117
    G_UNICODE_SCRIPT_OLD_PERMIC = 118
    G_UNICODE_SCRIPT_PAHAWH_HMONG = 119
    G_UNICODE_SCRIPT_PALMYRENE = 120
    G_UNICODE_SCRIPT_PAU_CIN_HAU = 121
    G_UNICODE_SCRIPT_PSALTER_PAHLAVI = 122
    G_UNICODE_SCRIPT_SIDDHAM = 123
    G_UNICODE_SCRIPT_TIRHUTA = 124
    G_UNICODE_SCRIPT_WARANG_CITI = 125
    G_UNICODE_SCRIPT_AHOM = 126
    G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS = 127
    G_UNICODE_SCRIPT_HATRAN = 128
    G_UNICODE_SCRIPT_MULTANI = 129
    G_UNICODE_SCRIPT_OLD_HUNGARIAN = 130
    G_UNICODE_SCRIPT_SIGNWRITING = 131
    G_UNICODE_SCRIPT_ADLAM = 132
    G_UNICODE_SCRIPT_BHAIKSUKI = 133
    G_UNICODE_SCRIPT_MARCHEN = 134
    G_UNICODE_SCRIPT_NEWA = 135
    G_UNICODE_SCRIPT_OSAGE = 136
    G_UNICODE_SCRIPT_TANGUT = 137
    G_UNICODE_SCRIPT_MASARAM_GONDI = 138
    G_UNICODE_SCRIPT_NUSHU = 139
    G_UNICODE_SCRIPT_SOYOMBO = 140
    G_UNICODE_SCRIPT_ZANABAZAR_SQUARE = 141
    G_UNICODE_SCRIPT_DOGRA = 142
    G_UNICODE_SCRIPT_GUNJALA_GONDI = 143
    G_UNICODE_SCRIPT_HANIFI_ROHINGYA = 144
    G_UNICODE_SCRIPT_MAKASAR = 145
    G_UNICODE_SCRIPT_MEDEFAIDRIN = 146
    G_UNICODE_SCRIPT_OLD_SOGDIAN = 147
    G_UNICODE_SCRIPT_SOGDIAN = 148
    G_UNICODE_SCRIPT_ELYMAIC = 149
    G_UNICODE_SCRIPT_NANDINAGARI = 150
    G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG = 151
    G_UNICODE_SCRIPT_WANCHO = 152
    G_UNICODE_SCRIPT_CHORASMIAN = 153
    G_UNICODE_SCRIPT_DIVES_AKURU = 154
    G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT = 155
    G_UNICODE_SCRIPT_YEZIDI = 156
    G_UNICODE_SCRIPT_CYPRO_MINOAN = 157
    G_UNICODE_SCRIPT_OLD_UYGHUR = 158
    G_UNICODE_SCRIPT_TANGSA = 159
    G_UNICODE_SCRIPT_TOTO = 160
    G_UNICODE_SCRIPT_VITHKUQI = 161
    G_UNICODE_SCRIPT_MATH = 162
    G_UNICODE_SCRIPT_KAWI = 163
    G_UNICODE_SCRIPT_NAG_MUNDARI = 164
    G_UNICODE_SCRIPT_TODHRI = 165
    G_UNICODE_SCRIPT_GARAY = 166
    G_UNICODE_SCRIPT_TULU_TIGALARI = 167
    G_UNICODE_SCRIPT_SUNUWAR = 168
    G_UNICODE_SCRIPT_GURUNG_KHEMA = 169
    G_UNICODE_SCRIPT_KIRAT_RAI = 170
    G_UNICODE_SCRIPT_OL_ONAL = 171
end

"""
    g_unicode_script_to_iso15924(script)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint32 g_unicode_script_to_iso15924 (GUnicodeScript script);
```
"""
function g_unicode_script_to_iso15924(script)
    @ccall libaravis.g_unicode_script_to_iso15924(script::GUnicodeScript)::guint32
end

"""
    g_unicode_script_from_iso15924(iso15924)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GUnicodeScript g_unicode_script_from_iso15924 (guint32 iso15924);
```
"""
function g_unicode_script_from_iso15924(iso15924)
    @ccall libaravis.g_unicode_script_from_iso15924(iso15924::guint32)::GUnicodeScript
end

"""
    g_unichar_isalnum(c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_unichar_isalnum (gunichar c) G_GNUC_CONST;
```
"""
function g_unichar_isalnum(c)
    @ccall libaravis.g_unichar_isalnum(c::gunichar)::gboolean
end

"""
    g_unichar_isalpha(c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_unichar_isalpha (gunichar c) G_GNUC_CONST;
```
"""
function g_unichar_isalpha(c)
    @ccall libaravis.g_unichar_isalpha(c::gunichar)::gboolean
end

"""
    g_unichar_iscntrl(c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_unichar_iscntrl (gunichar c) G_GNUC_CONST;
```
"""
function g_unichar_iscntrl(c)
    @ccall libaravis.g_unichar_iscntrl(c::gunichar)::gboolean
end

"""
    g_unichar_isdigit(c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_unichar_isdigit (gunichar c) G_GNUC_CONST;
```
"""
function g_unichar_isdigit(c)
    @ccall libaravis.g_unichar_isdigit(c::gunichar)::gboolean
end

"""
    g_unichar_isgraph(c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_unichar_isgraph (gunichar c) G_GNUC_CONST;
```
"""
function g_unichar_isgraph(c)
    @ccall libaravis.g_unichar_isgraph(c::gunichar)::gboolean
end

"""
    g_unichar_islower(c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_unichar_islower (gunichar c) G_GNUC_CONST;
```
"""
function g_unichar_islower(c)
    @ccall libaravis.g_unichar_islower(c::gunichar)::gboolean
end

"""
    g_unichar_isprint(c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_unichar_isprint (gunichar c) G_GNUC_CONST;
```
"""
function g_unichar_isprint(c)
    @ccall libaravis.g_unichar_isprint(c::gunichar)::gboolean
end

"""
    g_unichar_ispunct(c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_unichar_ispunct (gunichar c) G_GNUC_CONST;
```
"""
function g_unichar_ispunct(c)
    @ccall libaravis.g_unichar_ispunct(c::gunichar)::gboolean
end

"""
    g_unichar_isspace(c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_unichar_isspace (gunichar c) G_GNUC_CONST;
```
"""
function g_unichar_isspace(c)
    @ccall libaravis.g_unichar_isspace(c::gunichar)::gboolean
end

"""
    g_unichar_isupper(c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_unichar_isupper (gunichar c) G_GNUC_CONST;
```
"""
function g_unichar_isupper(c)
    @ccall libaravis.g_unichar_isupper(c::gunichar)::gboolean
end

"""
    g_unichar_isxdigit(c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_unichar_isxdigit (gunichar c) G_GNUC_CONST;
```
"""
function g_unichar_isxdigit(c)
    @ccall libaravis.g_unichar_isxdigit(c::gunichar)::gboolean
end

"""
    g_unichar_istitle(c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_unichar_istitle (gunichar c) G_GNUC_CONST;
```
"""
function g_unichar_istitle(c)
    @ccall libaravis.g_unichar_istitle(c::gunichar)::gboolean
end

"""
    g_unichar_isdefined(c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_unichar_isdefined (gunichar c) G_GNUC_CONST;
```
"""
function g_unichar_isdefined(c)
    @ccall libaravis.g_unichar_isdefined(c::gunichar)::gboolean
end

"""
    g_unichar_iswide(c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_unichar_iswide (gunichar c) G_GNUC_CONST;
```
"""
function g_unichar_iswide(c)
    @ccall libaravis.g_unichar_iswide(c::gunichar)::gboolean
end

"""
    g_unichar_iswide_cjk(c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_unichar_iswide_cjk(gunichar c) G_GNUC_CONST;
```
"""
function g_unichar_iswide_cjk(c)
    @ccall libaravis.g_unichar_iswide_cjk(c::gunichar)::gboolean
end

"""
    g_unichar_iszerowidth(c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_unichar_iszerowidth(gunichar c) G_GNUC_CONST;
```
"""
function g_unichar_iszerowidth(c)
    @ccall libaravis.g_unichar_iszerowidth(c::gunichar)::gboolean
end

"""
    g_unichar_ismark(c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_unichar_ismark (gunichar c) G_GNUC_CONST;
```
"""
function g_unichar_ismark(c)
    @ccall libaravis.g_unichar_ismark(c::gunichar)::gboolean
end

"""
    g_unichar_toupper(c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gunichar g_unichar_toupper (gunichar c) G_GNUC_CONST;
```
"""
function g_unichar_toupper(c)
    @ccall libaravis.g_unichar_toupper(c::gunichar)::gunichar
end

"""
    g_unichar_tolower(c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gunichar g_unichar_tolower (gunichar c) G_GNUC_CONST;
```
"""
function g_unichar_tolower(c)
    @ccall libaravis.g_unichar_tolower(c::gunichar)::gunichar
end

"""
    g_unichar_totitle(c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gunichar g_unichar_totitle (gunichar c) G_GNUC_CONST;
```
"""
function g_unichar_totitle(c)
    @ccall libaravis.g_unichar_totitle(c::gunichar)::gunichar
end

"""
    g_unichar_digit_value(c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_unichar_digit_value (gunichar c) G_GNUC_CONST;
```
"""
function g_unichar_digit_value(c)
    @ccall libaravis.g_unichar_digit_value(c::gunichar)::gint
end

"""
    g_unichar_xdigit_value(c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_unichar_xdigit_value (gunichar c) G_GNUC_CONST;
```
"""
function g_unichar_xdigit_value(c)
    @ccall libaravis.g_unichar_xdigit_value(c::gunichar)::gint
end

"""
    g_unichar_type(c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GUnicodeType g_unichar_type (gunichar c) G_GNUC_CONST;
```
"""
function g_unichar_type(c)
    @ccall libaravis.g_unichar_type(c::gunichar)::GUnicodeType
end

"""
    g_unichar_break_type(c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GUnicodeBreakType g_unichar_break_type (gunichar c) G_GNUC_CONST;
```
"""
function g_unichar_break_type(c)
    @ccall libaravis.g_unichar_break_type(c::gunichar)::GUnicodeBreakType
end

"""
    g_unichar_combining_class(uc)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_unichar_combining_class (gunichar uc) G_GNUC_CONST;
```
"""
function g_unichar_combining_class(uc)
    @ccall libaravis.g_unichar_combining_class(uc::gunichar)::gint
end

"""
    g_unichar_get_mirror_char(ch, mirrored_ch)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_unichar_get_mirror_char (gunichar ch, gunichar *mirrored_ch);
```
"""
function g_unichar_get_mirror_char(ch, mirrored_ch)
    @ccall libaravis.g_unichar_get_mirror_char(ch::gunichar, mirrored_ch::Ptr{gunichar})::gboolean
end

"""
    g_unichar_get_script(ch)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GUnicodeScript g_unichar_get_script (gunichar ch) G_GNUC_CONST;
```
"""
function g_unichar_get_script(ch)
    @ccall libaravis.g_unichar_get_script(ch::gunichar)::GUnicodeScript
end

"""
    g_unichar_validate(ch)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_unichar_validate (gunichar ch) G_GNUC_CONST;
```
"""
function g_unichar_validate(ch)
    @ccall libaravis.g_unichar_validate(ch::gunichar)::gboolean
end

"""
    g_unichar_compose(a, b, ch)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_unichar_compose (gunichar a, gunichar b, gunichar *ch);
```
"""
function g_unichar_compose(a, b, ch)
    @ccall libaravis.g_unichar_compose(a::gunichar, b::gunichar, ch::Ptr{gunichar})::gboolean
end

"""
    g_unichar_decompose(ch, a, b)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_unichar_decompose (gunichar ch, gunichar *a, gunichar *b);
```
"""
function g_unichar_decompose(ch, a, b)
    @ccall libaravis.g_unichar_decompose(ch::gunichar, a::Ptr{gunichar}, b::Ptr{gunichar})::gboolean
end

"""
    g_unichar_fully_decompose(ch, compat, result, result_len)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gsize g_unichar_fully_decompose (gunichar ch, gboolean compat, gunichar *result, gsize result_len);
```
"""
function g_unichar_fully_decompose(ch, compat, result, result_len)
    @ccall libaravis.g_unichar_fully_decompose(ch::gunichar, compat::gboolean, result::Ptr{gunichar}, result_len::gsize)::gsize
end

"""
    g_unicode_canonical_ordering(string, len)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_unicode_canonical_ordering (gunichar *string, gsize len);
```
"""
function g_unicode_canonical_ordering(string, len)
    @ccall libaravis.g_unicode_canonical_ordering(string::Ptr{gunichar}, len::gsize)::Cvoid
end

"""
    g_unicode_canonical_decomposition(ch, result_len)

### Prototype
```c
GLIB_DEPRECATED_IN_2_30 gunichar *g_unicode_canonical_decomposition (gunichar ch, gsize *result_len) G_GNUC_MALLOC;
```
"""
function g_unicode_canonical_decomposition(ch, result_len)
    @ccall libaravis.g_unicode_canonical_decomposition(ch::gunichar, result_len::Ptr{gsize})::Ptr{gunichar}
end

"""
    g_utf8_get_char(p)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gunichar g_utf8_get_char (const gchar *p) G_GNUC_PURE;
```
"""
function g_utf8_get_char(p)
    @ccall libaravis.g_utf8_get_char(p::Ptr{gchar})::gunichar
end

"""
    g_utf8_get_char_validated(p, max_len)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gunichar g_utf8_get_char_validated (const gchar *p, gssize max_len) G_GNUC_PURE;
```
"""
function g_utf8_get_char_validated(p, max_len)
    @ccall libaravis.g_utf8_get_char_validated(p::Ptr{gchar}, max_len::gssize)::gunichar
end

"""
    g_utf8_offset_to_pointer(str, offset)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_utf8_offset_to_pointer (const gchar *str, glong offset) G_GNUC_PURE;
```
"""
function g_utf8_offset_to_pointer(str, offset)
    @ccall libaravis.g_utf8_offset_to_pointer(str::Ptr{gchar}, offset::glong)::Ptr{gchar}
end

"""
    g_utf8_pointer_to_offset(str, pos)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL glong g_utf8_pointer_to_offset (const gchar *str, const gchar *pos) G_GNUC_PURE;
```
"""
function g_utf8_pointer_to_offset(str, pos)
    @ccall libaravis.g_utf8_pointer_to_offset(str::Ptr{gchar}, pos::Ptr{gchar})::glong
end

"""
    g_utf8_prev_char(p)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_utf8_prev_char (const gchar *p) G_GNUC_PURE;
```
"""
function g_utf8_prev_char(p)
    @ccall libaravis.g_utf8_prev_char(p::Ptr{gchar})::Ptr{gchar}
end

"""
    g_utf8_find_next_char(p, _end)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_utf8_find_next_char (const gchar *p, const gchar *end) G_GNUC_PURE;
```
"""
function g_utf8_find_next_char(p, _end)
    @ccall libaravis.g_utf8_find_next_char(p::Ptr{gchar}, _end::Ptr{gchar})::Ptr{gchar}
end

"""
    g_utf8_find_prev_char(str, p)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_utf8_find_prev_char (const gchar *str, const gchar *p) G_GNUC_PURE;
```
"""
function g_utf8_find_prev_char(str, p)
    @ccall libaravis.g_utf8_find_prev_char(str::Ptr{gchar}, p::Ptr{gchar})::Ptr{gchar}
end

"""
    g_utf8_strlen(p, max)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL glong g_utf8_strlen (const gchar *p, gssize max) G_GNUC_PURE;
```
"""
function g_utf8_strlen(p, max)
    @ccall libaravis.g_utf8_strlen(p::Ptr{gchar}, max::gssize)::glong
end

"""
    g_utf8_substring(str, start_pos, end_pos)

### Prototype
```c
GLIB_AVAILABLE_IN_2_30 gchar *g_utf8_substring (const gchar *str, glong start_pos, glong end_pos) G_GNUC_MALLOC;
```
"""
function g_utf8_substring(str, start_pos, end_pos)
    @ccall libaravis.g_utf8_substring(str::Ptr{gchar}, start_pos::glong, end_pos::glong)::Ptr{gchar}
end

"""
    g_utf8_strncpy(dest, src, n)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_utf8_strncpy (gchar *dest, const gchar *src, gsize n);
```
"""
function g_utf8_strncpy(dest, src, n)
    @ccall libaravis.g_utf8_strncpy(dest::Ptr{gchar}, src::Ptr{gchar}, n::gsize)::Ptr{gchar}
end

"""
    g_utf8_truncate_middle(string, truncate_length)

### Prototype
```c
GLIB_AVAILABLE_IN_2_78 gchar *g_utf8_truncate_middle (const gchar *string, gsize truncate_length);
```
"""
function g_utf8_truncate_middle(string, truncate_length)
    @ccall libaravis.g_utf8_truncate_middle(string::Ptr{gchar}, truncate_length::gsize)::Ptr{gchar}
end

"""
    g_utf8_strchr(p, len, c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_utf8_strchr (const gchar *p, gssize len, gunichar c);
```
"""
function g_utf8_strchr(p, len, c)
    @ccall libaravis.g_utf8_strchr(p::Ptr{gchar}, len::gssize, c::gunichar)::Ptr{gchar}
end

"""
    g_utf8_strrchr(p, len, c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_utf8_strrchr (const gchar *p, gssize len, gunichar c);
```
"""
function g_utf8_strrchr(p, len, c)
    @ccall libaravis.g_utf8_strrchr(p::Ptr{gchar}, len::gssize, c::gunichar)::Ptr{gchar}
end

"""
    g_utf8_strreverse(str, len)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_utf8_strreverse (const gchar *str, gssize len);
```
"""
function g_utf8_strreverse(str, len)
    @ccall libaravis.g_utf8_strreverse(str::Ptr{gchar}, len::gssize)::Ptr{gchar}
end

"""
    g_utf8_to_utf16(str, len, items_read, items_written, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gunichar2 *g_utf8_to_utf16 (const gchar *str, glong len, glong *items_read, glong *items_written, GError **error) G_GNUC_MALLOC;
```
"""
function g_utf8_to_utf16(str, len, items_read, items_written, error)
    @ccall libaravis.g_utf8_to_utf16(str::Ptr{gchar}, len::glong, items_read::Ptr{glong}, items_written::Ptr{glong}, error::Ptr{Ptr{GError}})::Ptr{gunichar2}
end

"""
    g_utf8_to_ucs4(str, len, items_read, items_written, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gunichar * g_utf8_to_ucs4 (const gchar *str, glong len, glong *items_read, glong *items_written, GError **error) G_GNUC_MALLOC;
```
"""
function g_utf8_to_ucs4(str, len, items_read, items_written, error)
    @ccall libaravis.g_utf8_to_ucs4(str::Ptr{gchar}, len::glong, items_read::Ptr{glong}, items_written::Ptr{glong}, error::Ptr{Ptr{GError}})::Ptr{gunichar}
end

"""
    g_utf8_to_ucs4_fast(str, len, items_written)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gunichar * g_utf8_to_ucs4_fast (const gchar *str, glong len, glong *items_written) G_GNUC_MALLOC;
```
"""
function g_utf8_to_ucs4_fast(str, len, items_written)
    @ccall libaravis.g_utf8_to_ucs4_fast(str::Ptr{gchar}, len::glong, items_written::Ptr{glong})::Ptr{gunichar}
end

"""
    g_utf16_to_ucs4(str, len, items_read, items_written, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gunichar * g_utf16_to_ucs4 (const gunichar2 *str, glong len, glong *items_read, glong *items_written, GError **error) G_GNUC_MALLOC;
```
"""
function g_utf16_to_ucs4(str, len, items_read, items_written, error)
    @ccall libaravis.g_utf16_to_ucs4(str::Ptr{gunichar2}, len::glong, items_read::Ptr{glong}, items_written::Ptr{glong}, error::Ptr{Ptr{GError}})::Ptr{gunichar}
end

"""
    g_utf16_to_utf8(str, len, items_read, items_written, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_utf16_to_utf8 (const gunichar2 *str, glong len, glong *items_read, glong *items_written, GError **error) G_GNUC_MALLOC;
```
"""
function g_utf16_to_utf8(str, len, items_read, items_written, error)
    @ccall libaravis.g_utf16_to_utf8(str::Ptr{gunichar2}, len::glong, items_read::Ptr{glong}, items_written::Ptr{glong}, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_ucs4_to_utf16(str, len, items_read, items_written, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gunichar2 *g_ucs4_to_utf16 (const gunichar *str, glong len, glong *items_read, glong *items_written, GError **error) G_GNUC_MALLOC;
```
"""
function g_ucs4_to_utf16(str, len, items_read, items_written, error)
    @ccall libaravis.g_ucs4_to_utf16(str::Ptr{gunichar}, len::glong, items_read::Ptr{glong}, items_written::Ptr{glong}, error::Ptr{Ptr{GError}})::Ptr{gunichar2}
end

"""
    g_ucs4_to_utf8(str, len, items_read, items_written, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_ucs4_to_utf8 (const gunichar *str, glong len, glong *items_read, glong *items_written, GError **error) G_GNUC_MALLOC;
```
"""
function g_ucs4_to_utf8(str, len, items_read, items_written, error)
    @ccall libaravis.g_ucs4_to_utf8(str::Ptr{gunichar}, len::glong, items_read::Ptr{glong}, items_written::Ptr{glong}, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_unichar_to_utf8(c, outbuf)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_unichar_to_utf8 (gunichar c, gchar *outbuf);
```
"""
function g_unichar_to_utf8(c, outbuf)
    @ccall libaravis.g_unichar_to_utf8(c::gunichar, outbuf::Ptr{gchar})::gint
end

"""
    g_utf8_validate(str, max_len, _end)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_utf8_validate (const gchar *str, gssize max_len, const gchar **end);
```
"""
function g_utf8_validate(str, max_len, _end)
    @ccall libaravis.g_utf8_validate(str::Ptr{gchar}, max_len::gssize, _end::Ptr{Ptr{gchar}})::gboolean
end

"""
    g_utf8_validate_len(str, max_len, _end)

### Prototype
```c
GLIB_AVAILABLE_IN_2_60 gboolean g_utf8_validate_len (const gchar *str, gsize max_len, const gchar **end);
```
"""
function g_utf8_validate_len(str, max_len, _end)
    @ccall libaravis.g_utf8_validate_len(str::Ptr{gchar}, max_len::gsize, _end::Ptr{Ptr{gchar}})::gboolean
end

"""
    g_utf8_strup(str, len)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_utf8_strup (const gchar *str, gssize len) G_GNUC_MALLOC;
```
"""
function g_utf8_strup(str, len)
    @ccall libaravis.g_utf8_strup(str::Ptr{gchar}, len::gssize)::Ptr{gchar}
end

"""
    g_utf8_strdown(str, len)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_utf8_strdown (const gchar *str, gssize len) G_GNUC_MALLOC;
```
"""
function g_utf8_strdown(str, len)
    @ccall libaravis.g_utf8_strdown(str::Ptr{gchar}, len::gssize)::Ptr{gchar}
end

"""
    g_utf8_casefold(str, len)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_utf8_casefold (const gchar *str, gssize len) G_GNUC_MALLOC;
```
"""
function g_utf8_casefold(str, len)
    @ccall libaravis.g_utf8_casefold(str::Ptr{gchar}, len::gssize)::Ptr{gchar}
end

"""
    GNormalizeMode

[`GNormalizeMode`](@ref): \\_NORMALIZE\\_DEFAULT: standardize differences that do not affect the text content, such as the above-mentioned accent representation \\_NORMALIZE\\_NFD: another name for G\\_NORMALIZE\\_DEFAULT \\_NORMALIZE\\_DEFAULT\\_COMPOSE: like G\\_NORMALIZE\\_DEFAULT, but with composed forms rather than a maximally decomposed form \\_NORMALIZE\\_NFC: another name for G\\_NORMALIZE\\_DEFAULT\\_COMPOSE \\_NORMALIZE\\_ALL: beyond G\\_NORMALIZE\\_DEFAULT also standardize the "compatibility" characters in Unicode, such as SUPERSCRIPT THREE to the standard forms (in this case DIGIT THREE). Formatting information may be lost but for most text operations such characters should be considered the same \\_NORMALIZE\\_NFKD: another name for G\\_NORMALIZE\\_ALL \\_NORMALIZE\\_ALL\\_COMPOSE: like G\\_NORMALIZE\\_ALL, but with composed forms rather than a maximally decomposed form \\_NORMALIZE\\_NFKC: another name for G\\_NORMALIZE\\_ALL\\_COMPOSE

Defines how a Unicode string is transformed in a canonical form, standardizing such issues as whether a character with an accent is represented as a base character and combining accent or as a single precomposed character. Unicode strings should generally be normalized before comparing them.
"""
@cenum GNormalizeMode::UInt32 begin
    G_NORMALIZE_DEFAULT = 0
    G_NORMALIZE_NFD = 0
    G_NORMALIZE_DEFAULT_COMPOSE = 1
    G_NORMALIZE_NFC = 1
    G_NORMALIZE_ALL = 2
    G_NORMALIZE_NFKD = 2
    G_NORMALIZE_ALL_COMPOSE = 3
    G_NORMALIZE_NFKC = 3
end

"""
    g_utf8_normalize(str, len, mode)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_utf8_normalize (const gchar *str, gssize len, GNormalizeMode mode) G_GNUC_MALLOC;
```
"""
function g_utf8_normalize(str, len, mode)
    @ccall libaravis.g_utf8_normalize(str::Ptr{gchar}, len::gssize, mode::GNormalizeMode)::Ptr{gchar}
end

"""
    g_utf8_collate(str1, str2)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_utf8_collate (const gchar *str1, const gchar *str2) G_GNUC_PURE;
```
"""
function g_utf8_collate(str1, str2)
    @ccall libaravis.g_utf8_collate(str1::Ptr{gchar}, str2::Ptr{gchar})::gint
end

"""
    g_utf8_collate_key(str, len)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_utf8_collate_key (const gchar *str, gssize len) G_GNUC_MALLOC;
```
"""
function g_utf8_collate_key(str, len)
    @ccall libaravis.g_utf8_collate_key(str::Ptr{gchar}, len::gssize)::Ptr{gchar}
end

"""
    g_utf8_collate_key_for_filename(str, len)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_utf8_collate_key_for_filename (const gchar *str, gssize len) G_GNUC_MALLOC;
```
"""
function g_utf8_collate_key_for_filename(str, len)
    @ccall libaravis.g_utf8_collate_key_for_filename(str::Ptr{gchar}, len::gssize)::Ptr{gchar}
end

"""
    g_utf8_make_valid(str, len)

### Prototype
```c
GLIB_AVAILABLE_IN_2_52 gchar *g_utf8_make_valid (const gchar *str, gssize len) G_GNUC_MALLOC;
```
"""
function g_utf8_make_valid(str, len)
    @ccall libaravis.g_utf8_make_valid(str::Ptr{gchar}, len::gssize)::Ptr{gchar}
end

@cenum GAsciiType::UInt32 begin
    G_ASCII_ALNUM = 1
    G_ASCII_ALPHA = 2
    G_ASCII_CNTRL = 4
    G_ASCII_DIGIT = 8
    G_ASCII_GRAPH = 16
    G_ASCII_LOWER = 32
    G_ASCII_PRINT = 64
    G_ASCII_PUNCT = 128
    G_ASCII_SPACE = 256
    G_ASCII_UPPER = 512
    G_ASCII_XDIGIT = 1024
end

"""
    g_ascii_tolower(c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar g_ascii_tolower (gchar c) G_GNUC_CONST;
```
"""
function g_ascii_tolower(c)
    @ccall libaravis.g_ascii_tolower(c::gchar)::gchar
end

"""
    g_ascii_toupper(c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar g_ascii_toupper (gchar c) G_GNUC_CONST;
```
"""
function g_ascii_toupper(c)
    @ccall libaravis.g_ascii_toupper(c::gchar)::gchar
end

"""
    g_ascii_digit_value(c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_ascii_digit_value (gchar c) G_GNUC_CONST;
```
"""
function g_ascii_digit_value(c)
    @ccall libaravis.g_ascii_digit_value(c::gchar)::gint
end

"""
    g_ascii_xdigit_value(c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_ascii_xdigit_value (gchar c) G_GNUC_CONST;
```
"""
function g_ascii_xdigit_value(c)
    @ccall libaravis.g_ascii_xdigit_value(c::gchar)::gint
end

"""
    g_strdelimit(string, delimiters, new_delimiter)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_strdelimit (gchar *string, const gchar *delimiters, gchar new_delimiter);
```
"""
function g_strdelimit(string, delimiters, new_delimiter)
    @ccall libaravis.g_strdelimit(string::Ptr{gchar}, delimiters::Ptr{gchar}, new_delimiter::gchar)::Ptr{gchar}
end

"""
    g_strcanon(string, valid_chars, substitutor)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_strcanon (gchar *string, const gchar *valid_chars, gchar substitutor);
```
"""
function g_strcanon(string, valid_chars, substitutor)
    @ccall libaravis.g_strcanon(string::Ptr{gchar}, valid_chars::Ptr{gchar}, substitutor::gchar)::Ptr{gchar}
end

"""
    g_strsignal(signum)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_strsignal (gint signum) G_GNUC_CONST;
```
"""
function g_strsignal(signum)
    @ccall libaravis.g_strsignal(signum::gint)::Ptr{gchar}
end

"""
    g_strreverse(string)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar * g_strreverse (gchar *string);
```
"""
function g_strreverse(string)
    @ccall libaravis.g_strreverse(string::Ptr{gchar})::Ptr{gchar}
end

"""
    g_strlcpy(dest, src, dest_size)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gsize g_strlcpy (gchar *dest, const gchar *src, gsize dest_size);
```
"""
function g_strlcpy(dest, src, dest_size)
    @ccall libaravis.g_strlcpy(dest::Ptr{gchar}, src::Ptr{gchar}, dest_size::gsize)::gsize
end

"""
    g_strlcat(dest, src, dest_size)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gsize g_strlcat (gchar *dest, const gchar *src, gsize dest_size);
```
"""
function g_strlcat(dest, src, dest_size)
    @ccall libaravis.g_strlcat(dest::Ptr{gchar}, src::Ptr{gchar}, dest_size::gsize)::gsize
end

"""
    g_strstr_len(haystack, haystack_len, needle)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar * g_strstr_len (const gchar *haystack, gssize haystack_len, const gchar *needle);
```
"""
function g_strstr_len(haystack, haystack_len, needle)
    @ccall libaravis.g_strstr_len(haystack::Ptr{gchar}, haystack_len::gssize, needle::Ptr{gchar})::Ptr{gchar}
end

"""
    g_strrstr(haystack, needle)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar * g_strrstr (const gchar *haystack, const gchar *needle);
```
"""
function g_strrstr(haystack, needle)
    @ccall libaravis.g_strrstr(haystack::Ptr{gchar}, needle::Ptr{gchar})::Ptr{gchar}
end

"""
    g_strrstr_len(haystack, haystack_len, needle)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar * g_strrstr_len (const gchar *haystack, gssize haystack_len, const gchar *needle);
```
"""
function g_strrstr_len(haystack, haystack_len, needle)
    @ccall libaravis.g_strrstr_len(haystack::Ptr{gchar}, haystack_len::gssize, needle::Ptr{gchar})::Ptr{gchar}
end

"""
    g_strtod(nptr, endptr)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gdouble g_strtod (const gchar *nptr, gchar **endptr);
```
"""
function g_strtod(nptr, endptr)
    @ccall libaravis.g_strtod(nptr::Ptr{gchar}, endptr::Ptr{Ptr{gchar}})::gdouble
end

"""
    g_ascii_strtod(nptr, endptr)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gdouble g_ascii_strtod (const gchar *nptr, gchar **endptr);
```
"""
function g_ascii_strtod(nptr, endptr)
    @ccall libaravis.g_ascii_strtod(nptr::Ptr{gchar}, endptr::Ptr{Ptr{gchar}})::gdouble
end

"""
    g_ascii_strtoull(nptr, endptr, base)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint64 g_ascii_strtoull (const gchar *nptr, gchar **endptr, guint base);
```
"""
function g_ascii_strtoull(nptr, endptr, base)
    @ccall libaravis.g_ascii_strtoull(nptr::Ptr{gchar}, endptr::Ptr{Ptr{gchar}}, base::guint)::guint64
end

"""
    g_ascii_strtoll(nptr, endptr, base)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint64 g_ascii_strtoll (const gchar *nptr, gchar **endptr, guint base);
```
"""
function g_ascii_strtoll(nptr, endptr, base)
    @ccall libaravis.g_ascii_strtoll(nptr::Ptr{gchar}, endptr::Ptr{Ptr{gchar}}, base::guint)::gint64
end

"""
    g_ascii_dtostr(buffer, buf_len, d)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar * g_ascii_dtostr (gchar *buffer, gint buf_len, gdouble d);
```
"""
function g_ascii_dtostr(buffer, buf_len, d)
    @ccall libaravis.g_ascii_dtostr(buffer::Ptr{gchar}, buf_len::gint, d::gdouble)::Ptr{gchar}
end

"""
    g_ascii_formatd(buffer, buf_len, format, d)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar * g_ascii_formatd (gchar *buffer, gint buf_len, const gchar *format, gdouble d);
```
"""
function g_ascii_formatd(buffer, buf_len, format, d)
    @ccall libaravis.g_ascii_formatd(buffer::Ptr{gchar}, buf_len::gint, format::Ptr{gchar}, d::gdouble)::Ptr{gchar}
end

"""
    g_ascii_strcasecmp(s1, s2)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_ascii_strcasecmp (const gchar *s1, const gchar *s2);
```
"""
function g_ascii_strcasecmp(s1, s2)
    @ccall libaravis.g_ascii_strcasecmp(s1::Ptr{gchar}, s2::Ptr{gchar})::gint
end

"""
    g_ascii_strncasecmp(s1, s2, n)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_ascii_strncasecmp (const gchar *s1, const gchar *s2, gsize n);
```
"""
function g_ascii_strncasecmp(s1, s2, n)
    @ccall libaravis.g_ascii_strncasecmp(s1::Ptr{gchar}, s2::Ptr{gchar}, n::gsize)::gint
end

"""
    g_ascii_strdown(str, len)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_ascii_strdown (const gchar *str, gssize len) G_GNUC_MALLOC;
```
"""
function g_ascii_strdown(str, len)
    @ccall libaravis.g_ascii_strdown(str::Ptr{gchar}, len::gssize)::Ptr{gchar}
end

"""
    g_ascii_strup(str, len)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_ascii_strup (const gchar *str, gssize len) G_GNUC_MALLOC;
```
"""
function g_ascii_strup(str, len)
    @ccall libaravis.g_ascii_strup(str::Ptr{gchar}, len::gssize)::Ptr{gchar}
end

"""
    g_str_is_ascii(str)

### Prototype
```c
GLIB_AVAILABLE_IN_2_40 gboolean g_str_is_ascii (const gchar *str);
```
"""
function g_str_is_ascii(str)
    @ccall libaravis.g_str_is_ascii(str::Ptr{gchar})::gboolean
end

"""
    g_strcasecmp(s1, s2)

### Prototype
```c
GLIB_DEPRECATED gint g_strcasecmp (const gchar *s1, const gchar *s2);
```
"""
function g_strcasecmp(s1, s2)
    @ccall libaravis.g_strcasecmp(s1::Ptr{gchar}, s2::Ptr{gchar})::gint
end

"""
    g_strncasecmp(s1, s2, n)

### Prototype
```c
GLIB_DEPRECATED gint g_strncasecmp (const gchar *s1, const gchar *s2, guint n);
```
"""
function g_strncasecmp(s1, s2, n)
    @ccall libaravis.g_strncasecmp(s1::Ptr{gchar}, s2::Ptr{gchar}, n::guint)::gint
end

"""
    g_strdown(string)

### Prototype
```c
GLIB_DEPRECATED gchar* g_strdown (gchar *string);
```
"""
function g_strdown(string)
    @ccall libaravis.g_strdown(string::Ptr{gchar})::Ptr{gchar}
end

"""
    g_strup(string)

### Prototype
```c
GLIB_DEPRECATED gchar* g_strup (gchar *string);
```
"""
function g_strup(string)
    @ccall libaravis.g_strup(string::Ptr{gchar})::Ptr{gchar}
end

"""
    g_strndup(str, n)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_strndup (const gchar *str, gsize n) G_GNUC_MALLOC;
```
"""
function g_strndup(str, n)
    @ccall libaravis.g_strndup(str::Ptr{gchar}, n::gsize)::Ptr{gchar}
end

"""
    g_strnfill(length, fill_char)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_strnfill (gsize length, gchar fill_char) G_GNUC_MALLOC;
```
"""
function g_strnfill(length, fill_char)
    @ccall libaravis.g_strnfill(length::gsize, fill_char::gchar)::Ptr{gchar}
end

"""
    g_strcompress(source)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_strcompress (const gchar *source) G_GNUC_MALLOC;
```
"""
function g_strcompress(source)
    @ccall libaravis.g_strcompress(source::Ptr{gchar})::Ptr{gchar}
end

"""
    g_strescape(source, exceptions)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_strescape (const gchar *source, const gchar *exceptions) G_GNUC_MALLOC;
```
"""
function g_strescape(source, exceptions)
    @ccall libaravis.g_strescape(source::Ptr{gchar}, exceptions::Ptr{gchar})::Ptr{gchar}
end

"""
    g_memdup(mem, byte_size)

### Prototype
```c
GLIB_DEPRECATED_IN_2_68_FOR (g_memdup2) gpointer g_memdup (gconstpointer mem, guint byte_size) G_GNUC_ALLOC_SIZE(2);
```
"""
function g_memdup(mem, byte_size)
    @ccall libaravis.g_memdup(mem::gconstpointer, byte_size::guint)::gpointer
end

"""
    g_memdup2(mem, byte_size)

### Prototype
```c
GLIB_AVAILABLE_IN_2_68 gpointer g_memdup2 (gconstpointer mem, gsize byte_size) G_GNUC_ALLOC_SIZE(2);
```
"""
function g_memdup2(mem, byte_size)
    @ccall libaravis.g_memdup2(mem::gconstpointer, byte_size::gsize)::gpointer
end

const GStrv = Ptr{Ptr{gchar}}

"""
    g_strsplit(string, delimiter, max_tokens)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar** g_strsplit (const gchar *string, const gchar *delimiter, gint max_tokens);
```
"""
function g_strsplit(string, delimiter, max_tokens)
    @ccall libaravis.g_strsplit(string::Ptr{gchar}, delimiter::Ptr{gchar}, max_tokens::gint)::Ptr{Ptr{gchar}}
end

"""
    g_strsplit_set(string, delimiters, max_tokens)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar ** g_strsplit_set (const gchar *string, const gchar *delimiters, gint max_tokens);
```
"""
function g_strsplit_set(string, delimiters, max_tokens)
    @ccall libaravis.g_strsplit_set(string::Ptr{gchar}, delimiters::Ptr{gchar}, max_tokens::gint)::Ptr{Ptr{gchar}}
end

"""
    g_strjoinv(separator, str_array)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_strjoinv (const gchar *separator, gchar **str_array) G_GNUC_MALLOC;
```
"""
function g_strjoinv(separator, str_array)
    @ccall libaravis.g_strjoinv(separator::Ptr{gchar}, str_array::Ptr{Ptr{gchar}})::Ptr{gchar}
end

"""
    g_strfreev(str_array)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_strfreev (gchar **str_array);
```
"""
function g_strfreev(str_array)
    @ccall libaravis.g_strfreev(str_array::Ptr{Ptr{gchar}})::Cvoid
end

"""
    g_strdupv(str_array)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar** g_strdupv (gchar **str_array);
```
"""
function g_strdupv(str_array)
    @ccall libaravis.g_strdupv(str_array::Ptr{Ptr{gchar}})::Ptr{Ptr{gchar}}
end

"""
    g_stpcpy(dest, src)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_stpcpy (gchar *dest, const char *src);
```
"""
function g_stpcpy(dest, src)
    @ccall libaravis.g_stpcpy(dest::Ptr{gchar}, src::Cstring)::Ptr{gchar}
end

"""
    g_str_to_ascii(str, from_locale)

### Prototype
```c
GLIB_AVAILABLE_IN_2_40 gchar * g_str_to_ascii (const gchar *str, const gchar *from_locale);
```
"""
function g_str_to_ascii(str, from_locale)
    @ccall libaravis.g_str_to_ascii(str::Ptr{gchar}, from_locale::Ptr{gchar})::Ptr{gchar}
end

"""
    g_str_tokenize_and_fold(string, translit_locale, ascii_alternates)

### Prototype
```c
GLIB_AVAILABLE_IN_2_40 gchar ** g_str_tokenize_and_fold (const gchar *string, const gchar *translit_locale, gchar ***ascii_alternates);
```
"""
function g_str_tokenize_and_fold(string, translit_locale, ascii_alternates)
    @ccall libaravis.g_str_tokenize_and_fold(string::Ptr{gchar}, translit_locale::Ptr{gchar}, ascii_alternates::Ptr{Ptr{Ptr{gchar}}})::Ptr{Ptr{gchar}}
end

"""
    g_str_match_string(search_term, potential_hit, accept_alternates)

### Prototype
```c
GLIB_AVAILABLE_IN_2_40 gboolean g_str_match_string (const gchar *search_term, const gchar *potential_hit, gboolean accept_alternates);
```
"""
function g_str_match_string(search_term, potential_hit, accept_alternates)
    @ccall libaravis.g_str_match_string(search_term::Ptr{gchar}, potential_hit::Ptr{gchar}, accept_alternates::gboolean)::gboolean
end

"""
    g_strv_contains(strv, str)

### Prototype
```c
GLIB_AVAILABLE_IN_2_44 gboolean g_strv_contains (const gchar * const *strv, const gchar *str);
```
"""
function g_strv_contains(strv, str)
    @ccall libaravis.g_strv_contains(strv::Ptr{Ptr{gchar}}, str::Ptr{gchar})::gboolean
end

"""
    g_strv_equal(strv1, strv2)

### Prototype
```c
GLIB_AVAILABLE_IN_2_60 gboolean g_strv_equal (const gchar * const *strv1, const gchar * const *strv2);
```
"""
function g_strv_equal(strv1, strv2)
    @ccall libaravis.g_strv_equal(strv1::Ptr{Ptr{gchar}}, strv2::Ptr{Ptr{gchar}})::gboolean
end

"""
    GNumberParserError

[`GNumberParserError`](@ref): \\_NUMBER\\_PARSER\\_ERROR\\_INVALID: string was not a valid number \\_NUMBER\\_PARSER\\_ERROR\\_OUT\\_OF\\_BOUNDS: string was a number, but out of bounds

Error codes returned by functions converting a string to a number.

Since: 2.54
"""
@cenum GNumberParserError::UInt32 begin
    G_NUMBER_PARSER_ERROR_INVALID = 0
    G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS = 1
end

"""
    g_ascii_string_to_signed(str, base, min, max, out_num, error)

### Prototype
```c
GLIB_AVAILABLE_IN_2_54 gboolean g_ascii_string_to_signed (const gchar *str, guint base, gint64 min, gint64 max, gint64 *out_num, GError **error);
```
"""
function g_ascii_string_to_signed(str, base, min, max, out_num, error)
    @ccall libaravis.g_ascii_string_to_signed(str::Ptr{gchar}, base::guint, min::gint64, max::gint64, out_num::Ptr{gint64}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_ascii_string_to_unsigned(str, base, min, max, out_num, error)

### Prototype
```c
GLIB_AVAILABLE_IN_2_54 gboolean g_ascii_string_to_unsigned (const gchar *str, guint base, guint64 min, guint64 max, guint64 *out_num, GError **error);
```
"""
function g_ascii_string_to_unsigned(str, base, min, max, out_num, error)
    @ccall libaravis.g_ascii_string_to_unsigned(str::Ptr{gchar}, base::guint, min::guint64, max::guint64, out_num::Ptr{guint64}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_set_str(str_pointer, new_str)

[`g_set_str`](@ref): (skip) \\_pointer: (inout) (not optional) (nullable): a pointer to either a string or `NULL` \\_str: (nullable): a string to assign to \\_pointer

Updates a pointer to a string to a copy of \\_str and returns whether the string was changed.

If \\_str matches the previous string, this function is a no-op. If \\_str is different, a copy of it will be assigned to \\_pointer and the previous string pointed to by \\_pointer will be freed with [func.free].

\\_pointer must not be `NULL`, but can point to a `NULL` value.

One convenient usage of this function is in implementing property settings: ```C void foo\\_set\\_bar (Foo *foo, const char *new\\_bar) { [`g_return_if_fail`](@ref) (IS\\_FOO (foo));

if ([`g_set_str`](@ref) (&foo->bar, new\\_bar)) [`g_object_notify`](@ref) (foo, "bar"); } ```

Returns: true if the value of \\_pointer changed, false otherwise

Since: 2.76

### Prototype
```c
static inline gboolean g_set_str (char **str_pointer, const char *new_str);
```
"""
function g_set_str(str_pointer, new_str)
    @ccall libaravis.g_set_str(str_pointer::Ptr{Cstring}, new_str::Cstring)::gboolean
end

"""
    g_string_new(init)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GString* g_string_new (const gchar *init);
```
"""
function g_string_new(init)
    @ccall libaravis.g_string_new(init::Ptr{gchar})::Ptr{GString}
end

"""
    g_string_new_take(init)

### Prototype
```c
GLIB_AVAILABLE_IN_2_78 GString* g_string_new_take (gchar *init);
```
"""
function g_string_new_take(init)
    @ccall libaravis.g_string_new_take(init::Ptr{gchar})::Ptr{GString}
end

"""
    g_string_new_len(init, len)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GString* g_string_new_len (const gchar *init, gssize len);
```
"""
function g_string_new_len(init, len)
    @ccall libaravis.g_string_new_len(init::Ptr{gchar}, len::gssize)::Ptr{GString}
end

"""
    g_string_sized_new(dfl_size)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GString* g_string_sized_new (gsize dfl_size);
```
"""
function g_string_sized_new(dfl_size)
    @ccall libaravis.g_string_sized_new(dfl_size::gsize)::Ptr{GString}
end

"""
    g_string_copy(string)

### Prototype
```c
GLIB_AVAILABLE_IN_2_86 GString *g_string_copy (GString *string);
```
"""
function g_string_copy(string)
    @ccall libaravis.g_string_copy(string::Ptr{GString})::Ptr{GString}
end

"""
    g_string_free_to_bytes(string)

### Prototype
```c
GLIB_AVAILABLE_IN_2_34 GBytes* g_string_free_to_bytes (GString *string);
```
"""
function g_string_free_to_bytes(string)
    @ccall libaravis.g_string_free_to_bytes(string::Ptr{GString})::Ptr{GBytes}
end

"""
    g_string_equal(v, v2)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_string_equal (const GString *v, const GString *v2);
```
"""
function g_string_equal(v, v2)
    @ccall libaravis.g_string_equal(v::Ptr{GString}, v2::Ptr{GString})::gboolean
end

"""
    g_string_hash(str)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_string_hash (const GString *str);
```
"""
function g_string_hash(str)
    @ccall libaravis.g_string_hash(str::Ptr{GString})::guint
end

"""
    g_string_assign(string, rval)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GString* g_string_assign (GString *string, const gchar *rval);
```
"""
function g_string_assign(string, rval)
    @ccall libaravis.g_string_assign(string::Ptr{GString}, rval::Ptr{gchar})::Ptr{GString}
end

"""
    g_string_set_size(string, len)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GString* g_string_set_size (GString *string, gsize len);
```
"""
function g_string_set_size(string, len)
    @ccall libaravis.g_string_set_size(string::Ptr{GString}, len::gsize)::Ptr{GString}
end

"""
    g_string_insert_len(string, pos, val, len)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GString* g_string_insert_len (GString *string, gssize pos, const gchar *val, gssize len);
```
"""
function g_string_insert_len(string, pos, val, len)
    @ccall libaravis.g_string_insert_len(string::Ptr{GString}, pos::gssize, val::Ptr{gchar}, len::gssize)::Ptr{GString}
end

"""
    g_string_append_unichar(string, wc)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GString* g_string_append_unichar (GString *string, gunichar wc);
```
"""
function g_string_append_unichar(string, wc)
    @ccall libaravis.g_string_append_unichar(string::Ptr{GString}, wc::gunichar)::Ptr{GString}
end

"""
    g_string_prepend(string, val)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GString* g_string_prepend (GString *string, const gchar *val);
```
"""
function g_string_prepend(string, val)
    @ccall libaravis.g_string_prepend(string::Ptr{GString}, val::Ptr{gchar})::Ptr{GString}
end

"""
    g_string_prepend_c(string, c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GString* g_string_prepend_c (GString *string, gchar c);
```
"""
function g_string_prepend_c(string, c)
    @ccall libaravis.g_string_prepend_c(string::Ptr{GString}, c::gchar)::Ptr{GString}
end

"""
    g_string_prepend_unichar(string, wc)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GString* g_string_prepend_unichar (GString *string, gunichar wc);
```
"""
function g_string_prepend_unichar(string, wc)
    @ccall libaravis.g_string_prepend_unichar(string::Ptr{GString}, wc::gunichar)::Ptr{GString}
end

"""
    g_string_prepend_len(string, val, len)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GString* g_string_prepend_len (GString *string, const gchar *val, gssize len);
```
"""
function g_string_prepend_len(string, val, len)
    @ccall libaravis.g_string_prepend_len(string::Ptr{GString}, val::Ptr{gchar}, len::gssize)::Ptr{GString}
end

"""
    g_string_insert(string, pos, val)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GString* g_string_insert (GString *string, gssize pos, const gchar *val);
```
"""
function g_string_insert(string, pos, val)
    @ccall libaravis.g_string_insert(string::Ptr{GString}, pos::gssize, val::Ptr{gchar})::Ptr{GString}
end

"""
    g_string_insert_c(string, pos, c)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GString* g_string_insert_c (GString *string, gssize pos, gchar c);
```
"""
function g_string_insert_c(string, pos, c)
    @ccall libaravis.g_string_insert_c(string::Ptr{GString}, pos::gssize, c::gchar)::Ptr{GString}
end

"""
    g_string_insert_unichar(string, pos, wc)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GString* g_string_insert_unichar (GString *string, gssize pos, gunichar wc);
```
"""
function g_string_insert_unichar(string, pos, wc)
    @ccall libaravis.g_string_insert_unichar(string::Ptr{GString}, pos::gssize, wc::gunichar)::Ptr{GString}
end

"""
    g_string_overwrite(string, pos, val)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GString* g_string_overwrite (GString *string, gsize pos, const gchar *val);
```
"""
function g_string_overwrite(string, pos, val)
    @ccall libaravis.g_string_overwrite(string::Ptr{GString}, pos::gsize, val::Ptr{gchar})::Ptr{GString}
end

"""
    g_string_overwrite_len(string, pos, val, len)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GString* g_string_overwrite_len (GString *string, gsize pos, const gchar *val, gssize len);
```
"""
function g_string_overwrite_len(string, pos, val, len)
    @ccall libaravis.g_string_overwrite_len(string::Ptr{GString}, pos::gsize, val::Ptr{gchar}, len::gssize)::Ptr{GString}
end

"""
    g_string_erase(string, pos, len)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GString* g_string_erase (GString *string, gssize pos, gssize len);
```
"""
function g_string_erase(string, pos, len)
    @ccall libaravis.g_string_erase(string::Ptr{GString}, pos::gssize, len::gssize)::Ptr{GString}
end

"""
    g_string_replace(string, find, replace, limit)

### Prototype
```c
GLIB_AVAILABLE_IN_2_68 guint g_string_replace (GString *string, const gchar *find, const gchar *replace, guint limit);
```
"""
function g_string_replace(string, find, replace, limit)
    @ccall libaravis.g_string_replace(string::Ptr{GString}, find::Ptr{gchar}, replace::Ptr{gchar}, limit::guint)::guint
end

"""
    g_string_ascii_down(string)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GString* g_string_ascii_down (GString *string);
```
"""
function g_string_ascii_down(string)
    @ccall libaravis.g_string_ascii_down(string::Ptr{GString})::Ptr{GString}
end

"""
    g_string_ascii_up(string)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GString* g_string_ascii_up (GString *string);
```
"""
function g_string_ascii_up(string)
    @ccall libaravis.g_string_ascii_up(string::Ptr{GString})::Ptr{GString}
end

"""
    g_string_append_uri_escaped(string, unescaped, reserved_chars_allowed, allow_utf8)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GString* g_string_append_uri_escaped (GString *string, const gchar *unescaped, const gchar *reserved_chars_allowed, gboolean allow_utf8);
```
"""
function g_string_append_uri_escaped(string, unescaped, reserved_chars_allowed, allow_utf8)
    @ccall libaravis.g_string_append_uri_escaped(string::Ptr{GString}, unescaped::Ptr{gchar}, reserved_chars_allowed::Ptr{gchar}, allow_utf8::gboolean)::Ptr{GString}
end

"""
    g_string_down(string)

### Prototype
```c
GLIB_DEPRECATED GString *g_string_down (GString *string);
```
"""
function g_string_down(string)
    @ccall libaravis.g_string_down(string::Ptr{GString})::Ptr{GString}
end

"""
    g_string_up(string)

### Prototype
```c
GLIB_DEPRECATED GString *g_string_up (GString *string);
```
"""
function g_string_up(string)
    @ccall libaravis.g_string_up(string::Ptr{GString})::Ptr{GString}
end

struct _GIOFuncs
    io_read::Ptr{Cvoid}
    io_write::Ptr{Cvoid}
    io_seek::Ptr{Cvoid}
    io_close::Ptr{Cvoid}
    io_create_watch::Ptr{Cvoid}
    io_free::Ptr{Cvoid}
    io_set_flags::Ptr{Cvoid}
    io_get_flags::Ptr{Cvoid}
end

const GIOFuncs = _GIOFuncs

struct _GIOChannel
    data::NTuple{112, UInt8}
end

function Base.getproperty(x::Ptr{_GIOChannel}, f::Symbol)
    f === :ref_count && return Ptr{gint}(x + 0)
    f === :funcs && return Ptr{Ptr{GIOFuncs}}(x + 8)
    f === :encoding && return Ptr{Ptr{gchar}}(x + 16)
    f === :read_cd && return Ptr{GIConv}(x + 24)
    f === :write_cd && return Ptr{GIConv}(x + 32)
    f === :line_term && return Ptr{Ptr{gchar}}(x + 40)
    f === :line_term_len && return Ptr{guint}(x + 48)
    f === :buf_size && return Ptr{gsize}(x + 56)
    f === :read_buf && return Ptr{Ptr{GString}}(x + 64)
    f === :encoded_read_buf && return Ptr{Ptr{GString}}(x + 72)
    f === :write_buf && return Ptr{Ptr{GString}}(x + 80)
    f === :partial_write_buf && return Ptr{NTuple{6, gchar}}(x + 88)
    f === :use_buffer && return (Ptr{guint}(x + 92), 16, 1)
    f === :do_encode && return (Ptr{guint}(x + 92), 17, 1)
    f === :close_on_unref && return (Ptr{guint}(x + 92), 18, 1)
    f === :is_readable && return (Ptr{guint}(x + 92), 19, 1)
    f === :is_writeable && return (Ptr{guint}(x + 92), 20, 1)
    f === :is_seekable && return (Ptr{guint}(x + 92), 21, 1)
    f === :reserved1 && return Ptr{gpointer}(x + 96)
    f === :reserved2 && return Ptr{gpointer}(x + 104)
    return getfield(x, f)
end

function Base.getproperty(x::_GIOChannel, f::Symbol)
    r = Ref{_GIOChannel}(x)
    ptr = Base.unsafe_convert(Ptr{_GIOChannel}, r)
    fptr = getproperty(ptr, f)
    begin
        if fptr isa Ptr
            return GC.@preserve(r, unsafe_load(fptr))
        else
            (baseptr, offset, width) = fptr
            ty = eltype(baseptr)
            baseptr32 = convert(Ptr{UInt32}, baseptr)
            u64 = GC.@preserve(r, unsafe_load(baseptr32))
            if offset + width > 32
                u64 |= GC.@preserve(r, unsafe_load(baseptr32 + 4)) << 32
            end
            u64 = u64 >> offset & (1 << width - 1)
            return u64 % ty
        end
    end
end

function Base.setproperty!(x::Ptr{_GIOChannel}, f::Symbol, v)
    fptr = getproperty(x, f)
    if fptr isa Ptr
        unsafe_store!(getproperty(x, f), v)
    else
        (baseptr, offset, width) = fptr
        baseptr32 = convert(Ptr{UInt32}, baseptr)
        u64 = unsafe_load(baseptr32)
        straddle = offset + width > 32
        if straddle
            u64 |= unsafe_load(baseptr32 + 4) << 32
        end
        mask = 1 << width - 1
        u64 &= ~(mask << offset)
        u64 |= (unsigned(v) & mask) << offset
        unsafe_store!(baseptr32, u64 & typemax(UInt32))
        if straddle
            unsafe_store!(baseptr32 + 4, u64 >> 32)
        end
    end
end

function Base.propertynames(x::_GIOChannel, private::Bool = false)
    (:ref_count, :funcs, :encoding, :read_cd, :write_cd, :line_term, :line_term_len, :buf_size, :read_buf, :encoded_read_buf, :write_buf, :partial_write_buf, :use_buffer, :do_encode, :close_on_unref, :is_readable, :is_writeable, :is_seekable, :reserved1, :reserved2, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

const GIOChannel = _GIOChannel

@cenum GIOError::UInt32 begin
    G_IO_ERROR_NONE = 0
    G_IO_ERROR_AGAIN = 1
    G_IO_ERROR_INVAL = 2
    G_IO_ERROR_UNKNOWN = 3
end

@cenum GIOChannelError::UInt32 begin
    G_IO_CHANNEL_ERROR_FBIG = 0
    G_IO_CHANNEL_ERROR_INVAL = 1
    G_IO_CHANNEL_ERROR_IO = 2
    G_IO_CHANNEL_ERROR_ISDIR = 3
    G_IO_CHANNEL_ERROR_NOSPC = 4
    G_IO_CHANNEL_ERROR_NXIO = 5
    G_IO_CHANNEL_ERROR_OVERFLOW = 6
    G_IO_CHANNEL_ERROR_PIPE = 7
    G_IO_CHANNEL_ERROR_FAILED = 8
end

@cenum GIOStatus::UInt32 begin
    G_IO_STATUS_ERROR = 0
    G_IO_STATUS_NORMAL = 1
    G_IO_STATUS_EOF = 2
    G_IO_STATUS_AGAIN = 3
end

@cenum GSeekType::UInt32 begin
    G_SEEK_CUR = 0
    G_SEEK_SET = 1
    G_SEEK_END = 2
end

@cenum GIOFlags::UInt32 begin
    G_IO_FLAG_NONE = 0
    G_IO_FLAG_APPEND = 1
    G_IO_FLAG_NONBLOCK = 2
    G_IO_FLAG_IS_READABLE = 4
    G_IO_FLAG_IS_WRITABLE = 8
    G_IO_FLAG_IS_WRITEABLE = 8
    G_IO_FLAG_IS_SEEKABLE = 16
    G_IO_FLAG_MASK = 31
    G_IO_FLAG_GET_MASK = 31
    G_IO_FLAG_SET_MASK = 3
end

# typedef gboolean ( * GIOFunc ) ( GIOChannel * source , GIOCondition condition , gpointer data )
const GIOFunc = Ptr{Cvoid}

"""
    g_io_channel_init(channel)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_io_channel_init (GIOChannel *channel);
```
"""
function g_io_channel_init(channel)
    @ccall libaravis.g_io_channel_init(channel::Ptr{GIOChannel})::Cvoid
end

"""
    g_io_channel_ref(channel)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GIOChannel *g_io_channel_ref (GIOChannel *channel);
```
"""
function g_io_channel_ref(channel)
    @ccall libaravis.g_io_channel_ref(channel::Ptr{GIOChannel})::Ptr{GIOChannel}
end

"""
    g_io_channel_unref(channel)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_io_channel_unref (GIOChannel *channel);
```
"""
function g_io_channel_unref(channel)
    @ccall libaravis.g_io_channel_unref(channel::Ptr{GIOChannel})::Cvoid
end

"""
    g_io_channel_read(channel, buf, count, bytes_read)

### Prototype
```c
GLIB_DEPRECATED_FOR(g_io_channel_read_chars) GIOError g_io_channel_read (GIOChannel *channel, gchar *buf, gsize count, gsize *bytes_read);
```
"""
function g_io_channel_read(channel, buf, count, bytes_read)
    @ccall libaravis.g_io_channel_read(channel::Ptr{GIOChannel}, buf::Ptr{gchar}, count::gsize, bytes_read::Ptr{gsize})::GIOError
end

"""
    g_io_channel_write(channel, buf, count, bytes_written)

### Prototype
```c
GLIB_DEPRECATED_FOR(g_io_channel_write_chars) GIOError g_io_channel_write (GIOChannel *channel, const gchar *buf, gsize count, gsize *bytes_written);
```
"""
function g_io_channel_write(channel, buf, count, bytes_written)
    @ccall libaravis.g_io_channel_write(channel::Ptr{GIOChannel}, buf::Ptr{gchar}, count::gsize, bytes_written::Ptr{gsize})::GIOError
end

"""
    g_io_channel_seek(channel, offset, type)

### Prototype
```c
GLIB_DEPRECATED_FOR(g_io_channel_seek_position) GIOError g_io_channel_seek (GIOChannel *channel, gint64 offset, GSeekType type);
```
"""
function g_io_channel_seek(channel, offset, type)
    @ccall libaravis.g_io_channel_seek(channel::Ptr{GIOChannel}, offset::gint64, type::GSeekType)::GIOError
end

"""
    g_io_channel_close(channel)

### Prototype
```c
GLIB_DEPRECATED_FOR(g_io_channel_shutdown) void g_io_channel_close (GIOChannel *channel);
```
"""
function g_io_channel_close(channel)
    @ccall libaravis.g_io_channel_close(channel::Ptr{GIOChannel})::Cvoid
end

"""
    g_io_channel_shutdown(channel, flush, err)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GIOStatus g_io_channel_shutdown (GIOChannel *channel, gboolean flush, GError **err);
```
"""
function g_io_channel_shutdown(channel, flush, err)
    @ccall libaravis.g_io_channel_shutdown(channel::Ptr{GIOChannel}, flush::gboolean, err::Ptr{Ptr{GError}})::GIOStatus
end

"""
    g_io_add_watch_full(channel, priority, condition, func, user_data, notify)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_io_add_watch_full (GIOChannel *channel, gint priority, GIOCondition condition, GIOFunc func, gpointer user_data, GDestroyNotify notify);
```
"""
function g_io_add_watch_full(channel, priority, condition, func, user_data, notify)
    @ccall libaravis.g_io_add_watch_full(channel::Ptr{GIOChannel}, priority::gint, condition::GIOCondition, func::GIOFunc, user_data::gpointer, notify::GDestroyNotify)::guint
end

"""
    g_io_create_watch(channel, condition)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSource * g_io_create_watch (GIOChannel *channel, GIOCondition condition);
```
"""
function g_io_create_watch(channel, condition)
    @ccall libaravis.g_io_create_watch(channel::Ptr{GIOChannel}, condition::GIOCondition)::Ptr{GSource}
end

"""
    g_io_add_watch(channel, condition, func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_io_add_watch (GIOChannel *channel, GIOCondition condition, GIOFunc func, gpointer user_data);
```
"""
function g_io_add_watch(channel, condition, func, user_data)
    @ccall libaravis.g_io_add_watch(channel::Ptr{GIOChannel}, condition::GIOCondition, func::GIOFunc, user_data::gpointer)::guint
end

"""
    g_io_channel_set_buffer_size(channel, size)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_io_channel_set_buffer_size (GIOChannel *channel, gsize size);
```
"""
function g_io_channel_set_buffer_size(channel, size)
    @ccall libaravis.g_io_channel_set_buffer_size(channel::Ptr{GIOChannel}, size::gsize)::Cvoid
end

"""
    g_io_channel_get_buffer_size(channel)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gsize g_io_channel_get_buffer_size (GIOChannel *channel);
```
"""
function g_io_channel_get_buffer_size(channel)
    @ccall libaravis.g_io_channel_get_buffer_size(channel::Ptr{GIOChannel})::gsize
end

"""
    g_io_channel_get_buffer_condition(channel)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GIOCondition g_io_channel_get_buffer_condition (GIOChannel *channel);
```
"""
function g_io_channel_get_buffer_condition(channel)
    @ccall libaravis.g_io_channel_get_buffer_condition(channel::Ptr{GIOChannel})::GIOCondition
end

"""
    g_io_channel_set_flags(channel, flags, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GIOStatus g_io_channel_set_flags (GIOChannel *channel, GIOFlags flags, GError **error);
```
"""
function g_io_channel_set_flags(channel, flags, error)
    @ccall libaravis.g_io_channel_set_flags(channel::Ptr{GIOChannel}, flags::GIOFlags, error::Ptr{Ptr{GError}})::GIOStatus
end

"""
    g_io_channel_get_flags(channel)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GIOFlags g_io_channel_get_flags (GIOChannel *channel);
```
"""
function g_io_channel_get_flags(channel)
    @ccall libaravis.g_io_channel_get_flags(channel::Ptr{GIOChannel})::GIOFlags
end

"""
    g_io_channel_set_line_term(channel, line_term, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_io_channel_set_line_term (GIOChannel *channel, const gchar *line_term, gint length);
```
"""
function g_io_channel_set_line_term(channel, line_term, length)
    @ccall libaravis.g_io_channel_set_line_term(channel::Ptr{GIOChannel}, line_term::Ptr{gchar}, length::gint)::Cvoid
end

"""
    g_io_channel_get_line_term(channel, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_io_channel_get_line_term (GIOChannel *channel, gint *length);
```
"""
function g_io_channel_get_line_term(channel, length)
    @ccall libaravis.g_io_channel_get_line_term(channel::Ptr{GIOChannel}, length::Ptr{gint})::Ptr{gchar}
end

"""
    g_io_channel_set_buffered(channel, buffered)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_io_channel_set_buffered (GIOChannel *channel, gboolean buffered);
```
"""
function g_io_channel_set_buffered(channel, buffered)
    @ccall libaravis.g_io_channel_set_buffered(channel::Ptr{GIOChannel}, buffered::gboolean)::Cvoid
end

"""
    g_io_channel_get_buffered(channel)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_io_channel_get_buffered (GIOChannel *channel);
```
"""
function g_io_channel_get_buffered(channel)
    @ccall libaravis.g_io_channel_get_buffered(channel::Ptr{GIOChannel})::gboolean
end

"""
    g_io_channel_set_encoding(channel, encoding, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GIOStatus g_io_channel_set_encoding (GIOChannel *channel, const gchar *encoding, GError **error);
```
"""
function g_io_channel_set_encoding(channel, encoding, error)
    @ccall libaravis.g_io_channel_set_encoding(channel::Ptr{GIOChannel}, encoding::Ptr{gchar}, error::Ptr{Ptr{GError}})::GIOStatus
end

"""
    g_io_channel_get_encoding(channel)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_io_channel_get_encoding (GIOChannel *channel);
```
"""
function g_io_channel_get_encoding(channel)
    @ccall libaravis.g_io_channel_get_encoding(channel::Ptr{GIOChannel})::Ptr{gchar}
end

"""
    g_io_channel_set_close_on_unref(channel, do_close)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_io_channel_set_close_on_unref (GIOChannel *channel, gboolean do_close);
```
"""
function g_io_channel_set_close_on_unref(channel, do_close)
    @ccall libaravis.g_io_channel_set_close_on_unref(channel::Ptr{GIOChannel}, do_close::gboolean)::Cvoid
end

"""
    g_io_channel_get_close_on_unref(channel)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_io_channel_get_close_on_unref (GIOChannel *channel);
```
"""
function g_io_channel_get_close_on_unref(channel)
    @ccall libaravis.g_io_channel_get_close_on_unref(channel::Ptr{GIOChannel})::gboolean
end

"""
    g_io_channel_flush(channel, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GIOStatus g_io_channel_flush (GIOChannel *channel, GError **error);
```
"""
function g_io_channel_flush(channel, error)
    @ccall libaravis.g_io_channel_flush(channel::Ptr{GIOChannel}, error::Ptr{Ptr{GError}})::GIOStatus
end

"""
    g_io_channel_read_line(channel, str_return, length, terminator_pos, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GIOStatus g_io_channel_read_line (GIOChannel *channel, gchar **str_return, gsize *length, gsize *terminator_pos, GError **error);
```
"""
function g_io_channel_read_line(channel, str_return, length, terminator_pos, error)
    @ccall libaravis.g_io_channel_read_line(channel::Ptr{GIOChannel}, str_return::Ptr{Ptr{gchar}}, length::Ptr{gsize}, terminator_pos::Ptr{gsize}, error::Ptr{Ptr{GError}})::GIOStatus
end

"""
    g_io_channel_read_line_string(channel, buffer, terminator_pos, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GIOStatus g_io_channel_read_line_string (GIOChannel *channel, GString *buffer, gsize *terminator_pos, GError **error);
```
"""
function g_io_channel_read_line_string(channel, buffer, terminator_pos, error)
    @ccall libaravis.g_io_channel_read_line_string(channel::Ptr{GIOChannel}, buffer::Ptr{GString}, terminator_pos::Ptr{gsize}, error::Ptr{Ptr{GError}})::GIOStatus
end

"""
    g_io_channel_read_to_end(channel, str_return, length, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GIOStatus g_io_channel_read_to_end (GIOChannel *channel, gchar **str_return, gsize *length, GError **error);
```
"""
function g_io_channel_read_to_end(channel, str_return, length, error)
    @ccall libaravis.g_io_channel_read_to_end(channel::Ptr{GIOChannel}, str_return::Ptr{Ptr{gchar}}, length::Ptr{gsize}, error::Ptr{Ptr{GError}})::GIOStatus
end

"""
    g_io_channel_read_chars(channel, buf, count, bytes_read, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GIOStatus g_io_channel_read_chars (GIOChannel *channel, gchar *buf, gsize count, gsize *bytes_read, GError **error);
```
"""
function g_io_channel_read_chars(channel, buf, count, bytes_read, error)
    @ccall libaravis.g_io_channel_read_chars(channel::Ptr{GIOChannel}, buf::Ptr{gchar}, count::gsize, bytes_read::Ptr{gsize}, error::Ptr{Ptr{GError}})::GIOStatus
end

"""
    g_io_channel_read_unichar(channel, thechar, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GIOStatus g_io_channel_read_unichar (GIOChannel *channel, gunichar *thechar, GError **error);
```
"""
function g_io_channel_read_unichar(channel, thechar, error)
    @ccall libaravis.g_io_channel_read_unichar(channel::Ptr{GIOChannel}, thechar::Ptr{gunichar}, error::Ptr{Ptr{GError}})::GIOStatus
end

"""
    g_io_channel_write_chars(channel, buf, count, bytes_written, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GIOStatus g_io_channel_write_chars (GIOChannel *channel, const gchar *buf, gssize count, gsize *bytes_written, GError **error);
```
"""
function g_io_channel_write_chars(channel, buf, count, bytes_written, error)
    @ccall libaravis.g_io_channel_write_chars(channel::Ptr{GIOChannel}, buf::Ptr{gchar}, count::gssize, bytes_written::Ptr{gsize}, error::Ptr{Ptr{GError}})::GIOStatus
end

"""
    g_io_channel_write_unichar(channel, thechar, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GIOStatus g_io_channel_write_unichar (GIOChannel *channel, gunichar thechar, GError **error);
```
"""
function g_io_channel_write_unichar(channel, thechar, error)
    @ccall libaravis.g_io_channel_write_unichar(channel::Ptr{GIOChannel}, thechar::gunichar, error::Ptr{Ptr{GError}})::GIOStatus
end

"""
    g_io_channel_seek_position(channel, offset, type, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GIOStatus g_io_channel_seek_position (GIOChannel *channel, gint64 offset, GSeekType type, GError **error);
```
"""
function g_io_channel_seek_position(channel, offset, type, error)
    @ccall libaravis.g_io_channel_seek_position(channel::Ptr{GIOChannel}, offset::gint64, type::GSeekType, error::Ptr{Ptr{GError}})::GIOStatus
end

"""
    g_io_channel_new_file(filename, mode, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GIOChannel* g_io_channel_new_file (const gchar *filename, const gchar *mode, GError **error);
```
"""
function g_io_channel_new_file(filename, mode, error)
    @ccall libaravis.g_io_channel_new_file(filename::Ptr{gchar}, mode::Ptr{gchar}, error::Ptr{Ptr{GError}})::Ptr{GIOChannel}
end

"""
    g_io_channel_error_from_errno(en)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GIOChannelError g_io_channel_error_from_errno (gint en);
```
"""
function g_io_channel_error_from_errno(en)
    @ccall libaravis.g_io_channel_error_from_errno(en::gint)::GIOChannelError
end

"""
    g_io_channel_unix_new(fd)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GIOChannel* g_io_channel_unix_new (int fd);
```
"""
function g_io_channel_unix_new(fd)
    @ccall libaravis.g_io_channel_unix_new(fd::Cint)::Ptr{GIOChannel}
end

"""
    g_io_channel_unix_get_fd(channel)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_io_channel_unix_get_fd (GIOChannel *channel);
```
"""
function g_io_channel_unix_get_fd(channel)
    @ccall libaravis.g_io_channel_unix_get_fd(channel::Ptr{GIOChannel})::gint
end

@cenum GKeyFileError::UInt32 begin
    G_KEY_FILE_ERROR_UNKNOWN_ENCODING = 0
    G_KEY_FILE_ERROR_PARSE = 1
    G_KEY_FILE_ERROR_NOT_FOUND = 2
    G_KEY_FILE_ERROR_KEY_NOT_FOUND = 3
    G_KEY_FILE_ERROR_GROUP_NOT_FOUND = 4
    G_KEY_FILE_ERROR_INVALID_VALUE = 5
end

const _GKeyFile = Cvoid

const GKeyFile = _GKeyFile

@cenum GKeyFileFlags::UInt32 begin
    G_KEY_FILE_NONE = 0
    G_KEY_FILE_KEEP_COMMENTS = 1
    G_KEY_FILE_KEEP_TRANSLATIONS = 2
end

"""
    g_key_file_new()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GKeyFile *g_key_file_new (void);
```
"""
function g_key_file_new()
    @ccall libaravis.g_key_file_new()::Ptr{GKeyFile}
end

"""
    g_key_file_ref(key_file)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GKeyFile *g_key_file_ref (GKeyFile *key_file);
```
"""
function g_key_file_ref(key_file)
    @ccall libaravis.g_key_file_ref(key_file::Ptr{GKeyFile})::Ptr{GKeyFile}
end

"""
    g_key_file_unref(key_file)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_key_file_unref (GKeyFile *key_file);
```
"""
function g_key_file_unref(key_file)
    @ccall libaravis.g_key_file_unref(key_file::Ptr{GKeyFile})::Cvoid
end

"""
    g_key_file_free(key_file)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_key_file_free (GKeyFile *key_file);
```
"""
function g_key_file_free(key_file)
    @ccall libaravis.g_key_file_free(key_file::Ptr{GKeyFile})::Cvoid
end

"""
    g_key_file_set_list_separator(key_file, separator)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_key_file_set_list_separator (GKeyFile *key_file, gchar separator);
```
"""
function g_key_file_set_list_separator(key_file, separator)
    @ccall libaravis.g_key_file_set_list_separator(key_file::Ptr{GKeyFile}, separator::gchar)::Cvoid
end

"""
    g_key_file_load_from_file(key_file, file, flags, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_key_file_load_from_file (GKeyFile *key_file, const gchar *file, GKeyFileFlags flags, GError **error);
```
"""
function g_key_file_load_from_file(key_file, file, flags, error)
    @ccall libaravis.g_key_file_load_from_file(key_file::Ptr{GKeyFile}, file::Ptr{gchar}, flags::GKeyFileFlags, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_key_file_load_from_data(key_file, data, length, flags, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_key_file_load_from_data (GKeyFile *key_file, const gchar *data, gsize length, GKeyFileFlags flags, GError **error);
```
"""
function g_key_file_load_from_data(key_file, data, length, flags, error)
    @ccall libaravis.g_key_file_load_from_data(key_file::Ptr{GKeyFile}, data::Ptr{gchar}, length::gsize, flags::GKeyFileFlags, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_key_file_load_from_bytes(key_file, bytes, flags, error)

### Prototype
```c
GLIB_AVAILABLE_IN_2_50 gboolean g_key_file_load_from_bytes (GKeyFile *key_file, GBytes *bytes, GKeyFileFlags flags, GError **error);
```
"""
function g_key_file_load_from_bytes(key_file, bytes, flags, error)
    @ccall libaravis.g_key_file_load_from_bytes(key_file::Ptr{GKeyFile}, bytes::Ptr{GBytes}, flags::GKeyFileFlags, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_key_file_load_from_dirs(key_file, file, search_dirs, full_path, flags, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_key_file_load_from_dirs (GKeyFile *key_file, const gchar *file, const gchar **search_dirs, gchar **full_path, GKeyFileFlags flags, GError **error);
```
"""
function g_key_file_load_from_dirs(key_file, file, search_dirs, full_path, flags, error)
    @ccall libaravis.g_key_file_load_from_dirs(key_file::Ptr{GKeyFile}, file::Ptr{gchar}, search_dirs::Ptr{Ptr{gchar}}, full_path::Ptr{Ptr{gchar}}, flags::GKeyFileFlags, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_key_file_load_from_data_dirs(key_file, file, full_path, flags, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_key_file_load_from_data_dirs (GKeyFile *key_file, const gchar *file, gchar **full_path, GKeyFileFlags flags, GError **error);
```
"""
function g_key_file_load_from_data_dirs(key_file, file, full_path, flags, error)
    @ccall libaravis.g_key_file_load_from_data_dirs(key_file::Ptr{GKeyFile}, file::Ptr{gchar}, full_path::Ptr{Ptr{gchar}}, flags::GKeyFileFlags, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_key_file_to_data(key_file, length, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_key_file_to_data (GKeyFile *key_file, gsize *length, GError **error) G_GNUC_MALLOC;
```
"""
function g_key_file_to_data(key_file, length, error)
    @ccall libaravis.g_key_file_to_data(key_file::Ptr{GKeyFile}, length::Ptr{gsize}, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_key_file_save_to_file(key_file, filename, error)

### Prototype
```c
GLIB_AVAILABLE_IN_2_40 gboolean g_key_file_save_to_file (GKeyFile *key_file, const gchar *filename, GError **error);
```
"""
function g_key_file_save_to_file(key_file, filename, error)
    @ccall libaravis.g_key_file_save_to_file(key_file::Ptr{GKeyFile}, filename::Ptr{gchar}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_key_file_get_start_group(key_file)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_key_file_get_start_group (GKeyFile *key_file) G_GNUC_MALLOC;
```
"""
function g_key_file_get_start_group(key_file)
    @ccall libaravis.g_key_file_get_start_group(key_file::Ptr{GKeyFile})::Ptr{gchar}
end

"""
    g_key_file_get_groups(key_file, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar **g_key_file_get_groups (GKeyFile *key_file, gsize *length);
```
"""
function g_key_file_get_groups(key_file, length)
    @ccall libaravis.g_key_file_get_groups(key_file::Ptr{GKeyFile}, length::Ptr{gsize})::Ptr{Ptr{gchar}}
end

"""
    g_key_file_get_keys(key_file, group_name, length, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar **g_key_file_get_keys (GKeyFile *key_file, const gchar *group_name, gsize *length, GError **error);
```
"""
function g_key_file_get_keys(key_file, group_name, length, error)
    @ccall libaravis.g_key_file_get_keys(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, length::Ptr{gsize}, error::Ptr{Ptr{GError}})::Ptr{Ptr{gchar}}
end

"""
    g_key_file_has_group(key_file, group_name)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_key_file_has_group (GKeyFile *key_file, const gchar *group_name);
```
"""
function g_key_file_has_group(key_file, group_name)
    @ccall libaravis.g_key_file_has_group(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar})::gboolean
end

"""
    g_key_file_has_key(key_file, group_name, key, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_key_file_has_key (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
```
"""
function g_key_file_has_key(key_file, group_name, key, error)
    @ccall libaravis.g_key_file_has_key(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_key_file_get_value(key_file, group_name, key, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_key_file_get_value (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error) G_GNUC_MALLOC;
```
"""
function g_key_file_get_value(key_file, group_name, key, error)
    @ccall libaravis.g_key_file_get_value(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_key_file_set_value(key_file, group_name, key, value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_key_file_set_value (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *value);
```
"""
function g_key_file_set_value(key_file, group_name, key, value)
    @ccall libaravis.g_key_file_set_value(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, value::Ptr{gchar})::Cvoid
end

"""
    g_key_file_get_string(key_file, group_name, key, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_key_file_get_string (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error) G_GNUC_MALLOC;
```
"""
function g_key_file_get_string(key_file, group_name, key, error)
    @ccall libaravis.g_key_file_get_string(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_key_file_set_string(key_file, group_name, key, string)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_key_file_set_string (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *string);
```
"""
function g_key_file_set_string(key_file, group_name, key, string)
    @ccall libaravis.g_key_file_set_string(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, string::Ptr{gchar})::Cvoid
end

"""
    g_key_file_get_locale_string(key_file, group_name, key, locale, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_key_file_get_locale_string (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, GError **error) G_GNUC_MALLOC;
```
"""
function g_key_file_get_locale_string(key_file, group_name, key, locale, error)
    @ccall libaravis.g_key_file_get_locale_string(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, locale::Ptr{gchar}, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_key_file_get_locale_for_key(key_file, group_name, key, locale)

### Prototype
```c
GLIB_AVAILABLE_IN_2_56 gchar *g_key_file_get_locale_for_key (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale) G_GNUC_MALLOC;
```
"""
function g_key_file_get_locale_for_key(key_file, group_name, key, locale)
    @ccall libaravis.g_key_file_get_locale_for_key(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, locale::Ptr{gchar})::Ptr{gchar}
end

"""
    g_key_file_set_locale_string(key_file, group_name, key, locale, string)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_key_file_set_locale_string (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, const gchar *string);
```
"""
function g_key_file_set_locale_string(key_file, group_name, key, locale, string)
    @ccall libaravis.g_key_file_set_locale_string(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, locale::Ptr{gchar}, string::Ptr{gchar})::Cvoid
end

"""
    g_key_file_get_boolean(key_file, group_name, key, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_key_file_get_boolean (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
```
"""
function g_key_file_get_boolean(key_file, group_name, key, error)
    @ccall libaravis.g_key_file_get_boolean(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_key_file_set_boolean(key_file, group_name, key, value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_key_file_set_boolean (GKeyFile *key_file, const gchar *group_name, const gchar *key, gboolean value);
```
"""
function g_key_file_set_boolean(key_file, group_name, key, value)
    @ccall libaravis.g_key_file_set_boolean(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, value::gboolean)::Cvoid
end

"""
    g_key_file_get_integer(key_file, group_name, key, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_key_file_get_integer (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
```
"""
function g_key_file_get_integer(key_file, group_name, key, error)
    @ccall libaravis.g_key_file_get_integer(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, error::Ptr{Ptr{GError}})::gint
end

"""
    g_key_file_set_integer(key_file, group_name, key, value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_key_file_set_integer (GKeyFile *key_file, const gchar *group_name, const gchar *key, gint value);
```
"""
function g_key_file_set_integer(key_file, group_name, key, value)
    @ccall libaravis.g_key_file_set_integer(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, value::gint)::Cvoid
end

"""
    g_key_file_get_int64(key_file, group_name, key, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint64 g_key_file_get_int64 (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
```
"""
function g_key_file_get_int64(key_file, group_name, key, error)
    @ccall libaravis.g_key_file_get_int64(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, error::Ptr{Ptr{GError}})::gint64
end

"""
    g_key_file_set_int64(key_file, group_name, key, value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_key_file_set_int64 (GKeyFile *key_file, const gchar *group_name, const gchar *key, gint64 value);
```
"""
function g_key_file_set_int64(key_file, group_name, key, value)
    @ccall libaravis.g_key_file_set_int64(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, value::gint64)::Cvoid
end

"""
    g_key_file_get_uint64(key_file, group_name, key, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint64 g_key_file_get_uint64 (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
```
"""
function g_key_file_get_uint64(key_file, group_name, key, error)
    @ccall libaravis.g_key_file_get_uint64(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, error::Ptr{Ptr{GError}})::guint64
end

"""
    g_key_file_set_uint64(key_file, group_name, key, value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_key_file_set_uint64 (GKeyFile *key_file, const gchar *group_name, const gchar *key, guint64 value);
```
"""
function g_key_file_set_uint64(key_file, group_name, key, value)
    @ccall libaravis.g_key_file_set_uint64(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, value::guint64)::Cvoid
end

"""
    g_key_file_get_double(key_file, group_name, key, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gdouble g_key_file_get_double (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
```
"""
function g_key_file_get_double(key_file, group_name, key, error)
    @ccall libaravis.g_key_file_get_double(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, error::Ptr{Ptr{GError}})::gdouble
end

"""
    g_key_file_set_double(key_file, group_name, key, value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_key_file_set_double (GKeyFile *key_file, const gchar *group_name, const gchar *key, gdouble value);
```
"""
function g_key_file_set_double(key_file, group_name, key, value)
    @ccall libaravis.g_key_file_set_double(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, value::gdouble)::Cvoid
end

"""
    g_key_file_get_string_list(key_file, group_name, key, length, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar **g_key_file_get_string_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error);
```
"""
function g_key_file_get_string_list(key_file, group_name, key, length, error)
    @ccall libaravis.g_key_file_get_string_list(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, length::Ptr{gsize}, error::Ptr{Ptr{GError}})::Ptr{Ptr{gchar}}
end

"""
    g_key_file_set_string_list(key_file, group_name, key, list, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_key_file_set_string_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar * const list[], gsize length);
```
"""
function g_key_file_set_string_list(key_file, group_name, key, list, length)
    @ccall libaravis.g_key_file_set_string_list(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, list::Ptr{Ptr{gchar}}, length::gsize)::Cvoid
end

"""
    g_key_file_get_locale_string_list(key_file, group_name, key, locale, length, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar **g_key_file_get_locale_string_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, gsize *length, GError **error);
```
"""
function g_key_file_get_locale_string_list(key_file, group_name, key, locale, length, error)
    @ccall libaravis.g_key_file_get_locale_string_list(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, locale::Ptr{gchar}, length::Ptr{gsize}, error::Ptr{Ptr{GError}})::Ptr{Ptr{gchar}}
end

"""
    g_key_file_set_locale_string_list(key_file, group_name, key, locale, list, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_key_file_set_locale_string_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, const gchar * const list[], gsize length);
```
"""
function g_key_file_set_locale_string_list(key_file, group_name, key, locale, list, length)
    @ccall libaravis.g_key_file_set_locale_string_list(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, locale::Ptr{gchar}, list::Ptr{Ptr{gchar}}, length::gsize)::Cvoid
end

"""
    g_key_file_get_boolean_list(key_file, group_name, key, length, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean *g_key_file_get_boolean_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error) G_GNUC_MALLOC;
```
"""
function g_key_file_get_boolean_list(key_file, group_name, key, length, error)
    @ccall libaravis.g_key_file_get_boolean_list(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, length::Ptr{gsize}, error::Ptr{Ptr{GError}})::Ptr{gboolean}
end

"""
    g_key_file_set_boolean_list(key_file, group_name, key, list, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_key_file_set_boolean_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, gboolean list[], gsize length);
```
"""
function g_key_file_set_boolean_list(key_file, group_name, key, list, length)
    @ccall libaravis.g_key_file_set_boolean_list(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, list::Ptr{gboolean}, length::gsize)::Cvoid
end

"""
    g_key_file_get_integer_list(key_file, group_name, key, length, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint *g_key_file_get_integer_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error) G_GNUC_MALLOC;
```
"""
function g_key_file_get_integer_list(key_file, group_name, key, length, error)
    @ccall libaravis.g_key_file_get_integer_list(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, length::Ptr{gsize}, error::Ptr{Ptr{GError}})::Ptr{gint}
end

"""
    g_key_file_set_double_list(key_file, group_name, key, list, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_key_file_set_double_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, gdouble list[], gsize length);
```
"""
function g_key_file_set_double_list(key_file, group_name, key, list, length)
    @ccall libaravis.g_key_file_set_double_list(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, list::Ptr{gdouble}, length::gsize)::Cvoid
end

"""
    g_key_file_get_double_list(key_file, group_name, key, length, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gdouble *g_key_file_get_double_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error) G_GNUC_MALLOC;
```
"""
function g_key_file_get_double_list(key_file, group_name, key, length, error)
    @ccall libaravis.g_key_file_get_double_list(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, length::Ptr{gsize}, error::Ptr{Ptr{GError}})::Ptr{gdouble}
end

"""
    g_key_file_set_integer_list(key_file, group_name, key, list, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_key_file_set_integer_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, gint list[], gsize length);
```
"""
function g_key_file_set_integer_list(key_file, group_name, key, list, length)
    @ccall libaravis.g_key_file_set_integer_list(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, list::Ptr{gint}, length::gsize)::Cvoid
end

"""
    g_key_file_set_comment(key_file, group_name, key, comment, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_key_file_set_comment (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *comment, GError **error);
```
"""
function g_key_file_set_comment(key_file, group_name, key, comment, error)
    @ccall libaravis.g_key_file_set_comment(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, comment::Ptr{gchar}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_key_file_get_comment(key_file, group_name, key, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_key_file_get_comment (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error) G_GNUC_MALLOC;
```
"""
function g_key_file_get_comment(key_file, group_name, key, error)
    @ccall libaravis.g_key_file_get_comment(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_key_file_remove_comment(key_file, group_name, key, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_key_file_remove_comment (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
```
"""
function g_key_file_remove_comment(key_file, group_name, key, error)
    @ccall libaravis.g_key_file_remove_comment(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_key_file_remove_key(key_file, group_name, key, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_key_file_remove_key (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
```
"""
function g_key_file_remove_key(key_file, group_name, key, error)
    @ccall libaravis.g_key_file_remove_key(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, key::Ptr{gchar}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_key_file_remove_group(key_file, group_name, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_key_file_remove_group (GKeyFile *key_file, const gchar *group_name, GError **error);
```
"""
function g_key_file_remove_group(key_file, group_name, error)
    @ccall libaravis.g_key_file_remove_group(key_file::Ptr{GKeyFile}, group_name::Ptr{gchar}, error::Ptr{Ptr{GError}})::gboolean
end

const _GMappedFile = Cvoid

const GMappedFile = _GMappedFile

"""
    g_mapped_file_new(filename, writable, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GMappedFile *g_mapped_file_new (const gchar *filename, gboolean writable, GError **error);
```
"""
function g_mapped_file_new(filename, writable, error)
    @ccall libaravis.g_mapped_file_new(filename::Ptr{gchar}, writable::gboolean, error::Ptr{Ptr{GError}})::Ptr{GMappedFile}
end

"""
    g_mapped_file_new_from_fd(fd, writable, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GMappedFile *g_mapped_file_new_from_fd (gint fd, gboolean writable, GError **error);
```
"""
function g_mapped_file_new_from_fd(fd, writable, error)
    @ccall libaravis.g_mapped_file_new_from_fd(fd::gint, writable::gboolean, error::Ptr{Ptr{GError}})::Ptr{GMappedFile}
end

"""
    g_mapped_file_get_length(file)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gsize g_mapped_file_get_length (GMappedFile *file);
```
"""
function g_mapped_file_get_length(file)
    @ccall libaravis.g_mapped_file_get_length(file::Ptr{GMappedFile})::gsize
end

"""
    g_mapped_file_get_contents(file)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_mapped_file_get_contents (GMappedFile *file);
```
"""
function g_mapped_file_get_contents(file)
    @ccall libaravis.g_mapped_file_get_contents(file::Ptr{GMappedFile})::Ptr{gchar}
end

"""
    g_mapped_file_get_bytes(file)

### Prototype
```c
GLIB_AVAILABLE_IN_2_34 GBytes * g_mapped_file_get_bytes (GMappedFile *file);
```
"""
function g_mapped_file_get_bytes(file)
    @ccall libaravis.g_mapped_file_get_bytes(file::Ptr{GMappedFile})::Ptr{GBytes}
end

"""
    g_mapped_file_ref(file)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GMappedFile *g_mapped_file_ref (GMappedFile *file);
```
"""
function g_mapped_file_ref(file)
    @ccall libaravis.g_mapped_file_ref(file::Ptr{GMappedFile})::Ptr{GMappedFile}
end

"""
    g_mapped_file_unref(file)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_mapped_file_unref (GMappedFile *file);
```
"""
function g_mapped_file_unref(file)
    @ccall libaravis.g_mapped_file_unref(file::Ptr{GMappedFile})::Cvoid
end

"""
    g_mapped_file_free(file)

### Prototype
```c
GLIB_DEPRECATED_FOR(g_mapped_file_unref) void g_mapped_file_free (GMappedFile *file);
```
"""
function g_mapped_file_free(file)
    @ccall libaravis.g_mapped_file_free(file::Ptr{GMappedFile})::Cvoid
end

"""
    GMarkupError

[`GMarkupError`](@ref): \\_MARKUP\\_ERROR\\_BAD\\_UTF8: text being parsed was not valid UTF-8 \\_MARKUP\\_ERROR\\_EMPTY: document contained nothing, or only whitespace \\_MARKUP\\_ERROR\\_PARSE: document was ill-formed \\_MARKUP\\_ERROR\\_UNKNOWN\\_ELEMENT: error should be set by #[`GMarkupParser`](@ref) functions; element wasn't known \\_MARKUP\\_ERROR\\_UNKNOWN\\_ATTRIBUTE: error should be set by #[`GMarkupParser`](@ref) functions; attribute wasn't known \\_MARKUP\\_ERROR\\_INVALID\\_CONTENT: error should be set by #[`GMarkupParser`](@ref) functions; content was invalid \\_MARKUP\\_ERROR\\_MISSING\\_ATTRIBUTE: error should be set by #[`GMarkupParser`](@ref) functions; a required attribute was missing

Error codes returned by markup parsing.
"""
@cenum GMarkupError::UInt32 begin
    G_MARKUP_ERROR_BAD_UTF8 = 0
    G_MARKUP_ERROR_EMPTY = 1
    G_MARKUP_ERROR_PARSE = 2
    G_MARKUP_ERROR_UNKNOWN_ELEMENT = 3
    G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE = 4
    G_MARKUP_ERROR_INVALID_CONTENT = 5
    G_MARKUP_ERROR_MISSING_ATTRIBUTE = 6
end

"""
    GMarkupParseFlags

[`GMarkupParseFlags`](@ref): \\_MARKUP\\_DEFAULT\\_FLAGS: No special behaviour. Since: 2.74 \\_MARKUP\\_DO\\_NOT\\_USE\\_THIS\\_UNSUPPORTED\\_FLAG: flag you should not use \\_MARKUP\\_TREAT\\_CDATA\\_AS\\_TEXT: When this flag is set, CDATA marked sections are not passed literally to the  function of the parser. Instead, the content of the section (without the `<![CDATA[` and `]]>`) is passed to the

\\test function. This flag was added in GLib 2.12 \\_MARKUP\\_PREFIX\\_ERROR\\_POSITION: Normally errors caught by GMarkup itself have line/column information prefixed to them to let the caller know the location of the error. When this flag is set the location information is also prefixed to errors generated by the #[`GMarkupParser`](@ref) implementation functions \\_MARKUP\\_IGNORE\\_QUALIFIED: Ignore (don't report) qualified attributes and tags, along with their contents. A qualified attribute or tag is one that contains ':' in its name (ie: is in another namespace). Since: 2.40.

Flags that affect the behaviour of the parser.
"""
@cenum GMarkupParseFlags::UInt32 begin
    G_MARKUP_DEFAULT_FLAGS = 0
    G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG = 1
    G_MARKUP_TREAT_CDATA_AS_TEXT = 2
    G_MARKUP_PREFIX_ERROR_POSITION = 4
    G_MARKUP_IGNORE_QUALIFIED = 8
end

const _GMarkupParseContext = Cvoid

"""
[`GMarkupParseContext`](@ref):

A parse context is used to parse a stream of bytes that you expect to contain marked-up text.

See [`g_markup_parse_context_new`](@ref)(), #[`GMarkupParser`](@ref), and so on for more details.
"""
const GMarkupParseContext = _GMarkupParseContext

"""
    _GMarkupParser

[`GMarkupParser`](@ref): \\_element: Callback to invoke when the opening tag of an element is seen. The callback's \\_names and \\_values parameters are NULL-terminated. \\_element: Callback to invoke when the closing tag of an element is seen. Note that this is also called for empty tags like `<empty/>`.

\\test : Callback to invoke when some text is seen (text is always inside an element). Note that the text of an element may be spread over multiple calls of this function. If the G\\_MARKUP\\_TREAT\\_CDATA\\_AS\\_TEXT flag is set, this function is also called for the content of CDATA marked sections. : Callback to invoke for comments, processing instructions and doctype declarations; if you're re-writing the parsed document, write the passthrough text back out in the same position. If the G\\_MARKUP\\_TREAT\\_CDATA\\_AS\\_TEXT flag is not set, this function is also called for CDATA marked sections. : Callback to invoke when an error occurs.

Any of the fields in #[`GMarkupParser`](@ref) can be NULL, in which case they will be ignored. Except for the  function, any of these callbacks can set an error; in particular the G\\_MARKUP\\_ERROR\\_UNKNOWN\\_ELEMENT, G\\_MARKUP\\_ERROR\\_UNKNOWN\\_ATTRIBUTE, and G\\_MARKUP\\_ERROR\\_INVALID\\_CONTENT errors are intended to be set from these callbacks. If you set an error from a callback, [`g_markup_parse_context_parse`](@ref)() will report that error back to its caller.

Refer to the [GMarkup](../glib/markup.html) documentation to understand the scope and limitations of [`GMarkupParser`](@ref). In particular, it is not a full XML parser and it must not be used to process untrusted data.
"""
struct _GMarkupParser
    start_element::Ptr{Cvoid}
    end_element::Ptr{Cvoid}
    text::Ptr{Cvoid}
    passthrough::Ptr{Cvoid}
    error::Ptr{Cvoid}
end

"""
[`GMarkupParser`](@ref): \\_element: Callback to invoke when the opening tag of an element is seen. The callback's \\_names and \\_values parameters are NULL-terminated. \\_element: Callback to invoke when the closing tag of an element is seen. Note that this is also called for empty tags like `<empty/>`.

\\test : Callback to invoke when some text is seen (text is always inside an element). Note that the text of an element may be spread over multiple calls of this function. If the G\\_MARKUP\\_TREAT\\_CDATA\\_AS\\_TEXT flag is set, this function is also called for the content of CDATA marked sections. : Callback to invoke for comments, processing instructions and doctype declarations; if you're re-writing the parsed document, write the passthrough text back out in the same position. If the G\\_MARKUP\\_TREAT\\_CDATA\\_AS\\_TEXT flag is not set, this function is also called for CDATA marked sections. : Callback to invoke when an error occurs.

Any of the fields in #[`GMarkupParser`](@ref) can be NULL, in which case they will be ignored. Except for the  function, any of these callbacks can set an error; in particular the G\\_MARKUP\\_ERROR\\_UNKNOWN\\_ELEMENT, G\\_MARKUP\\_ERROR\\_UNKNOWN\\_ATTRIBUTE, and G\\_MARKUP\\_ERROR\\_INVALID\\_CONTENT errors are intended to be set from these callbacks. If you set an error from a callback, [`g_markup_parse_context_parse`](@ref)() will report that error back to its caller.

Refer to the [GMarkup](../glib/markup.html) documentation to understand the scope and limitations of [`GMarkupParser`](@ref). In particular, it is not a full XML parser and it must not be used to process untrusted data.
"""
const GMarkupParser = _GMarkupParser

"""
    g_markup_parse_context_new(parser, flags, user_data, user_data_dnotify)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GMarkupParseContext *g_markup_parse_context_new (const GMarkupParser *parser, GMarkupParseFlags flags, gpointer user_data, GDestroyNotify user_data_dnotify);
```
"""
function g_markup_parse_context_new(parser, flags, user_data, user_data_dnotify)
    @ccall libaravis.g_markup_parse_context_new(parser::Ptr{GMarkupParser}, flags::GMarkupParseFlags, user_data::gpointer, user_data_dnotify::GDestroyNotify)::Ptr{GMarkupParseContext}
end

"""
    g_markup_parse_context_ref(context)

### Prototype
```c
GLIB_AVAILABLE_IN_2_36 GMarkupParseContext *g_markup_parse_context_ref (GMarkupParseContext *context);
```
"""
function g_markup_parse_context_ref(context)
    @ccall libaravis.g_markup_parse_context_ref(context::Ptr{GMarkupParseContext})::Ptr{GMarkupParseContext}
end

"""
    g_markup_parse_context_unref(context)

### Prototype
```c
GLIB_AVAILABLE_IN_2_36 void g_markup_parse_context_unref (GMarkupParseContext *context);
```
"""
function g_markup_parse_context_unref(context)
    @ccall libaravis.g_markup_parse_context_unref(context::Ptr{GMarkupParseContext})::Cvoid
end

"""
    g_markup_parse_context_free(context)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_markup_parse_context_free (GMarkupParseContext *context);
```
"""
function g_markup_parse_context_free(context)
    @ccall libaravis.g_markup_parse_context_free(context::Ptr{GMarkupParseContext})::Cvoid
end

"""
    g_markup_parse_context_parse(context, text, text_len, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_markup_parse_context_parse (GMarkupParseContext *context, const gchar *text, gssize text_len, GError **error);
```
"""
function g_markup_parse_context_parse(context, text, text_len, error)
    @ccall libaravis.g_markup_parse_context_parse(context::Ptr{GMarkupParseContext}, text::Ptr{gchar}, text_len::gssize, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_markup_parse_context_push(context, parser, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_markup_parse_context_push (GMarkupParseContext *context, const GMarkupParser *parser, gpointer user_data);
```
"""
function g_markup_parse_context_push(context, parser, user_data)
    @ccall libaravis.g_markup_parse_context_push(context::Ptr{GMarkupParseContext}, parser::Ptr{GMarkupParser}, user_data::gpointer)::Cvoid
end

"""
    g_markup_parse_context_pop(context)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_markup_parse_context_pop (GMarkupParseContext *context);
```
"""
function g_markup_parse_context_pop(context)
    @ccall libaravis.g_markup_parse_context_pop(context::Ptr{GMarkupParseContext})::gpointer
end

"""
    g_markup_parse_context_end_parse(context, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_markup_parse_context_end_parse (GMarkupParseContext *context, GError **error);
```
"""
function g_markup_parse_context_end_parse(context, error)
    @ccall libaravis.g_markup_parse_context_end_parse(context::Ptr{GMarkupParseContext}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_markup_parse_context_get_element(context)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_markup_parse_context_get_element (GMarkupParseContext *context);
```
"""
function g_markup_parse_context_get_element(context)
    @ccall libaravis.g_markup_parse_context_get_element(context::Ptr{GMarkupParseContext})::Ptr{gchar}
end

"""
    g_markup_parse_context_get_element_stack(context)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const GSList * g_markup_parse_context_get_element_stack (GMarkupParseContext *context);
```
"""
function g_markup_parse_context_get_element_stack(context)
    @ccall libaravis.g_markup_parse_context_get_element_stack(context::Ptr{GMarkupParseContext})::Ptr{GSList}
end

"""
    g_markup_parse_context_get_position(context, line_number, char_number)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_markup_parse_context_get_position (GMarkupParseContext *context, gint *line_number, gint *char_number);
```
"""
function g_markup_parse_context_get_position(context, line_number, char_number)
    @ccall libaravis.g_markup_parse_context_get_position(context::Ptr{GMarkupParseContext}, line_number::Ptr{gint}, char_number::Ptr{gint})::Cvoid
end

"""
    g_markup_parse_context_get_user_data(context)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_markup_parse_context_get_user_data (GMarkupParseContext *context);
```
"""
function g_markup_parse_context_get_user_data(context)
    @ccall libaravis.g_markup_parse_context_get_user_data(context::Ptr{GMarkupParseContext})::gpointer
end

"""
    g_markup_escape_text(text, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_markup_escape_text (const gchar *text, gssize length);
```
"""
function g_markup_escape_text(text, length)
    @ccall libaravis.g_markup_escape_text(text::Ptr{gchar}, length::gssize)::Ptr{gchar}
end

@cenum GMarkupCollectType::UInt32 begin
    G_MARKUP_COLLECT_INVALID = 0
    G_MARKUP_COLLECT_STRING = 1
    G_MARKUP_COLLECT_STRDUP = 2
    G_MARKUP_COLLECT_BOOLEAN = 3
    G_MARKUP_COLLECT_TRISTATE = 4
    G_MARKUP_COLLECT_OPTIONAL = 65536
end

"""
    g_variant_type_string_is_valid(type_string)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_variant_type_string_is_valid (const gchar *type_string) G_GNUC_CONST;
```
"""
function g_variant_type_string_is_valid(type_string)
    @ccall libaravis.g_variant_type_string_is_valid(type_string::Ptr{gchar})::gboolean
end

"""
    g_variant_type_string_scan(string, limit, endptr)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_variant_type_string_scan (const gchar *string, const gchar *limit, const gchar **endptr);
```
"""
function g_variant_type_string_scan(string, limit, endptr)
    @ccall libaravis.g_variant_type_string_scan(string::Ptr{gchar}, limit::Ptr{gchar}, endptr::Ptr{Ptr{gchar}})::gboolean
end

"""
    g_variant_type_free(type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_variant_type_free (GVariantType *type);
```
"""
function g_variant_type_free(type)
    @ccall libaravis.g_variant_type_free(type::Ptr{GVariantType})::Cvoid
end

"""
    g_variant_type_copy(type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariantType * g_variant_type_copy (const GVariantType *type);
```
"""
function g_variant_type_copy(type)
    @ccall libaravis.g_variant_type_copy(type::Ptr{GVariantType})::Ptr{GVariantType}
end

"""
    g_variant_type_new(type_string)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariantType * g_variant_type_new (const gchar *type_string);
```
"""
function g_variant_type_new(type_string)
    @ccall libaravis.g_variant_type_new(type_string::Ptr{gchar})::Ptr{GVariantType}
end

"""
    g_variant_type_get_string_length(type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gsize g_variant_type_get_string_length (const GVariantType *type);
```
"""
function g_variant_type_get_string_length(type)
    @ccall libaravis.g_variant_type_get_string_length(type::Ptr{GVariantType})::gsize
end

"""
    g_variant_type_peek_string(type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_variant_type_peek_string (const GVariantType *type);
```
"""
function g_variant_type_peek_string(type)
    @ccall libaravis.g_variant_type_peek_string(type::Ptr{GVariantType})::Ptr{gchar}
end

"""
    g_variant_type_dup_string(type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar * g_variant_type_dup_string (const GVariantType *type);
```
"""
function g_variant_type_dup_string(type)
    @ccall libaravis.g_variant_type_dup_string(type::Ptr{GVariantType})::Ptr{gchar}
end

"""
    g_variant_type_is_definite(type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_variant_type_is_definite (const GVariantType *type) G_GNUC_CONST;
```
"""
function g_variant_type_is_definite(type)
    @ccall libaravis.g_variant_type_is_definite(type::Ptr{GVariantType})::gboolean
end

"""
    g_variant_type_is_container(type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_variant_type_is_container (const GVariantType *type) G_GNUC_CONST;
```
"""
function g_variant_type_is_container(type)
    @ccall libaravis.g_variant_type_is_container(type::Ptr{GVariantType})::gboolean
end

"""
    g_variant_type_is_basic(type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_variant_type_is_basic (const GVariantType *type) G_GNUC_CONST;
```
"""
function g_variant_type_is_basic(type)
    @ccall libaravis.g_variant_type_is_basic(type::Ptr{GVariantType})::gboolean
end

"""
    g_variant_type_is_maybe(type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_variant_type_is_maybe (const GVariantType *type) G_GNUC_CONST;
```
"""
function g_variant_type_is_maybe(type)
    @ccall libaravis.g_variant_type_is_maybe(type::Ptr{GVariantType})::gboolean
end

"""
    g_variant_type_is_array(type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_variant_type_is_array (const GVariantType *type) G_GNUC_CONST;
```
"""
function g_variant_type_is_array(type)
    @ccall libaravis.g_variant_type_is_array(type::Ptr{GVariantType})::gboolean
end

"""
    g_variant_type_is_tuple(type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_variant_type_is_tuple (const GVariantType *type) G_GNUC_CONST;
```
"""
function g_variant_type_is_tuple(type)
    @ccall libaravis.g_variant_type_is_tuple(type::Ptr{GVariantType})::gboolean
end

"""
    g_variant_type_is_dict_entry(type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_variant_type_is_dict_entry (const GVariantType *type) G_GNUC_CONST;
```
"""
function g_variant_type_is_dict_entry(type)
    @ccall libaravis.g_variant_type_is_dict_entry(type::Ptr{GVariantType})::gboolean
end

"""
    g_variant_type_is_variant(type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_variant_type_is_variant (const GVariantType *type) G_GNUC_CONST;
```
"""
function g_variant_type_is_variant(type)
    @ccall libaravis.g_variant_type_is_variant(type::Ptr{GVariantType})::gboolean
end

"""
    g_variant_type_hash(type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_variant_type_hash (gconstpointer type);
```
"""
function g_variant_type_hash(type)
    @ccall libaravis.g_variant_type_hash(type::gconstpointer)::guint
end

"""
    g_variant_type_equal(type1, type2)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_variant_type_equal (gconstpointer type1, gconstpointer type2);
```
"""
function g_variant_type_equal(type1, type2)
    @ccall libaravis.g_variant_type_equal(type1::gconstpointer, type2::gconstpointer)::gboolean
end

"""
    g_variant_type_is_subtype_of(type, supertype)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_variant_type_is_subtype_of (const GVariantType *type, const GVariantType *supertype) G_GNUC_CONST;
```
"""
function g_variant_type_is_subtype_of(type, supertype)
    @ccall libaravis.g_variant_type_is_subtype_of(type::Ptr{GVariantType}, supertype::Ptr{GVariantType})::gboolean
end

"""
    g_variant_type_element(type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const GVariantType * g_variant_type_element (const GVariantType *type) G_GNUC_CONST;
```
"""
function g_variant_type_element(type)
    @ccall libaravis.g_variant_type_element(type::Ptr{GVariantType})::Ptr{GVariantType}
end

"""
    g_variant_type_first(type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const GVariantType * g_variant_type_first (const GVariantType *type) G_GNUC_CONST;
```
"""
function g_variant_type_first(type)
    @ccall libaravis.g_variant_type_first(type::Ptr{GVariantType})::Ptr{GVariantType}
end

"""
    g_variant_type_next(type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const GVariantType * g_variant_type_next (const GVariantType *type) G_GNUC_CONST;
```
"""
function g_variant_type_next(type)
    @ccall libaravis.g_variant_type_next(type::Ptr{GVariantType})::Ptr{GVariantType}
end

"""
    g_variant_type_n_items(type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gsize g_variant_type_n_items (const GVariantType *type) G_GNUC_CONST;
```
"""
function g_variant_type_n_items(type)
    @ccall libaravis.g_variant_type_n_items(type::Ptr{GVariantType})::gsize
end

"""
    g_variant_type_key(type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const GVariantType * g_variant_type_key (const GVariantType *type) G_GNUC_CONST;
```
"""
function g_variant_type_key(type)
    @ccall libaravis.g_variant_type_key(type::Ptr{GVariantType})::Ptr{GVariantType}
end

"""
    g_variant_type_value(type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const GVariantType * g_variant_type_value (const GVariantType *type) G_GNUC_CONST;
```
"""
function g_variant_type_value(type)
    @ccall libaravis.g_variant_type_value(type::Ptr{GVariantType})::Ptr{GVariantType}
end

"""
    g_variant_type_new_array(element)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariantType * g_variant_type_new_array (const GVariantType *element);
```
"""
function g_variant_type_new_array(element)
    @ccall libaravis.g_variant_type_new_array(element::Ptr{GVariantType})::Ptr{GVariantType}
end

"""
    g_variant_type_new_maybe(element)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariantType * g_variant_type_new_maybe (const GVariantType *element);
```
"""
function g_variant_type_new_maybe(element)
    @ccall libaravis.g_variant_type_new_maybe(element::Ptr{GVariantType})::Ptr{GVariantType}
end

"""
    g_variant_type_new_tuple(items, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariantType * g_variant_type_new_tuple (const GVariantType * const *items, gint length);
```
"""
function g_variant_type_new_tuple(items, length)
    @ccall libaravis.g_variant_type_new_tuple(items::Ptr{Ptr{GVariantType}}, length::gint)::Ptr{GVariantType}
end

"""
    g_variant_type_new_dict_entry(key, value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariantType * g_variant_type_new_dict_entry (const GVariantType *key, const GVariantType *value);
```
"""
function g_variant_type_new_dict_entry(key, value)
    @ccall libaravis.g_variant_type_new_dict_entry(key::Ptr{GVariantType}, value::Ptr{GVariantType})::Ptr{GVariantType}
end

"""
    g_variant_type_string_get_depth_(type_string)

### Prototype
```c
GLIB_AVAILABLE_IN_2_60 gsize g_variant_type_string_get_depth_ (const gchar *type_string);
```
"""
function g_variant_type_string_get_depth_(type_string)
    @ccall libaravis.g_variant_type_string_get_depth_(type_string::Ptr{gchar})::gsize
end

@cenum GVariantClass::UInt32 begin
    G_VARIANT_CLASS_BOOLEAN = 98
    G_VARIANT_CLASS_BYTE = 121
    G_VARIANT_CLASS_INT16 = 110
    G_VARIANT_CLASS_UINT16 = 113
    G_VARIANT_CLASS_INT32 = 105
    G_VARIANT_CLASS_UINT32 = 117
    G_VARIANT_CLASS_INT64 = 120
    G_VARIANT_CLASS_UINT64 = 116
    G_VARIANT_CLASS_HANDLE = 104
    G_VARIANT_CLASS_DOUBLE = 100
    G_VARIANT_CLASS_STRING = 115
    G_VARIANT_CLASS_OBJECT_PATH = 111
    G_VARIANT_CLASS_SIGNATURE = 103
    G_VARIANT_CLASS_VARIANT = 118
    G_VARIANT_CLASS_MAYBE = 109
    G_VARIANT_CLASS_ARRAY = 97
    G_VARIANT_CLASS_TUPLE = 40
    G_VARIANT_CLASS_DICT_ENTRY = 123
end

"""
    g_variant_unref(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_variant_unref (GVariant *value);
```
"""
function g_variant_unref(value)
    @ccall libaravis.g_variant_unref(value::Ptr{GVariant})::Cvoid
end

"""
    g_variant_ref(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_ref (GVariant *value);
```
"""
function g_variant_ref(value)
    @ccall libaravis.g_variant_ref(value::Ptr{GVariant})::Ptr{GVariant}
end

"""
    g_variant_ref_sink(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_ref_sink (GVariant *value);
```
"""
function g_variant_ref_sink(value)
    @ccall libaravis.g_variant_ref_sink(value::Ptr{GVariant})::Ptr{GVariant}
end

"""
    g_variant_is_floating(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_variant_is_floating (GVariant *value);
```
"""
function g_variant_is_floating(value)
    @ccall libaravis.g_variant_is_floating(value::Ptr{GVariant})::gboolean
end

"""
    g_variant_take_ref(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_take_ref (GVariant *value);
```
"""
function g_variant_take_ref(value)
    @ccall libaravis.g_variant_take_ref(value::Ptr{GVariant})::Ptr{GVariant}
end

"""
    g_variant_get_type(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const GVariantType * g_variant_get_type (GVariant *value);
```
"""
function g_variant_get_type(value)
    @ccall libaravis.g_variant_get_type(value::Ptr{GVariant})::Ptr{GVariantType}
end

"""
    g_variant_get_type_string(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_variant_get_type_string (GVariant *value);
```
"""
function g_variant_get_type_string(value)
    @ccall libaravis.g_variant_get_type_string(value::Ptr{GVariant})::Ptr{gchar}
end

"""
    g_variant_is_of_type(value, type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_variant_is_of_type (GVariant *value, const GVariantType *type);
```
"""
function g_variant_is_of_type(value, type)
    @ccall libaravis.g_variant_is_of_type(value::Ptr{GVariant}, type::Ptr{GVariantType})::gboolean
end

"""
    g_variant_is_container(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_variant_is_container (GVariant *value);
```
"""
function g_variant_is_container(value)
    @ccall libaravis.g_variant_is_container(value::Ptr{GVariant})::gboolean
end

"""
    g_variant_classify(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariantClass g_variant_classify (GVariant *value);
```
"""
function g_variant_classify(value)
    @ccall libaravis.g_variant_classify(value::Ptr{GVariant})::GVariantClass
end

"""
    g_variant_new_boolean(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_new_boolean (gboolean value);
```
"""
function g_variant_new_boolean(value)
    @ccall libaravis.g_variant_new_boolean(value::gboolean)::Ptr{GVariant}
end

"""
    g_variant_new_byte(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_new_byte (guint8 value);
```
"""
function g_variant_new_byte(value)
    @ccall libaravis.g_variant_new_byte(value::guint8)::Ptr{GVariant}
end

"""
    g_variant_new_int16(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_new_int16 (gint16 value);
```
"""
function g_variant_new_int16(value)
    @ccall libaravis.g_variant_new_int16(value::gint16)::Ptr{GVariant}
end

"""
    g_variant_new_uint16(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_new_uint16 (guint16 value);
```
"""
function g_variant_new_uint16(value)
    @ccall libaravis.g_variant_new_uint16(value::guint16)::Ptr{GVariant}
end

"""
    g_variant_new_int32(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_new_int32 (gint32 value);
```
"""
function g_variant_new_int32(value)
    @ccall libaravis.g_variant_new_int32(value::gint32)::Ptr{GVariant}
end

"""
    g_variant_new_uint32(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_new_uint32 (guint32 value);
```
"""
function g_variant_new_uint32(value)
    @ccall libaravis.g_variant_new_uint32(value::guint32)::Ptr{GVariant}
end

"""
    g_variant_new_int64(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_new_int64 (gint64 value);
```
"""
function g_variant_new_int64(value)
    @ccall libaravis.g_variant_new_int64(value::gint64)::Ptr{GVariant}
end

"""
    g_variant_new_uint64(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_new_uint64 (guint64 value);
```
"""
function g_variant_new_uint64(value)
    @ccall libaravis.g_variant_new_uint64(value::guint64)::Ptr{GVariant}
end

"""
    g_variant_new_handle(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_new_handle (gint32 value);
```
"""
function g_variant_new_handle(value)
    @ccall libaravis.g_variant_new_handle(value::gint32)::Ptr{GVariant}
end

"""
    g_variant_new_double(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_new_double (gdouble value);
```
"""
function g_variant_new_double(value)
    @ccall libaravis.g_variant_new_double(value::gdouble)::Ptr{GVariant}
end

"""
    g_variant_new_string(string)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_new_string (const gchar *string);
```
"""
function g_variant_new_string(string)
    @ccall libaravis.g_variant_new_string(string::Ptr{gchar})::Ptr{GVariant}
end

"""
    g_variant_new_take_string(string)

### Prototype
```c
GLIB_AVAILABLE_IN_2_38 GVariant * g_variant_new_take_string (gchar *string);
```
"""
function g_variant_new_take_string(string)
    @ccall libaravis.g_variant_new_take_string(string::Ptr{gchar})::Ptr{GVariant}
end

"""
    g_variant_new_object_path(object_path)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_new_object_path (const gchar *object_path);
```
"""
function g_variant_new_object_path(object_path)
    @ccall libaravis.g_variant_new_object_path(object_path::Ptr{gchar})::Ptr{GVariant}
end

"""
    g_variant_is_object_path(string)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_variant_is_object_path (const gchar *string);
```
"""
function g_variant_is_object_path(string)
    @ccall libaravis.g_variant_is_object_path(string::Ptr{gchar})::gboolean
end

"""
    g_variant_new_signature(signature)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_new_signature (const gchar *signature);
```
"""
function g_variant_new_signature(signature)
    @ccall libaravis.g_variant_new_signature(signature::Ptr{gchar})::Ptr{GVariant}
end

"""
    g_variant_is_signature(string)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_variant_is_signature (const gchar *string);
```
"""
function g_variant_is_signature(string)
    @ccall libaravis.g_variant_is_signature(string::Ptr{gchar})::gboolean
end

"""
    g_variant_new_variant(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_new_variant (GVariant *value);
```
"""
function g_variant_new_variant(value)
    @ccall libaravis.g_variant_new_variant(value::Ptr{GVariant})::Ptr{GVariant}
end

"""
    g_variant_new_strv(strv, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_new_strv (const gchar * const *strv, gssize length);
```
"""
function g_variant_new_strv(strv, length)
    @ccall libaravis.g_variant_new_strv(strv::Ptr{Ptr{gchar}}, length::gssize)::Ptr{GVariant}
end

"""
    g_variant_new_objv(strv, length)

### Prototype
```c
GLIB_AVAILABLE_IN_2_30 GVariant * g_variant_new_objv (const gchar * const *strv, gssize length);
```
"""
function g_variant_new_objv(strv, length)
    @ccall libaravis.g_variant_new_objv(strv::Ptr{Ptr{gchar}}, length::gssize)::Ptr{GVariant}
end

"""
    g_variant_new_bytestring(string)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_new_bytestring (const gchar *string);
```
"""
function g_variant_new_bytestring(string)
    @ccall libaravis.g_variant_new_bytestring(string::Ptr{gchar})::Ptr{GVariant}
end

"""
    g_variant_new_bytestring_array(strv, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_new_bytestring_array (const gchar * const *strv, gssize length);
```
"""
function g_variant_new_bytestring_array(strv, length)
    @ccall libaravis.g_variant_new_bytestring_array(strv::Ptr{Ptr{gchar}}, length::gssize)::Ptr{GVariant}
end

"""
    g_variant_new_fixed_array(element_type, elements, n_elements, element_size)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_new_fixed_array (const GVariantType *element_type, gconstpointer elements, gsize n_elements, gsize element_size);
```
"""
function g_variant_new_fixed_array(element_type, elements, n_elements, element_size)
    @ccall libaravis.g_variant_new_fixed_array(element_type::Ptr{GVariantType}, elements::gconstpointer, n_elements::gsize, element_size::gsize)::Ptr{GVariant}
end

"""
    g_variant_get_boolean(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_variant_get_boolean (GVariant *value);
```
"""
function g_variant_get_boolean(value)
    @ccall libaravis.g_variant_get_boolean(value::Ptr{GVariant})::gboolean
end

"""
    g_variant_get_byte(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint8 g_variant_get_byte (GVariant *value);
```
"""
function g_variant_get_byte(value)
    @ccall libaravis.g_variant_get_byte(value::Ptr{GVariant})::guint8
end

"""
    g_variant_get_int16(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint16 g_variant_get_int16 (GVariant *value);
```
"""
function g_variant_get_int16(value)
    @ccall libaravis.g_variant_get_int16(value::Ptr{GVariant})::gint16
end

"""
    g_variant_get_uint16(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint16 g_variant_get_uint16 (GVariant *value);
```
"""
function g_variant_get_uint16(value)
    @ccall libaravis.g_variant_get_uint16(value::Ptr{GVariant})::guint16
end

"""
    g_variant_get_int32(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint32 g_variant_get_int32 (GVariant *value);
```
"""
function g_variant_get_int32(value)
    @ccall libaravis.g_variant_get_int32(value::Ptr{GVariant})::gint32
end

"""
    g_variant_get_uint32(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint32 g_variant_get_uint32 (GVariant *value);
```
"""
function g_variant_get_uint32(value)
    @ccall libaravis.g_variant_get_uint32(value::Ptr{GVariant})::guint32
end

"""
    g_variant_get_int64(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint64 g_variant_get_int64 (GVariant *value);
```
"""
function g_variant_get_int64(value)
    @ccall libaravis.g_variant_get_int64(value::Ptr{GVariant})::gint64
end

"""
    g_variant_get_uint64(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint64 g_variant_get_uint64 (GVariant *value);
```
"""
function g_variant_get_uint64(value)
    @ccall libaravis.g_variant_get_uint64(value::Ptr{GVariant})::guint64
end

"""
    g_variant_get_handle(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint32 g_variant_get_handle (GVariant *value);
```
"""
function g_variant_get_handle(value)
    @ccall libaravis.g_variant_get_handle(value::Ptr{GVariant})::gint32
end

"""
    g_variant_get_double(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gdouble g_variant_get_double (GVariant *value);
```
"""
function g_variant_get_double(value)
    @ccall libaravis.g_variant_get_double(value::Ptr{GVariant})::gdouble
end

"""
    g_variant_get_variant(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_get_variant (GVariant *value);
```
"""
function g_variant_get_variant(value)
    @ccall libaravis.g_variant_get_variant(value::Ptr{GVariant})::Ptr{GVariant}
end

"""
    g_variant_get_string(value, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_variant_get_string (GVariant *value, gsize *length);
```
"""
function g_variant_get_string(value, length)
    @ccall libaravis.g_variant_get_string(value::Ptr{GVariant}, length::Ptr{gsize})::Ptr{gchar}
end

"""
    g_variant_dup_string(value, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar * g_variant_dup_string (GVariant *value, gsize *length);
```
"""
function g_variant_dup_string(value, length)
    @ccall libaravis.g_variant_dup_string(value::Ptr{GVariant}, length::Ptr{gsize})::Ptr{gchar}
end

"""
    g_variant_get_strv(value, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar ** g_variant_get_strv (GVariant *value, gsize *length);
```
"""
function g_variant_get_strv(value, length)
    @ccall libaravis.g_variant_get_strv(value::Ptr{GVariant}, length::Ptr{gsize})::Ptr{Ptr{gchar}}
end

"""
    g_variant_dup_strv(value, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar ** g_variant_dup_strv (GVariant *value, gsize *length);
```
"""
function g_variant_dup_strv(value, length)
    @ccall libaravis.g_variant_dup_strv(value::Ptr{GVariant}, length::Ptr{gsize})::Ptr{Ptr{gchar}}
end

"""
    g_variant_get_objv(value, length)

### Prototype
```c
GLIB_AVAILABLE_IN_2_30 const gchar ** g_variant_get_objv (GVariant *value, gsize *length);
```
"""
function g_variant_get_objv(value, length)
    @ccall libaravis.g_variant_get_objv(value::Ptr{GVariant}, length::Ptr{gsize})::Ptr{Ptr{gchar}}
end

"""
    g_variant_dup_objv(value, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar ** g_variant_dup_objv (GVariant *value, gsize *length);
```
"""
function g_variant_dup_objv(value, length)
    @ccall libaravis.g_variant_dup_objv(value::Ptr{GVariant}, length::Ptr{gsize})::Ptr{Ptr{gchar}}
end

"""
    g_variant_get_bytestring(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_variant_get_bytestring (GVariant *value);
```
"""
function g_variant_get_bytestring(value)
    @ccall libaravis.g_variant_get_bytestring(value::Ptr{GVariant})::Ptr{gchar}
end

"""
    g_variant_dup_bytestring(value, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar * g_variant_dup_bytestring (GVariant *value, gsize *length);
```
"""
function g_variant_dup_bytestring(value, length)
    @ccall libaravis.g_variant_dup_bytestring(value::Ptr{GVariant}, length::Ptr{gsize})::Ptr{gchar}
end

"""
    g_variant_get_bytestring_array(value, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar ** g_variant_get_bytestring_array (GVariant *value, gsize *length);
```
"""
function g_variant_get_bytestring_array(value, length)
    @ccall libaravis.g_variant_get_bytestring_array(value::Ptr{GVariant}, length::Ptr{gsize})::Ptr{Ptr{gchar}}
end

"""
    g_variant_dup_bytestring_array(value, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar ** g_variant_dup_bytestring_array (GVariant *value, gsize *length);
```
"""
function g_variant_dup_bytestring_array(value, length)
    @ccall libaravis.g_variant_dup_bytestring_array(value::Ptr{GVariant}, length::Ptr{gsize})::Ptr{Ptr{gchar}}
end

"""
    g_variant_new_maybe(child_type, child)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_new_maybe (const GVariantType *child_type, GVariant *child);
```
"""
function g_variant_new_maybe(child_type, child)
    @ccall libaravis.g_variant_new_maybe(child_type::Ptr{GVariantType}, child::Ptr{GVariant})::Ptr{GVariant}
end

"""
    g_variant_new_array(child_type, children, n_children)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_new_array (const GVariantType *child_type, GVariant * const *children, gsize n_children);
```
"""
function g_variant_new_array(child_type, children, n_children)
    @ccall libaravis.g_variant_new_array(child_type::Ptr{GVariantType}, children::Ptr{Ptr{GVariant}}, n_children::gsize)::Ptr{GVariant}
end

"""
    g_variant_new_tuple(children, n_children)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_new_tuple (GVariant * const *children, gsize n_children);
```
"""
function g_variant_new_tuple(children, n_children)
    @ccall libaravis.g_variant_new_tuple(children::Ptr{Ptr{GVariant}}, n_children::gsize)::Ptr{GVariant}
end

"""
    g_variant_new_dict_entry(key, value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_new_dict_entry (GVariant *key, GVariant *value);
```
"""
function g_variant_new_dict_entry(key, value)
    @ccall libaravis.g_variant_new_dict_entry(key::Ptr{GVariant}, value::Ptr{GVariant})::Ptr{GVariant}
end

"""
    g_variant_get_maybe(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_get_maybe (GVariant *value);
```
"""
function g_variant_get_maybe(value)
    @ccall libaravis.g_variant_get_maybe(value::Ptr{GVariant})::Ptr{GVariant}
end

"""
    g_variant_n_children(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gsize g_variant_n_children (GVariant *value);
```
"""
function g_variant_n_children(value)
    @ccall libaravis.g_variant_n_children(value::Ptr{GVariant})::gsize
end

"""
    g_variant_get_child_value(value, index_)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_get_child_value (GVariant *value, gsize index_);
```
"""
function g_variant_get_child_value(value, index_)
    @ccall libaravis.g_variant_get_child_value(value::Ptr{GVariant}, index_::gsize)::Ptr{GVariant}
end

"""
    g_variant_lookup_value(dictionary, key, expected_type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_lookup_value (GVariant *dictionary, const gchar *key, const GVariantType *expected_type);
```
"""
function g_variant_lookup_value(dictionary, key, expected_type)
    @ccall libaravis.g_variant_lookup_value(dictionary::Ptr{GVariant}, key::Ptr{gchar}, expected_type::Ptr{GVariantType})::Ptr{GVariant}
end

"""
    g_variant_get_fixed_array(value, n_elements, element_size)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gconstpointer g_variant_get_fixed_array (GVariant *value, gsize *n_elements, gsize element_size);
```
"""
function g_variant_get_fixed_array(value, n_elements, element_size)
    @ccall libaravis.g_variant_get_fixed_array(value::Ptr{GVariant}, n_elements::Ptr{gsize}, element_size::gsize)::gconstpointer
end

"""
    g_variant_get_size(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gsize g_variant_get_size (GVariant *value);
```
"""
function g_variant_get_size(value)
    @ccall libaravis.g_variant_get_size(value::Ptr{GVariant})::gsize
end

"""
    g_variant_get_data(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gconstpointer g_variant_get_data (GVariant *value);
```
"""
function g_variant_get_data(value)
    @ccall libaravis.g_variant_get_data(value::Ptr{GVariant})::gconstpointer
end

"""
    g_variant_get_data_as_bytes(value)

### Prototype
```c
GLIB_AVAILABLE_IN_2_36 GBytes * g_variant_get_data_as_bytes (GVariant *value);
```
"""
function g_variant_get_data_as_bytes(value)
    @ccall libaravis.g_variant_get_data_as_bytes(value::Ptr{GVariant})::Ptr{GBytes}
end

"""
    g_variant_store(value, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_variant_store (GVariant *value, gpointer data);
```
"""
function g_variant_store(value, data)
    @ccall libaravis.g_variant_store(value::Ptr{GVariant}, data::gpointer)::Cvoid
end

"""
    g_variant_print_string(value, string, type_annotate)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GString * g_variant_print_string (GVariant *value, GString *string, gboolean type_annotate);
```
"""
function g_variant_print_string(value, string, type_annotate)
    @ccall libaravis.g_variant_print_string(value::Ptr{GVariant}, string::Ptr{GString}, type_annotate::gboolean)::Ptr{GString}
end

"""
    g_variant_hash(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_variant_hash (gconstpointer value);
```
"""
function g_variant_hash(value)
    @ccall libaravis.g_variant_hash(value::gconstpointer)::guint
end

"""
    g_variant_get_normal_form(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_get_normal_form (GVariant *value);
```
"""
function g_variant_get_normal_form(value)
    @ccall libaravis.g_variant_get_normal_form(value::Ptr{GVariant})::Ptr{GVariant}
end

"""
    g_variant_is_normal_form(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_variant_is_normal_form (GVariant *value);
```
"""
function g_variant_is_normal_form(value)
    @ccall libaravis.g_variant_is_normal_form(value::Ptr{GVariant})::gboolean
end

"""
    g_variant_byteswap(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_byteswap (GVariant *value);
```
"""
function g_variant_byteswap(value)
    @ccall libaravis.g_variant_byteswap(value::Ptr{GVariant})::Ptr{GVariant}
end

"""
    g_variant_new_from_bytes(type, bytes, trusted)

### Prototype
```c
GLIB_AVAILABLE_IN_2_36 GVariant * g_variant_new_from_bytes (const GVariantType *type, GBytes *bytes, gboolean trusted);
```
"""
function g_variant_new_from_bytes(type, bytes, trusted)
    @ccall libaravis.g_variant_new_from_bytes(type::Ptr{GVariantType}, bytes::Ptr{GBytes}, trusted::gboolean)::Ptr{GVariant}
end

"""
    g_variant_new_from_data(type, data, size, trusted, notify, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_new_from_data (const GVariantType *type, gconstpointer data, gsize size, gboolean trusted, GDestroyNotify notify, gpointer user_data);
```
"""
function g_variant_new_from_data(type, data, size, trusted, notify, user_data)
    @ccall libaravis.g_variant_new_from_data(type::Ptr{GVariantType}, data::gconstpointer, size::gsize, trusted::gboolean, notify::GDestroyNotify, user_data::gpointer)::Ptr{GVariant}
end

struct _GVariantIter
    x::NTuple{16, guintptr}
end

const GVariantIter = _GVariantIter

"""
    g_variant_iter_new(value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariantIter * g_variant_iter_new (GVariant *value);
```
"""
function g_variant_iter_new(value)
    @ccall libaravis.g_variant_iter_new(value::Ptr{GVariant})::Ptr{GVariantIter}
end

"""
    g_variant_iter_init(iter, value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gsize g_variant_iter_init (GVariantIter *iter, GVariant *value);
```
"""
function g_variant_iter_init(iter, value)
    @ccall libaravis.g_variant_iter_init(iter::Ptr{GVariantIter}, value::Ptr{GVariant})::gsize
end

"""
    g_variant_iter_copy(iter)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariantIter * g_variant_iter_copy (GVariantIter *iter);
```
"""
function g_variant_iter_copy(iter)
    @ccall libaravis.g_variant_iter_copy(iter::Ptr{GVariantIter})::Ptr{GVariantIter}
end

"""
    g_variant_iter_n_children(iter)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gsize g_variant_iter_n_children (GVariantIter *iter);
```
"""
function g_variant_iter_n_children(iter)
    @ccall libaravis.g_variant_iter_n_children(iter::Ptr{GVariantIter})::gsize
end

"""
    g_variant_iter_free(iter)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_variant_iter_free (GVariantIter *iter);
```
"""
function g_variant_iter_free(iter)
    @ccall libaravis.g_variant_iter_free(iter::Ptr{GVariantIter})::Cvoid
end

"""
    g_variant_iter_next_value(iter)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_iter_next_value (GVariantIter *iter);
```
"""
function g_variant_iter_next_value(iter)
    @ccall libaravis.g_variant_iter_next_value(iter::Ptr{GVariantIter})::Ptr{GVariant}
end

struct __JL_Ctag_29
    data::NTuple{128, UInt8}
end

function Base.getproperty(x::Ptr{__JL_Ctag_29}, f::Symbol)
    f === :s && return Ptr{__JL_Ctag_30}(x + 0)
    f === :x && return Ptr{NTuple{16, guintptr}}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::__JL_Ctag_29, f::Symbol)
    r = Ref{__JL_Ctag_29}(x)
    ptr = Base.unsafe_convert(Ptr{__JL_Ctag_29}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{__JL_Ctag_29}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::__JL_Ctag_29, private::Bool = false)
    (:s, :x, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

struct _GVariantBuilder
    data::NTuple{128, UInt8}
end

function Base.getproperty(x::Ptr{_GVariantBuilder}, f::Symbol)
    f === :u && return Ptr{__JL_Ctag_29}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::_GVariantBuilder, f::Symbol)
    r = Ref{_GVariantBuilder}(x)
    ptr = Base.unsafe_convert(Ptr{_GVariantBuilder}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{_GVariantBuilder}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::_GVariantBuilder, private::Bool = false)
    (:u, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

const GVariantBuilder = _GVariantBuilder

@cenum GVariantParseError::UInt32 begin
    G_VARIANT_PARSE_ERROR_FAILED = 0
    G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED = 1
    G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE = 2
    G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED = 3
    G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END = 4
    G_VARIANT_PARSE_ERROR_INVALID_CHARACTER = 5
    G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING = 6
    G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH = 7
    G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE = 8
    G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING = 9
    G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE = 10
    G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE = 11
    G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG = 12
    G_VARIANT_PARSE_ERROR_TYPE_ERROR = 13
    G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN = 14
    G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD = 15
    G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT = 16
    G_VARIANT_PARSE_ERROR_VALUE_EXPECTED = 17
    G_VARIANT_PARSE_ERROR_RECURSION = 18
end

"""
    g_variant_parser_get_error_quark()

### Prototype
```c
GLIB_DEPRECATED_IN_2_38_FOR(g_variant_parse_error_quark) GQuark g_variant_parser_get_error_quark (void);
```
"""
function g_variant_parser_get_error_quark()
    @ccall libaravis.g_variant_parser_get_error_quark()::GQuark
end

"""
    g_variant_builder_new(type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariantBuilder * g_variant_builder_new (const GVariantType *type);
```
"""
function g_variant_builder_new(type)
    @ccall libaravis.g_variant_builder_new(type::Ptr{GVariantType})::Ptr{GVariantBuilder}
end

"""
    g_variant_builder_unref(builder)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_variant_builder_unref (GVariantBuilder *builder);
```
"""
function g_variant_builder_unref(builder)
    @ccall libaravis.g_variant_builder_unref(builder::Ptr{GVariantBuilder})::Cvoid
end

"""
    g_variant_builder_ref(builder)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariantBuilder * g_variant_builder_ref (GVariantBuilder *builder);
```
"""
function g_variant_builder_ref(builder)
    @ccall libaravis.g_variant_builder_ref(builder::Ptr{GVariantBuilder})::Ptr{GVariantBuilder}
end

"""
    g_variant_builder_init(builder, type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_variant_builder_init (GVariantBuilder *builder, const GVariantType *type);
```
"""
function g_variant_builder_init(builder, type)
    @ccall libaravis.g_variant_builder_init(builder::Ptr{GVariantBuilder}, type::Ptr{GVariantType})::Cvoid
end

"""
    g_variant_builder_init_static(builder, type)

### Prototype
```c
GLIB_AVAILABLE_IN_2_84 void g_variant_builder_init_static (GVariantBuilder *builder, const GVariantType *type);
```
"""
function g_variant_builder_init_static(builder, type)
    @ccall libaravis.g_variant_builder_init_static(builder::Ptr{GVariantBuilder}, type::Ptr{GVariantType})::Cvoid
end

"""
    g_variant_builder_end(builder)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_builder_end (GVariantBuilder *builder);
```
"""
function g_variant_builder_end(builder)
    @ccall libaravis.g_variant_builder_end(builder::Ptr{GVariantBuilder})::Ptr{GVariant}
end

"""
    g_variant_builder_clear(builder)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_variant_builder_clear (GVariantBuilder *builder);
```
"""
function g_variant_builder_clear(builder)
    @ccall libaravis.g_variant_builder_clear(builder::Ptr{GVariantBuilder})::Cvoid
end

"""
    g_variant_builder_open(builder, type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_variant_builder_open (GVariantBuilder *builder, const GVariantType *type);
```
"""
function g_variant_builder_open(builder, type)
    @ccall libaravis.g_variant_builder_open(builder::Ptr{GVariantBuilder}, type::Ptr{GVariantType})::Cvoid
end

"""
    g_variant_builder_close(builder)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_variant_builder_close (GVariantBuilder *builder);
```
"""
function g_variant_builder_close(builder)
    @ccall libaravis.g_variant_builder_close(builder::Ptr{GVariantBuilder})::Cvoid
end

"""
    g_variant_builder_add_value(builder, value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_variant_builder_add_value (GVariantBuilder *builder, GVariant *value);
```
"""
function g_variant_builder_add_value(builder, value)
    @ccall libaravis.g_variant_builder_add_value(builder::Ptr{GVariantBuilder}, value::Ptr{GVariant})::Cvoid
end

"""
    g_variant_check_format_string(value, format_string, copy_only)

### Prototype
```c
GLIB_AVAILABLE_IN_2_34 gboolean g_variant_check_format_string (GVariant *value, const gchar *format_string, gboolean copy_only);
```
"""
function g_variant_check_format_string(value, format_string, copy_only)
    @ccall libaravis.g_variant_check_format_string(value::Ptr{GVariant}, format_string::Ptr{gchar}, copy_only::gboolean)::gboolean
end

"""
    g_variant_parse(type, text, limit, endptr, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GVariant * g_variant_parse (const GVariantType *type, const gchar *text, const gchar *limit, const gchar **endptr, GError **error);
```
"""
function g_variant_parse(type, text, limit, endptr, error)
    @ccall libaravis.g_variant_parse(type::Ptr{GVariantType}, text::Ptr{gchar}, limit::Ptr{gchar}, endptr::Ptr{Ptr{gchar}}, error::Ptr{Ptr{GError}})::Ptr{GVariant}
end

"""
    g_variant_parse_error_print_context(error, source_str)

### Prototype
```c
GLIB_AVAILABLE_IN_2_40 gchar * g_variant_parse_error_print_context (GError *error, const gchar *source_str);
```
"""
function g_variant_parse_error_print_context(error, source_str)
    @ccall libaravis.g_variant_parse_error_print_context(error::Ptr{GError}, source_str::Ptr{gchar})::Ptr{gchar}
end

"""
    g_variant_compare(one, two)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_variant_compare (gconstpointer one, gconstpointer two);
```
"""
function g_variant_compare(one, two)
    @ccall libaravis.g_variant_compare(one::gconstpointer, two::gconstpointer)::gint
end

struct __JL_Ctag_31
    data::NTuple{128, UInt8}
end

function Base.getproperty(x::Ptr{__JL_Ctag_31}, f::Symbol)
    f === :s && return Ptr{__JL_Ctag_32}(x + 0)
    f === :x && return Ptr{NTuple{16, guintptr}}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::__JL_Ctag_31, f::Symbol)
    r = Ref{__JL_Ctag_31}(x)
    ptr = Base.unsafe_convert(Ptr{__JL_Ctag_31}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{__JL_Ctag_31}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::__JL_Ctag_31, private::Bool = false)
    (:s, :x, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

struct _GVariantDict
    data::NTuple{128, UInt8}
end

function Base.getproperty(x::Ptr{_GVariantDict}, f::Symbol)
    f === :u && return Ptr{__JL_Ctag_31}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::_GVariantDict, f::Symbol)
    r = Ref{_GVariantDict}(x)
    ptr = Base.unsafe_convert(Ptr{_GVariantDict}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{_GVariantDict}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::_GVariantDict, private::Bool = false)
    (:u, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

const GVariantDict = _GVariantDict

"""
    g_variant_dict_new(from_asv)

### Prototype
```c
GLIB_AVAILABLE_IN_2_40 GVariantDict * g_variant_dict_new (GVariant *from_asv);
```
"""
function g_variant_dict_new(from_asv)
    @ccall libaravis.g_variant_dict_new(from_asv::Ptr{GVariant})::Ptr{GVariantDict}
end

"""
    g_variant_dict_init(dict, from_asv)

### Prototype
```c
GLIB_AVAILABLE_IN_2_40 void g_variant_dict_init (GVariantDict *dict, GVariant *from_asv);
```
"""
function g_variant_dict_init(dict, from_asv)
    @ccall libaravis.g_variant_dict_init(dict::Ptr{GVariantDict}, from_asv::Ptr{GVariant})::Cvoid
end

"""
    g_variant_dict_lookup_value(dict, key, expected_type)

### Prototype
```c
GLIB_AVAILABLE_IN_2_40 GVariant * g_variant_dict_lookup_value (GVariantDict *dict, const gchar *key, const GVariantType *expected_type);
```
"""
function g_variant_dict_lookup_value(dict, key, expected_type)
    @ccall libaravis.g_variant_dict_lookup_value(dict::Ptr{GVariantDict}, key::Ptr{gchar}, expected_type::Ptr{GVariantType})::Ptr{GVariant}
end

"""
    g_variant_dict_contains(dict, key)

### Prototype
```c
GLIB_AVAILABLE_IN_2_40 gboolean g_variant_dict_contains (GVariantDict *dict, const gchar *key);
```
"""
function g_variant_dict_contains(dict, key)
    @ccall libaravis.g_variant_dict_contains(dict::Ptr{GVariantDict}, key::Ptr{gchar})::gboolean
end

"""
    g_variant_dict_insert_value(dict, key, value)

### Prototype
```c
GLIB_AVAILABLE_IN_2_40 void g_variant_dict_insert_value (GVariantDict *dict, const gchar *key, GVariant *value);
```
"""
function g_variant_dict_insert_value(dict, key, value)
    @ccall libaravis.g_variant_dict_insert_value(dict::Ptr{GVariantDict}, key::Ptr{gchar}, value::Ptr{GVariant})::Cvoid
end

"""
    g_variant_dict_remove(dict, key)

### Prototype
```c
GLIB_AVAILABLE_IN_2_40 gboolean g_variant_dict_remove (GVariantDict *dict, const gchar *key);
```
"""
function g_variant_dict_remove(dict, key)
    @ccall libaravis.g_variant_dict_remove(dict::Ptr{GVariantDict}, key::Ptr{gchar})::gboolean
end

"""
    g_variant_dict_clear(dict)

### Prototype
```c
GLIB_AVAILABLE_IN_2_40 void g_variant_dict_clear (GVariantDict *dict);
```
"""
function g_variant_dict_clear(dict)
    @ccall libaravis.g_variant_dict_clear(dict::Ptr{GVariantDict})::Cvoid
end

"""
    g_variant_dict_end(dict)

### Prototype
```c
GLIB_AVAILABLE_IN_2_40 GVariant * g_variant_dict_end (GVariantDict *dict);
```
"""
function g_variant_dict_end(dict)
    @ccall libaravis.g_variant_dict_end(dict::Ptr{GVariantDict})::Ptr{GVariant}
end

"""
    g_variant_dict_ref(dict)

### Prototype
```c
GLIB_AVAILABLE_IN_2_40 GVariantDict * g_variant_dict_ref (GVariantDict *dict);
```
"""
function g_variant_dict_ref(dict)
    @ccall libaravis.g_variant_dict_ref(dict::Ptr{GVariantDict})::Ptr{GVariantDict}
end

"""
    g_variant_dict_unref(dict)

### Prototype
```c
GLIB_AVAILABLE_IN_2_40 void g_variant_dict_unref (GVariantDict *dict);
```
"""
function g_variant_dict_unref(dict)
    @ccall libaravis.g_variant_dict_unref(dict::Ptr{GVariantDict})::Cvoid
end

@cenum GLogLevelFlags::Int32 begin
    G_LOG_FLAG_RECURSION = 1
    G_LOG_FLAG_FATAL = 2
    G_LOG_LEVEL_ERROR = 4
    G_LOG_LEVEL_CRITICAL = 8
    G_LOG_LEVEL_WARNING = 16
    G_LOG_LEVEL_MESSAGE = 32
    G_LOG_LEVEL_INFO = 64
    G_LOG_LEVEL_DEBUG = 128
    G_LOG_LEVEL_MASK = -4
end

# typedef void ( * GLogFunc ) ( const gchar * log_domain , GLogLevelFlags log_level , const gchar * message , gpointer user_data )
const GLogFunc = Ptr{Cvoid}

"""
    g_log_set_handler(log_domain, log_levels, log_func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_log_set_handler (const gchar *log_domain, GLogLevelFlags log_levels, GLogFunc log_func, gpointer user_data);
```
"""
function g_log_set_handler(log_domain, log_levels, log_func, user_data)
    @ccall libaravis.g_log_set_handler(log_domain::Ptr{gchar}, log_levels::GLogLevelFlags, log_func::GLogFunc, user_data::gpointer)::guint
end

"""
    g_log_set_handler_full(log_domain, log_levels, log_func, user_data, destroy)

### Prototype
```c
GLIB_AVAILABLE_IN_2_46 guint g_log_set_handler_full (const gchar *log_domain, GLogLevelFlags log_levels, GLogFunc log_func, gpointer user_data, GDestroyNotify destroy);
```
"""
function g_log_set_handler_full(log_domain, log_levels, log_func, user_data, destroy)
    @ccall libaravis.g_log_set_handler_full(log_domain::Ptr{gchar}, log_levels::GLogLevelFlags, log_func::GLogFunc, user_data::gpointer, destroy::GDestroyNotify)::guint
end

"""
    g_log_remove_handler(log_domain, handler_id)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_log_remove_handler (const gchar *log_domain, guint handler_id);
```
"""
function g_log_remove_handler(log_domain, handler_id)
    @ccall libaravis.g_log_remove_handler(log_domain::Ptr{gchar}, handler_id::guint)::Cvoid
end

"""
    g_log_default_handler(log_domain, log_level, message, unused_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_log_default_handler (const gchar *log_domain, GLogLevelFlags log_level, const gchar *message, gpointer unused_data);
```
"""
function g_log_default_handler(log_domain, log_level, message, unused_data)
    @ccall libaravis.g_log_default_handler(log_domain::Ptr{gchar}, log_level::GLogLevelFlags, message::Ptr{gchar}, unused_data::gpointer)::Cvoid
end

"""
    g_log_set_default_handler(log_func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GLogFunc g_log_set_default_handler (GLogFunc log_func, gpointer user_data);
```
"""
function g_log_set_default_handler(log_func, user_data)
    @ccall libaravis.g_log_set_default_handler(log_func::GLogFunc, user_data::gpointer)::GLogFunc
end

"""
    g_log_set_fatal_mask(log_domain, fatal_mask)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GLogLevelFlags g_log_set_fatal_mask (const gchar *log_domain, GLogLevelFlags fatal_mask);
```
"""
function g_log_set_fatal_mask(log_domain, fatal_mask)
    @ccall libaravis.g_log_set_fatal_mask(log_domain::Ptr{gchar}, fatal_mask::GLogLevelFlags)::GLogLevelFlags
end

"""
    g_log_set_always_fatal(fatal_mask)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GLogLevelFlags g_log_set_always_fatal (GLogLevelFlags fatal_mask);
```
"""
function g_log_set_always_fatal(fatal_mask)
    @ccall libaravis.g_log_set_always_fatal(fatal_mask::GLogLevelFlags)::GLogLevelFlags
end

"""
    g_log_get_always_fatal()

### Prototype
```c
GLIB_AVAILABLE_IN_2_86 GLogLevelFlags g_log_get_always_fatal (void);
```
"""
function g_log_get_always_fatal()
    @ccall libaravis.g_log_get_always_fatal()::GLogLevelFlags
end

"""
    GLogWriterOutput

[`GLogWriterOutput`](@ref): \\_LOG\\_WRITER\\_HANDLED: Log writer has handled the log entry. \\_LOG\\_WRITER\\_UNHANDLED: Log writer could not handle the log entry.

Return values from #GLogWriterFuncs to indicate whether the given log entry was successfully handled by the writer, or whether there was an error in handling it (and hence a fallback writer should be used).

If a #[`GLogWriterFunc`](@ref) ignores a log entry, it should return G\\_LOG\\_WRITER\\_HANDLED.

Since: 2.50
"""
@cenum GLogWriterOutput::UInt32 begin
    G_LOG_WRITER_HANDLED = 1
    G_LOG_WRITER_UNHANDLED = 0
end

struct _GLogField
    key::Ptr{gchar}
    value::gconstpointer
    length::gssize
end

"""
[`GLogField`](@ref): : field name (UTF-8 string) : field value (arbitrary bytes) : length of , in bytes, or -1 if it is nul-terminated

Structure representing a single field in a structured log entry. See [`g_log_structured`](@ref)() for details.

Log fields may contain arbitrary values, including binary with embedded nul bytes. If the field contains a string, the string must be UTF-8 encoded and have a trailing nul byte. Otherwise,  must be set to a non-negative value.

Since: 2.50
"""
const GLogField = _GLogField

# typedef GLogWriterOutput ( * GLogWriterFunc ) ( GLogLevelFlags log_level , const GLogField * fields , gsize n_fields , gpointer user_data )
"""
[`GLogWriterFunc`](@ref): \\_level: log level of the message : (array length=n\\_fields): fields forming the message \\_fields: number of  \\_data: user data passed to [`g_log_set_writer_func`](@ref)()

Writer function for log entries. A log entry is a collection of one or more #GLogFields, using the standard [field names from journal specification](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html). See [`g_log_structured`](@ref)() for more information.

Writer functions must ignore fields which they do not recognise, unless they can write arbitrary binary output, as field values may be arbitrary binary.

\\_level is guaranteed to be included in  as the `PRIORITY` field, but is provided separately for convenience of deciding whether or where to output the log entry.

Writer functions should return G\\_LOG\\_WRITER\\_HANDLED if they handled the log message successfully or if they deliberately ignored it. If there was an error handling the message (for example, if the writer function is meant to send messages to a remote logging server and there is a network error), it should return G\\_LOG\\_WRITER\\_UNHANDLED. This allows writer functions to be chained and fall back to simpler handlers in case of failure.

Returns: G\\_LOG\\_WRITER\\_HANDLED if the log entry was handled successfully; G\\_LOG\\_WRITER\\_UNHANDLED otherwise

Since: 2.50
"""
const GLogWriterFunc = Ptr{Cvoid}

"""
    g_log_structured_array(log_level, fields, n_fields)

### Prototype
```c
GLIB_AVAILABLE_IN_2_50 void g_log_structured_array (GLogLevelFlags log_level, const GLogField *fields, gsize n_fields);
```
"""
function g_log_structured_array(log_level, fields, n_fields)
    @ccall libaravis.g_log_structured_array(log_level::GLogLevelFlags, fields::Ptr{GLogField}, n_fields::gsize)::Cvoid
end

"""
    g_log_variant(log_domain, log_level, fields)

### Prototype
```c
GLIB_AVAILABLE_IN_2_50 void g_log_variant (const gchar *log_domain, GLogLevelFlags log_level, GVariant *fields);
```
"""
function g_log_variant(log_domain, log_level, fields)
    @ccall libaravis.g_log_variant(log_domain::Ptr{gchar}, log_level::GLogLevelFlags, fields::Ptr{GVariant})::Cvoid
end

"""
    g_log_set_writer_func(func, user_data, user_data_free)

### Prototype
```c
GLIB_AVAILABLE_IN_2_50 void g_log_set_writer_func (GLogWriterFunc func, gpointer user_data, GDestroyNotify user_data_free);
```
"""
function g_log_set_writer_func(func, user_data, user_data_free)
    @ccall libaravis.g_log_set_writer_func(func::GLogWriterFunc, user_data::gpointer, user_data_free::GDestroyNotify)::Cvoid
end

"""
    g_log_writer_supports_color(output_fd)

### Prototype
```c
GLIB_AVAILABLE_IN_2_50 gboolean g_log_writer_supports_color (gint output_fd);
```
"""
function g_log_writer_supports_color(output_fd)
    @ccall libaravis.g_log_writer_supports_color(output_fd::gint)::gboolean
end

"""
    g_log_writer_is_journald(output_fd)

### Prototype
```c
GLIB_AVAILABLE_IN_2_50 gboolean g_log_writer_is_journald (gint output_fd);
```
"""
function g_log_writer_is_journald(output_fd)
    @ccall libaravis.g_log_writer_is_journald(output_fd::gint)::gboolean
end

"""
    g_log_writer_format_fields(log_level, fields, n_fields, use_color)

### Prototype
```c
GLIB_AVAILABLE_IN_2_50 gchar *g_log_writer_format_fields (GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gboolean use_color);
```
"""
function g_log_writer_format_fields(log_level, fields, n_fields, use_color)
    @ccall libaravis.g_log_writer_format_fields(log_level::GLogLevelFlags, fields::Ptr{GLogField}, n_fields::gsize, use_color::gboolean)::Ptr{gchar}
end

"""
    g_log_writer_syslog(log_level, fields, n_fields, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_2_80 GLogWriterOutput g_log_writer_syslog (GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data);
```
"""
function g_log_writer_syslog(log_level, fields, n_fields, user_data)
    @ccall libaravis.g_log_writer_syslog(log_level::GLogLevelFlags, fields::Ptr{GLogField}, n_fields::gsize, user_data::gpointer)::GLogWriterOutput
end

"""
    g_log_writer_journald(log_level, fields, n_fields, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_2_50 GLogWriterOutput g_log_writer_journald (GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data);
```
"""
function g_log_writer_journald(log_level, fields, n_fields, user_data)
    @ccall libaravis.g_log_writer_journald(log_level::GLogLevelFlags, fields::Ptr{GLogField}, n_fields::gsize, user_data::gpointer)::GLogWriterOutput
end

"""
    g_log_writer_standard_streams(log_level, fields, n_fields, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_2_50 GLogWriterOutput g_log_writer_standard_streams (GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data);
```
"""
function g_log_writer_standard_streams(log_level, fields, n_fields, user_data)
    @ccall libaravis.g_log_writer_standard_streams(log_level::GLogLevelFlags, fields::Ptr{GLogField}, n_fields::gsize, user_data::gpointer)::GLogWriterOutput
end

"""
    g_log_writer_default(log_level, fields, n_fields, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_2_50 GLogWriterOutput g_log_writer_default (GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data);
```
"""
function g_log_writer_default(log_level, fields, n_fields, user_data)
    @ccall libaravis.g_log_writer_default(log_level::GLogLevelFlags, fields::Ptr{GLogField}, n_fields::gsize, user_data::gpointer)::GLogWriterOutput
end

"""
    g_log_writer_default_set_use_stderr(use_stderr)

### Prototype
```c
GLIB_AVAILABLE_IN_2_68 void g_log_writer_default_set_use_stderr (gboolean use_stderr);
```
"""
function g_log_writer_default_set_use_stderr(use_stderr)
    @ccall libaravis.g_log_writer_default_set_use_stderr(use_stderr::gboolean)::Cvoid
end

"""
    g_log_writer_default_would_drop(log_level, log_domain)

### Prototype
```c
GLIB_AVAILABLE_IN_2_68 gboolean g_log_writer_default_would_drop (GLogLevelFlags log_level, const char *log_domain);
```
"""
function g_log_writer_default_would_drop(log_level, log_domain)
    @ccall libaravis.g_log_writer_default_would_drop(log_level::GLogLevelFlags, log_domain::Cstring)::gboolean
end

"""
    g_log_writer_default_set_debug_domains(domains)

### Prototype
```c
GLIB_AVAILABLE_IN_2_80 void g_log_writer_default_set_debug_domains (const gchar * const *domains);
```
"""
function g_log_writer_default_set_debug_domains(domains)
    @ccall libaravis.g_log_writer_default_set_debug_domains(domains::Ptr{Ptr{gchar}})::Cvoid
end

"""
    g_log_get_debug_enabled()

### Prototype
```c
GLIB_AVAILABLE_IN_2_72 gboolean g_log_get_debug_enabled (void);
```
"""
function g_log_get_debug_enabled()
    @ccall libaravis.g_log_get_debug_enabled()::gboolean
end

"""
    g_log_set_debug_enabled(enabled)

### Prototype
```c
GLIB_AVAILABLE_IN_2_72 void g_log_set_debug_enabled (gboolean enabled);
```
"""
function g_log_set_debug_enabled(enabled)
    @ccall libaravis.g_log_set_debug_enabled(enabled::gboolean)::Cvoid
end

"""
    _g_log_fallback_handler(log_domain, log_level, message, unused_data)

### Prototype
```c
void _g_log_fallback_handler (const gchar *log_domain, GLogLevelFlags log_level, const gchar *message, gpointer unused_data);
```
"""
function _g_log_fallback_handler(log_domain, log_level, message, unused_data)
    @ccall libaravis._g_log_fallback_handler(log_domain::Ptr{gchar}, log_level::GLogLevelFlags, message::Ptr{gchar}, unused_data::gpointer)::Cvoid
end

"""
    g_assert_warning(log_domain, file, line, pretty_function, expression)

### Prototype
```c
G_NORETURN GLIB_DEPRECATED void g_assert_warning (const char *log_domain, const char *file, const int line, const char *pretty_function, const char *expression);
```
"""
function g_assert_warning(log_domain, file, line, pretty_function, expression)
    @ccall libaravis.g_assert_warning(log_domain::Cstring, file::Cstring, line::Cint, pretty_function::Cstring, expression::Cstring)::Cvoid
end

# typedef void ( * GPrintFunc ) ( const gchar * string )
"""
[`GPrintFunc`](@ref): : the message to output

Specifies the type of the print handler functions. These are called with the complete formatted string to output.
"""
const GPrintFunc = Ptr{Cvoid}

"""
    g_set_print_handler(func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GPrintFunc g_set_print_handler (GPrintFunc func);
```
"""
function g_set_print_handler(func)
    @ccall libaravis.g_set_print_handler(func::GPrintFunc)::GPrintFunc
end

"""
    g_set_printerr_handler(func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GPrintFunc g_set_printerr_handler (GPrintFunc func);
```
"""
function g_set_printerr_handler(func)
    @ccall libaravis.g_set_printerr_handler(func::GPrintFunc)::GPrintFunc
end

const _GOptionContext = Cvoid

"""
[`GOptionContext`](@ref):

A [`GOptionContext`](@ref) struct defines which options are accepted by the commandline option parser. The struct has only private  fields and should not be directly accessed.
"""
const GOptionContext = _GOptionContext

const _GOptionGroup = Cvoid

"""
[`GOptionGroup`](@ref):

A [`GOptionGroup`](@ref) struct defines the options in a single group. The struct has only private fields and should not be directly accessed.

All options in a group share the same translation function. Libraries which need to parse commandline options are expected to provide a function for getting a [`GOptionGroup`](@ref) holding their options, which the application can then add to its #[`GOptionContext`](@ref).
"""
const GOptionGroup = _GOptionGroup

"""
    GOptionArg

[`GOptionArg`](@ref): \\_OPTION\\_ARG\\_NONE: No extra argument. This is useful for simple flags or booleans. \\_OPTION\\_ARG\\_STRING: The option takes a UTF-8 string argument. \\_OPTION\\_ARG\\_INT: The option takes an integer argument. \\_OPTION\\_ARG\\_CALLBACK: The option provides a callback (of type #[`GOptionArgFunc`](@ref)) to parse the extra argument. \\_OPTION\\_ARG\\_FILENAME: The option takes a filename as argument, which will be in the GLib filename encoding rather than UTF-8. \\_OPTION\\_ARG\\_STRING\\_ARRAY: The option takes a string argument, multiple uses of the option are collected into an array of strings. \\_OPTION\\_ARG\\_FILENAME\\_ARRAY: The option takes a filename as argument,  multiple uses of the option are collected into an array of strings. \\_OPTION\\_ARG\\_DOUBLE: The option takes a double argument. The argument can be formatted either for the user's locale or for the "C" locale. Since 2.12 \\_OPTION\\_ARG\\_INT64: The option takes a 64-bit integer. Like G\\_OPTION\\_ARG\\_INT but for larger numbers. The number can be in decimal base, or in hexadecimal (when prefixed with `0x`, for example, `0xffffffff`). Since 2.12

The #[`GOptionArg`](@ref) enum values determine which type of extra argument the options expect to find. If an option expects an extra argument, it can be specified in several ways; with a short option: `-x arg`, with a long option: `--name arg` or combined in a single argument: `--name=arg`.
"""
@cenum GOptionArg::UInt32 begin
    G_OPTION_ARG_NONE = 0
    G_OPTION_ARG_STRING = 1
    G_OPTION_ARG_INT = 2
    G_OPTION_ARG_CALLBACK = 3
    G_OPTION_ARG_FILENAME = 4
    G_OPTION_ARG_STRING_ARRAY = 5
    G_OPTION_ARG_FILENAME_ARRAY = 6
    G_OPTION_ARG_DOUBLE = 7
    G_OPTION_ARG_INT64 = 8
end

"""
    _GOptionEntry

[`GOptionEntry`](@ref): \\_name: The long name of an option can be used to specify it in a commandline as `--long\\_name`. Every option must have a long name. To resolve conflicts if multiple option groups contain the same long name, it is also possible to specify the option as `--groupname-long\\_name`.

\\short \\_name: If an option has a short name, it can be specified `-short\\_name` in a commandline.

\\short \\_name must be a printable ASCII character different from '-', or zero if the option has no short name. : Flags from #[`GOptionFlags`](@ref)

* : The type of the option, as a #[`GOptionArg`](@ref)

* \\_data: If the

* type is G\\_OPTION\\_ARG\\_CALLBACK, then

* \\_data must point to a #[`GOptionArgFunc`](@ref) callback function, which will be called to handle the extra argument. Otherwise,

* \\_data is a pointer to a location to store the value, the required type of the location depends on the

* type:

- G\\_OPTION\\_ARG\\_NONE: gboolean - G\\_OPTION\\_ARG\\_STRING: gchar* - G\\_OPTION\\_ARG\\_INT: gint - G\\_OPTION\\_ARG\\_FILENAME: gchar* - G\\_OPTION\\_ARG\\_STRING\\_ARRAY: gchar** - G\\_OPTION\\_ARG\\_FILENAME\\_ARRAY: gchar** - G\\_OPTION\\_ARG\\_DOUBLE: gdouble

If

* type is G\\_OPTION\\_ARG\\_STRING or G\\_OPTION\\_ARG\\_FILENAME, the location will contain a newly allocated string if the option was given. That string needs to be freed by the callee using [`g_free`](@ref)(). Likewise if

* type is G\\_OPTION\\_ARG\\_STRING\\_ARRAY or G\\_OPTION\\_ARG\\_FILENAME\\_ARRAY, the data should be freed using [`g_strfreev`](@ref)(). : the description for the option in `--help` output. The  is translated using the \\_func of the group, see [`g_option_group_set_translation_domain`](@ref)().

* \\_description: The placeholder to use for the extra argument parsed by the option in `--help` output. The

* \\_description is translated using the \\_func of the group, see [`g_option_group_set_translation_domain`](@ref)().

A [`GOptionEntry`](@ref) struct defines a single option. To have an effect, they must be added to a #[`GOptionGroup`](@ref) with [`g_option_context_add_main_entries`](@ref)() or [`g_option_group_add_entries`](@ref)().
"""
struct _GOptionEntry
    long_name::Ptr{gchar}
    short_name::gchar
    flags::gint
    arg::GOptionArg
    arg_data::gpointer
    description::Ptr{gchar}
    arg_description::Ptr{gchar}
end

"""
[`GOptionEntry`](@ref): \\_name: The long name of an option can be used to specify it in a commandline as `--long\\_name`. Every option must have a long name. To resolve conflicts if multiple option groups contain the same long name, it is also possible to specify the option as `--groupname-long\\_name`.

\\short \\_name: If an option has a short name, it can be specified `-short\\_name` in a commandline.

\\short \\_name must be a printable ASCII character different from '-', or zero if the option has no short name. : Flags from #[`GOptionFlags`](@ref)

* : The type of the option, as a #[`GOptionArg`](@ref)

* \\_data: If the

* type is G\\_OPTION\\_ARG\\_CALLBACK, then

* \\_data must point to a #[`GOptionArgFunc`](@ref) callback function, which will be called to handle the extra argument. Otherwise,

* \\_data is a pointer to a location to store the value, the required type of the location depends on the

* type:

- G\\_OPTION\\_ARG\\_NONE: gboolean - G\\_OPTION\\_ARG\\_STRING: gchar* - G\\_OPTION\\_ARG\\_INT: gint - G\\_OPTION\\_ARG\\_FILENAME: gchar* - G\\_OPTION\\_ARG\\_STRING\\_ARRAY: gchar** - G\\_OPTION\\_ARG\\_FILENAME\\_ARRAY: gchar** - G\\_OPTION\\_ARG\\_DOUBLE: gdouble

If

* type is G\\_OPTION\\_ARG\\_STRING or G\\_OPTION\\_ARG\\_FILENAME, the location will contain a newly allocated string if the option was given. That string needs to be freed by the callee using [`g_free`](@ref)(). Likewise if

* type is G\\_OPTION\\_ARG\\_STRING\\_ARRAY or G\\_OPTION\\_ARG\\_FILENAME\\_ARRAY, the data should be freed using [`g_strfreev`](@ref)(). : the description for the option in `--help` output. The  is translated using the \\_func of the group, see [`g_option_group_set_translation_domain`](@ref)().

* \\_description: The placeholder to use for the extra argument parsed by the option in `--help` output. The

* \\_description is translated using the \\_func of the group, see [`g_option_group_set_translation_domain`](@ref)().

A [`GOptionEntry`](@ref) struct defines a single option. To have an effect, they must be added to a #[`GOptionGroup`](@ref) with [`g_option_context_add_main_entries`](@ref)() or [`g_option_group_add_entries`](@ref)().
"""
const GOptionEntry = _GOptionEntry

"""
    GOptionFlags

G\\_OPTION\\_FLAG\\_DEPRECATED:

This flag marks the option as deprecated in the `--help`.

You should update the description of the option to describe what the user should do in response to the deprecation, for instance: remove the option, or replace it with another one.

Since: 2.84
"""
@cenum GOptionFlags::UInt32 begin
    G_OPTION_FLAG_NONE = 0
    G_OPTION_FLAG_HIDDEN = 1
    G_OPTION_FLAG_IN_MAIN = 2
    G_OPTION_FLAG_REVERSE = 4
    G_OPTION_FLAG_NO_ARG = 8
    G_OPTION_FLAG_FILENAME = 16
    G_OPTION_FLAG_OPTIONAL_ARG = 32
    G_OPTION_FLAG_NOALIAS = 64
    G_OPTION_FLAG_DEPRECATED = 128
end

# typedef gboolean ( * GOptionArgFunc ) ( const gchar * option_name , const gchar * value , gpointer data , GError * * error )
"""
[`GOptionArgFunc`](@ref): \\_name: The name of the option being parsed. This will be either a  single dash followed by a single letter (for a short name) or two dashes followed by a long option name. : The value to be parsed.

\\date : User data added to the #[`GOptionGroup`](@ref) containing the option when it was created with [`g_option_group_new`](@ref)() : A return location for errors. The error code G\\_OPTION\\_ERROR\\_FAILED is intended to be used for errors in #[`GOptionArgFunc`](@ref) callbacks.

The type of function to be passed as callback for G\\_OPTION\\_ARG\\_CALLBACK options.

Returns: TRUE if the option was successfully parsed, FALSE if an error  occurred, in which case  should be set with [`g_set_error`](@ref)()
"""
const GOptionArgFunc = Ptr{Cvoid}

# typedef gboolean ( * GOptionParseFunc ) ( GOptionContext * context , GOptionGroup * group , gpointer data , GError * * error )
"""
[`GOptionParseFunc`](@ref): : The active #[`GOptionContext`](@ref) : The group to which the function belongs

\\date : User data added to the #[`GOptionGroup`](@ref) containing the option when it was created with [`g_option_group_new`](@ref)() : A return location for error details

The type of function that can be called before and after parsing.

Returns: TRUE if the function completed successfully, FALSE if an error  occurred, in which case  should be set with [`g_set_error`](@ref)()
"""
const GOptionParseFunc = Ptr{Cvoid}

# typedef void ( * GOptionErrorFunc ) ( GOptionContext * context , GOptionGroup * group , gpointer data , GError * * error )
"""
[`GOptionErrorFunc`](@ref): : The active #[`GOptionContext`](@ref) : The group to which the function belongs

\\date : User data added to the #[`GOptionGroup`](@ref) containing the option when it was created with [`g_option_group_new`](@ref)() : The #[`GError`](@ref) containing details about the parse error

The type of function to be used as callback when a parse error occurs.
"""
const GOptionErrorFunc = Ptr{Cvoid}

"""
    GOptionError

[`GOptionError`](@ref): \\_OPTION\\_ERROR\\_UNKNOWN\\_OPTION: An option was not known to the parser. This error will only be reported, if the parser hasn't been instructed to ignore unknown options, see [`g_option_context_set_ignore_unknown_options`](@ref)(). \\_OPTION\\_ERROR\\_BAD\\_VALUE: A value couldn't be parsed. \\_OPTION\\_ERROR\\_FAILED: A #[`GOptionArgFunc`](@ref) callback failed.

Error codes returned by option parsing.
"""
@cenum GOptionError::UInt32 begin
    G_OPTION_ERROR_UNKNOWN_OPTION = 0
    G_OPTION_ERROR_BAD_VALUE = 1
    G_OPTION_ERROR_FAILED = 2
end

"""
    g_option_context_new(parameter_string)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GOptionContext *g_option_context_new (const gchar *parameter_string);
```
"""
function g_option_context_new(parameter_string)
    @ccall libaravis.g_option_context_new(parameter_string::Ptr{gchar})::Ptr{GOptionContext}
end

"""
    g_option_context_set_summary(context, summary)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_option_context_set_summary (GOptionContext *context, const gchar *summary);
```
"""
function g_option_context_set_summary(context, summary)
    @ccall libaravis.g_option_context_set_summary(context::Ptr{GOptionContext}, summary::Ptr{gchar})::Cvoid
end

"""
    g_option_context_get_summary(context)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_option_context_get_summary (GOptionContext *context);
```
"""
function g_option_context_get_summary(context)
    @ccall libaravis.g_option_context_get_summary(context::Ptr{GOptionContext})::Ptr{gchar}
end

"""
    g_option_context_set_description(context, description)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_option_context_set_description (GOptionContext *context, const gchar *description);
```
"""
function g_option_context_set_description(context, description)
    @ccall libaravis.g_option_context_set_description(context::Ptr{GOptionContext}, description::Ptr{gchar})::Cvoid
end

"""
    g_option_context_get_description(context)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * g_option_context_get_description (GOptionContext *context);
```
"""
function g_option_context_get_description(context)
    @ccall libaravis.g_option_context_get_description(context::Ptr{GOptionContext})::Ptr{gchar}
end

"""
    g_option_context_free(context)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_option_context_free (GOptionContext *context);
```
"""
function g_option_context_free(context)
    @ccall libaravis.g_option_context_free(context::Ptr{GOptionContext})::Cvoid
end

"""
    g_option_context_set_help_enabled(context, help_enabled)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_option_context_set_help_enabled (GOptionContext *context, gboolean help_enabled);
```
"""
function g_option_context_set_help_enabled(context, help_enabled)
    @ccall libaravis.g_option_context_set_help_enabled(context::Ptr{GOptionContext}, help_enabled::gboolean)::Cvoid
end

"""
    g_option_context_get_help_enabled(context)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_option_context_get_help_enabled (GOptionContext *context);
```
"""
function g_option_context_get_help_enabled(context)
    @ccall libaravis.g_option_context_get_help_enabled(context::Ptr{GOptionContext})::gboolean
end

"""
    g_option_context_set_ignore_unknown_options(context, ignore_unknown)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_option_context_set_ignore_unknown_options (GOptionContext *context, gboolean ignore_unknown);
```
"""
function g_option_context_set_ignore_unknown_options(context, ignore_unknown)
    @ccall libaravis.g_option_context_set_ignore_unknown_options(context::Ptr{GOptionContext}, ignore_unknown::gboolean)::Cvoid
end

"""
    g_option_context_get_ignore_unknown_options(context)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_option_context_get_ignore_unknown_options (GOptionContext *context);
```
"""
function g_option_context_get_ignore_unknown_options(context)
    @ccall libaravis.g_option_context_get_ignore_unknown_options(context::Ptr{GOptionContext})::gboolean
end

"""
    g_option_context_set_strict_posix(context, strict_posix)

### Prototype
```c
GLIB_AVAILABLE_IN_2_44 void g_option_context_set_strict_posix (GOptionContext *context, gboolean strict_posix);
```
"""
function g_option_context_set_strict_posix(context, strict_posix)
    @ccall libaravis.g_option_context_set_strict_posix(context::Ptr{GOptionContext}, strict_posix::gboolean)::Cvoid
end

"""
    g_option_context_get_strict_posix(context)

### Prototype
```c
GLIB_AVAILABLE_IN_2_44 gboolean g_option_context_get_strict_posix (GOptionContext *context);
```
"""
function g_option_context_get_strict_posix(context)
    @ccall libaravis.g_option_context_get_strict_posix(context::Ptr{GOptionContext})::gboolean
end

"""
    g_option_context_add_main_entries(context, entries, translation_domain)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_option_context_add_main_entries (GOptionContext *context, const GOptionEntry *entries, const gchar *translation_domain);
```
"""
function g_option_context_add_main_entries(context, entries, translation_domain)
    @ccall libaravis.g_option_context_add_main_entries(context::Ptr{GOptionContext}, entries::Ptr{GOptionEntry}, translation_domain::Ptr{gchar})::Cvoid
end

"""
    g_option_context_parse(context, argc, argv, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_option_context_parse (GOptionContext *context, gint *argc, gchar ***argv, GError **error);
```
"""
function g_option_context_parse(context, argc, argv, error)
    @ccall libaravis.g_option_context_parse(context::Ptr{GOptionContext}, argc::Ptr{gint}, argv::Ptr{Ptr{Ptr{gchar}}}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_option_context_parse_strv(context, arguments, error)

### Prototype
```c
GLIB_AVAILABLE_IN_2_40 gboolean g_option_context_parse_strv (GOptionContext *context, gchar ***arguments, GError **error);
```
"""
function g_option_context_parse_strv(context, arguments, error)
    @ccall libaravis.g_option_context_parse_strv(context::Ptr{GOptionContext}, arguments::Ptr{Ptr{Ptr{gchar}}}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_option_context_set_translate_func(context, func, data, destroy_notify)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_option_context_set_translate_func (GOptionContext *context, GTranslateFunc func, gpointer data, GDestroyNotify destroy_notify);
```
"""
function g_option_context_set_translate_func(context, func, data, destroy_notify)
    @ccall libaravis.g_option_context_set_translate_func(context::Ptr{GOptionContext}, func::GTranslateFunc, data::gpointer, destroy_notify::GDestroyNotify)::Cvoid
end

"""
    g_option_context_set_translation_domain(context, domain)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_option_context_set_translation_domain (GOptionContext *context, const gchar *domain);
```
"""
function g_option_context_set_translation_domain(context, domain)
    @ccall libaravis.g_option_context_set_translation_domain(context::Ptr{GOptionContext}, domain::Ptr{gchar})::Cvoid
end

"""
    g_option_context_add_group(context, group)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_option_context_add_group (GOptionContext *context, GOptionGroup *group);
```
"""
function g_option_context_add_group(context, group)
    @ccall libaravis.g_option_context_add_group(context::Ptr{GOptionContext}, group::Ptr{GOptionGroup})::Cvoid
end

"""
    g_option_context_set_main_group(context, group)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_option_context_set_main_group (GOptionContext *context, GOptionGroup *group);
```
"""
function g_option_context_set_main_group(context, group)
    @ccall libaravis.g_option_context_set_main_group(context::Ptr{GOptionContext}, group::Ptr{GOptionGroup})::Cvoid
end

"""
    g_option_context_get_main_group(context)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GOptionGroup *g_option_context_get_main_group (GOptionContext *context);
```
"""
function g_option_context_get_main_group(context)
    @ccall libaravis.g_option_context_get_main_group(context::Ptr{GOptionContext})::Ptr{GOptionGroup}
end

"""
    g_option_context_get_help(context, main_help, group)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_option_context_get_help (GOptionContext *context, gboolean main_help, GOptionGroup *group);
```
"""
function g_option_context_get_help(context, main_help, group)
    @ccall libaravis.g_option_context_get_help(context::Ptr{GOptionContext}, main_help::gboolean, group::Ptr{GOptionGroup})::Ptr{gchar}
end

"""
    g_option_group_new(name, description, help_description, user_data, destroy)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GOptionGroup *g_option_group_new (const gchar *name, const gchar *description, const gchar *help_description, gpointer user_data, GDestroyNotify destroy);
```
"""
function g_option_group_new(name, description, help_description, user_data, destroy)
    @ccall libaravis.g_option_group_new(name::Ptr{gchar}, description::Ptr{gchar}, help_description::Ptr{gchar}, user_data::gpointer, destroy::GDestroyNotify)::Ptr{GOptionGroup}
end

"""
    g_option_group_set_parse_hooks(group, pre_parse_func, post_parse_func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_option_group_set_parse_hooks (GOptionGroup *group, GOptionParseFunc pre_parse_func, GOptionParseFunc post_parse_func);
```
"""
function g_option_group_set_parse_hooks(group, pre_parse_func, post_parse_func)
    @ccall libaravis.g_option_group_set_parse_hooks(group::Ptr{GOptionGroup}, pre_parse_func::GOptionParseFunc, post_parse_func::GOptionParseFunc)::Cvoid
end

"""
    g_option_group_set_error_hook(group, error_func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_option_group_set_error_hook (GOptionGroup *group, GOptionErrorFunc error_func);
```
"""
function g_option_group_set_error_hook(group, error_func)
    @ccall libaravis.g_option_group_set_error_hook(group::Ptr{GOptionGroup}, error_func::GOptionErrorFunc)::Cvoid
end

"""
    g_option_group_free(group)

### Prototype
```c
GLIB_DEPRECATED_IN_2_44 void g_option_group_free (GOptionGroup *group);
```
"""
function g_option_group_free(group)
    @ccall libaravis.g_option_group_free(group::Ptr{GOptionGroup})::Cvoid
end

"""
    g_option_group_ref(group)

### Prototype
```c
GLIB_AVAILABLE_IN_2_44 GOptionGroup *g_option_group_ref (GOptionGroup *group);
```
"""
function g_option_group_ref(group)
    @ccall libaravis.g_option_group_ref(group::Ptr{GOptionGroup})::Ptr{GOptionGroup}
end

"""
    g_option_group_unref(group)

### Prototype
```c
GLIB_AVAILABLE_IN_2_44 void g_option_group_unref (GOptionGroup *group);
```
"""
function g_option_group_unref(group)
    @ccall libaravis.g_option_group_unref(group::Ptr{GOptionGroup})::Cvoid
end

"""
    g_option_group_add_entries(group, entries)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_option_group_add_entries (GOptionGroup *group, const GOptionEntry *entries);
```
"""
function g_option_group_add_entries(group, entries)
    @ccall libaravis.g_option_group_add_entries(group::Ptr{GOptionGroup}, entries::Ptr{GOptionEntry})::Cvoid
end

"""
    g_option_group_set_translate_func(group, func, data, destroy_notify)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_option_group_set_translate_func (GOptionGroup *group, GTranslateFunc func, gpointer data, GDestroyNotify destroy_notify);
```
"""
function g_option_group_set_translate_func(group, func, data, destroy_notify)
    @ccall libaravis.g_option_group_set_translate_func(group::Ptr{GOptionGroup}, func::GTranslateFunc, data::gpointer, destroy_notify::GDestroyNotify)::Cvoid
end

"""
    g_option_group_set_translation_domain(group, domain)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_option_group_set_translation_domain (GOptionGroup *group, const gchar *domain);
```
"""
function g_option_group_set_translation_domain(group, domain)
    @ccall libaravis.g_option_group_set_translation_domain(group::Ptr{GOptionGroup}, domain::Ptr{gchar})::Cvoid
end

struct _GPathBuf
    dummy::NTuple{8, gpointer}
end

const GPathBuf = _GPathBuf

"""
    g_path_buf_new()

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 GPathBuf * g_path_buf_new (void);
```
"""
function g_path_buf_new()
    @ccall libaravis.g_path_buf_new()::Ptr{GPathBuf}
end

"""
    g_path_buf_new_from_path(path)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 GPathBuf * g_path_buf_new_from_path (const char *path);
```
"""
function g_path_buf_new_from_path(path)
    @ccall libaravis.g_path_buf_new_from_path(path::Cstring)::Ptr{GPathBuf}
end

"""
    g_path_buf_init(buf)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 GPathBuf * g_path_buf_init (GPathBuf *buf);
```
"""
function g_path_buf_init(buf)
    @ccall libaravis.g_path_buf_init(buf::Ptr{GPathBuf})::Ptr{GPathBuf}
end

"""
    g_path_buf_init_from_path(buf, path)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 GPathBuf * g_path_buf_init_from_path (GPathBuf *buf, const char *path);
```
"""
function g_path_buf_init_from_path(buf, path)
    @ccall libaravis.g_path_buf_init_from_path(buf::Ptr{GPathBuf}, path::Cstring)::Ptr{GPathBuf}
end

"""
    g_path_buf_clear(buf)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 void g_path_buf_clear (GPathBuf *buf);
```
"""
function g_path_buf_clear(buf)
    @ccall libaravis.g_path_buf_clear(buf::Ptr{GPathBuf})::Cvoid
end

"""
    g_path_buf_clear_to_path(buf)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 char * g_path_buf_clear_to_path (GPathBuf *buf) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_path_buf_clear_to_path(buf)
    @ccall libaravis.g_path_buf_clear_to_path(buf::Ptr{GPathBuf})::Cstring
end

"""
    g_path_buf_free(buf)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 void g_path_buf_free (GPathBuf *buf);
```
"""
function g_path_buf_free(buf)
    @ccall libaravis.g_path_buf_free(buf::Ptr{GPathBuf})::Cvoid
end

"""
    g_path_buf_free_to_path(buf)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 char * g_path_buf_free_to_path (GPathBuf *buf) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_path_buf_free_to_path(buf)
    @ccall libaravis.g_path_buf_free_to_path(buf::Ptr{GPathBuf})::Cstring
end

"""
    g_path_buf_copy(buf)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 GPathBuf * g_path_buf_copy (GPathBuf *buf);
```
"""
function g_path_buf_copy(buf)
    @ccall libaravis.g_path_buf_copy(buf::Ptr{GPathBuf})::Ptr{GPathBuf}
end

"""
    g_path_buf_push(buf, path)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 GPathBuf * g_path_buf_push (GPathBuf *buf, const char *path);
```
"""
function g_path_buf_push(buf, path)
    @ccall libaravis.g_path_buf_push(buf::Ptr{GPathBuf}, path::Cstring)::Ptr{GPathBuf}
end

"""
    g_path_buf_pop(buf)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 gboolean g_path_buf_pop (GPathBuf *buf);
```
"""
function g_path_buf_pop(buf)
    @ccall libaravis.g_path_buf_pop(buf::Ptr{GPathBuf})::gboolean
end

"""
    g_path_buf_set_filename(buf, file_name)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 gboolean g_path_buf_set_filename (GPathBuf *buf, const char *file_name);
```
"""
function g_path_buf_set_filename(buf, file_name)
    @ccall libaravis.g_path_buf_set_filename(buf::Ptr{GPathBuf}, file_name::Cstring)::gboolean
end

"""
    g_path_buf_set_extension(buf, extension)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 gboolean g_path_buf_set_extension (GPathBuf *buf, const char *extension);
```
"""
function g_path_buf_set_extension(buf, extension)
    @ccall libaravis.g_path_buf_set_extension(buf::Ptr{GPathBuf}, extension::Cstring)::gboolean
end

"""
    g_path_buf_to_path(buf)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 char * g_path_buf_to_path (GPathBuf *buf) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_path_buf_to_path(buf)
    @ccall libaravis.g_path_buf_to_path(buf::Ptr{GPathBuf})::Cstring
end

"""
    g_path_buf_equal(v1, v2)

### Prototype
```c
GLIB_AVAILABLE_IN_2_76 gboolean g_path_buf_equal (gconstpointer v1, gconstpointer v2);
```
"""
function g_path_buf_equal(v1, v2)
    @ccall libaravis.g_path_buf_equal(v1::gconstpointer, v2::gconstpointer)::gboolean
end

const _GPatternSpec = Cvoid

const GPatternSpec = _GPatternSpec

"""
    g_pattern_spec_new(pattern)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GPatternSpec* g_pattern_spec_new (const gchar *pattern);
```
"""
function g_pattern_spec_new(pattern)
    @ccall libaravis.g_pattern_spec_new(pattern::Ptr{gchar})::Ptr{GPatternSpec}
end

"""
    g_pattern_spec_free(pspec)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_pattern_spec_free (GPatternSpec *pspec);
```
"""
function g_pattern_spec_free(pspec)
    @ccall libaravis.g_pattern_spec_free(pspec::Ptr{GPatternSpec})::Cvoid
end

"""
    g_pattern_spec_copy(pspec)

### Prototype
```c
GLIB_AVAILABLE_IN_2_70 GPatternSpec *g_pattern_spec_copy (GPatternSpec *pspec);
```
"""
function g_pattern_spec_copy(pspec)
    @ccall libaravis.g_pattern_spec_copy(pspec::Ptr{GPatternSpec})::Ptr{GPatternSpec}
end

"""
    g_pattern_spec_equal(pspec1, pspec2)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_pattern_spec_equal (GPatternSpec *pspec1, GPatternSpec *pspec2);
```
"""
function g_pattern_spec_equal(pspec1, pspec2)
    @ccall libaravis.g_pattern_spec_equal(pspec1::Ptr{GPatternSpec}, pspec2::Ptr{GPatternSpec})::gboolean
end

"""
    g_pattern_spec_match(pspec, string_length, string, string_reversed)

### Prototype
```c
GLIB_AVAILABLE_IN_2_70 gboolean g_pattern_spec_match (GPatternSpec *pspec, gsize string_length, const gchar *string, const gchar *string_reversed);
```
"""
function g_pattern_spec_match(pspec, string_length, string, string_reversed)
    @ccall libaravis.g_pattern_spec_match(pspec::Ptr{GPatternSpec}, string_length::gsize, string::Ptr{gchar}, string_reversed::Ptr{gchar})::gboolean
end

"""
    g_pattern_spec_match_string(pspec, string)

### Prototype
```c
GLIB_AVAILABLE_IN_2_70 gboolean g_pattern_spec_match_string (GPatternSpec *pspec, const gchar *string);
```
"""
function g_pattern_spec_match_string(pspec, string)
    @ccall libaravis.g_pattern_spec_match_string(pspec::Ptr{GPatternSpec}, string::Ptr{gchar})::gboolean
end

"""
    g_pattern_match(pspec, string_length, string, string_reversed)

### Prototype
```c
GLIB_DEPRECATED_IN_2_70_FOR (g_pattern_spec_match) gboolean g_pattern_match (GPatternSpec *pspec, guint string_length, const gchar *string, const gchar *string_reversed);
```
"""
function g_pattern_match(pspec, string_length, string, string_reversed)
    @ccall libaravis.g_pattern_match(pspec::Ptr{GPatternSpec}, string_length::guint, string::Ptr{gchar}, string_reversed::Ptr{gchar})::gboolean
end

"""
    g_pattern_match_string(pspec, string)

### Prototype
```c
GLIB_DEPRECATED_IN_2_70_FOR (g_pattern_spec_match_string) gboolean g_pattern_match_string (GPatternSpec *pspec, const gchar *string);
```
"""
function g_pattern_match_string(pspec, string)
    @ccall libaravis.g_pattern_match_string(pspec::Ptr{GPatternSpec}, string::Ptr{gchar})::gboolean
end

"""
    g_pattern_match_simple(pattern, string)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_pattern_match_simple (const gchar *pattern, const gchar *string);
```
"""
function g_pattern_match_simple(pattern, string)
    @ccall libaravis.g_pattern_match_simple(pattern::Ptr{gchar}, string::Ptr{gchar})::gboolean
end

"""
    g_spaced_primes_closest(num)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_spaced_primes_closest (guint num) G_GNUC_CONST;
```
"""
function g_spaced_primes_closest(num)
    @ccall libaravis.g_spaced_primes_closest(num::guint)::guint
end

"""
    g_qsort_with_data(pbase, total_elems, size, compare_func, user_data)

### Prototype
```c
GLIB_DEPRECATED_IN_2_82_FOR(g_sort_array) void g_qsort_with_data (gconstpointer pbase, gint total_elems, gsize size, GCompareDataFunc compare_func, gpointer user_data);
```
"""
function g_qsort_with_data(pbase, total_elems, size, compare_func, user_data)
    @ccall libaravis.g_qsort_with_data(pbase::gconstpointer, total_elems::gint, size::gsize, compare_func::GCompareDataFunc, user_data::gpointer)::Cvoid
end

"""
    g_sort_array(array, n_elements, element_size, compare_func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_2_82 void g_sort_array (const void *array, size_t n_elements, size_t element_size, GCompareDataFunc compare_func, void *user_data);
```
"""
function g_sort_array(array, n_elements, element_size, compare_func, user_data)
    @ccall libaravis.g_sort_array(array::Ptr{Cvoid}, n_elements::Csize_t, element_size::Csize_t, compare_func::GCompareDataFunc, user_data::Ptr{Cvoid})::Cvoid
end

"""
    g_queue_new()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GQueue* g_queue_new (void);
```
"""
function g_queue_new()
    @ccall libaravis.g_queue_new()::Ptr{GQueue}
end

"""
    g_queue_free(queue)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_queue_free (GQueue *queue);
```
"""
function g_queue_free(queue)
    @ccall libaravis.g_queue_free(queue::Ptr{GQueue})::Cvoid
end

"""
    g_queue_init(queue)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_queue_init (GQueue *queue);
```
"""
function g_queue_init(queue)
    @ccall libaravis.g_queue_init(queue::Ptr{GQueue})::Cvoid
end

"""
    g_queue_clear(queue)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_queue_clear (GQueue *queue);
```
"""
function g_queue_clear(queue)
    @ccall libaravis.g_queue_clear(queue::Ptr{GQueue})::Cvoid
end

"""
    g_queue_is_empty(queue)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_queue_is_empty (GQueue *queue);
```
"""
function g_queue_is_empty(queue)
    @ccall libaravis.g_queue_is_empty(queue::Ptr{GQueue})::gboolean
end

"""
    g_queue_clear_full(queue, free_func)

### Prototype
```c
GLIB_AVAILABLE_IN_2_60 void g_queue_clear_full (GQueue *queue, GDestroyNotify free_func);
```
"""
function g_queue_clear_full(queue, free_func)
    @ccall libaravis.g_queue_clear_full(queue::Ptr{GQueue}, free_func::GDestroyNotify)::Cvoid
end

"""
    g_queue_get_length(queue)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_queue_get_length (GQueue *queue);
```
"""
function g_queue_get_length(queue)
    @ccall libaravis.g_queue_get_length(queue::Ptr{GQueue})::guint
end

"""
    g_queue_reverse(queue)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_queue_reverse (GQueue *queue);
```
"""
function g_queue_reverse(queue)
    @ccall libaravis.g_queue_reverse(queue::Ptr{GQueue})::Cvoid
end

"""
    g_queue_copy(queue)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GQueue * g_queue_copy (GQueue *queue);
```
"""
function g_queue_copy(queue)
    @ccall libaravis.g_queue_copy(queue::Ptr{GQueue})::Ptr{GQueue}
end

"""
    g_queue_foreach(queue, func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_queue_foreach (GQueue *queue, GFunc func, gpointer user_data);
```
"""
function g_queue_foreach(queue, func, user_data)
    @ccall libaravis.g_queue_foreach(queue::Ptr{GQueue}, func::GFunc, user_data::gpointer)::Cvoid
end

"""
    g_queue_find(queue, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList * g_queue_find (GQueue *queue, gconstpointer data);
```
"""
function g_queue_find(queue, data)
    @ccall libaravis.g_queue_find(queue::Ptr{GQueue}, data::gconstpointer)::Ptr{GList}
end

"""
    g_queue_find_custom(queue, data, func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList * g_queue_find_custom (GQueue *queue, gconstpointer data, GCompareFunc func);
```
"""
function g_queue_find_custom(queue, data, func)
    @ccall libaravis.g_queue_find_custom(queue::Ptr{GQueue}, data::gconstpointer, func::GCompareFunc)::Ptr{GList}
end

"""
    g_queue_sort(queue, compare_func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_queue_sort (GQueue *queue, GCompareDataFunc compare_func, gpointer user_data);
```
"""
function g_queue_sort(queue, compare_func, user_data)
    @ccall libaravis.g_queue_sort(queue::Ptr{GQueue}, compare_func::GCompareDataFunc, user_data::gpointer)::Cvoid
end

"""
    g_queue_push_head(queue, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_queue_push_head (GQueue *queue, gpointer data);
```
"""
function g_queue_push_head(queue, data)
    @ccall libaravis.g_queue_push_head(queue::Ptr{GQueue}, data::gpointer)::Cvoid
end

"""
    g_queue_push_tail(queue, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_queue_push_tail (GQueue *queue, gpointer data);
```
"""
function g_queue_push_tail(queue, data)
    @ccall libaravis.g_queue_push_tail(queue::Ptr{GQueue}, data::gpointer)::Cvoid
end

"""
    g_queue_push_nth(queue, data, n)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_queue_push_nth (GQueue *queue, gpointer data, gint n);
```
"""
function g_queue_push_nth(queue, data, n)
    @ccall libaravis.g_queue_push_nth(queue::Ptr{GQueue}, data::gpointer, n::gint)::Cvoid
end

"""
    g_queue_pop_head(queue)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_queue_pop_head (GQueue *queue);
```
"""
function g_queue_pop_head(queue)
    @ccall libaravis.g_queue_pop_head(queue::Ptr{GQueue})::gpointer
end

"""
    g_queue_pop_tail(queue)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_queue_pop_tail (GQueue *queue);
```
"""
function g_queue_pop_tail(queue)
    @ccall libaravis.g_queue_pop_tail(queue::Ptr{GQueue})::gpointer
end

"""
    g_queue_pop_nth(queue, n)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_queue_pop_nth (GQueue *queue, guint n);
```
"""
function g_queue_pop_nth(queue, n)
    @ccall libaravis.g_queue_pop_nth(queue::Ptr{GQueue}, n::guint)::gpointer
end

"""
    g_queue_peek_head(queue)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_queue_peek_head (GQueue *queue);
```
"""
function g_queue_peek_head(queue)
    @ccall libaravis.g_queue_peek_head(queue::Ptr{GQueue})::gpointer
end

"""
    g_queue_peek_tail(queue)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_queue_peek_tail (GQueue *queue);
```
"""
function g_queue_peek_tail(queue)
    @ccall libaravis.g_queue_peek_tail(queue::Ptr{GQueue})::gpointer
end

"""
    g_queue_peek_nth(queue, n)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_queue_peek_nth (GQueue *queue, guint n);
```
"""
function g_queue_peek_nth(queue, n)
    @ccall libaravis.g_queue_peek_nth(queue::Ptr{GQueue}, n::guint)::gpointer
end

"""
    g_queue_index(queue, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_queue_index (GQueue *queue, gconstpointer data);
```
"""
function g_queue_index(queue, data)
    @ccall libaravis.g_queue_index(queue::Ptr{GQueue}, data::gconstpointer)::gint
end

"""
    g_queue_remove(queue, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_queue_remove (GQueue *queue, gconstpointer data);
```
"""
function g_queue_remove(queue, data)
    @ccall libaravis.g_queue_remove(queue::Ptr{GQueue}, data::gconstpointer)::gboolean
end

"""
    g_queue_remove_all(queue, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_queue_remove_all (GQueue *queue, gconstpointer data);
```
"""
function g_queue_remove_all(queue, data)
    @ccall libaravis.g_queue_remove_all(queue::Ptr{GQueue}, data::gconstpointer)::guint
end

"""
    g_queue_insert_before(queue, sibling, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_queue_insert_before (GQueue *queue, GList *sibling, gpointer data);
```
"""
function g_queue_insert_before(queue, sibling, data)
    @ccall libaravis.g_queue_insert_before(queue::Ptr{GQueue}, sibling::Ptr{GList}, data::gpointer)::Cvoid
end

"""
    g_queue_insert_before_link(queue, sibling, link_)

### Prototype
```c
GLIB_AVAILABLE_IN_2_62 void g_queue_insert_before_link (GQueue *queue, GList *sibling, GList *link_);
```
"""
function g_queue_insert_before_link(queue, sibling, link_)
    @ccall libaravis.g_queue_insert_before_link(queue::Ptr{GQueue}, sibling::Ptr{GList}, link_::Ptr{GList})::Cvoid
end

"""
    g_queue_insert_after(queue, sibling, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_queue_insert_after (GQueue *queue, GList *sibling, gpointer data);
```
"""
function g_queue_insert_after(queue, sibling, data)
    @ccall libaravis.g_queue_insert_after(queue::Ptr{GQueue}, sibling::Ptr{GList}, data::gpointer)::Cvoid
end

"""
    g_queue_insert_after_link(queue, sibling, link_)

### Prototype
```c
GLIB_AVAILABLE_IN_2_62 void g_queue_insert_after_link (GQueue *queue, GList *sibling, GList *link_);
```
"""
function g_queue_insert_after_link(queue, sibling, link_)
    @ccall libaravis.g_queue_insert_after_link(queue::Ptr{GQueue}, sibling::Ptr{GList}, link_::Ptr{GList})::Cvoid
end

"""
    g_queue_insert_sorted(queue, data, func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_queue_insert_sorted (GQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data);
```
"""
function g_queue_insert_sorted(queue, data, func, user_data)
    @ccall libaravis.g_queue_insert_sorted(queue::Ptr{GQueue}, data::gpointer, func::GCompareDataFunc, user_data::gpointer)::Cvoid
end

"""
    g_queue_push_head_link(queue, link_)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_queue_push_head_link (GQueue *queue, GList *link_);
```
"""
function g_queue_push_head_link(queue, link_)
    @ccall libaravis.g_queue_push_head_link(queue::Ptr{GQueue}, link_::Ptr{GList})::Cvoid
end

"""
    g_queue_push_tail_link(queue, link_)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_queue_push_tail_link (GQueue *queue, GList *link_);
```
"""
function g_queue_push_tail_link(queue, link_)
    @ccall libaravis.g_queue_push_tail_link(queue::Ptr{GQueue}, link_::Ptr{GList})::Cvoid
end

"""
    g_queue_push_nth_link(queue, n, link_)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_queue_push_nth_link (GQueue *queue, gint n, GList *link_);
```
"""
function g_queue_push_nth_link(queue, n, link_)
    @ccall libaravis.g_queue_push_nth_link(queue::Ptr{GQueue}, n::gint, link_::Ptr{GList})::Cvoid
end

"""
    g_queue_pop_head_link(queue)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList* g_queue_pop_head_link (GQueue *queue);
```
"""
function g_queue_pop_head_link(queue)
    @ccall libaravis.g_queue_pop_head_link(queue::Ptr{GQueue})::Ptr{GList}
end

"""
    g_queue_pop_tail_link(queue)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList* g_queue_pop_tail_link (GQueue *queue);
```
"""
function g_queue_pop_tail_link(queue)
    @ccall libaravis.g_queue_pop_tail_link(queue::Ptr{GQueue})::Ptr{GList}
end

"""
    g_queue_pop_nth_link(queue, n)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList* g_queue_pop_nth_link (GQueue *queue, guint n);
```
"""
function g_queue_pop_nth_link(queue, n)
    @ccall libaravis.g_queue_pop_nth_link(queue::Ptr{GQueue}, n::guint)::Ptr{GList}
end

"""
    g_queue_peek_head_link(queue)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList* g_queue_peek_head_link (GQueue *queue);
```
"""
function g_queue_peek_head_link(queue)
    @ccall libaravis.g_queue_peek_head_link(queue::Ptr{GQueue})::Ptr{GList}
end

"""
    g_queue_peek_tail_link(queue)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList* g_queue_peek_tail_link (GQueue *queue);
```
"""
function g_queue_peek_tail_link(queue)
    @ccall libaravis.g_queue_peek_tail_link(queue::Ptr{GQueue})::Ptr{GList}
end

"""
    g_queue_peek_nth_link(queue, n)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GList* g_queue_peek_nth_link (GQueue *queue, guint n);
```
"""
function g_queue_peek_nth_link(queue, n)
    @ccall libaravis.g_queue_peek_nth_link(queue::Ptr{GQueue}, n::guint)::Ptr{GList}
end

"""
    g_queue_link_index(queue, link_)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_queue_link_index (GQueue *queue, GList *link_);
```
"""
function g_queue_link_index(queue, link_)
    @ccall libaravis.g_queue_link_index(queue::Ptr{GQueue}, link_::Ptr{GList})::gint
end

"""
    g_queue_unlink(queue, link_)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_queue_unlink (GQueue *queue, GList *link_);
```
"""
function g_queue_unlink(queue, link_)
    @ccall libaravis.g_queue_unlink(queue::Ptr{GQueue}, link_::Ptr{GList})::Cvoid
end

"""
    g_queue_delete_link(queue, link_)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_queue_delete_link (GQueue *queue, GList *link_);
```
"""
function g_queue_delete_link(queue, link_)
    @ccall libaravis.g_queue_delete_link(queue::Ptr{GQueue}, link_::Ptr{GList})::Cvoid
end

"""
    g_rand_new_with_seed(seed)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GRand* g_rand_new_with_seed (guint32 seed);
```
"""
function g_rand_new_with_seed(seed)
    @ccall libaravis.g_rand_new_with_seed(seed::guint32)::Ptr{GRand}
end

"""
    g_rand_new_with_seed_array(seed, seed_length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GRand* g_rand_new_with_seed_array (const guint32 *seed, guint seed_length);
```
"""
function g_rand_new_with_seed_array(seed, seed_length)
    @ccall libaravis.g_rand_new_with_seed_array(seed::Ptr{guint32}, seed_length::guint)::Ptr{GRand}
end

"""
    g_rand_new()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GRand* g_rand_new (void);
```
"""
function g_rand_new()
    @ccall libaravis.g_rand_new()::Ptr{GRand}
end

"""
    g_rand_free(rand_)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_rand_free (GRand *rand_);
```
"""
function g_rand_free(rand_)
    @ccall libaravis.g_rand_free(rand_::Ptr{GRand})::Cvoid
end

"""
    g_rand_copy(rand_)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GRand* g_rand_copy (GRand *rand_);
```
"""
function g_rand_copy(rand_)
    @ccall libaravis.g_rand_copy(rand_::Ptr{GRand})::Ptr{GRand}
end

"""
    g_rand_set_seed(rand_, seed)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_rand_set_seed (GRand *rand_, guint32 seed);
```
"""
function g_rand_set_seed(rand_, seed)
    @ccall libaravis.g_rand_set_seed(rand_::Ptr{GRand}, seed::guint32)::Cvoid
end

"""
    g_rand_set_seed_array(rand_, seed, seed_length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_rand_set_seed_array (GRand *rand_, const guint32 *seed, guint seed_length);
```
"""
function g_rand_set_seed_array(rand_, seed, seed_length)
    @ccall libaravis.g_rand_set_seed_array(rand_::Ptr{GRand}, seed::Ptr{guint32}, seed_length::guint)::Cvoid
end

"""
    g_rand_int_range(rand_, _begin, _end)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint32 g_rand_int_range (GRand *rand_, gint32 begin, gint32 end);
```
"""
function g_rand_int_range(rand_, _begin, _end)
    @ccall libaravis.g_rand_int_range(rand_::Ptr{GRand}, _begin::gint32, _end::gint32)::gint32
end

"""
    g_rand_double(rand_)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gdouble g_rand_double (GRand *rand_);
```
"""
function g_rand_double(rand_)
    @ccall libaravis.g_rand_double(rand_::Ptr{GRand})::gdouble
end

"""
    g_rand_double_range(rand_, _begin, _end)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gdouble g_rand_double_range (GRand *rand_, gdouble begin, gdouble end);
```
"""
function g_rand_double_range(rand_, _begin, _end)
    @ccall libaravis.g_rand_double_range(rand_::Ptr{GRand}, _begin::gdouble, _end::gdouble)::gdouble
end

"""
    g_random_set_seed(seed)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_random_set_seed (guint32 seed);
```
"""
function g_random_set_seed(seed)
    @ccall libaravis.g_random_set_seed(seed::guint32)::Cvoid
end

"""
    g_random_int_range(_begin, _end)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint32 g_random_int_range (gint32 begin, gint32 end);
```
"""
function g_random_int_range(_begin, _end)
    @ccall libaravis.g_random_int_range(_begin::gint32, _end::gint32)::gint32
end

"""
    g_random_double()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gdouble g_random_double (void);
```
"""
function g_random_double()
    @ccall libaravis.g_random_double()::gdouble
end

"""
    g_random_double_range(_begin, _end)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gdouble g_random_double_range (gdouble begin, gdouble end);
```
"""
function g_random_double_range(_begin, _end)
    @ccall libaravis.g_random_double_range(_begin::gdouble, _end::gdouble)::gdouble
end

"""
    g_rc_box_release(mem_block)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 void g_rc_box_release (gpointer mem_block);
```
"""
function g_rc_box_release(mem_block)
    @ccall libaravis.g_rc_box_release(mem_block::gpointer)::Cvoid
end

"""
    g_rc_box_release_full(mem_block, clear_func)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 void g_rc_box_release_full (gpointer mem_block, GDestroyNotify clear_func);
```
"""
function g_rc_box_release_full(mem_block, clear_func)
    @ccall libaravis.g_rc_box_release_full(mem_block::gpointer, clear_func::GDestroyNotify)::Cvoid
end

"""
    g_rc_box_get_size(mem_block)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 gsize g_rc_box_get_size (gpointer mem_block);
```
"""
function g_rc_box_get_size(mem_block)
    @ccall libaravis.g_rc_box_get_size(mem_block::gpointer)::gsize
end

"""
    g_atomic_rc_box_release(mem_block)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 void g_atomic_rc_box_release (gpointer mem_block);
```
"""
function g_atomic_rc_box_release(mem_block)
    @ccall libaravis.g_atomic_rc_box_release(mem_block::gpointer)::Cvoid
end

"""
    g_atomic_rc_box_release_full(mem_block, clear_func)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 void g_atomic_rc_box_release_full (gpointer mem_block, GDestroyNotify clear_func);
```
"""
function g_atomic_rc_box_release_full(mem_block, clear_func)
    @ccall libaravis.g_atomic_rc_box_release_full(mem_block::gpointer, clear_func::GDestroyNotify)::Cvoid
end

"""
    g_atomic_rc_box_get_size(mem_block)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 gsize g_atomic_rc_box_get_size (gpointer mem_block);
```
"""
function g_atomic_rc_box_get_size(mem_block)
    @ccall libaravis.g_atomic_rc_box_get_size(mem_block::gpointer)::gsize
end

"""
    g_ref_count_init(rc)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 void g_ref_count_init (grefcount *rc);
```
"""
function g_ref_count_init(rc)
    @ccall libaravis.g_ref_count_init(rc::Ptr{grefcount})::Cvoid
end

"""
    g_ref_count_inc(rc)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 void g_ref_count_inc (grefcount *rc);
```
"""
function g_ref_count_inc(rc)
    @ccall libaravis.g_ref_count_inc(rc::Ptr{grefcount})::Cvoid
end

"""
    g_ref_count_dec(rc)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 gboolean g_ref_count_dec (grefcount *rc);
```
"""
function g_ref_count_dec(rc)
    @ccall libaravis.g_ref_count_dec(rc::Ptr{grefcount})::gboolean
end

"""
    g_ref_count_compare(rc, val)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 gboolean g_ref_count_compare (grefcount *rc, gint val);
```
"""
function g_ref_count_compare(rc, val)
    @ccall libaravis.g_ref_count_compare(rc::Ptr{grefcount}, val::gint)::gboolean
end

"""
    g_atomic_ref_count_init(arc)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 void g_atomic_ref_count_init (gatomicrefcount *arc);
```
"""
function g_atomic_ref_count_init(arc)
    @ccall libaravis.g_atomic_ref_count_init(arc::Ptr{gatomicrefcount})::Cvoid
end

"""
    g_atomic_ref_count_inc(arc)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 void g_atomic_ref_count_inc (gatomicrefcount *arc);
```
"""
function g_atomic_ref_count_inc(arc)
    @ccall libaravis.g_atomic_ref_count_inc(arc::Ptr{gatomicrefcount})::Cvoid
end

"""
    g_atomic_ref_count_dec(arc)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 gboolean g_atomic_ref_count_dec (gatomicrefcount *arc);
```
"""
function g_atomic_ref_count_dec(arc)
    @ccall libaravis.g_atomic_ref_count_dec(arc::Ptr{gatomicrefcount})::gboolean
end

"""
    g_atomic_ref_count_compare(arc, val)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 gboolean g_atomic_ref_count_compare (gatomicrefcount *arc, gint val);
```
"""
function g_atomic_ref_count_compare(arc, val)
    @ccall libaravis.g_atomic_ref_count_compare(arc::Ptr{gatomicrefcount}, val::gint)::gboolean
end

"""
    g_ref_string_new(str)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 char * g_ref_string_new (const char *str);
```
"""
function g_ref_string_new(str)
    @ccall libaravis.g_ref_string_new(str::Cstring)::Cstring
end

"""
    g_ref_string_new_len(str, len)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 char * g_ref_string_new_len (const char *str, gssize len);
```
"""
function g_ref_string_new_len(str, len)
    @ccall libaravis.g_ref_string_new_len(str::Cstring, len::gssize)::Cstring
end

"""
    g_ref_string_new_intern(str)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 char * g_ref_string_new_intern (const char *str);
```
"""
function g_ref_string_new_intern(str)
    @ccall libaravis.g_ref_string_new_intern(str::Cstring)::Cstring
end

"""
    g_ref_string_acquire(str)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 char * g_ref_string_acquire (char *str);
```
"""
function g_ref_string_acquire(str)
    @ccall libaravis.g_ref_string_acquire(str::Cstring)::Cstring
end

"""
    g_ref_string_release(str)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 void g_ref_string_release (char *str);
```
"""
function g_ref_string_release(str)
    @ccall libaravis.g_ref_string_release(str::Cstring)::Cvoid
end

"""
    g_ref_string_length(str)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 gsize g_ref_string_length (char *str);
```
"""
function g_ref_string_length(str)
    @ccall libaravis.g_ref_string_length(str::Cstring)::gsize
end

"""
[`GRefString`](@ref):

A typedef for a reference-counted string. A pointer to a #[`GRefString`](@ref) can be treated like a standard `char*` array by all code, but can additionally have `g\\_ref\\_string\\_*()` methods called on it. `g\\_ref\\_string\\_*()` methods cannot be called on `char*` arrays not allocated using [`g_ref_string_new`](@ref)().

If using #[`GRefString`](@ref) with autocleanups, [`g_autoptr`](@ref)() must be used rather than [`g_autofree`](@ref)(), so that the reference counting metadata is also freed.

Since: 2.58
"""
const GRefString = Cchar

"""
    g_ref_string_equal(str1, str2)

### Prototype
```c
GLIB_AVAILABLE_IN_2_84 gboolean g_ref_string_equal (const char *str1, const char *str2);
```
"""
function g_ref_string_equal(str1, str2)
    @ccall libaravis.g_ref_string_equal(str1::Cstring, str2::Cstring)::gboolean
end

"""
    GRegexError

[`GRegexError`](@ref): \\_REGEX\\_ERROR\\_COMPILE: Compilation of the regular expression failed. \\_REGEX\\_ERROR\\_OPTIMIZE: Optimization of the regular expression failed. \\_REGEX\\_ERROR\\_REPLACE: Replacement failed due to an ill-formed replacement string. \\_REGEX\\_ERROR\\_MATCH: The match process failed. \\_REGEX\\_ERROR\\_INTERNAL: Internal error of the regular expression engine. Since 2.16 \\_REGEX\\_ERROR\\_STRAY\\_BACKSLASH: "\\\\" at end of pattern. Since 2.16 \\_REGEX\\_ERROR\\_MISSING\\_CONTROL\\_CHAR: "\\\\c" at end of pattern. Since 2.16 \\_REGEX\\_ERROR\\_UNRECOGNIZED\\_ESCAPE: Unrecognized character follows "\\\\". Since 2.16 \\_REGEX\\_ERROR\\_QUANTIFIERS\\_OUT\\_OF\\_ORDER: Numbers out of order in "{}" quantifier. Since 2.16 \\_REGEX\\_ERROR\\_QUANTIFIER\\_TOO\\_BIG: Number too big in "{}" quantifier. Since 2.16 \\_REGEX\\_ERROR\\_UNTERMINATED\\_CHARACTER\\_CLASS: Missing terminating "]" for character class. Since 2.16 \\_REGEX\\_ERROR\\_INVALID\\_ESCAPE\\_IN\\_CHARACTER\\_CLASS: Invalid escape sequence in character class. Since 2.16 \\_REGEX\\_ERROR\\_RANGE\\_OUT\\_OF\\_ORDER: Range out of order in character class. Since 2.16 \\_REGEX\\_ERROR\\_NOTHING\\_TO\\_REPEAT: Nothing to repeat. Since 2.16 \\_REGEX\\_ERROR\\_UNRECOGNIZED\\_CHARACTER: Unrecognized character after "(?", "(?<" or "(?P". Since 2.16 \\_REGEX\\_ERROR\\_POSIX\\_NAMED\\_CLASS\\_OUTSIDE\\_CLASS: POSIX named classes are supported only within a class. Since 2.16 \\_REGEX\\_ERROR\\_UNMATCHED\\_PARENTHESIS: Missing terminating ")" or ")" without opening "(". Since 2.16 \\_REGEX\\_ERROR\\_INEXISTENT\\_SUBPATTERN\\_REFERENCE: Reference to non-existent subpattern. Since 2.16 \\_REGEX\\_ERROR\\_UNTERMINATED\\_COMMENT: Missing terminating ")" after comment. Since 2.16 \\_REGEX\\_ERROR\\_EXPRESSION\\_TOO\\_LARGE: Regular expression too large. Since 2.16 \\_REGEX\\_ERROR\\_MEMORY\\_ERROR: Failed to get memory. Since 2.16 \\_REGEX\\_ERROR\\_VARIABLE\\_LENGTH\\_LOOKBEHIND: Lookbehind assertion is not fixed length. Since 2.16 \\_REGEX\\_ERROR\\_MALFORMED\\_CONDITION: Malformed number or name after "(?(". Since 2.16 \\_REGEX\\_ERROR\\_TOO\\_MANY\\_CONDITIONAL\\_BRANCHES: Conditional group contains more than two branches. Since 2.16 \\_REGEX\\_ERROR\\_ASSERTION\\_EXPECTED: Assertion expected after "(?(". Since 2.16 \\_REGEX\\_ERROR\\_UNKNOWN\\_POSIX\\_CLASS\\_NAME: Unknown POSIX class name. Since 2.16 \\_REGEX\\_ERROR\\_POSIX\\_COLLATING\\_ELEMENTS\\_NOT\\_SUPPORTED: POSIX collating elements are not supported. Since 2.16 \\_REGEX\\_ERROR\\_HEX\\_CODE\\_TOO\\_LARGE: Character value in "\\\\x{...}" sequence is too large. Since 2.16 \\_REGEX\\_ERROR\\_INVALID\\_CONDITION: Invalid condition "(?(0)". Since 2.16 \\_REGEX\\_ERROR\\_SINGLE\\_BYTE\\_MATCH\\_IN\\_LOOKBEHIND: \\C not allowed in lookbehind assertion. Since 2.16 \\_REGEX\\_ERROR\\_INFINITE\\_LOOP: Recursive call could loop indefinitely. Since 2.16 \\_REGEX\\_ERROR\\_MISSING\\_SUBPATTERN\\_NAME\\_TERMINATOR: Missing terminator in subpattern name. Since 2.16 \\_REGEX\\_ERROR\\_DUPLICATE\\_SUBPATTERN\\_NAME: Two named subpatterns have the same name. Since 2.16 \\_REGEX\\_ERROR\\_MALFORMED\\_PROPERTY: Malformed "\\\\P" or "\\\\p" sequence. Since 2.16 \\_REGEX\\_ERROR\\_UNKNOWN\\_PROPERTY: Unknown property name after "\\\\P" or "\\\\p". Since 2.16 \\_REGEX\\_ERROR\\_SUBPATTERN\\_NAME\\_TOO\\_LONG: Subpattern name is too long (maximum 32 characters). Since 2.16 \\_REGEX\\_ERROR\\_TOO\\_MANY\\_SUBPATTERNS: Too many named subpatterns (maximum 10,000). Since 2.16 \\_REGEX\\_ERROR\\_INVALID\\_OCTAL\\_VALUE: Octal value is greater than "\\\\377". Since 2.16 \\_REGEX\\_ERROR\\_TOO\\_MANY\\_BRANCHES\\_IN\\_DEFINE: "DEFINE" group contains more than one branch. Since 2.16 \\_REGEX\\_ERROR\\_DEFINE\\_REPETION: Repeating a "DEFINE" group is not allowed. This error is never raised. Since: 2.16 Deprecated: 2.34 \\_REGEX\\_ERROR\\_INCONSISTENT\\_NEWLINE\\_OPTIONS: Inconsistent newline options. Since 2.16 \\_REGEX\\_ERROR\\_MISSING\\_BACK\\_REFERENCE: "\\\\g" is not followed by a braced, angle-bracketed, or quoted name or number, or by a plain number. Since: 2.16 \\_REGEX\\_ERROR\\_INVALID\\_RELATIVE\\_REFERENCE: relative reference must not be zero. Since: 2.34 \\_REGEX\\_ERROR\\_BACKTRACKING\\_CONTROL\\_VERB\\_ARGUMENT\\_FORBIDDEN: the backtracing control verb used does not allow an argument. Since: 2.34 \\_REGEX\\_ERROR\\_UNKNOWN\\_BACKTRACKING\\_CONTROL\\_VERB: unknown backtracing  control verb. Since: 2.34 \\_REGEX\\_ERROR\\_NUMBER\\_TOO\\_BIG: number is too big in escape sequence. Since: 2.34 \\_REGEX\\_ERROR\\_MISSING\\_SUBPATTERN\\_NAME: Missing subpattern name. Since: 2.34 \\_REGEX\\_ERROR\\_MISSING\\_DIGIT: Missing digit. Since 2.34 \\_REGEX\\_ERROR\\_INVALID\\_DATA\\_CHARACTER: In JavaScript compatibility mode, "[" is an invalid data character. Since: 2.34 \\_REGEX\\_ERROR\\_EXTRA\\_SUBPATTERN\\_NAME: different names for subpatterns of the  same number are not allowed. Since: 2.34 \\_REGEX\\_ERROR\\_BACKTRACKING\\_CONTROL\\_VERB\\_ARGUMENT\\_REQUIRED: the backtracing control verb requires an argument. Since: 2.34 \\_REGEX\\_ERROR\\_INVALID\\_CONTROL\\_CHAR: "\\\\c" must be followed by an ASCII  character. Since: 2.34 \\_REGEX\\_ERROR\\_MISSING\\_NAME: "\\\\k" is not followed by a braced, angle-bracketed, or  quoted name. Since: 2.34 \\_REGEX\\_ERROR\\_NOT\\_SUPPORTED\\_IN\\_CLASS: "\\\\N" is not supported in a class. Since: 2.34 \\_REGEX\\_ERROR\\_TOO\\_MANY\\_FORWARD\\_REFERENCES: too many forward references. Since: 2.34 \\_REGEX\\_ERROR\\_NAME\\_TOO\\_LONG: the name is too long in "(*MARK)", "(*PRUNE)",  "(*SKIP)", or "(*THEN)". Since: 2.34 \\_REGEX\\_ERROR\\_CHARACTER\\_VALUE\\_TOO\\_LARGE: the character value in the \\u sequence is too large. Since: 2.34

Error codes returned by regular expressions functions.

Since: 2.14
"""
@cenum GRegexError::UInt32 begin
    G_REGEX_ERROR_COMPILE = 0
    G_REGEX_ERROR_OPTIMIZE = 1
    G_REGEX_ERROR_REPLACE = 2
    G_REGEX_ERROR_MATCH = 3
    G_REGEX_ERROR_INTERNAL = 4
    G_REGEX_ERROR_STRAY_BACKSLASH = 101
    G_REGEX_ERROR_MISSING_CONTROL_CHAR = 102
    G_REGEX_ERROR_UNRECOGNIZED_ESCAPE = 103
    G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER = 104
    G_REGEX_ERROR_QUANTIFIER_TOO_BIG = 105
    G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS = 106
    G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS = 107
    G_REGEX_ERROR_RANGE_OUT_OF_ORDER = 108
    G_REGEX_ERROR_NOTHING_TO_REPEAT = 109
    G_REGEX_ERROR_UNRECOGNIZED_CHARACTER = 112
    G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS = 113
    G_REGEX_ERROR_UNMATCHED_PARENTHESIS = 114
    G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE = 115
    G_REGEX_ERROR_UNTERMINATED_COMMENT = 118
    G_REGEX_ERROR_EXPRESSION_TOO_LARGE = 120
    G_REGEX_ERROR_MEMORY_ERROR = 121
    G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND = 125
    G_REGEX_ERROR_MALFORMED_CONDITION = 126
    G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES = 127
    G_REGEX_ERROR_ASSERTION_EXPECTED = 128
    G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME = 130
    G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED = 131
    G_REGEX_ERROR_HEX_CODE_TOO_LARGE = 134
    G_REGEX_ERROR_INVALID_CONDITION = 135
    G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND = 136
    G_REGEX_ERROR_INFINITE_LOOP = 140
    G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR = 142
    G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME = 143
    G_REGEX_ERROR_MALFORMED_PROPERTY = 146
    G_REGEX_ERROR_UNKNOWN_PROPERTY = 147
    G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG = 148
    G_REGEX_ERROR_TOO_MANY_SUBPATTERNS = 149
    G_REGEX_ERROR_INVALID_OCTAL_VALUE = 151
    G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE = 154
    G_REGEX_ERROR_DEFINE_REPETION = 155
    G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS = 156
    G_REGEX_ERROR_MISSING_BACK_REFERENCE = 157
    G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE = 158
    G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN = 159
    G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB = 160
    G_REGEX_ERROR_NUMBER_TOO_BIG = 161
    G_REGEX_ERROR_MISSING_SUBPATTERN_NAME = 162
    G_REGEX_ERROR_MISSING_DIGIT = 163
    G_REGEX_ERROR_INVALID_DATA_CHARACTER = 164
    G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME = 165
    G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED = 166
    G_REGEX_ERROR_INVALID_CONTROL_CHAR = 168
    G_REGEX_ERROR_MISSING_NAME = 169
    G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS = 171
    G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES = 172
    G_REGEX_ERROR_NAME_TOO_LONG = 175
    G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE = 176
end

"""
    GRegexCompileFlags

[`GRegexCompileFlags`](@ref): \\_REGEX\\_DEFAULT: No special options set. Since: 2.74 \\_REGEX\\_CASELESS: Letters in the pattern match both upper- and lowercase letters. This option can be changed within a pattern by a "(?i)" option setting. \\_REGEX\\_MULTILINE: By default, [`GRegex`](@ref) treats the strings as consisting of a single line of characters (even if it actually contains newlines). The "start of line" metacharacter ("^") matches only at the start of the string, while the "end of line" metacharacter ("\$") matches only at the end of the string, or before a terminating newline (unless G\\_REGEX\\_DOLLAR\\_ENDONLY is set). When G\\_REGEX\\_MULTILINE is set, the "start of line" and "end of line" constructs match immediately following or immediately before any newline in the string, respectively, as well as at the very start and end. This can be changed within a pattern by a "(?m)" option setting. \\_REGEX\\_DOTALL: A dot metacharacter (".") in the pattern matches all characters, including newlines. Without it, newlines are excluded. This option can be changed within a pattern by a ("?s") option setting. \\_REGEX\\_EXTENDED: Whitespace data characters in the pattern are totally ignored except when escaped or inside a character class. Whitespace does not include the VT character (code 11). In addition, characters between an unescaped "#" outside a character class and the next newline character, inclusive, are also ignored. This can be changed within a pattern by a "(?x)" option setting. \\_REGEX\\_ANCHORED: The pattern is forced to be "anchored", that is, it is constrained to match only at the first matching point in the string that is being searched. This effect can also be achieved by appropriate constructs in the pattern itself such as the "^" metacharacter. \\_REGEX\\_DOLLAR\\_ENDONLY: A dollar metacharacter ("\$") in the pattern matches only at the end of the string. Without this option, a dollar also matches immediately before the final character if it is a newline (but not before any other newlines). This option is ignored if G\\_REGEX\\_MULTILINE is set. \\_REGEX\\_UNGREEDY: Inverts the "greediness" of the quantifiers so that they are not greedy by default, but become greedy if followed by "?". It can also be set by a "(?U)" option setting within the pattern. \\_REGEX\\_RAW: Usually strings must be valid UTF-8 strings, using this flag they are considered as a raw sequence of bytes. \\_REGEX\\_NO\\_AUTO\\_CAPTURE: Disables the use of numbered capturing parentheses in the pattern. Any opening parenthesis that is not followed by "?" behaves as if it were followed by "?:" but named parentheses can still be used for capturing (and they acquire numbers in the usual way). \\_REGEX\\_OPTIMIZE: Since 2.74 and the port to pcre2, requests JIT compilation, which, if the just-in-time compiler is available, further processes a compiled pattern into machine code that executes much faster. However, it comes at the cost of extra processing before the match is performed, so it is most beneficial to use this when the same compiled pattern is used for matching many times. Before 2.74 this option used the built-in non-JIT optimizations in pcre1. \\_REGEX\\_FIRSTLINE: Limits an unanchored pattern to match before (or at) the first newline. Since: 2.34 \\_REGEX\\_DUPNAMES: Names used to identify capturing subpatterns need not be unique. This can be helpful for certain types of pattern when it is known that only one instance of the named subpattern can ever be matched. \\_REGEX\\_NEWLINE\\_CR: Usually any newline character or character sequence is recognized. If this option is set, the only recognized newline character is ''. \\_REGEX\\_NEWLINE\\_LF: Usually any newline character or character sequence is recognized. If this option is set, the only recognized newline character is ''. \\_REGEX\\_NEWLINE\\_CRLF: Usually any newline character or character sequence is recognized. If this option is set, the only recognized newline character sequence is ''. \\_REGEX\\_NEWLINE\\_ANYCRLF: Usually any newline character or character sequence is recognized. If this option is set, the only recognized newline character sequences are '', '', and ''. Since: 2.34 \\_REGEX\\_BSR\\_ANYCRLF: Usually any newline character or character sequence is recognised. If this option is set, then "\\R" only recognizes the newline characters '', '' and ''. Since: 2.34 \\_REGEX\\_JAVASCRIPT\\_COMPAT: Changes behaviour so that it is compatible with JavaScript rather than PCRE. Since GLib 2.74 this is no longer supported, as libpcre2 does not support it. Since: 2.34 Deprecated: 2.74

Flags specifying compile-time options.

Since: 2.14
"""
@cenum GRegexCompileFlags::UInt32 begin
    G_REGEX_DEFAULT = 0
    G_REGEX_CASELESS = 1
    G_REGEX_MULTILINE = 2
    G_REGEX_DOTALL = 4
    G_REGEX_EXTENDED = 8
    G_REGEX_ANCHORED = 16
    G_REGEX_DOLLAR_ENDONLY = 32
    G_REGEX_UNGREEDY = 512
    G_REGEX_RAW = 2048
    G_REGEX_NO_AUTO_CAPTURE = 4096
    G_REGEX_OPTIMIZE = 8192
    G_REGEX_FIRSTLINE = 262144
    G_REGEX_DUPNAMES = 524288
    G_REGEX_NEWLINE_CR = 1048576
    G_REGEX_NEWLINE_LF = 2097152
    G_REGEX_NEWLINE_CRLF = 3145728
    G_REGEX_NEWLINE_ANYCRLF = 5242880
    G_REGEX_BSR_ANYCRLF = 8388608
    G_REGEX_JAVASCRIPT_COMPAT = 33554432
end

"""
    GRegexMatchFlags

[`GRegexMatchFlags`](@ref): \\_REGEX\\_MATCH\\_DEFAULT: No special options set. Since: 2.74 \\_REGEX\\_MATCH\\_ANCHORED: The pattern is forced to be "anchored", that is, it is constrained to match only at the first matching point in the string that is being searched. This effect can also be achieved by appropriate constructs in the pattern itself such as the "^" metacharacter. \\_REGEX\\_MATCH\\_NOTBOL: Specifies that first character of the string is not the beginning of a line, so the circumflex metacharacter should not match before it. Setting this without G\\_REGEX\\_MULTILINE (at compile time) causes circumflex never to match. This option affects only the behaviour of the circumflex metacharacter, it does not affect "\\A". \\_REGEX\\_MATCH\\_NOTEOL: Specifies that the end of the subject string is not the end of a line, so the dollar metacharacter should not match it nor (except in multiline mode) a newline immediately before it. Setting this without G\\_REGEX\\_MULTILINE (at compile time) causes dollar never to match. This option affects only the behaviour of the dollar metacharacter, it does not affect "\\Z" or "\\z". \\_REGEX\\_MATCH\\_NOTEMPTY: An empty string is not considered to be a valid match if this option is set. If there are alternatives in the pattern, they are tried. If all the alternatives match the empty string, the entire match fails. For example, if the pattern "a?b?" is applied to a string not beginning with "a" or "b", it matches the empty string at the start of the string. With this flag set, this match is not valid, so [`GRegex`](@ref) searches further into the string for occurrences of "a" or "b". \\_REGEX\\_MATCH\\_PARTIAL: Turns on the partial matching feature, for more documentation on partial matching see [`g_match_info_is_partial_match`](@ref)(). \\_REGEX\\_MATCH\\_NEWLINE\\_CR: Overrides the newline definition set when creating a new #[`GRegex`](@ref), setting the '' character as line terminator. \\_REGEX\\_MATCH\\_NEWLINE\\_LF: Overrides the newline definition set when creating a new #[`GRegex`](@ref), setting the '' character as line terminator. \\_REGEX\\_MATCH\\_NEWLINE\\_CRLF: Overrides the newline definition set when creating a new #[`GRegex`](@ref), setting the '' characters sequence as line terminator. \\_REGEX\\_MATCH\\_NEWLINE\\_ANY: Overrides the newline definition set when creating a new #[`GRegex`](@ref), any Unicode newline sequence is recognised as a newline. These are '', '' and '', and the single characters U+000B LINE TABULATION, U+000C FORM FEED (FF), U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and U+2029 PARAGRAPH SEPARATOR. \\_REGEX\\_MATCH\\_NEWLINE\\_ANYCRLF: Overrides the newline definition set when creating a new #[`GRegex`](@ref); any '', '', or '' character sequence is recognized as a newline. Since: 2.34 \\_REGEX\\_MATCH\\_BSR\\_ANYCRLF: Overrides the newline definition for "\\R" set when creating a new #[`GRegex`](@ref); only '', '', or '' character sequences are recognized as a newline by "\\R". Since: 2.34 \\_REGEX\\_MATCH\\_BSR\\_ANY: Overrides the newline definition for "\\R" set when creating a new #[`GRegex`](@ref); any Unicode newline character or character sequence are recognized as a newline by "\\R". These are '', '' and '', and the single characters U+000B LINE TABULATION, U+000C FORM FEED (FF), U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and U+2029 PARAGRAPH SEPARATOR. Since: 2.34 \\_REGEX\\_MATCH\\_PARTIAL\\_SOFT: An alias for G\\_REGEX\\_MATCH\\_PARTIAL. Since: 2.34 \\_REGEX\\_MATCH\\_PARTIAL\\_HARD: Turns on the partial matching feature. In contrast to to G\\_REGEX\\_MATCH\\_PARTIAL\\_SOFT, this stops matching as soon as a partial match is found, without continuing to search for a possible complete match. See [`g_match_info_is_partial_match`](@ref)() for more information. Since: 2.34 \\_REGEX\\_MATCH\\_NOTEMPTY\\_ATSTART: Like G\\_REGEX\\_MATCH\\_NOTEMPTY, but only applied to the start of the matched string. For anchored patterns this can only happen for pattern containing "\\K". Since: 2.34

Flags specifying match-time options.

Since: 2.14
"""
@cenum GRegexMatchFlags::UInt32 begin
    G_REGEX_MATCH_DEFAULT = 0
    G_REGEX_MATCH_ANCHORED = 16
    G_REGEX_MATCH_NOTBOL = 128
    G_REGEX_MATCH_NOTEOL = 256
    G_REGEX_MATCH_NOTEMPTY = 1024
    G_REGEX_MATCH_PARTIAL = 32768
    G_REGEX_MATCH_NEWLINE_CR = 1048576
    G_REGEX_MATCH_NEWLINE_LF = 2097152
    G_REGEX_MATCH_NEWLINE_CRLF = 3145728
    G_REGEX_MATCH_NEWLINE_ANY = 4194304
    G_REGEX_MATCH_NEWLINE_ANYCRLF = 5242880
    G_REGEX_MATCH_BSR_ANYCRLF = 8388608
    G_REGEX_MATCH_BSR_ANY = 16777216
    G_REGEX_MATCH_PARTIAL_SOFT = 32768
    G_REGEX_MATCH_PARTIAL_HARD = 134217728
    G_REGEX_MATCH_NOTEMPTY_ATSTART = 268435456
end

const _GRegex = Cvoid

const GRegex = _GRegex

const _GMatchInfo = Cvoid

"""
[`GMatchInfo`](@ref):

A [`GMatchInfo`](@ref) is an opaque struct used to return information about matches.
"""
const GMatchInfo = _GMatchInfo

# typedef gboolean ( * GRegexEvalCallback ) ( const GMatchInfo * match_info , GString * result , gpointer user_data )
"""
[`GRegexEvalCallback`](@ref): \\_info: the #[`GMatchInfo`](@ref) generated by the match. Use [`g_match_info_get_regex`](@ref)() and [`g_match_info_get_string`](@ref)() if you need the #[`GRegex`](@ref) or the matched string.

\\result : a #[`GString`](@ref) containing the new string \\_data: user data passed to [`g_regex_replace_eval`](@ref)()

Specifies the type of the function passed to [`g_regex_replace_eval`](@ref)(). It is called for each occurrence of the pattern in the string passed to [`g_regex_replace_eval`](@ref)(), and it should append the replacement to

\\result .

Returns: FALSE to continue the replacement process, TRUE to stop it

Since: 2.14
"""
const GRegexEvalCallback = Ptr{Cvoid}

"""
    g_regex_new(pattern, compile_options, match_options, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GRegex *g_regex_new (const gchar *pattern, GRegexCompileFlags compile_options, GRegexMatchFlags match_options, GError **error);
```
"""
function g_regex_new(pattern, compile_options, match_options, error)
    @ccall libaravis.g_regex_new(pattern::Ptr{gchar}, compile_options::GRegexCompileFlags, match_options::GRegexMatchFlags, error::Ptr{Ptr{GError}})::Ptr{GRegex}
end

"""
    g_regex_ref(regex)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GRegex *g_regex_ref (GRegex *regex);
```
"""
function g_regex_ref(regex)
    @ccall libaravis.g_regex_ref(regex::Ptr{GRegex})::Ptr{GRegex}
end

"""
    g_regex_unref(regex)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_regex_unref (GRegex *regex);
```
"""
function g_regex_unref(regex)
    @ccall libaravis.g_regex_unref(regex::Ptr{GRegex})::Cvoid
end

"""
    g_regex_get_pattern(regex)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar *g_regex_get_pattern (const GRegex *regex);
```
"""
function g_regex_get_pattern(regex)
    @ccall libaravis.g_regex_get_pattern(regex::Ptr{GRegex})::Ptr{gchar}
end

"""
    g_regex_get_max_backref(regex)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_regex_get_max_backref (const GRegex *regex);
```
"""
function g_regex_get_max_backref(regex)
    @ccall libaravis.g_regex_get_max_backref(regex::Ptr{GRegex})::gint
end

"""
    g_regex_get_capture_count(regex)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_regex_get_capture_count (const GRegex *regex);
```
"""
function g_regex_get_capture_count(regex)
    @ccall libaravis.g_regex_get_capture_count(regex::Ptr{GRegex})::gint
end

"""
    g_regex_get_has_cr_or_lf(regex)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_regex_get_has_cr_or_lf (const GRegex *regex);
```
"""
function g_regex_get_has_cr_or_lf(regex)
    @ccall libaravis.g_regex_get_has_cr_or_lf(regex::Ptr{GRegex})::gboolean
end

"""
    g_regex_get_max_lookbehind(regex)

### Prototype
```c
GLIB_AVAILABLE_IN_2_38 gint g_regex_get_max_lookbehind (const GRegex *regex);
```
"""
function g_regex_get_max_lookbehind(regex)
    @ccall libaravis.g_regex_get_max_lookbehind(regex::Ptr{GRegex})::gint
end

"""
    g_regex_get_string_number(regex, name)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_regex_get_string_number (const GRegex *regex, const gchar *name);
```
"""
function g_regex_get_string_number(regex, name)
    @ccall libaravis.g_regex_get_string_number(regex::Ptr{GRegex}, name::Ptr{gchar})::gint
end

"""
    g_regex_escape_string(string, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_regex_escape_string (const gchar *string, gint length);
```
"""
function g_regex_escape_string(string, length)
    @ccall libaravis.g_regex_escape_string(string::Ptr{gchar}, length::gint)::Ptr{gchar}
end

"""
    g_regex_escape_nul(string, length)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_regex_escape_nul (const gchar *string, gint length);
```
"""
function g_regex_escape_nul(string, length)
    @ccall libaravis.g_regex_escape_nul(string::Ptr{gchar}, length::gint)::Ptr{gchar}
end

"""
    g_regex_get_compile_flags(regex)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GRegexCompileFlags g_regex_get_compile_flags (const GRegex *regex);
```
"""
function g_regex_get_compile_flags(regex)
    @ccall libaravis.g_regex_get_compile_flags(regex::Ptr{GRegex})::GRegexCompileFlags
end

"""
    g_regex_get_match_flags(regex)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GRegexMatchFlags g_regex_get_match_flags (const GRegex *regex);
```
"""
function g_regex_get_match_flags(regex)
    @ccall libaravis.g_regex_get_match_flags(regex::Ptr{GRegex})::GRegexMatchFlags
end

"""
    g_regex_match_simple(pattern, string, compile_options, match_options)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_regex_match_simple (const gchar *pattern, const gchar *string, GRegexCompileFlags compile_options, GRegexMatchFlags match_options);
```
"""
function g_regex_match_simple(pattern, string, compile_options, match_options)
    @ccall libaravis.g_regex_match_simple(pattern::Ptr{gchar}, string::Ptr{gchar}, compile_options::GRegexCompileFlags, match_options::GRegexMatchFlags)::gboolean
end

"""
    g_regex_match(regex, string, match_options, match_info)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_regex_match (const GRegex *regex, const gchar *string, GRegexMatchFlags match_options, GMatchInfo **match_info);
```
"""
function g_regex_match(regex, string, match_options, match_info)
    @ccall libaravis.g_regex_match(regex::Ptr{GRegex}, string::Ptr{gchar}, match_options::GRegexMatchFlags, match_info::Ptr{Ptr{GMatchInfo}})::gboolean
end

"""
    g_regex_match_full(regex, string, string_len, start_position, match_options, match_info, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_regex_match_full (const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GMatchInfo **match_info, GError **error);
```
"""
function g_regex_match_full(regex, string, string_len, start_position, match_options, match_info, error)
    @ccall libaravis.g_regex_match_full(regex::Ptr{GRegex}, string::Ptr{gchar}, string_len::gssize, start_position::gint, match_options::GRegexMatchFlags, match_info::Ptr{Ptr{GMatchInfo}}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_regex_match_all(regex, string, match_options, match_info)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_regex_match_all (const GRegex *regex, const gchar *string, GRegexMatchFlags match_options, GMatchInfo **match_info);
```
"""
function g_regex_match_all(regex, string, match_options, match_info)
    @ccall libaravis.g_regex_match_all(regex::Ptr{GRegex}, string::Ptr{gchar}, match_options::GRegexMatchFlags, match_info::Ptr{Ptr{GMatchInfo}})::gboolean
end

"""
    g_regex_match_all_full(regex, string, string_len, start_position, match_options, match_info, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_regex_match_all_full (const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GMatchInfo **match_info, GError **error);
```
"""
function g_regex_match_all_full(regex, string, string_len, start_position, match_options, match_info, error)
    @ccall libaravis.g_regex_match_all_full(regex::Ptr{GRegex}, string::Ptr{gchar}, string_len::gssize, start_position::gint, match_options::GRegexMatchFlags, match_info::Ptr{Ptr{GMatchInfo}}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_regex_split_simple(pattern, string, compile_options, match_options)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar **g_regex_split_simple (const gchar *pattern, const gchar *string, GRegexCompileFlags compile_options, GRegexMatchFlags match_options);
```
"""
function g_regex_split_simple(pattern, string, compile_options, match_options)
    @ccall libaravis.g_regex_split_simple(pattern::Ptr{gchar}, string::Ptr{gchar}, compile_options::GRegexCompileFlags, match_options::GRegexMatchFlags)::Ptr{Ptr{gchar}}
end

"""
    g_regex_split(regex, string, match_options)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar **g_regex_split (const GRegex *regex, const gchar *string, GRegexMatchFlags match_options);
```
"""
function g_regex_split(regex, string, match_options)
    @ccall libaravis.g_regex_split(regex::Ptr{GRegex}, string::Ptr{gchar}, match_options::GRegexMatchFlags)::Ptr{Ptr{gchar}}
end

"""
    g_regex_split_full(regex, string, string_len, start_position, match_options, max_tokens, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar **g_regex_split_full (const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, gint max_tokens, GError **error);
```
"""
function g_regex_split_full(regex, string, string_len, start_position, match_options, max_tokens, error)
    @ccall libaravis.g_regex_split_full(regex::Ptr{GRegex}, string::Ptr{gchar}, string_len::gssize, start_position::gint, match_options::GRegexMatchFlags, max_tokens::gint, error::Ptr{Ptr{GError}})::Ptr{Ptr{gchar}}
end

"""
    g_regex_replace(regex, string, string_len, start_position, replacement, match_options, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_regex_replace (const GRegex *regex, const gchar *string, gssize string_len, gint start_position, const gchar *replacement, GRegexMatchFlags match_options, GError **error);
```
"""
function g_regex_replace(regex, string, string_len, start_position, replacement, match_options, error)
    @ccall libaravis.g_regex_replace(regex::Ptr{GRegex}, string::Ptr{gchar}, string_len::gssize, start_position::gint, replacement::Ptr{gchar}, match_options::GRegexMatchFlags, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_regex_replace_literal(regex, string, string_len, start_position, replacement, match_options, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_regex_replace_literal (const GRegex *regex, const gchar *string, gssize string_len, gint start_position, const gchar *replacement, GRegexMatchFlags match_options, GError **error);
```
"""
function g_regex_replace_literal(regex, string, string_len, start_position, replacement, match_options, error)
    @ccall libaravis.g_regex_replace_literal(regex::Ptr{GRegex}, string::Ptr{gchar}, string_len::gssize, start_position::gint, replacement::Ptr{gchar}, match_options::GRegexMatchFlags, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_regex_replace_eval(regex, string, string_len, start_position, match_options, eval, user_data, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_regex_replace_eval (const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GRegexEvalCallback eval, gpointer user_data, GError **error);
```
"""
function g_regex_replace_eval(regex, string, string_len, start_position, match_options, eval, user_data, error)
    @ccall libaravis.g_regex_replace_eval(regex::Ptr{GRegex}, string::Ptr{gchar}, string_len::gssize, start_position::gint, match_options::GRegexMatchFlags, eval::GRegexEvalCallback, user_data::gpointer, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_regex_check_replacement(replacement, has_references, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_regex_check_replacement (const gchar *replacement, gboolean *has_references, GError **error);
```
"""
function g_regex_check_replacement(replacement, has_references, error)
    @ccall libaravis.g_regex_check_replacement(replacement::Ptr{gchar}, has_references::Ptr{gboolean}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_match_info_get_regex(match_info)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GRegex *g_match_info_get_regex (const GMatchInfo *match_info);
```
"""
function g_match_info_get_regex(match_info)
    @ccall libaravis.g_match_info_get_regex(match_info::Ptr{GMatchInfo})::Ptr{GRegex}
end

"""
    g_match_info_get_string(match_info)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar *g_match_info_get_string (const GMatchInfo *match_info);
```
"""
function g_match_info_get_string(match_info)
    @ccall libaravis.g_match_info_get_string(match_info::Ptr{GMatchInfo})::Ptr{gchar}
end

"""
    g_match_info_ref(match_info)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GMatchInfo *g_match_info_ref (GMatchInfo *match_info);
```
"""
function g_match_info_ref(match_info)
    @ccall libaravis.g_match_info_ref(match_info::Ptr{GMatchInfo})::Ptr{GMatchInfo}
end

"""
    g_match_info_unref(match_info)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_match_info_unref (GMatchInfo *match_info);
```
"""
function g_match_info_unref(match_info)
    @ccall libaravis.g_match_info_unref(match_info::Ptr{GMatchInfo})::Cvoid
end

"""
    g_match_info_free(match_info)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_match_info_free (GMatchInfo *match_info);
```
"""
function g_match_info_free(match_info)
    @ccall libaravis.g_match_info_free(match_info::Ptr{GMatchInfo})::Cvoid
end

"""
    g_match_info_next(match_info, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_match_info_next (GMatchInfo *match_info, GError **error);
```
"""
function g_match_info_next(match_info, error)
    @ccall libaravis.g_match_info_next(match_info::Ptr{GMatchInfo}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_match_info_matches(match_info)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_match_info_matches (const GMatchInfo *match_info);
```
"""
function g_match_info_matches(match_info)
    @ccall libaravis.g_match_info_matches(match_info::Ptr{GMatchInfo})::gboolean
end

"""
    g_match_info_get_match_count(match_info)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_match_info_get_match_count (const GMatchInfo *match_info);
```
"""
function g_match_info_get_match_count(match_info)
    @ccall libaravis.g_match_info_get_match_count(match_info::Ptr{GMatchInfo})::gint
end

"""
    g_match_info_is_partial_match(match_info)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_match_info_is_partial_match (const GMatchInfo *match_info);
```
"""
function g_match_info_is_partial_match(match_info)
    @ccall libaravis.g_match_info_is_partial_match(match_info::Ptr{GMatchInfo})::gboolean
end

"""
    g_match_info_expand_references(match_info, string_to_expand, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_match_info_expand_references(const GMatchInfo *match_info, const gchar *string_to_expand, GError **error);
```
"""
function g_match_info_expand_references(match_info, string_to_expand, error)
    @ccall libaravis.g_match_info_expand_references(match_info::Ptr{GMatchInfo}, string_to_expand::Ptr{gchar}, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_match_info_fetch(match_info, match_num)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_match_info_fetch (const GMatchInfo *match_info, gint match_num);
```
"""
function g_match_info_fetch(match_info, match_num)
    @ccall libaravis.g_match_info_fetch(match_info::Ptr{GMatchInfo}, match_num::gint)::Ptr{gchar}
end

"""
    g_match_info_fetch_pos(match_info, match_num, start_pos, end_pos)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_match_info_fetch_pos (const GMatchInfo *match_info, gint match_num, gint *start_pos, gint *end_pos);
```
"""
function g_match_info_fetch_pos(match_info, match_num, start_pos, end_pos)
    @ccall libaravis.g_match_info_fetch_pos(match_info::Ptr{GMatchInfo}, match_num::gint, start_pos::Ptr{gint}, end_pos::Ptr{gint})::gboolean
end

"""
    g_match_info_fetch_named(match_info, name)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar *g_match_info_fetch_named (const GMatchInfo *match_info, const gchar *name);
```
"""
function g_match_info_fetch_named(match_info, name)
    @ccall libaravis.g_match_info_fetch_named(match_info::Ptr{GMatchInfo}, name::Ptr{gchar})::Ptr{gchar}
end

"""
    g_match_info_fetch_named_pos(match_info, name, start_pos, end_pos)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_match_info_fetch_named_pos (const GMatchInfo *match_info, const gchar *name, gint *start_pos, gint *end_pos);
```
"""
function g_match_info_fetch_named_pos(match_info, name, start_pos, end_pos)
    @ccall libaravis.g_match_info_fetch_named_pos(match_info::Ptr{GMatchInfo}, name::Ptr{gchar}, start_pos::Ptr{gint}, end_pos::Ptr{gint})::gboolean
end

"""
    g_match_info_fetch_all(match_info)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar **g_match_info_fetch_all (const GMatchInfo *match_info);
```
"""
function g_match_info_fetch_all(match_info)
    @ccall libaravis.g_match_info_fetch_all(match_info::Ptr{GMatchInfo})::Ptr{Ptr{gchar}}
end

@cenum GErrorType::UInt32 begin
    G_ERR_UNKNOWN = 0
    G_ERR_UNEXP_EOF = 1
    G_ERR_UNEXP_EOF_IN_STRING = 2
    G_ERR_UNEXP_EOF_IN_COMMENT = 3
    G_ERR_NON_DIGIT_IN_CONST = 4
    G_ERR_DIGIT_RADIX = 5
    G_ERR_FLOAT_RADIX = 6
    G_ERR_FLOAT_MALFORMED = 7
end

"""
    g_scanner_new(config_templ)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GScanner* g_scanner_new (const GScannerConfig *config_templ);
```
"""
function g_scanner_new(config_templ)
    @ccall libaravis.g_scanner_new(config_templ::Ptr{GScannerConfig})::Ptr{GScanner}
end

"""
    g_scanner_destroy(scanner)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_scanner_destroy (GScanner *scanner);
```
"""
function g_scanner_destroy(scanner)
    @ccall libaravis.g_scanner_destroy(scanner::Ptr{GScanner})::Cvoid
end

"""
    g_scanner_input_file(scanner, input_fd)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_scanner_input_file (GScanner *scanner, gint input_fd);
```
"""
function g_scanner_input_file(scanner, input_fd)
    @ccall libaravis.g_scanner_input_file(scanner::Ptr{GScanner}, input_fd::gint)::Cvoid
end

"""
    g_scanner_sync_file_offset(scanner)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_scanner_sync_file_offset (GScanner *scanner);
```
"""
function g_scanner_sync_file_offset(scanner)
    @ccall libaravis.g_scanner_sync_file_offset(scanner::Ptr{GScanner})::Cvoid
end

"""
    g_scanner_input_text(scanner, text, text_len)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_scanner_input_text (GScanner *scanner, const gchar *text, guint text_len);
```
"""
function g_scanner_input_text(scanner, text, text_len)
    @ccall libaravis.g_scanner_input_text(scanner::Ptr{GScanner}, text::Ptr{gchar}, text_len::guint)::Cvoid
end

"""
    g_scanner_get_next_token(scanner)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GTokenType g_scanner_get_next_token (GScanner *scanner);
```
"""
function g_scanner_get_next_token(scanner)
    @ccall libaravis.g_scanner_get_next_token(scanner::Ptr{GScanner})::GTokenType
end

"""
    g_scanner_peek_next_token(scanner)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GTokenType g_scanner_peek_next_token (GScanner *scanner);
```
"""
function g_scanner_peek_next_token(scanner)
    @ccall libaravis.g_scanner_peek_next_token(scanner::Ptr{GScanner})::GTokenType
end

"""
    g_scanner_cur_token(scanner)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GTokenType g_scanner_cur_token (GScanner *scanner);
```
"""
function g_scanner_cur_token(scanner)
    @ccall libaravis.g_scanner_cur_token(scanner::Ptr{GScanner})::GTokenType
end

"""
    g_scanner_cur_value(scanner)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GTokenValue g_scanner_cur_value (GScanner *scanner);
```
"""
function g_scanner_cur_value(scanner)
    @ccall libaravis.g_scanner_cur_value(scanner::Ptr{GScanner})::GTokenValue
end

"""
    g_scanner_cur_line(scanner)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_scanner_cur_line (GScanner *scanner);
```
"""
function g_scanner_cur_line(scanner)
    @ccall libaravis.g_scanner_cur_line(scanner::Ptr{GScanner})::guint
end

"""
    g_scanner_cur_position(scanner)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_scanner_cur_position (GScanner *scanner);
```
"""
function g_scanner_cur_position(scanner)
    @ccall libaravis.g_scanner_cur_position(scanner::Ptr{GScanner})::guint
end

"""
    g_scanner_eof(scanner)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_scanner_eof (GScanner *scanner);
```
"""
function g_scanner_eof(scanner)
    @ccall libaravis.g_scanner_eof(scanner::Ptr{GScanner})::gboolean
end

"""
    g_scanner_set_scope(scanner, scope_id)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_scanner_set_scope (GScanner *scanner, guint scope_id);
```
"""
function g_scanner_set_scope(scanner, scope_id)
    @ccall libaravis.g_scanner_set_scope(scanner::Ptr{GScanner}, scope_id::guint)::guint
end

"""
    g_scanner_scope_lookup_symbol(scanner, scope_id, symbol)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_scanner_scope_lookup_symbol (GScanner *scanner, guint scope_id, const gchar *symbol);
```
"""
function g_scanner_scope_lookup_symbol(scanner, scope_id, symbol)
    @ccall libaravis.g_scanner_scope_lookup_symbol(scanner::Ptr{GScanner}, scope_id::guint, symbol::Ptr{gchar})::gpointer
end

"""
    g_scanner_lookup_symbol(scanner, symbol)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_scanner_lookup_symbol (GScanner *scanner, const gchar *symbol);
```
"""
function g_scanner_lookup_symbol(scanner, symbol)
    @ccall libaravis.g_scanner_lookup_symbol(scanner::Ptr{GScanner}, symbol::Ptr{gchar})::gpointer
end

"""
    g_scanner_unexp_token(scanner, expected_token, identifier_spec, symbol_spec, symbol_name, message, is_error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_scanner_unexp_token (GScanner *scanner, GTokenType expected_token, const gchar *identifier_spec, const gchar *symbol_spec, const gchar *symbol_name, const gchar *message, gint is_error);
```
"""
function g_scanner_unexp_token(scanner, expected_token, identifier_spec, symbol_spec, symbol_name, message, is_error)
    @ccall libaravis.g_scanner_unexp_token(scanner::Ptr{GScanner}, expected_token::GTokenType, identifier_spec::Ptr{gchar}, symbol_spec::Ptr{gchar}, symbol_name::Ptr{gchar}, message::Ptr{gchar}, is_error::gint)::Cvoid
end

const _GSequence = Cvoid

const GSequence = _GSequence

const _GSequenceNode = Cvoid

const GSequenceIter = _GSequenceNode

# typedef gint ( * GSequenceIterCompareFunc ) ( GSequenceIter * a , GSequenceIter * b , gpointer data )
const GSequenceIterCompareFunc = Ptr{Cvoid}

"""
    g_sequence_new(data_destroy)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSequence * g_sequence_new (GDestroyNotify data_destroy);
```
"""
function g_sequence_new(data_destroy)
    @ccall libaravis.g_sequence_new(data_destroy::GDestroyNotify)::Ptr{GSequence}
end

"""
    g_sequence_free(seq)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_sequence_free (GSequence *seq);
```
"""
function g_sequence_free(seq)
    @ccall libaravis.g_sequence_free(seq::Ptr{GSequence})::Cvoid
end

"""
    g_sequence_get_length(seq)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_sequence_get_length (GSequence *seq);
```
"""
function g_sequence_get_length(seq)
    @ccall libaravis.g_sequence_get_length(seq::Ptr{GSequence})::gint
end

"""
    g_sequence_foreach(seq, func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_sequence_foreach (GSequence *seq, GFunc func, gpointer user_data);
```
"""
function g_sequence_foreach(seq, func, user_data)
    @ccall libaravis.g_sequence_foreach(seq::Ptr{GSequence}, func::GFunc, user_data::gpointer)::Cvoid
end

"""
    g_sequence_foreach_range(_begin, _end, func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_sequence_foreach_range (GSequenceIter *begin, GSequenceIter *end, GFunc func, gpointer user_data);
```
"""
function g_sequence_foreach_range(_begin, _end, func, user_data)
    @ccall libaravis.g_sequence_foreach_range(_begin::Ptr{GSequenceIter}, _end::Ptr{GSequenceIter}, func::GFunc, user_data::gpointer)::Cvoid
end

"""
    g_sequence_sort(seq, cmp_func, cmp_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_sequence_sort (GSequence *seq, GCompareDataFunc cmp_func, gpointer cmp_data);
```
"""
function g_sequence_sort(seq, cmp_func, cmp_data)
    @ccall libaravis.g_sequence_sort(seq::Ptr{GSequence}, cmp_func::GCompareDataFunc, cmp_data::gpointer)::Cvoid
end

"""
    g_sequence_sort_iter(seq, cmp_func, cmp_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_sequence_sort_iter (GSequence *seq, GSequenceIterCompareFunc cmp_func, gpointer cmp_data);
```
"""
function g_sequence_sort_iter(seq, cmp_func, cmp_data)
    @ccall libaravis.g_sequence_sort_iter(seq::Ptr{GSequence}, cmp_func::GSequenceIterCompareFunc, cmp_data::gpointer)::Cvoid
end

"""
    g_sequence_is_empty(seq)

### Prototype
```c
GLIB_AVAILABLE_IN_2_48 gboolean g_sequence_is_empty (GSequence *seq);
```
"""
function g_sequence_is_empty(seq)
    @ccall libaravis.g_sequence_is_empty(seq::Ptr{GSequence})::gboolean
end

"""
    g_sequence_get_begin_iter(seq)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSequenceIter *g_sequence_get_begin_iter (GSequence *seq);
```
"""
function g_sequence_get_begin_iter(seq)
    @ccall libaravis.g_sequence_get_begin_iter(seq::Ptr{GSequence})::Ptr{GSequenceIter}
end

"""
    g_sequence_get_end_iter(seq)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSequenceIter *g_sequence_get_end_iter (GSequence *seq);
```
"""
function g_sequence_get_end_iter(seq)
    @ccall libaravis.g_sequence_get_end_iter(seq::Ptr{GSequence})::Ptr{GSequenceIter}
end

"""
    g_sequence_get_iter_at_pos(seq, pos)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSequenceIter *g_sequence_get_iter_at_pos (GSequence *seq, gint pos);
```
"""
function g_sequence_get_iter_at_pos(seq, pos)
    @ccall libaravis.g_sequence_get_iter_at_pos(seq::Ptr{GSequence}, pos::gint)::Ptr{GSequenceIter}
end

"""
    g_sequence_append(seq, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSequenceIter *g_sequence_append (GSequence *seq, gpointer data);
```
"""
function g_sequence_append(seq, data)
    @ccall libaravis.g_sequence_append(seq::Ptr{GSequence}, data::gpointer)::Ptr{GSequenceIter}
end

"""
    g_sequence_prepend(seq, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSequenceIter *g_sequence_prepend (GSequence *seq, gpointer data);
```
"""
function g_sequence_prepend(seq, data)
    @ccall libaravis.g_sequence_prepend(seq::Ptr{GSequence}, data::gpointer)::Ptr{GSequenceIter}
end

"""
    g_sequence_insert_before(iter, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSequenceIter *g_sequence_insert_before (GSequenceIter *iter, gpointer data);
```
"""
function g_sequence_insert_before(iter, data)
    @ccall libaravis.g_sequence_insert_before(iter::Ptr{GSequenceIter}, data::gpointer)::Ptr{GSequenceIter}
end

"""
    g_sequence_move(src, dest)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_sequence_move (GSequenceIter *src, GSequenceIter *dest);
```
"""
function g_sequence_move(src, dest)
    @ccall libaravis.g_sequence_move(src::Ptr{GSequenceIter}, dest::Ptr{GSequenceIter})::Cvoid
end

"""
    g_sequence_swap(a, b)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_sequence_swap (GSequenceIter *a, GSequenceIter *b);
```
"""
function g_sequence_swap(a, b)
    @ccall libaravis.g_sequence_swap(a::Ptr{GSequenceIter}, b::Ptr{GSequenceIter})::Cvoid
end

"""
    g_sequence_insert_sorted(seq, data, cmp_func, cmp_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSequenceIter *g_sequence_insert_sorted (GSequence *seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data);
```
"""
function g_sequence_insert_sorted(seq, data, cmp_func, cmp_data)
    @ccall libaravis.g_sequence_insert_sorted(seq::Ptr{GSequence}, data::gpointer, cmp_func::GCompareDataFunc, cmp_data::gpointer)::Ptr{GSequenceIter}
end

"""
    g_sequence_insert_sorted_iter(seq, data, iter_cmp, cmp_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSequenceIter *g_sequence_insert_sorted_iter (GSequence *seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
```
"""
function g_sequence_insert_sorted_iter(seq, data, iter_cmp, cmp_data)
    @ccall libaravis.g_sequence_insert_sorted_iter(seq::Ptr{GSequence}, data::gpointer, iter_cmp::GSequenceIterCompareFunc, cmp_data::gpointer)::Ptr{GSequenceIter}
end

"""
    g_sequence_sort_changed(iter, cmp_func, cmp_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_sequence_sort_changed (GSequenceIter *iter, GCompareDataFunc cmp_func, gpointer cmp_data);
```
"""
function g_sequence_sort_changed(iter, cmp_func, cmp_data)
    @ccall libaravis.g_sequence_sort_changed(iter::Ptr{GSequenceIter}, cmp_func::GCompareDataFunc, cmp_data::gpointer)::Cvoid
end

"""
    g_sequence_sort_changed_iter(iter, iter_cmp, cmp_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_sequence_sort_changed_iter (GSequenceIter *iter, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
```
"""
function g_sequence_sort_changed_iter(iter, iter_cmp, cmp_data)
    @ccall libaravis.g_sequence_sort_changed_iter(iter::Ptr{GSequenceIter}, iter_cmp::GSequenceIterCompareFunc, cmp_data::gpointer)::Cvoid
end

"""
    g_sequence_remove(iter)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_sequence_remove (GSequenceIter *iter);
```
"""
function g_sequence_remove(iter)
    @ccall libaravis.g_sequence_remove(iter::Ptr{GSequenceIter})::Cvoid
end

"""
    g_sequence_remove_range(_begin, _end)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_sequence_remove_range (GSequenceIter *begin, GSequenceIter *end);
```
"""
function g_sequence_remove_range(_begin, _end)
    @ccall libaravis.g_sequence_remove_range(_begin::Ptr{GSequenceIter}, _end::Ptr{GSequenceIter})::Cvoid
end

"""
    g_sequence_move_range(dest, _begin, _end)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_sequence_move_range (GSequenceIter *dest, GSequenceIter *begin, GSequenceIter *end);
```
"""
function g_sequence_move_range(dest, _begin, _end)
    @ccall libaravis.g_sequence_move_range(dest::Ptr{GSequenceIter}, _begin::Ptr{GSequenceIter}, _end::Ptr{GSequenceIter})::Cvoid
end

"""
    g_sequence_search(seq, data, cmp_func, cmp_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSequenceIter *g_sequence_search (GSequence *seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data);
```
"""
function g_sequence_search(seq, data, cmp_func, cmp_data)
    @ccall libaravis.g_sequence_search(seq::Ptr{GSequence}, data::gpointer, cmp_func::GCompareDataFunc, cmp_data::gpointer)::Ptr{GSequenceIter}
end

"""
    g_sequence_search_iter(seq, data, iter_cmp, cmp_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSequenceIter *g_sequence_search_iter (GSequence *seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
```
"""
function g_sequence_search_iter(seq, data, iter_cmp, cmp_data)
    @ccall libaravis.g_sequence_search_iter(seq::Ptr{GSequence}, data::gpointer, iter_cmp::GSequenceIterCompareFunc, cmp_data::gpointer)::Ptr{GSequenceIter}
end

"""
    g_sequence_lookup(seq, data, cmp_func, cmp_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSequenceIter *g_sequence_lookup (GSequence *seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data);
```
"""
function g_sequence_lookup(seq, data, cmp_func, cmp_data)
    @ccall libaravis.g_sequence_lookup(seq::Ptr{GSequence}, data::gpointer, cmp_func::GCompareDataFunc, cmp_data::gpointer)::Ptr{GSequenceIter}
end

"""
    g_sequence_lookup_iter(seq, data, iter_cmp, cmp_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSequenceIter *g_sequence_lookup_iter (GSequence *seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
```
"""
function g_sequence_lookup_iter(seq, data, iter_cmp, cmp_data)
    @ccall libaravis.g_sequence_lookup_iter(seq::Ptr{GSequence}, data::gpointer, iter_cmp::GSequenceIterCompareFunc, cmp_data::gpointer)::Ptr{GSequenceIter}
end

"""
    g_sequence_get(iter)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_sequence_get (GSequenceIter *iter);
```
"""
function g_sequence_get(iter)
    @ccall libaravis.g_sequence_get(iter::Ptr{GSequenceIter})::gpointer
end

"""
    g_sequence_set(iter, data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_sequence_set (GSequenceIter *iter, gpointer data);
```
"""
function g_sequence_set(iter, data)
    @ccall libaravis.g_sequence_set(iter::Ptr{GSequenceIter}, data::gpointer)::Cvoid
end

"""
    g_sequence_iter_is_begin(iter)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_sequence_iter_is_begin (GSequenceIter *iter);
```
"""
function g_sequence_iter_is_begin(iter)
    @ccall libaravis.g_sequence_iter_is_begin(iter::Ptr{GSequenceIter})::gboolean
end

"""
    g_sequence_iter_is_end(iter)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_sequence_iter_is_end (GSequenceIter *iter);
```
"""
function g_sequence_iter_is_end(iter)
    @ccall libaravis.g_sequence_iter_is_end(iter::Ptr{GSequenceIter})::gboolean
end

"""
    g_sequence_iter_next(iter)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSequenceIter *g_sequence_iter_next (GSequenceIter *iter);
```
"""
function g_sequence_iter_next(iter)
    @ccall libaravis.g_sequence_iter_next(iter::Ptr{GSequenceIter})::Ptr{GSequenceIter}
end

"""
    g_sequence_iter_prev(iter)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSequenceIter *g_sequence_iter_prev (GSequenceIter *iter);
```
"""
function g_sequence_iter_prev(iter)
    @ccall libaravis.g_sequence_iter_prev(iter::Ptr{GSequenceIter})::Ptr{GSequenceIter}
end

"""
    g_sequence_iter_get_position(iter)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_sequence_iter_get_position (GSequenceIter *iter);
```
"""
function g_sequence_iter_get_position(iter)
    @ccall libaravis.g_sequence_iter_get_position(iter::Ptr{GSequenceIter})::gint
end

"""
    g_sequence_iter_move(iter, delta)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSequenceIter *g_sequence_iter_move (GSequenceIter *iter, gint delta);
```
"""
function g_sequence_iter_move(iter, delta)
    @ccall libaravis.g_sequence_iter_move(iter::Ptr{GSequenceIter}, delta::gint)::Ptr{GSequenceIter}
end

"""
    g_sequence_iter_get_sequence(iter)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSequence * g_sequence_iter_get_sequence (GSequenceIter *iter);
```
"""
function g_sequence_iter_get_sequence(iter)
    @ccall libaravis.g_sequence_iter_get_sequence(iter::Ptr{GSequenceIter})::Ptr{GSequence}
end

"""
    g_sequence_iter_compare(a, b)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_sequence_iter_compare (GSequenceIter *a, GSequenceIter *b);
```
"""
function g_sequence_iter_compare(a, b)
    @ccall libaravis.g_sequence_iter_compare(a::Ptr{GSequenceIter}, b::Ptr{GSequenceIter})::gint
end

"""
    g_sequence_range_get_midpoint(_begin, _end)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GSequenceIter *g_sequence_range_get_midpoint (GSequenceIter *begin, GSequenceIter *end);
```
"""
function g_sequence_range_get_midpoint(_begin, _end)
    @ccall libaravis.g_sequence_range_get_midpoint(_begin::Ptr{GSequenceIter}, _end::Ptr{GSequenceIter})::Ptr{GSequenceIter}
end

@cenum GShellError::UInt32 begin
    G_SHELL_ERROR_BAD_QUOTING = 0
    G_SHELL_ERROR_EMPTY_STRING = 1
    G_SHELL_ERROR_FAILED = 2
end

"""
    g_shell_quote(unquoted_string)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_shell_quote (const gchar *unquoted_string);
```
"""
function g_shell_quote(unquoted_string)
    @ccall libaravis.g_shell_quote(unquoted_string::Ptr{gchar})::Ptr{gchar}
end

"""
    g_shell_unquote(quoted_string, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_shell_unquote (const gchar *quoted_string, GError **error);
```
"""
function g_shell_unquote(quoted_string, error)
    @ccall libaravis.g_shell_unquote(quoted_string::Ptr{gchar}, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_shell_parse_argv(command_line, argcp, argvp, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_shell_parse_argv (const gchar *command_line, gint *argcp, gchar ***argvp, GError **error);
```
"""
function g_shell_parse_argv(command_line, argcp, argvp, error)
    @ccall libaravis.g_shell_parse_argv(command_line::Ptr{gchar}, argcp::Ptr{gint}, argvp::Ptr{Ptr{Ptr{gchar}}}, error::Ptr{Ptr{GError}})::gboolean
end

@cenum GSliceConfig::UInt32 begin
    G_SLICE_CONFIG_ALWAYS_MALLOC = 1
    G_SLICE_CONFIG_BYPASS_MAGAZINES = 2
    G_SLICE_CONFIG_WORKING_SET_MSECS = 3
    G_SLICE_CONFIG_COLOR_INCREMENT = 4
    G_SLICE_CONFIG_CHUNK_SIZES = 5
    G_SLICE_CONFIG_CONTENTION_COUNTER = 6
end

"""
    g_slice_set_config(ckey, value)

### Prototype
```c
GLIB_DEPRECATED_IN_2_34 void g_slice_set_config (GSliceConfig ckey, gint64 value);
```
"""
function g_slice_set_config(ckey, value)
    @ccall libaravis.g_slice_set_config(ckey::GSliceConfig, value::gint64)::Cvoid
end

"""
    g_slice_get_config(ckey)

### Prototype
```c
GLIB_DEPRECATED_IN_2_34 gint64 g_slice_get_config (GSliceConfig ckey);
```
"""
function g_slice_get_config(ckey)
    @ccall libaravis.g_slice_get_config(ckey::GSliceConfig)::gint64
end

"""
    g_slice_get_config_state(ckey, address, n_values)

### Prototype
```c
GLIB_DEPRECATED_IN_2_34 gint64* g_slice_get_config_state (GSliceConfig ckey, gint64 address, guint *n_values);
```
"""
function g_slice_get_config_state(ckey, address, n_values)
    @ccall libaravis.g_slice_get_config_state(ckey::GSliceConfig, address::gint64, n_values::Ptr{guint})::Ptr{gint64}
end

"""
    GSpawnError

[`GSpawnError`](@ref): \\_SPAWN\\_ERROR\\_FORK: Fork failed due to lack of memory. \\_SPAWN\\_ERROR\\_READ: Read or select on pipes failed. \\_SPAWN\\_ERROR\\_CHDIR: Changing to working directory failed. \\_SPAWN\\_ERROR\\_ACCES: execv() returned `EACCES` \\_SPAWN\\_ERROR\\_PERM: execv() returned `EPERM` \\_SPAWN\\_ERROR\\_TOO\\_BIG: execv() returned `E2BIG` \\_SPAWN\\_ERROR\\_2BIG: deprecated alias for G\\_SPAWN\\_ERROR\\_TOO\\_BIG (deprecated since GLib 2.32) \\_SPAWN\\_ERROR\\_NOEXEC: execv() returned `ENOEXEC` \\_SPAWN\\_ERROR\\_NAMETOOLONG: execv() returned `ENAMETOOLONG` \\_SPAWN\\_ERROR\\_NOENT: execv() returned `ENOENT` \\_SPAWN\\_ERROR\\_NOMEM: execv() returned `ENOMEM` \\_SPAWN\\_ERROR\\_NOTDIR: execv() returned `ENOTDIR` \\_SPAWN\\_ERROR\\_LOOP: execv() returned `ELOOP` \\_SPAWN\\_ERROR\\_TXTBUSY: execv() returned `ETXTBUSY` \\_SPAWN\\_ERROR\\_IO: execv() returned `EIO` \\_SPAWN\\_ERROR\\_NFILE: execv() returned `ENFILE` \\_SPAWN\\_ERROR\\_MFILE: execv() returned `EMFILE` \\_SPAWN\\_ERROR\\_INVAL: execv() returned `EINVAL` \\_SPAWN\\_ERROR\\_ISDIR: execv() returned `EISDIR` \\_SPAWN\\_ERROR\\_LIBBAD: execv() returned `ELIBBAD` \\_SPAWN\\_ERROR\\_FAILED: Some other fatal failure, `error->message` should explain.

Error codes returned by spawning processes.
"""
@cenum GSpawnError::UInt32 begin
    G_SPAWN_ERROR_FORK = 0
    G_SPAWN_ERROR_READ = 1
    G_SPAWN_ERROR_CHDIR = 2
    G_SPAWN_ERROR_ACCES = 3
    G_SPAWN_ERROR_PERM = 4
    G_SPAWN_ERROR_TOO_BIG = 5
    G_SPAWN_ERROR_2BIG = 5
    G_SPAWN_ERROR_NOEXEC = 6
    G_SPAWN_ERROR_NAMETOOLONG = 7
    G_SPAWN_ERROR_NOENT = 8
    G_SPAWN_ERROR_NOMEM = 9
    G_SPAWN_ERROR_NOTDIR = 10
    G_SPAWN_ERROR_LOOP = 11
    G_SPAWN_ERROR_TXTBUSY = 12
    G_SPAWN_ERROR_IO = 13
    G_SPAWN_ERROR_NFILE = 14
    G_SPAWN_ERROR_MFILE = 15
    G_SPAWN_ERROR_INVAL = 16
    G_SPAWN_ERROR_ISDIR = 17
    G_SPAWN_ERROR_LIBBAD = 18
    G_SPAWN_ERROR_FAILED = 19
end

# typedef void ( * GSpawnChildSetupFunc ) ( gpointer data )
"""
[`GSpawnChildSetupFunc`](@ref):

\\date : user data passed to the function.

Specifies the type of the setup function passed to [`g_spawn_async`](@ref)(), [`g_spawn_sync`](@ref)() and [`g_spawn_async_with_pipes`](@ref)(), which can, in very limited ways, be used to affect the child's execution.

On POSIX platforms, the function is called in the child after GLib has performed all the setup it plans to perform, but before calling exec(). Actions taken in this function will only affect the child, not the parent.

On Windows, the function is called in the parent. Its usefulness on Windows is thus questionable. In many cases executing the child setup function in the parent can have ill effects, and you should be very careful when porting software to Windows that uses child setup functions.

However, even on POSIX, you are extremely limited in what you can safely do from a #[`GSpawnChildSetupFunc`](@ref), because any mutexes that were held by other threads in the parent process at the time of the fork() will still be locked in the child process, and they will never be unlocked (since the threads that held them don't exist in the child). POSIX allows only async-signal-safe functions (see signal(7)) to be called in the child between fork() and exec(), which drastically limits the usefulness of child setup functions.

In particular, it is not safe to call any function which may call malloc(), which includes POSIX functions such as setenv(). If you need to set up the child environment differently from the parent, you should use [`g_get_environ`](@ref)(), [`g_environ_setenv`](@ref)(), and [`g_environ_unsetenv`](@ref)(), and then pass the complete environment list to the `g\\_spawn...` function.
"""
const GSpawnChildSetupFunc = Ptr{Cvoid}

"""
    GSpawnFlags

[`GSpawnFlags`](@ref): \\_SPAWN\\_DEFAULT: no flags, default behaviour \\_SPAWN\\_LEAVE\\_DESCRIPTORS\\_OPEN: the parent's open file descriptors will be inherited by the child; otherwise all descriptors except stdin, stdout and stderr will be closed before calling exec() in the child. \\_SPAWN\\_DO\\_NOT\\_REAP\\_CHILD: the child will not be automatically reaped; you must use [`g_child_watch_add`](@ref)() yourself (or call waitpid() or handle `SIGCHLD` yourself), or the child will become a zombie. \\_SPAWN\\_SEARCH\\_PATH: `argv[0]` need not be an absolute path, it will be looked for in the user's `PATH`. \\_SPAWN\\_STDOUT\\_TO\\_DEV\\_NULL: the child's standard output will be discarded, instead of going to the same location as the parent's standard output. \\_SPAWN\\_STDERR\\_TO\\_DEV\\_NULL: the child's standard error will be discarded. \\_SPAWN\\_CHILD\\_INHERITS\\_STDIN: the child will inherit the parent's standard input (by default, the child's standard input is attached to `/dev/null`). \\_SPAWN\\_FILE\\_AND\\_ARGV\\_ZERO: the first element of `argv` is the file to execute, while the remaining elements are the actual argument vector to pass to the file. Normally [`g_spawn_async_with_pipes`](@ref)() uses `argv[0]` as the file to execute, and passes all of `argv` to the child. \\_SPAWN\\_SEARCH\\_PATH\\_FROM\\_ENVP: if `argv[0]` is not an absolute path, it will be looked for in the `PATH` from the passed child environment. Since: 2.34 \\_SPAWN\\_CLOEXEC\\_PIPES: create all pipes with the `O_CLOEXEC` flag set. Since: 2.40 \\_SPAWN\\_CHILD\\_INHERITS\\_STDOUT: the child will inherit the parent's standard output. Since: 2.74 \\_SPAWN\\_CHILD\\_INHERITS\\_STDERR: the child will inherit the parent's standard error. Since: 2.74 \\_SPAWN\\_STDIN\\_FROM\\_DEV\\_NULL: the child's standard input is attached to `/dev/null`. Since: 2.74

Flags passed to [`g_spawn_sync`](@ref)(), [`g_spawn_async`](@ref)() and [`g_spawn_async_with_pipes`](@ref)().
"""
@cenum GSpawnFlags::UInt32 begin
    G_SPAWN_DEFAULT = 0
    G_SPAWN_LEAVE_DESCRIPTORS_OPEN = 1
    G_SPAWN_DO_NOT_REAP_CHILD = 2
    G_SPAWN_SEARCH_PATH = 4
    G_SPAWN_STDOUT_TO_DEV_NULL = 8
    G_SPAWN_STDERR_TO_DEV_NULL = 16
    G_SPAWN_CHILD_INHERITS_STDIN = 32
    G_SPAWN_FILE_AND_ARGV_ZERO = 64
    G_SPAWN_SEARCH_PATH_FROM_ENVP = 128
    G_SPAWN_CLOEXEC_PIPES = 256
    G_SPAWN_CHILD_INHERITS_STDOUT = 512
    G_SPAWN_CHILD_INHERITS_STDERR = 1024
    G_SPAWN_STDIN_FROM_DEV_NULL = 2048
end

"""
    g_spawn_async(working_directory, argv, envp, flags, child_setup, user_data, child_pid, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_spawn_async (const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid *child_pid, GError **error);
```
"""
function g_spawn_async(working_directory, argv, envp, flags, child_setup, user_data, child_pid, error)
    @ccall libaravis.g_spawn_async(working_directory::Ptr{gchar}, argv::Ptr{Ptr{gchar}}, envp::Ptr{Ptr{gchar}}, flags::GSpawnFlags, child_setup::GSpawnChildSetupFunc, user_data::gpointer, child_pid::Ptr{GPid}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_spawn_async_with_pipes(working_directory, argv, envp, flags, child_setup, user_data, child_pid, standard_input, standard_output, standard_error, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_spawn_async_with_pipes (const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid *child_pid, gint *standard_input, gint *standard_output, gint *standard_error, GError **error);
```
"""
function g_spawn_async_with_pipes(working_directory, argv, envp, flags, child_setup, user_data, child_pid, standard_input, standard_output, standard_error, error)
    @ccall libaravis.g_spawn_async_with_pipes(working_directory::Ptr{gchar}, argv::Ptr{Ptr{gchar}}, envp::Ptr{Ptr{gchar}}, flags::GSpawnFlags, child_setup::GSpawnChildSetupFunc, user_data::gpointer, child_pid::Ptr{GPid}, standard_input::Ptr{gint}, standard_output::Ptr{gint}, standard_error::Ptr{gint}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_spawn_async_with_pipes_and_fds(working_directory, argv, envp, flags, child_setup, user_data, stdin_fd, stdout_fd, stderr_fd, source_fds, target_fds, n_fds, child_pid_out, stdin_pipe_out, stdout_pipe_out, stderr_pipe_out, error)

### Prototype
```c
GLIB_AVAILABLE_IN_2_68 gboolean g_spawn_async_with_pipes_and_fds (const gchar *working_directory, const gchar * const *argv, const gchar * const *envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, gint stdin_fd, gint stdout_fd, gint stderr_fd, const gint *source_fds, const gint *target_fds, gsize n_fds, GPid *child_pid_out, gint *stdin_pipe_out, gint *stdout_pipe_out, gint *stderr_pipe_out, GError **error);
```
"""
function g_spawn_async_with_pipes_and_fds(working_directory, argv, envp, flags, child_setup, user_data, stdin_fd, stdout_fd, stderr_fd, source_fds, target_fds, n_fds, child_pid_out, stdin_pipe_out, stdout_pipe_out, stderr_pipe_out, error)
    @ccall libaravis.g_spawn_async_with_pipes_and_fds(working_directory::Ptr{gchar}, argv::Ptr{Ptr{gchar}}, envp::Ptr{Ptr{gchar}}, flags::GSpawnFlags, child_setup::GSpawnChildSetupFunc, user_data::gpointer, stdin_fd::gint, stdout_fd::gint, stderr_fd::gint, source_fds::Ptr{gint}, target_fds::Ptr{gint}, n_fds::gsize, child_pid_out::Ptr{GPid}, stdin_pipe_out::Ptr{gint}, stdout_pipe_out::Ptr{gint}, stderr_pipe_out::Ptr{gint}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_spawn_async_with_fds(working_directory, argv, envp, flags, child_setup, user_data, child_pid, stdin_fd, stdout_fd, stderr_fd, error)

### Prototype
```c
GLIB_AVAILABLE_IN_2_58 gboolean g_spawn_async_with_fds (const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid *child_pid, gint stdin_fd, gint stdout_fd, gint stderr_fd, GError **error);
```
"""
function g_spawn_async_with_fds(working_directory, argv, envp, flags, child_setup, user_data, child_pid, stdin_fd, stdout_fd, stderr_fd, error)
    @ccall libaravis.g_spawn_async_with_fds(working_directory::Ptr{gchar}, argv::Ptr{Ptr{gchar}}, envp::Ptr{Ptr{gchar}}, flags::GSpawnFlags, child_setup::GSpawnChildSetupFunc, user_data::gpointer, child_pid::Ptr{GPid}, stdin_fd::gint, stdout_fd::gint, stderr_fd::gint, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_spawn_sync(working_directory, argv, envp, flags, child_setup, user_data, standard_output, standard_error, wait_status, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_spawn_sync (const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, gchar **standard_output, gchar **standard_error, gint *wait_status, GError **error);
```
"""
function g_spawn_sync(working_directory, argv, envp, flags, child_setup, user_data, standard_output, standard_error, wait_status, error)
    @ccall libaravis.g_spawn_sync(working_directory::Ptr{gchar}, argv::Ptr{Ptr{gchar}}, envp::Ptr{Ptr{gchar}}, flags::GSpawnFlags, child_setup::GSpawnChildSetupFunc, user_data::gpointer, standard_output::Ptr{Ptr{gchar}}, standard_error::Ptr{Ptr{gchar}}, wait_status::Ptr{gint}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_spawn_command_line_sync(command_line, standard_output, standard_error, wait_status, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_spawn_command_line_sync (const gchar *command_line, gchar **standard_output, gchar **standard_error, gint *wait_status, GError **error);
```
"""
function g_spawn_command_line_sync(command_line, standard_output, standard_error, wait_status, error)
    @ccall libaravis.g_spawn_command_line_sync(command_line::Ptr{gchar}, standard_output::Ptr{Ptr{gchar}}, standard_error::Ptr{Ptr{gchar}}, wait_status::Ptr{gint}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_spawn_command_line_async(command_line, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_spawn_command_line_async (const gchar *command_line, GError **error);
```
"""
function g_spawn_command_line_async(command_line, error)
    @ccall libaravis.g_spawn_command_line_async(command_line::Ptr{gchar}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_spawn_check_wait_status(wait_status, error)

### Prototype
```c
GLIB_AVAILABLE_IN_2_70 gboolean g_spawn_check_wait_status (gint wait_status, GError **error);
```
"""
function g_spawn_check_wait_status(wait_status, error)
    @ccall libaravis.g_spawn_check_wait_status(wait_status::gint, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_spawn_check_exit_status(wait_status, error)

### Prototype
```c
GLIB_DEPRECATED_IN_2_70_FOR(g_spawn_check_wait_status) gboolean g_spawn_check_exit_status (gint wait_status, GError **error);
```
"""
function g_spawn_check_exit_status(wait_status, error)
    @ccall libaravis.g_spawn_check_exit_status(wait_status::gint, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_spawn_close_pid(pid)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_spawn_close_pid (GPid pid);
```
"""
function g_spawn_close_pid(pid)
    @ccall libaravis.g_spawn_close_pid(pid::GPid)::Cvoid
end

const _GStringChunk = Cvoid

const GStringChunk = _GStringChunk

"""
    g_string_chunk_new(size)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GStringChunk* g_string_chunk_new (gsize size);
```
"""
function g_string_chunk_new(size)
    @ccall libaravis.g_string_chunk_new(size::gsize)::Ptr{GStringChunk}
end

"""
    g_string_chunk_free(chunk)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_string_chunk_free (GStringChunk *chunk);
```
"""
function g_string_chunk_free(chunk)
    @ccall libaravis.g_string_chunk_free(chunk::Ptr{GStringChunk})::Cvoid
end

"""
    g_string_chunk_clear(chunk)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_string_chunk_clear (GStringChunk *chunk);
```
"""
function g_string_chunk_clear(chunk)
    @ccall libaravis.g_string_chunk_clear(chunk::Ptr{GStringChunk})::Cvoid
end

"""
    g_string_chunk_insert(chunk, string)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_string_chunk_insert (GStringChunk *chunk, const gchar *string);
```
"""
function g_string_chunk_insert(chunk, string)
    @ccall libaravis.g_string_chunk_insert(chunk::Ptr{GStringChunk}, string::Ptr{gchar})::Ptr{gchar}
end

"""
    g_string_chunk_insert_len(chunk, string, len)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_string_chunk_insert_len (GStringChunk *chunk, const gchar *string, gssize len);
```
"""
function g_string_chunk_insert_len(chunk, string, len)
    @ccall libaravis.g_string_chunk_insert_len(chunk::Ptr{GStringChunk}, string::Ptr{gchar}, len::gssize)::Ptr{gchar}
end

"""
    g_string_chunk_insert_const(chunk, string)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gchar* g_string_chunk_insert_const (GStringChunk *chunk, const gchar *string);
```
"""
function g_string_chunk_insert_const(chunk, string)
    @ccall libaravis.g_string_chunk_insert_const(chunk::Ptr{GStringChunk}, string::Ptr{gchar})::Ptr{gchar}
end

const _GStrvBuilder = Cvoid

const GStrvBuilder = _GStrvBuilder

"""
    g_strv_builder_new()

### Prototype
```c
GLIB_AVAILABLE_IN_2_68 GStrvBuilder *g_strv_builder_new (void);
```
"""
function g_strv_builder_new()
    @ccall libaravis.g_strv_builder_new()::Ptr{GStrvBuilder}
end

"""
    g_strv_builder_unref(builder)

### Prototype
```c
GLIB_AVAILABLE_IN_2_68 void g_strv_builder_unref (GStrvBuilder *builder);
```
"""
function g_strv_builder_unref(builder)
    @ccall libaravis.g_strv_builder_unref(builder::Ptr{GStrvBuilder})::Cvoid
end

"""
    g_strv_builder_unref_to_strv(builder)

### Prototype
```c
GLIB_AVAILABLE_IN_2_82 GStrv g_strv_builder_unref_to_strv (GStrvBuilder *builder);
```
"""
function g_strv_builder_unref_to_strv(builder)
    @ccall libaravis.g_strv_builder_unref_to_strv(builder::Ptr{GStrvBuilder})::GStrv
end

"""
    g_strv_builder_ref(builder)

### Prototype
```c
GLIB_AVAILABLE_IN_2_68 GStrvBuilder *g_strv_builder_ref (GStrvBuilder *builder);
```
"""
function g_strv_builder_ref(builder)
    @ccall libaravis.g_strv_builder_ref(builder::Ptr{GStrvBuilder})::Ptr{GStrvBuilder}
end

"""
    g_strv_builder_add(builder, value)

### Prototype
```c
GLIB_AVAILABLE_IN_2_68 void g_strv_builder_add (GStrvBuilder *builder, const char *value);
```
"""
function g_strv_builder_add(builder, value)
    @ccall libaravis.g_strv_builder_add(builder::Ptr{GStrvBuilder}, value::Cstring)::Cvoid
end

"""
    g_strv_builder_addv(builder, value)

### Prototype
```c
GLIB_AVAILABLE_IN_2_70 void g_strv_builder_addv (GStrvBuilder *builder, const char **value);
```
"""
function g_strv_builder_addv(builder, value)
    @ccall libaravis.g_strv_builder_addv(builder::Ptr{GStrvBuilder}, value::Ptr{Cstring})::Cvoid
end

"""
    g_strv_builder_take(builder, value)

### Prototype
```c
GLIB_AVAILABLE_IN_2_80 void g_strv_builder_take (GStrvBuilder *builder, char *value);
```
"""
function g_strv_builder_take(builder, value)
    @ccall libaravis.g_strv_builder_take(builder::Ptr{GStrvBuilder}, value::Cstring)::Cvoid
end

"""
    g_strv_builder_end(builder)

### Prototype
```c
GLIB_AVAILABLE_IN_2_68 GStrv g_strv_builder_end (GStrvBuilder *builder);
```
"""
function g_strv_builder_end(builder)
    @ccall libaravis.g_strv_builder_end(builder::Ptr{GStrvBuilder})::GStrv
end

const GTestCase = Cvoid

const GTestSuite = Cvoid

# typedef void ( * GTestFunc ) ( void )
const GTestFunc = Ptr{Cvoid}

# typedef void ( * GTestDataFunc ) ( gconstpointer user_data )
const GTestDataFunc = Ptr{Cvoid}

"""
    g_test_subprocess()

### Prototype
```c
GLIB_AVAILABLE_IN_2_38 gboolean g_test_subprocess (void);
```
"""
function g_test_subprocess()
    @ccall libaravis.g_test_subprocess()::gboolean
end

"""
    g_test_run()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL int g_test_run (void);
```
"""
function g_test_run()
    @ccall libaravis.g_test_run()::Cint
end

"""
    g_test_add_func(testpath, test_func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_test_add_func (const char *testpath, GTestFunc test_func);
```
"""
function g_test_add_func(testpath, test_func)
    @ccall libaravis.g_test_add_func(testpath::Cstring, test_func::GTestFunc)::Cvoid
end

"""
    g_test_add_data_func(testpath, test_data, test_func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_test_add_data_func (const char *testpath, gconstpointer test_data, GTestDataFunc test_func);
```
"""
function g_test_add_data_func(testpath, test_data, test_func)
    @ccall libaravis.g_test_add_data_func(testpath::Cstring, test_data::gconstpointer, test_func::GTestDataFunc)::Cvoid
end

"""
    g_test_add_data_func_full(testpath, test_data, test_func, data_free_func)

### Prototype
```c
GLIB_AVAILABLE_IN_2_34 void g_test_add_data_func_full (const char *testpath, gpointer test_data, GTestDataFunc test_func, GDestroyNotify data_free_func);
```
"""
function g_test_add_data_func_full(testpath, test_data, test_func, data_free_func)
    @ccall libaravis.g_test_add_data_func_full(testpath::Cstring, test_data::gpointer, test_func::GTestDataFunc, data_free_func::GDestroyNotify)::Cvoid
end

"""
    g_test_get_path()

### Prototype
```c
GLIB_AVAILABLE_IN_2_68 const char * g_test_get_path (void);
```
"""
function g_test_get_path()
    @ccall libaravis.g_test_get_path()::Cstring
end

"""
    g_test_fail()

### Prototype
```c
GLIB_AVAILABLE_IN_2_30 void g_test_fail (void);
```
"""
function g_test_fail()
    @ccall libaravis.g_test_fail()::Cvoid
end

"""
    g_test_incomplete(msg)

### Prototype
```c
GLIB_AVAILABLE_IN_2_38 void g_test_incomplete (const gchar *msg);
```
"""
function g_test_incomplete(msg)
    @ccall libaravis.g_test_incomplete(msg::Ptr{gchar})::Cvoid
end

"""
    g_test_skip(msg)

### Prototype
```c
GLIB_AVAILABLE_IN_2_38 void g_test_skip (const gchar *msg);
```
"""
function g_test_skip(msg)
    @ccall libaravis.g_test_skip(msg::Ptr{gchar})::Cvoid
end

"""
    g_test_failed()

### Prototype
```c
GLIB_AVAILABLE_IN_2_38 gboolean g_test_failed (void);
```
"""
function g_test_failed()
    @ccall libaravis.g_test_failed()::gboolean
end

"""
    g_test_set_nonfatal_assertions()

### Prototype
```c
GLIB_AVAILABLE_IN_2_38 void g_test_set_nonfatal_assertions (void);
```
"""
function g_test_set_nonfatal_assertions()
    @ccall libaravis.g_test_set_nonfatal_assertions()::Cvoid
end

"""
    g_test_disable_crash_reporting()

### Prototype
```c
GLIB_AVAILABLE_IN_2_78 void g_test_disable_crash_reporting (void);
```
"""
function g_test_disable_crash_reporting()
    @ccall libaravis.g_test_disable_crash_reporting()::Cvoid
end

"""
    g_test_bug_base(uri_pattern)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_test_bug_base (const char *uri_pattern);
```
"""
function g_test_bug_base(uri_pattern)
    @ccall libaravis.g_test_bug_base(uri_pattern::Cstring)::Cvoid
end

"""
    g_test_bug(bug_uri_snippet)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_test_bug (const char *bug_uri_snippet);
```
"""
function g_test_bug(bug_uri_snippet)
    @ccall libaravis.g_test_bug(bug_uri_snippet::Cstring)::Cvoid
end

"""
    g_test_summary(summary)

### Prototype
```c
GLIB_AVAILABLE_IN_2_62 void g_test_summary (const char *summary);
```
"""
function g_test_summary(summary)
    @ccall libaravis.g_test_summary(summary::Cstring)::Cvoid
end

"""
    g_test_timer_start()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_test_timer_start (void);
```
"""
function g_test_timer_start()
    @ccall libaravis.g_test_timer_start()::Cvoid
end

"""
    g_test_timer_elapsed()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL double g_test_timer_elapsed (void);
```
"""
function g_test_timer_elapsed()
    @ccall libaravis.g_test_timer_elapsed()::Cdouble
end

"""
    g_test_timer_last()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL double g_test_timer_last (void);
```
"""
function g_test_timer_last()
    @ccall libaravis.g_test_timer_last()::Cdouble
end

"""
    g_test_queue_free(gfree_pointer)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_test_queue_free (gpointer gfree_pointer);
```
"""
function g_test_queue_free(gfree_pointer)
    @ccall libaravis.g_test_queue_free(gfree_pointer::gpointer)::Cvoid
end

"""
    GTestTrapFlags

[`GTestTrapFlags`](@ref): \\_TEST\\_TRAP\\_DEFAULT: Default behaviour. Since: 2.74 \\_TEST\\_TRAP\\_SILENCE\\_STDOUT: Redirect stdout of the test child to `/dev/null` so it cannot be observed on the console during test runs. The actual output is still captured though to allow later tests with [`g_test_trap_assert_stdout`](@ref)(). \\_TEST\\_TRAP\\_SILENCE\\_STDERR: Redirect stderr of the test child to `/dev/null` so it cannot be observed on the console during test runs. The actual output is still captured though to allow later tests with [`g_test_trap_assert_stderr`](@ref)(). \\_TEST\\_TRAP\\_INHERIT\\_STDIN: If this flag is given, stdin of the child process is shared with stdin of its parent process. It is redirected to `/dev/null` otherwise.

Flags to pass to [func.test\\_trap\\_fork] to control input and output.

Test traps are guards around forked tests. These flags determine what traps to set.

Deprecated: 2.38: [`GTestTrapFlags`](@ref) is used only with [func.test\\_trap\\_fork], which is deprecated. Its replacement, [func.test\\_trap\\_subprocess] uses [flags.TestSubprocessFlags].
"""
@cenum GTestTrapFlags::UInt32 begin
    G_TEST_TRAP_DEFAULT = 0
    G_TEST_TRAP_SILENCE_STDOUT = 128
    G_TEST_TRAP_SILENCE_STDERR = 256
    G_TEST_TRAP_INHERIT_STDIN = 512
end

"""
    g_test_trap_fork(usec_timeout, test_trap_flags)

### Prototype
```c
GLIB_DEPRECATED_IN_2_38_FOR (g_test_trap_subprocess) gboolean g_test_trap_fork (guint64 usec_timeout, GTestTrapFlags test_trap_flags);
```
"""
function g_test_trap_fork(usec_timeout, test_trap_flags)
    @ccall libaravis.g_test_trap_fork(usec_timeout::guint64, test_trap_flags::GTestTrapFlags)::gboolean
end

@cenum GTestSubprocessFlags::UInt32 begin
    G_TEST_SUBPROCESS_DEFAULT = 0
    G_TEST_SUBPROCESS_INHERIT_STDIN = 1
    G_TEST_SUBPROCESS_INHERIT_STDOUT = 2
    G_TEST_SUBPROCESS_INHERIT_STDERR = 4
end

"""
    g_test_trap_subprocess(test_path, usec_timeout, test_flags)

### Prototype
```c
GLIB_AVAILABLE_IN_2_38 void g_test_trap_subprocess (const char *test_path, guint64 usec_timeout, GTestSubprocessFlags test_flags);
```
"""
function g_test_trap_subprocess(test_path, usec_timeout, test_flags)
    @ccall libaravis.g_test_trap_subprocess(test_path::Cstring, usec_timeout::guint64, test_flags::GTestSubprocessFlags)::Cvoid
end

"""
    g_test_trap_subprocess_with_envp(test_path, envp, usec_timeout, test_flags)

### Prototype
```c
GLIB_AVAILABLE_IN_2_80 void g_test_trap_subprocess_with_envp (const char *test_path, const char * const *envp, guint64 usec_timeout, GTestSubprocessFlags test_flags);
```
"""
function g_test_trap_subprocess_with_envp(test_path, envp, usec_timeout, test_flags)
    @ccall libaravis.g_test_trap_subprocess_with_envp(test_path::Cstring, envp::Ptr{Cstring}, usec_timeout::guint64, test_flags::GTestSubprocessFlags)::Cvoid
end

"""
    g_test_trap_has_passed()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_test_trap_has_passed (void);
```
"""
function g_test_trap_has_passed()
    @ccall libaravis.g_test_trap_has_passed()::gboolean
end

"""
    g_test_trap_reached_timeout()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_test_trap_reached_timeout (void);
```
"""
function g_test_trap_reached_timeout()
    @ccall libaravis.g_test_trap_reached_timeout()::gboolean
end

"""
    g_test_rand_int_range(_begin, _end)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint32 g_test_rand_int_range (gint32 begin, gint32 end);
```
"""
function g_test_rand_int_range(_begin, _end)
    @ccall libaravis.g_test_rand_int_range(_begin::gint32, _end::gint32)::gint32
end

"""
    g_test_rand_double()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL double g_test_rand_double (void);
```
"""
function g_test_rand_double()
    @ccall libaravis.g_test_rand_double()::Cdouble
end

"""
    g_test_rand_double_range(range_start, range_end)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL double g_test_rand_double_range (double range_start, double range_end);
```
"""
function g_test_rand_double_range(range_start, range_end)
    @ccall libaravis.g_test_rand_double_range(range_start::Cdouble, range_end::Cdouble)::Cdouble
end

"""
    g_test_create_case(test_name, data_size, test_data, data_setup, data_test, data_teardown)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GTestCase* g_test_create_case (const char *test_name, gsize data_size, gconstpointer test_data, GTestFixtureFunc data_setup, GTestFixtureFunc data_test, GTestFixtureFunc data_teardown);
```
"""
function g_test_create_case(test_name, data_size, test_data, data_setup, data_test, data_teardown)
    @ccall libaravis.g_test_create_case(test_name::Cstring, data_size::gsize, test_data::gconstpointer, data_setup::GTestFixtureFunc, data_test::GTestFixtureFunc, data_teardown::GTestFixtureFunc)::Ptr{GTestCase}
end

"""
    g_test_create_suite(suite_name)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GTestSuite* g_test_create_suite (const char *suite_name);
```
"""
function g_test_create_suite(suite_name)
    @ccall libaravis.g_test_create_suite(suite_name::Cstring)::Ptr{GTestSuite}
end

"""
    g_test_get_root()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GTestSuite* g_test_get_root (void);
```
"""
function g_test_get_root()
    @ccall libaravis.g_test_get_root()::Ptr{GTestSuite}
end

"""
    g_test_suite_add(suite, test_case)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_test_suite_add (GTestSuite *suite, GTestCase *test_case);
```
"""
function g_test_suite_add(suite, test_case)
    @ccall libaravis.g_test_suite_add(suite::Ptr{GTestSuite}, test_case::Ptr{GTestCase})::Cvoid
end

"""
    g_test_suite_add_suite(suite, nestedsuite)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_test_suite_add_suite (GTestSuite *suite, GTestSuite *nestedsuite);
```
"""
function g_test_suite_add_suite(suite, nestedsuite)
    @ccall libaravis.g_test_suite_add_suite(suite::Ptr{GTestSuite}, nestedsuite::Ptr{GTestSuite})::Cvoid
end

"""
    g_test_run_suite(suite)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL int g_test_run_suite (GTestSuite *suite);
```
"""
function g_test_run_suite(suite)
    @ccall libaravis.g_test_run_suite(suite::Ptr{GTestSuite})::Cint
end

"""
    g_test_case_free(test_case)

### Prototype
```c
GLIB_AVAILABLE_IN_2_70 void g_test_case_free (GTestCase *test_case);
```
"""
function g_test_case_free(test_case)
    @ccall libaravis.g_test_case_free(test_case::Ptr{GTestCase})::Cvoid
end

"""
    g_test_suite_free(suite)

### Prototype
```c
GLIB_AVAILABLE_IN_2_70 void g_test_suite_free (GTestSuite *suite);
```
"""
function g_test_suite_free(suite)
    @ccall libaravis.g_test_suite_free(suite::Ptr{GTestSuite})::Cvoid
end

struct GTestConfig
    test_initialized::gboolean
    test_quick::gboolean
    test_perf::gboolean
    test_verbose::gboolean
    test_quiet::gboolean
    test_undefined::gboolean
end

@cenum GTestResult::UInt32 begin
    G_TEST_RUN_SUCCESS = 0
    G_TEST_RUN_SKIPPED = 1
    G_TEST_RUN_FAILURE = 2
    G_TEST_RUN_INCOMPLETE = 3
end

@cenum GTestLogType::UInt32 begin
    G_TEST_LOG_NONE = 0
    G_TEST_LOG_ERROR = 1
    G_TEST_LOG_START_BINARY = 2
    G_TEST_LOG_LIST_CASE = 3
    G_TEST_LOG_SKIP_CASE = 4
    G_TEST_LOG_START_CASE = 5
    G_TEST_LOG_STOP_CASE = 6
    G_TEST_LOG_MIN_RESULT = 7
    G_TEST_LOG_MAX_RESULT = 8
    G_TEST_LOG_MESSAGE = 9
    G_TEST_LOG_START_SUITE = 10
    G_TEST_LOG_STOP_SUITE = 11
end

struct GTestLogMsg
    log_type::GTestLogType
    n_strings::guint
    strings::Ptr{Ptr{gchar}}
    n_nums::guint
    nums::Ptr{Float64}
end

struct GTestLogBuffer
    data::Ptr{GString}
    msgs::Ptr{GSList}
end

"""
    g_test_log_type_name(log_type)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const char* g_test_log_type_name (GTestLogType log_type);
```
"""
function g_test_log_type_name(log_type)
    @ccall libaravis.g_test_log_type_name(log_type::GTestLogType)::Cstring
end

"""
    g_test_log_buffer_new()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GTestLogBuffer* g_test_log_buffer_new (void);
```
"""
function g_test_log_buffer_new()
    @ccall libaravis.g_test_log_buffer_new()::Ptr{GTestLogBuffer}
end

"""
    g_test_log_buffer_free(tbuffer)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_test_log_buffer_free (GTestLogBuffer *tbuffer);
```
"""
function g_test_log_buffer_free(tbuffer)
    @ccall libaravis.g_test_log_buffer_free(tbuffer::Ptr{GTestLogBuffer})::Cvoid
end

"""
    g_test_log_buffer_push(tbuffer, n_bytes, bytes)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_test_log_buffer_push (GTestLogBuffer *tbuffer, guint n_bytes, const guint8 *bytes);
```
"""
function g_test_log_buffer_push(tbuffer, n_bytes, bytes)
    @ccall libaravis.g_test_log_buffer_push(tbuffer::Ptr{GTestLogBuffer}, n_bytes::guint, bytes::Ptr{guint8})::Cvoid
end

"""
    g_test_log_buffer_pop(tbuffer)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GTestLogMsg* g_test_log_buffer_pop (GTestLogBuffer *tbuffer);
```
"""
function g_test_log_buffer_pop(tbuffer)
    @ccall libaravis.g_test_log_buffer_pop(tbuffer::Ptr{GTestLogBuffer})::Ptr{GTestLogMsg}
end

"""
    g_test_log_msg_free(tmsg)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_test_log_msg_free (GTestLogMsg *tmsg);
```
"""
function g_test_log_msg_free(tmsg)
    @ccall libaravis.g_test_log_msg_free(tmsg::Ptr{GTestLogMsg})::Cvoid
end

# typedef gboolean ( * GTestLogFatalFunc ) ( const gchar * log_domain , GLogLevelFlags log_level , const gchar * message , gpointer user_data )
"""
[`GTestLogFatalFunc`](@ref): \\_domain: the log domain of the message \\_level: the log level of the message (including the fatal and recursion flags) : the message to process \\_data: user data, set in [`g_test_log_set_fatal_handler`](@ref)()

Specifies the prototype of fatal log handler functions.

Returns: TRUE if the program should abort, FALSE otherwise

Since: 2.22
"""
const GTestLogFatalFunc = Ptr{Cvoid}

"""
    g_test_log_set_fatal_handler(log_func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_test_log_set_fatal_handler (GTestLogFatalFunc log_func, gpointer user_data);
```
"""
function g_test_log_set_fatal_handler(log_func, user_data)
    @ccall libaravis.g_test_log_set_fatal_handler(log_func::GTestLogFatalFunc, user_data::gpointer)::Cvoid
end

"""
    g_test_expect_message(log_domain, log_level, pattern)

### Prototype
```c
GLIB_AVAILABLE_IN_2_34 void g_test_expect_message (const gchar *log_domain, GLogLevelFlags log_level, const gchar *pattern);
```
"""
function g_test_expect_message(log_domain, log_level, pattern)
    @ccall libaravis.g_test_expect_message(log_domain::Ptr{gchar}, log_level::GLogLevelFlags, pattern::Ptr{gchar})::Cvoid
end

@cenum GTestFileType::UInt32 begin
    G_TEST_DIST = 0
    G_TEST_BUILT = 1
end

"""
    g_test_get_dir(file_type)

### Prototype
```c
GLIB_AVAILABLE_IN_2_38 const gchar *g_test_get_dir (GTestFileType file_type);
```
"""
function g_test_get_dir(file_type)
    @ccall libaravis.g_test_get_dir(file_type::GTestFileType)::Ptr{gchar}
end

struct _GThreadPool
    func::GFunc
    user_data::gpointer
    exclusive::gboolean
end

const GThreadPool = _GThreadPool

"""
    g_thread_pool_new(func, user_data, max_threads, exclusive, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GThreadPool * g_thread_pool_new (GFunc func, gpointer user_data, gint max_threads, gboolean exclusive, GError **error);
```
"""
function g_thread_pool_new(func, user_data, max_threads, exclusive, error)
    @ccall libaravis.g_thread_pool_new(func::GFunc, user_data::gpointer, max_threads::gint, exclusive::gboolean, error::Ptr{Ptr{GError}})::Ptr{GThreadPool}
end

"""
    g_thread_pool_new_full(func, user_data, item_free_func, max_threads, exclusive, error)

### Prototype
```c
GLIB_AVAILABLE_IN_2_70 GThreadPool * g_thread_pool_new_full (GFunc func, gpointer user_data, GDestroyNotify item_free_func, gint max_threads, gboolean exclusive, GError **error);
```
"""
function g_thread_pool_new_full(func, user_data, item_free_func, max_threads, exclusive, error)
    @ccall libaravis.g_thread_pool_new_full(func::GFunc, user_data::gpointer, item_free_func::GDestroyNotify, max_threads::gint, exclusive::gboolean, error::Ptr{Ptr{GError}})::Ptr{GThreadPool}
end

"""
    g_thread_pool_free(pool, immediate, wait_)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_thread_pool_free (GThreadPool *pool, gboolean immediate, gboolean wait_);
```
"""
function g_thread_pool_free(pool, immediate, wait_)
    @ccall libaravis.g_thread_pool_free(pool::Ptr{GThreadPool}, immediate::gboolean, wait_::gboolean)::Cvoid
end

"""
    g_thread_pool_push(pool, data, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_thread_pool_push (GThreadPool *pool, gpointer data, GError **error);
```
"""
function g_thread_pool_push(pool, data, error)
    @ccall libaravis.g_thread_pool_push(pool::Ptr{GThreadPool}, data::gpointer, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_thread_pool_unprocessed(pool)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_thread_pool_unprocessed (GThreadPool *pool);
```
"""
function g_thread_pool_unprocessed(pool)
    @ccall libaravis.g_thread_pool_unprocessed(pool::Ptr{GThreadPool})::guint
end

"""
    g_thread_pool_set_sort_function(pool, func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_thread_pool_set_sort_function (GThreadPool *pool, GCompareDataFunc func, gpointer user_data);
```
"""
function g_thread_pool_set_sort_function(pool, func, user_data)
    @ccall libaravis.g_thread_pool_set_sort_function(pool::Ptr{GThreadPool}, func::GCompareDataFunc, user_data::gpointer)::Cvoid
end

"""
    g_thread_pool_move_to_front(pool, data)

### Prototype
```c
GLIB_AVAILABLE_IN_2_46 gboolean g_thread_pool_move_to_front (GThreadPool *pool, gpointer data);
```
"""
function g_thread_pool_move_to_front(pool, data)
    @ccall libaravis.g_thread_pool_move_to_front(pool::Ptr{GThreadPool}, data::gpointer)::gboolean
end

"""
    g_thread_pool_set_max_threads(pool, max_threads, error)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_thread_pool_set_max_threads (GThreadPool *pool, gint max_threads, GError **error);
```
"""
function g_thread_pool_set_max_threads(pool, max_threads, error)
    @ccall libaravis.g_thread_pool_set_max_threads(pool::Ptr{GThreadPool}, max_threads::gint, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_thread_pool_get_max_threads(pool)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_thread_pool_get_max_threads (GThreadPool *pool);
```
"""
function g_thread_pool_get_max_threads(pool)
    @ccall libaravis.g_thread_pool_get_max_threads(pool::Ptr{GThreadPool})::gint
end

"""
    g_thread_pool_get_num_threads(pool)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_thread_pool_get_num_threads (GThreadPool *pool);
```
"""
function g_thread_pool_get_num_threads(pool)
    @ccall libaravis.g_thread_pool_get_num_threads(pool::Ptr{GThreadPool})::guint
end

"""
    g_thread_pool_set_max_unused_threads(max_threads)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_thread_pool_set_max_unused_threads (gint max_threads);
```
"""
function g_thread_pool_set_max_unused_threads(max_threads)
    @ccall libaravis.g_thread_pool_set_max_unused_threads(max_threads::gint)::Cvoid
end

"""
    g_thread_pool_get_max_unused_threads()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_thread_pool_get_max_unused_threads (void);
```
"""
function g_thread_pool_get_max_unused_threads()
    @ccall libaravis.g_thread_pool_get_max_unused_threads()::gint
end

"""
    g_thread_pool_get_num_unused_threads()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_thread_pool_get_num_unused_threads (void);
```
"""
function g_thread_pool_get_num_unused_threads()
    @ccall libaravis.g_thread_pool_get_num_unused_threads()::guint
end

"""
    g_thread_pool_stop_unused_threads()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_thread_pool_stop_unused_threads (void);
```
"""
function g_thread_pool_stop_unused_threads()
    @ccall libaravis.g_thread_pool_stop_unused_threads()::Cvoid
end

"""
    g_thread_pool_set_max_idle_time(interval)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_thread_pool_set_max_idle_time (guint interval);
```
"""
function g_thread_pool_set_max_idle_time(interval)
    @ccall libaravis.g_thread_pool_set_max_idle_time(interval::guint)::Cvoid
end

"""
    g_thread_pool_get_max_idle_time()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL guint g_thread_pool_get_max_idle_time (void);
```
"""
function g_thread_pool_get_max_idle_time()
    @ccall libaravis.g_thread_pool_get_max_idle_time()::guint
end

const _GTimer = Cvoid

const GTimer = _GTimer

"""
    g_timer_new()

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GTimer* g_timer_new (void);
```
"""
function g_timer_new()
    @ccall libaravis.g_timer_new()::Ptr{GTimer}
end

"""
    g_timer_destroy(timer)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_timer_destroy (GTimer *timer);
```
"""
function g_timer_destroy(timer)
    @ccall libaravis.g_timer_destroy(timer::Ptr{GTimer})::Cvoid
end

"""
    g_timer_start(timer)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_timer_start (GTimer *timer);
```
"""
function g_timer_start(timer)
    @ccall libaravis.g_timer_start(timer::Ptr{GTimer})::Cvoid
end

"""
    g_timer_stop(timer)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_timer_stop (GTimer *timer);
```
"""
function g_timer_stop(timer)
    @ccall libaravis.g_timer_stop(timer::Ptr{GTimer})::Cvoid
end

"""
    g_timer_reset(timer)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_timer_reset (GTimer *timer);
```
"""
function g_timer_reset(timer)
    @ccall libaravis.g_timer_reset(timer::Ptr{GTimer})::Cvoid
end

"""
    g_timer_continue(timer)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_timer_continue (GTimer *timer);
```
"""
function g_timer_continue(timer)
    @ccall libaravis.g_timer_continue(timer::Ptr{GTimer})::Cvoid
end

"""
    g_timer_elapsed(timer, microseconds)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gdouble g_timer_elapsed (GTimer *timer, gulong *microseconds);
```
"""
function g_timer_elapsed(timer, microseconds)
    @ccall libaravis.g_timer_elapsed(timer::Ptr{GTimer}, microseconds::Ptr{gulong})::gdouble
end

"""
    g_timer_is_active(timer)

### Prototype
```c
GLIB_AVAILABLE_IN_2_62 gboolean g_timer_is_active (GTimer *timer);
```
"""
function g_timer_is_active(timer)
    @ccall libaravis.g_timer_is_active(timer::Ptr{GTimer})::gboolean
end

"""
    g_usleep(microseconds)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_usleep (gulong microseconds);
```
"""
function g_usleep(microseconds)
    @ccall libaravis.g_usleep(microseconds::gulong)::Cvoid
end

"""
    g_time_val_add(time_, microseconds)

### Prototype
```c
GLIB_DEPRECATED_IN_2_62 void g_time_val_add (GTimeVal *time_, glong microseconds);
```
"""
function g_time_val_add(time_, microseconds)
    @ccall libaravis.g_time_val_add(time_::Ptr{GTimeVal}, microseconds::glong)::Cvoid
end

"""
    g_time_val_from_iso8601(iso_date, time_)

### Prototype
```c
GLIB_DEPRECATED_IN_2_62_FOR(g_date_time_new_from_iso8601) gboolean g_time_val_from_iso8601 (const gchar *iso_date, GTimeVal *time_);
```
"""
function g_time_val_from_iso8601(iso_date, time_)
    @ccall libaravis.g_time_val_from_iso8601(iso_date::Ptr{gchar}, time_::Ptr{GTimeVal})::gboolean
end

"""
    g_time_val_to_iso8601(time_)

### Prototype
```c
GLIB_DEPRECATED_IN_2_62_FOR(g_date_time_format) gchar* g_time_val_to_iso8601 (GTimeVal *time_) G_GNUC_MALLOC;
```
"""
function g_time_val_to_iso8601(time_)
    @ccall libaravis.g_time_val_to_iso8601(time_::Ptr{GTimeVal})::Ptr{gchar}
end

struct _GTrashStack
    data::NTuple{8, UInt8}
end

function Base.getproperty(x::Ptr{_GTrashStack}, f::Symbol)
    f === :next && return Ptr{Ptr{GTrashStack}}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::_GTrashStack, f::Symbol)
    r = Ref{_GTrashStack}(x)
    ptr = Base.unsafe_convert(Ptr{_GTrashStack}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{_GTrashStack}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::_GTrashStack, private::Bool = false)
    (:next, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

const GTrashStack = _GTrashStack

"""
    g_trash_stack_push(stack_p, data_p)

### Prototype
```c
GLIB_DEPRECATED_IN_2_48 void g_trash_stack_push (GTrashStack **stack_p, gpointer data_p);
```
"""
function g_trash_stack_push(stack_p, data_p)
    @ccall libaravis.g_trash_stack_push(stack_p::Ptr{Ptr{GTrashStack}}, data_p::gpointer)::Cvoid
end

"""
    g_trash_stack_pop(stack_p)

### Prototype
```c
GLIB_DEPRECATED_IN_2_48 gpointer g_trash_stack_pop (GTrashStack **stack_p);
```
"""
function g_trash_stack_pop(stack_p)
    @ccall libaravis.g_trash_stack_pop(stack_p::Ptr{Ptr{GTrashStack}})::gpointer
end

"""
    g_trash_stack_peek(stack_p)

### Prototype
```c
GLIB_DEPRECATED_IN_2_48 gpointer g_trash_stack_peek (GTrashStack **stack_p);
```
"""
function g_trash_stack_peek(stack_p)
    @ccall libaravis.g_trash_stack_peek(stack_p::Ptr{Ptr{GTrashStack}})::gpointer
end

"""
    g_trash_stack_height(stack_p)

### Prototype
```c
GLIB_DEPRECATED_IN_2_48 guint g_trash_stack_height (GTrashStack **stack_p);
```
"""
function g_trash_stack_height(stack_p)
    @ccall libaravis.g_trash_stack_height(stack_p::Ptr{Ptr{GTrashStack}})::guint
end

const _GTree = Cvoid

const GTree = _GTree

const _GTreeNode = Cvoid

"""
[`GTreeNode`](@ref):

An opaque type which identifies a specific node in a #[`GTree`](@ref).

Since: 2.68
"""
const GTreeNode = _GTreeNode

# typedef gboolean ( * GTraverseFunc ) ( gpointer key , gpointer value , gpointer data )
const GTraverseFunc = Ptr{Cvoid}

# typedef gboolean ( * GTraverseNodeFunc ) ( GTreeNode * node , gpointer data )
"""
[`GTraverseNodeFunc`](@ref): : a #[`GTreeNode`](@ref)

\\date : user data passed to [`g_tree_foreach_node`](@ref)()

Specifies the type of function passed to [`g_tree_foreach_node`](@ref)(). It is passed each node, together with the \\_data parameter passed to [`g_tree_foreach_node`](@ref)(). If the function returns TRUE, the traversal is stopped.

Returns: TRUE to stop the traversal Since: 2.68
"""
const GTraverseNodeFunc = Ptr{Cvoid}

"""
    g_tree_new(key_compare_func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GTree* g_tree_new (GCompareFunc key_compare_func);
```
"""
function g_tree_new(key_compare_func)
    @ccall libaravis.g_tree_new(key_compare_func::GCompareFunc)::Ptr{GTree}
end

"""
    g_tree_new_with_data(key_compare_func, key_compare_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GTree* g_tree_new_with_data (GCompareDataFunc key_compare_func, gpointer key_compare_data);
```
"""
function g_tree_new_with_data(key_compare_func, key_compare_data)
    @ccall libaravis.g_tree_new_with_data(key_compare_func::GCompareDataFunc, key_compare_data::gpointer)::Ptr{GTree}
end

"""
    g_tree_new_full(key_compare_func, key_compare_data, key_destroy_func, value_destroy_func)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GTree* g_tree_new_full (GCompareDataFunc key_compare_func, gpointer key_compare_data, GDestroyNotify key_destroy_func, GDestroyNotify value_destroy_func);
```
"""
function g_tree_new_full(key_compare_func, key_compare_data, key_destroy_func, value_destroy_func)
    @ccall libaravis.g_tree_new_full(key_compare_func::GCompareDataFunc, key_compare_data::gpointer, key_destroy_func::GDestroyNotify, value_destroy_func::GDestroyNotify)::Ptr{GTree}
end

"""
    g_tree_node_first(tree)

### Prototype
```c
GLIB_AVAILABLE_IN_2_68 GTreeNode *g_tree_node_first (GTree *tree);
```
"""
function g_tree_node_first(tree)
    @ccall libaravis.g_tree_node_first(tree::Ptr{GTree})::Ptr{GTreeNode}
end

"""
    g_tree_node_last(tree)

### Prototype
```c
GLIB_AVAILABLE_IN_2_68 GTreeNode *g_tree_node_last (GTree *tree);
```
"""
function g_tree_node_last(tree)
    @ccall libaravis.g_tree_node_last(tree::Ptr{GTree})::Ptr{GTreeNode}
end

"""
    g_tree_node_previous(node)

### Prototype
```c
GLIB_AVAILABLE_IN_2_68 GTreeNode *g_tree_node_previous (GTreeNode *node);
```
"""
function g_tree_node_previous(node)
    @ccall libaravis.g_tree_node_previous(node::Ptr{GTreeNode})::Ptr{GTreeNode}
end

"""
    g_tree_node_next(node)

### Prototype
```c
GLIB_AVAILABLE_IN_2_68 GTreeNode *g_tree_node_next (GTreeNode *node);
```
"""
function g_tree_node_next(node)
    @ccall libaravis.g_tree_node_next(node::Ptr{GTreeNode})::Ptr{GTreeNode}
end

"""
    g_tree_ref(tree)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL GTree* g_tree_ref (GTree *tree);
```
"""
function g_tree_ref(tree)
    @ccall libaravis.g_tree_ref(tree::Ptr{GTree})::Ptr{GTree}
end

"""
    g_tree_unref(tree)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_tree_unref (GTree *tree);
```
"""
function g_tree_unref(tree)
    @ccall libaravis.g_tree_unref(tree::Ptr{GTree})::Cvoid
end

"""
    g_tree_destroy(tree)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_tree_destroy (GTree *tree);
```
"""
function g_tree_destroy(tree)
    @ccall libaravis.g_tree_destroy(tree::Ptr{GTree})::Cvoid
end

"""
    g_tree_insert_node(tree, key, value)

### Prototype
```c
GLIB_AVAILABLE_IN_2_68 GTreeNode *g_tree_insert_node (GTree *tree, gpointer key, gpointer value);
```
"""
function g_tree_insert_node(tree, key, value)
    @ccall libaravis.g_tree_insert_node(tree::Ptr{GTree}, key::gpointer, value::gpointer)::Ptr{GTreeNode}
end

"""
    g_tree_insert(tree, key, value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_tree_insert (GTree *tree, gpointer key, gpointer value);
```
"""
function g_tree_insert(tree, key, value)
    @ccall libaravis.g_tree_insert(tree::Ptr{GTree}, key::gpointer, value::gpointer)::Cvoid
end

"""
    g_tree_replace_node(tree, key, value)

### Prototype
```c
GLIB_AVAILABLE_IN_2_68 GTreeNode *g_tree_replace_node (GTree *tree, gpointer key, gpointer value);
```
"""
function g_tree_replace_node(tree, key, value)
    @ccall libaravis.g_tree_replace_node(tree::Ptr{GTree}, key::gpointer, value::gpointer)::Ptr{GTreeNode}
end

"""
    g_tree_replace(tree, key, value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_tree_replace (GTree *tree, gpointer key, gpointer value);
```
"""
function g_tree_replace(tree, key, value)
    @ccall libaravis.g_tree_replace(tree::Ptr{GTree}, key::gpointer, value::gpointer)::Cvoid
end

"""
    g_tree_remove(tree, key)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_tree_remove (GTree *tree, gconstpointer key);
```
"""
function g_tree_remove(tree, key)
    @ccall libaravis.g_tree_remove(tree::Ptr{GTree}, key::gconstpointer)::gboolean
end

"""
    g_tree_remove_all(tree)

### Prototype
```c
GLIB_AVAILABLE_IN_2_70 void g_tree_remove_all (GTree *tree);
```
"""
function g_tree_remove_all(tree)
    @ccall libaravis.g_tree_remove_all(tree::Ptr{GTree})::Cvoid
end

"""
    g_tree_steal(tree, key)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_tree_steal (GTree *tree, gconstpointer key);
```
"""
function g_tree_steal(tree, key)
    @ccall libaravis.g_tree_steal(tree::Ptr{GTree}, key::gconstpointer)::gboolean
end

"""
    g_tree_node_key(node)

### Prototype
```c
GLIB_AVAILABLE_IN_2_68 gpointer g_tree_node_key (GTreeNode *node);
```
"""
function g_tree_node_key(node)
    @ccall libaravis.g_tree_node_key(node::Ptr{GTreeNode})::gpointer
end

"""
    g_tree_node_value(node)

### Prototype
```c
GLIB_AVAILABLE_IN_2_68 gpointer g_tree_node_value (GTreeNode *node);
```
"""
function g_tree_node_value(node)
    @ccall libaravis.g_tree_node_value(node::Ptr{GTreeNode})::gpointer
end

"""
    g_tree_lookup_node(tree, key)

### Prototype
```c
GLIB_AVAILABLE_IN_2_68 GTreeNode *g_tree_lookup_node (GTree *tree, gconstpointer key);
```
"""
function g_tree_lookup_node(tree, key)
    @ccall libaravis.g_tree_lookup_node(tree::Ptr{GTree}, key::gconstpointer)::Ptr{GTreeNode}
end

"""
    g_tree_lookup(tree, key)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_tree_lookup (GTree *tree, gconstpointer key);
```
"""
function g_tree_lookup(tree, key)
    @ccall libaravis.g_tree_lookup(tree::Ptr{GTree}, key::gconstpointer)::gpointer
end

"""
    g_tree_lookup_extended(tree, lookup_key, orig_key, value)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gboolean g_tree_lookup_extended (GTree *tree, gconstpointer lookup_key, gpointer *orig_key, gpointer *value);
```
"""
function g_tree_lookup_extended(tree, lookup_key, orig_key, value)
    @ccall libaravis.g_tree_lookup_extended(tree::Ptr{GTree}, lookup_key::gconstpointer, orig_key::Ptr{gpointer}, value::Ptr{gpointer})::gboolean
end

"""
    g_tree_foreach(tree, func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL void g_tree_foreach (GTree *tree, GTraverseFunc func, gpointer user_data);
```
"""
function g_tree_foreach(tree, func, user_data)
    @ccall libaravis.g_tree_foreach(tree::Ptr{GTree}, func::GTraverseFunc, user_data::gpointer)::Cvoid
end

"""
    g_tree_foreach_node(tree, func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_2_68 void g_tree_foreach_node (GTree *tree, GTraverseNodeFunc func, gpointer user_data);
```
"""
function g_tree_foreach_node(tree, func, user_data)
    @ccall libaravis.g_tree_foreach_node(tree::Ptr{GTree}, func::GTraverseNodeFunc, user_data::gpointer)::Cvoid
end

"""
    g_tree_traverse(tree, traverse_func, traverse_type, user_data)

### Prototype
```c
GLIB_DEPRECATED void g_tree_traverse (GTree *tree, GTraverseFunc traverse_func, GTraverseType traverse_type, gpointer user_data);
```
"""
function g_tree_traverse(tree, traverse_func, traverse_type, user_data)
    @ccall libaravis.g_tree_traverse(tree::Ptr{GTree}, traverse_func::GTraverseFunc, traverse_type::GTraverseType, user_data::gpointer)::Cvoid
end

"""
    g_tree_search_node(tree, search_func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_2_68 GTreeNode *g_tree_search_node (GTree *tree, GCompareFunc search_func, gconstpointer user_data);
```
"""
function g_tree_search_node(tree, search_func, user_data)
    @ccall libaravis.g_tree_search_node(tree::Ptr{GTree}, search_func::GCompareFunc, user_data::gconstpointer)::Ptr{GTreeNode}
end

"""
    g_tree_search(tree, search_func, user_data)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gpointer g_tree_search (GTree *tree, GCompareFunc search_func, gconstpointer user_data);
```
"""
function g_tree_search(tree, search_func, user_data)
    @ccall libaravis.g_tree_search(tree::Ptr{GTree}, search_func::GCompareFunc, user_data::gconstpointer)::gpointer
end

"""
    g_tree_lower_bound(tree, key)

### Prototype
```c
GLIB_AVAILABLE_IN_2_68 GTreeNode *g_tree_lower_bound (GTree *tree, gconstpointer key);
```
"""
function g_tree_lower_bound(tree, key)
    @ccall libaravis.g_tree_lower_bound(tree::Ptr{GTree}, key::gconstpointer)::Ptr{GTreeNode}
end

"""
    g_tree_upper_bound(tree, key)

### Prototype
```c
GLIB_AVAILABLE_IN_2_68 GTreeNode *g_tree_upper_bound (GTree *tree, gconstpointer key);
```
"""
function g_tree_upper_bound(tree, key)
    @ccall libaravis.g_tree_upper_bound(tree::Ptr{GTree}, key::gconstpointer)::Ptr{GTreeNode}
end

"""
    g_tree_height(tree)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_tree_height (GTree *tree);
```
"""
function g_tree_height(tree)
    @ccall libaravis.g_tree_height(tree::Ptr{GTree})::gint
end

"""
    g_tree_nnodes(tree)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL gint g_tree_nnodes (GTree *tree);
```
"""
function g_tree_nnodes(tree)
    @ccall libaravis.g_tree_nnodes(tree::Ptr{GTree})::gint
end

const _GUri = Cvoid

const GUri = _GUri

"""
    g_uri_ref(uri)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 GUri * g_uri_ref (GUri *uri);
```
"""
function g_uri_ref(uri)
    @ccall libaravis.g_uri_ref(uri::Ptr{GUri})::Ptr{GUri}
end

"""
    g_uri_unref(uri)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 void g_uri_unref (GUri *uri);
```
"""
function g_uri_unref(uri)
    @ccall libaravis.g_uri_unref(uri::Ptr{GUri})::Cvoid
end

"""
    GUriFlags

[`GUriFlags`](@ref): \\_URI\\_FLAGS\\_NONE: No flags set. \\_URI\\_FLAGS\\_PARSE\\_RELAXED: Parse the URI more relaxedly than the [RFC 3986](https://tools.ietf.org/html/rfc3986) grammar specifies, fixing up or ignoring common mistakes in URIs coming from external sources. This is also needed for some obscure URI schemes where `;` separates the host from the path. Dont use this flag unless you need to. \\_URI\\_FLAGS\\_HAS\\_PASSWORD: The userinfo field may contain a password, which will be separated from the username by `:`. \\_URI\\_FLAGS\\_HAS\\_AUTH\\_PARAMS: The userinfo may contain additional authentication-related parameters, which will be separated from the username and/or password by `;`. \\_URI\\_FLAGS\\_NON\\_DNS: The host component should not be assumed to be a DNS hostname or IP address (for example, for `smb` URIs with NetBIOS hostnames). \\_URI\\_FLAGS\\_ENCODED: When parsing a URI, this indicates that `%`-encoded characters in the userinfo, path, query, and fragment fields should not be decoded. (And likewise the host field if G\\_URI\\_FLAGS\\_NON\\_DNS is also set.) When building a URI, it indicates that you have already `%`-encoded the components, and so #[`GUri`](@ref) should not do any encoding itself. \\_URI\\_FLAGS\\_ENCODED\\_QUERY: Same as G\\_URI\\_FLAGS\\_ENCODED, for the query field only. \\_URI\\_FLAGS\\_ENCODED\\_PATH: Same as G\\_URI\\_FLAGS\\_ENCODED, for the path only. \\_URI\\_FLAGS\\_ENCODED\\_FRAGMENT: Same as G\\_URI\\_FLAGS\\_ENCODED, for the fragment only. \\_URI\\_FLAGS\\_SCHEME\\_NORMALIZE: A scheme-based normalization will be applied. For example, when parsing an HTTP URI changing omitted path to `/` and omitted port to `80`; and when building a URI, changing empty path to `/` and default port `80`). This only supports a subset of known schemes. (Since: 2.68)

Flags that describe a URI.

When parsing a URI, if you need to choose different flags based on the type of URI, you can use [`g_uri_peek_scheme`](@ref)() on the URI string to check the scheme first, and use that to decide what flags to parse it with.

Since: 2.66
"""
@cenum GUriFlags::UInt32 begin
    G_URI_FLAGS_NONE = 0
    G_URI_FLAGS_PARSE_RELAXED = 1
    G_URI_FLAGS_HAS_PASSWORD = 2
    G_URI_FLAGS_HAS_AUTH_PARAMS = 4
    G_URI_FLAGS_ENCODED = 8
    G_URI_FLAGS_NON_DNS = 16
    G_URI_FLAGS_ENCODED_QUERY = 32
    G_URI_FLAGS_ENCODED_PATH = 64
    G_URI_FLAGS_ENCODED_FRAGMENT = 128
    G_URI_FLAGS_SCHEME_NORMALIZE = 256
end

"""
    g_uri_split(uri_ref, flags, scheme, userinfo, host, port, path, query, fragment, error)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 gboolean g_uri_split (const gchar *uri_ref, GUriFlags flags, gchar **scheme, gchar **userinfo, gchar **host, gint *port, gchar **path, gchar **query, gchar **fragment, GError **error);
```
"""
function g_uri_split(uri_ref, flags, scheme, userinfo, host, port, path, query, fragment, error)
    @ccall libaravis.g_uri_split(uri_ref::Ptr{gchar}, flags::GUriFlags, scheme::Ptr{Ptr{gchar}}, userinfo::Ptr{Ptr{gchar}}, host::Ptr{Ptr{gchar}}, port::Ptr{gint}, path::Ptr{Ptr{gchar}}, query::Ptr{Ptr{gchar}}, fragment::Ptr{Ptr{gchar}}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_uri_split_with_user(uri_ref, flags, scheme, user, password, auth_params, host, port, path, query, fragment, error)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 gboolean g_uri_split_with_user (const gchar *uri_ref, GUriFlags flags, gchar **scheme, gchar **user, gchar **password, gchar **auth_params, gchar **host, gint *port, gchar **path, gchar **query, gchar **fragment, GError **error);
```
"""
function g_uri_split_with_user(uri_ref, flags, scheme, user, password, auth_params, host, port, path, query, fragment, error)
    @ccall libaravis.g_uri_split_with_user(uri_ref::Ptr{gchar}, flags::GUriFlags, scheme::Ptr{Ptr{gchar}}, user::Ptr{Ptr{gchar}}, password::Ptr{Ptr{gchar}}, auth_params::Ptr{Ptr{gchar}}, host::Ptr{Ptr{gchar}}, port::Ptr{gint}, path::Ptr{Ptr{gchar}}, query::Ptr{Ptr{gchar}}, fragment::Ptr{Ptr{gchar}}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_uri_split_network(uri_string, flags, scheme, host, port, error)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 gboolean g_uri_split_network (const gchar *uri_string, GUriFlags flags, gchar **scheme, gchar **host, gint *port, GError **error);
```
"""
function g_uri_split_network(uri_string, flags, scheme, host, port, error)
    @ccall libaravis.g_uri_split_network(uri_string::Ptr{gchar}, flags::GUriFlags, scheme::Ptr{Ptr{gchar}}, host::Ptr{Ptr{gchar}}, port::Ptr{gint}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_uri_is_valid(uri_string, flags, error)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 gboolean g_uri_is_valid (const gchar *uri_string, GUriFlags flags, GError **error);
```
"""
function g_uri_is_valid(uri_string, flags, error)
    @ccall libaravis.g_uri_is_valid(uri_string::Ptr{gchar}, flags::GUriFlags, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_uri_join(flags, scheme, userinfo, host, port, path, query, fragment)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 gchar * g_uri_join (GUriFlags flags, const gchar *scheme, const gchar *userinfo, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment);
```
"""
function g_uri_join(flags, scheme, userinfo, host, port, path, query, fragment)
    @ccall libaravis.g_uri_join(flags::GUriFlags, scheme::Ptr{gchar}, userinfo::Ptr{gchar}, host::Ptr{gchar}, port::gint, path::Ptr{gchar}, query::Ptr{gchar}, fragment::Ptr{gchar})::Ptr{gchar}
end

"""
    g_uri_join_with_user(flags, scheme, user, password, auth_params, host, port, path, query, fragment)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 gchar * g_uri_join_with_user (GUriFlags flags, const gchar *scheme, const gchar *user, const gchar *password, const gchar *auth_params, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment);
```
"""
function g_uri_join_with_user(flags, scheme, user, password, auth_params, host, port, path, query, fragment)
    @ccall libaravis.g_uri_join_with_user(flags::GUriFlags, scheme::Ptr{gchar}, user::Ptr{gchar}, password::Ptr{gchar}, auth_params::Ptr{gchar}, host::Ptr{gchar}, port::gint, path::Ptr{gchar}, query::Ptr{gchar}, fragment::Ptr{gchar})::Ptr{gchar}
end

"""
    g_uri_parse(uri_string, flags, error)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 GUri * g_uri_parse (const gchar *uri_string, GUriFlags flags, GError **error);
```
"""
function g_uri_parse(uri_string, flags, error)
    @ccall libaravis.g_uri_parse(uri_string::Ptr{gchar}, flags::GUriFlags, error::Ptr{Ptr{GError}})::Ptr{GUri}
end

"""
    g_uri_parse_relative(base_uri, uri_ref, flags, error)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 GUri * g_uri_parse_relative (GUri *base_uri, const gchar *uri_ref, GUriFlags flags, GError **error);
```
"""
function g_uri_parse_relative(base_uri, uri_ref, flags, error)
    @ccall libaravis.g_uri_parse_relative(base_uri::Ptr{GUri}, uri_ref::Ptr{gchar}, flags::GUriFlags, error::Ptr{Ptr{GError}})::Ptr{GUri}
end

"""
    g_uri_resolve_relative(base_uri_string, uri_ref, flags, error)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 gchar * g_uri_resolve_relative (const gchar *base_uri_string, const gchar *uri_ref, GUriFlags flags, GError **error);
```
"""
function g_uri_resolve_relative(base_uri_string, uri_ref, flags, error)
    @ccall libaravis.g_uri_resolve_relative(base_uri_string::Ptr{gchar}, uri_ref::Ptr{gchar}, flags::GUriFlags, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_uri_build(flags, scheme, userinfo, host, port, path, query, fragment)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 GUri * g_uri_build (GUriFlags flags, const gchar *scheme, const gchar *userinfo, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment);
```
"""
function g_uri_build(flags, scheme, userinfo, host, port, path, query, fragment)
    @ccall libaravis.g_uri_build(flags::GUriFlags, scheme::Ptr{gchar}, userinfo::Ptr{gchar}, host::Ptr{gchar}, port::gint, path::Ptr{gchar}, query::Ptr{gchar}, fragment::Ptr{gchar})::Ptr{GUri}
end

"""
    g_uri_build_with_user(flags, scheme, user, password, auth_params, host, port, path, query, fragment)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 GUri * g_uri_build_with_user (GUriFlags flags, const gchar *scheme, const gchar *user, const gchar *password, const gchar *auth_params, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment);
```
"""
function g_uri_build_with_user(flags, scheme, user, password, auth_params, host, port, path, query, fragment)
    @ccall libaravis.g_uri_build_with_user(flags::GUriFlags, scheme::Ptr{gchar}, user::Ptr{gchar}, password::Ptr{gchar}, auth_params::Ptr{gchar}, host::Ptr{gchar}, port::gint, path::Ptr{gchar}, query::Ptr{gchar}, fragment::Ptr{gchar})::Ptr{GUri}
end

"""
    GUriHideFlags

[`GUriHideFlags`](@ref): \\_URI\\_HIDE\\_NONE: No flags set. \\_URI\\_HIDE\\_USERINFO: Hide the userinfo. \\_URI\\_HIDE\\_PASSWORD: Hide the password. \\_URI\\_HIDE\\_AUTH\\_PARAMS: Hide the auth\\_params. \\_URI\\_HIDE\\_QUERY: Hide the query. \\_URI\\_HIDE\\_FRAGMENT: Hide the fragment.

Flags describing what parts of the URI to hide in [`g_uri_to_string_partial`](@ref)(). Note that G\\_URI\\_HIDE\\_PASSWORD and G\\_URI\\_HIDE\\_AUTH\\_PARAMS will only work if the #[`GUri`](@ref) was parsed with the corresponding flags.

Since: 2.66
"""
@cenum GUriHideFlags::UInt32 begin
    G_URI_HIDE_NONE = 0
    G_URI_HIDE_USERINFO = 1
    G_URI_HIDE_PASSWORD = 2
    G_URI_HIDE_AUTH_PARAMS = 4
    G_URI_HIDE_QUERY = 8
    G_URI_HIDE_FRAGMENT = 16
end

"""
    g_uri_to_string(uri)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 char * g_uri_to_string (GUri *uri);
```
"""
function g_uri_to_string(uri)
    @ccall libaravis.g_uri_to_string(uri::Ptr{GUri})::Cstring
end

"""
    g_uri_to_string_partial(uri, flags)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 char * g_uri_to_string_partial (GUri *uri, GUriHideFlags flags);
```
"""
function g_uri_to_string_partial(uri, flags)
    @ccall libaravis.g_uri_to_string_partial(uri::Ptr{GUri}, flags::GUriHideFlags)::Cstring
end

"""
    g_uri_get_scheme(uri)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 const gchar *g_uri_get_scheme (GUri *uri);
```
"""
function g_uri_get_scheme(uri)
    @ccall libaravis.g_uri_get_scheme(uri::Ptr{GUri})::Ptr{gchar}
end

"""
    g_uri_get_userinfo(uri)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 const gchar *g_uri_get_userinfo (GUri *uri);
```
"""
function g_uri_get_userinfo(uri)
    @ccall libaravis.g_uri_get_userinfo(uri::Ptr{GUri})::Ptr{gchar}
end

"""
    g_uri_get_user(uri)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 const gchar *g_uri_get_user (GUri *uri);
```
"""
function g_uri_get_user(uri)
    @ccall libaravis.g_uri_get_user(uri::Ptr{GUri})::Ptr{gchar}
end

"""
    g_uri_get_password(uri)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 const gchar *g_uri_get_password (GUri *uri);
```
"""
function g_uri_get_password(uri)
    @ccall libaravis.g_uri_get_password(uri::Ptr{GUri})::Ptr{gchar}
end

"""
    g_uri_get_auth_params(uri)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 const gchar *g_uri_get_auth_params (GUri *uri);
```
"""
function g_uri_get_auth_params(uri)
    @ccall libaravis.g_uri_get_auth_params(uri::Ptr{GUri})::Ptr{gchar}
end

"""
    g_uri_get_host(uri)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 const gchar *g_uri_get_host (GUri *uri);
```
"""
function g_uri_get_host(uri)
    @ccall libaravis.g_uri_get_host(uri::Ptr{GUri})::Ptr{gchar}
end

"""
    g_uri_get_port(uri)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 gint g_uri_get_port (GUri *uri);
```
"""
function g_uri_get_port(uri)
    @ccall libaravis.g_uri_get_port(uri::Ptr{GUri})::gint
end

"""
    g_uri_get_path(uri)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 const gchar *g_uri_get_path (GUri *uri);
```
"""
function g_uri_get_path(uri)
    @ccall libaravis.g_uri_get_path(uri::Ptr{GUri})::Ptr{gchar}
end

"""
    g_uri_get_query(uri)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 const gchar *g_uri_get_query (GUri *uri);
```
"""
function g_uri_get_query(uri)
    @ccall libaravis.g_uri_get_query(uri::Ptr{GUri})::Ptr{gchar}
end

"""
    g_uri_get_fragment(uri)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 const gchar *g_uri_get_fragment (GUri *uri);
```
"""
function g_uri_get_fragment(uri)
    @ccall libaravis.g_uri_get_fragment(uri::Ptr{GUri})::Ptr{gchar}
end

"""
    g_uri_get_flags(uri)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 GUriFlags g_uri_get_flags (GUri *uri);
```
"""
function g_uri_get_flags(uri)
    @ccall libaravis.g_uri_get_flags(uri::Ptr{GUri})::GUriFlags
end

"""
    GUriParamsFlags

[`GUriParamsFlags`](@ref): \\_URI\\_PARAMS\\_NONE: No flags set. \\_URI\\_PARAMS\\_CASE\\_INSENSITIVE: Parameter names are case insensitive. \\_URI\\_PARAMS\\_WWW\\_FORM: Replace `+` with space character. Only useful for URLs on the web, using the `https` or `http` schemas. \\_URI\\_PARAMS\\_PARSE\\_RELAXED: See G\\_URI\\_FLAGS\\_PARSE\\_RELAXED.

Flags modifying the way parameters are handled by [`g_uri_parse_params`](@ref)() and #[`GUriParamsIter`](@ref).

Since: 2.66
"""
@cenum GUriParamsFlags::UInt32 begin
    G_URI_PARAMS_NONE = 0
    G_URI_PARAMS_CASE_INSENSITIVE = 1
    G_URI_PARAMS_WWW_FORM = 2
    G_URI_PARAMS_PARSE_RELAXED = 4
end

"""
    g_uri_parse_params(params, length, separators, flags, error)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 GHashTable *g_uri_parse_params (const gchar *params, gssize length, const gchar *separators, GUriParamsFlags flags, GError **error);
```
"""
function g_uri_parse_params(params, length, separators, flags, error)
    @ccall libaravis.g_uri_parse_params(params::Ptr{gchar}, length::gssize, separators::Ptr{gchar}, flags::GUriParamsFlags, error::Ptr{Ptr{GError}})::Ptr{GHashTable}
end

struct _GUriParamsIter
    dummy0::gint
    dummy1::gpointer
    dummy2::gpointer
    dummy3::NTuple{256, guint8}
end

const GUriParamsIter = _GUriParamsIter

"""
    g_uri_params_iter_init(iter, params, length, separators, flags)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 void g_uri_params_iter_init (GUriParamsIter *iter, const gchar *params, gssize length, const gchar *separators, GUriParamsFlags flags);
```
"""
function g_uri_params_iter_init(iter, params, length, separators, flags)
    @ccall libaravis.g_uri_params_iter_init(iter::Ptr{GUriParamsIter}, params::Ptr{gchar}, length::gssize, separators::Ptr{gchar}, flags::GUriParamsFlags)::Cvoid
end

"""
    g_uri_params_iter_next(iter, attribute, value, error)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 gboolean g_uri_params_iter_next (GUriParamsIter *iter, gchar **attribute, gchar **value, GError **error);
```
"""
function g_uri_params_iter_next(iter, attribute, value, error)
    @ccall libaravis.g_uri_params_iter_next(iter::Ptr{GUriParamsIter}, attribute::Ptr{Ptr{gchar}}, value::Ptr{Ptr{gchar}}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    GUriError

[`GUriError`](@ref): \\_URI\\_ERROR\\_FAILED: Generic error if no more specific error is available. See the error message for details. \\_URI\\_ERROR\\_BAD\\_SCHEME: The scheme of a URI could not be parsed. \\_URI\\_ERROR\\_BAD\\_USER: The user/userinfo of a URI could not be parsed. \\_URI\\_ERROR\\_BAD\\_PASSWORD: The password of a URI could not be parsed. \\_URI\\_ERROR\\_BAD\\_AUTH\\_PARAMS: The authentication parameters of a URI could not be parsed. \\_URI\\_ERROR\\_BAD\\_HOST: The host of a URI could not be parsed. \\_URI\\_ERROR\\_BAD\\_PORT: The port of a URI could not be parsed. \\_URI\\_ERROR\\_BAD\\_PATH: The path of a URI could not be parsed. \\_URI\\_ERROR\\_BAD\\_QUERY: The query of a URI could not be parsed. \\_URI\\_ERROR\\_BAD\\_FRAGMENT: The fragment of a URI could not be parsed.

Error codes returned by #[`GUri`](@ref) methods.

Since: 2.66
"""
@cenum GUriError::UInt32 begin
    G_URI_ERROR_FAILED = 0
    G_URI_ERROR_BAD_SCHEME = 1
    G_URI_ERROR_BAD_USER = 2
    G_URI_ERROR_BAD_PASSWORD = 3
    G_URI_ERROR_BAD_AUTH_PARAMS = 4
    G_URI_ERROR_BAD_HOST = 5
    G_URI_ERROR_BAD_PORT = 6
    G_URI_ERROR_BAD_PATH = 7
    G_URI_ERROR_BAD_QUERY = 8
    G_URI_ERROR_BAD_FRAGMENT = 9
end

"""
    g_uri_unescape_string(escaped_string, illegal_characters)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL char * g_uri_unescape_string (const char *escaped_string, const char *illegal_characters);
```
"""
function g_uri_unescape_string(escaped_string, illegal_characters)
    @ccall libaravis.g_uri_unescape_string(escaped_string::Cstring, illegal_characters::Cstring)::Cstring
end

"""
    g_uri_unescape_segment(escaped_string, escaped_string_end, illegal_characters)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL char * g_uri_unescape_segment (const char *escaped_string, const char *escaped_string_end, const char *illegal_characters);
```
"""
function g_uri_unescape_segment(escaped_string, escaped_string_end, illegal_characters)
    @ccall libaravis.g_uri_unescape_segment(escaped_string::Cstring, escaped_string_end::Cstring, illegal_characters::Cstring)::Cstring
end

"""
    g_uri_parse_scheme(uri)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL char * g_uri_parse_scheme (const char *uri);
```
"""
function g_uri_parse_scheme(uri)
    @ccall libaravis.g_uri_parse_scheme(uri::Cstring)::Cstring
end

"""
    g_uri_peek_scheme(uri)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 const char *g_uri_peek_scheme (const char *uri);
```
"""
function g_uri_peek_scheme(uri)
    @ccall libaravis.g_uri_peek_scheme(uri::Cstring)::Cstring
end

"""
    g_uri_escape_string(unescaped, reserved_chars_allowed, allow_utf8)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL char * g_uri_escape_string (const char *unescaped, const char *reserved_chars_allowed, gboolean allow_utf8);
```
"""
function g_uri_escape_string(unescaped, reserved_chars_allowed, allow_utf8)
    @ccall libaravis.g_uri_escape_string(unescaped::Cstring, reserved_chars_allowed::Cstring, allow_utf8::gboolean)::Cstring
end

"""
    g_uri_unescape_bytes(escaped_string, length, illegal_characters, error)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 GBytes * g_uri_unescape_bytes (const char *escaped_string, gssize length, const char *illegal_characters, GError **error);
```
"""
function g_uri_unescape_bytes(escaped_string, length, illegal_characters, error)
    @ccall libaravis.g_uri_unescape_bytes(escaped_string::Cstring, length::gssize, illegal_characters::Cstring, error::Ptr{Ptr{GError}})::Ptr{GBytes}
end

"""
    g_uri_escape_bytes(unescaped, length, reserved_chars_allowed)

### Prototype
```c
GLIB_AVAILABLE_IN_2_66 char * g_uri_escape_bytes (const guint8 *unescaped, gsize length, const char *reserved_chars_allowed);
```
"""
function g_uri_escape_bytes(unescaped, length, reserved_chars_allowed)
    @ccall libaravis.g_uri_escape_bytes(unescaped::Ptr{guint8}, length::gsize, reserved_chars_allowed::Cstring)::Cstring
end

"""
    g_uuid_string_is_valid(str)

### Prototype
```c
GLIB_AVAILABLE_IN_2_52 gboolean g_uuid_string_is_valid (const gchar *str);
```
"""
function g_uuid_string_is_valid(str)
    @ccall libaravis.g_uuid_string_is_valid(str::Ptr{gchar})::gboolean
end

"""
    g_uuid_string_random()

### Prototype
```c
GLIB_AVAILABLE_IN_2_52 gchar * g_uuid_string_random (void);
```
"""
function g_uuid_string_random()
    @ccall libaravis.g_uuid_string_random()::Ptr{gchar}
end

"""
    glib_check_version(required_major, required_minor, required_micro)

### Prototype
```c
GLIB_AVAILABLE_IN_ALL const gchar * glib_check_version (guint required_major, guint required_minor, guint required_micro);
```
"""
function glib_check_version(required_major, required_minor, required_micro)
    @ccall libaravis.glib_check_version(required_major::guint, required_minor::guint, required_micro::guint)::Ptr{gchar}
end

const _GAllocator = Cvoid

const GAllocator = _GAllocator

"""
    g_mem_chunk_destroy(mem_chunk)

### Prototype
```c
GLIB_DEPRECATED void g_mem_chunk_destroy (GMemChunk *mem_chunk);
```
"""
function g_mem_chunk_destroy(mem_chunk)
    @ccall libaravis.g_mem_chunk_destroy(mem_chunk::Ptr{GMemChunk})::Cvoid
end

"""
    g_mem_chunk_clean(mem_chunk)

### Prototype
```c
GLIB_DEPRECATED void g_mem_chunk_clean (GMemChunk *mem_chunk);
```
"""
function g_mem_chunk_clean(mem_chunk)
    @ccall libaravis.g_mem_chunk_clean(mem_chunk::Ptr{GMemChunk})::Cvoid
end

"""
    g_mem_chunk_reset(mem_chunk)

### Prototype
```c
GLIB_DEPRECATED void g_mem_chunk_reset (GMemChunk *mem_chunk);
```
"""
function g_mem_chunk_reset(mem_chunk)
    @ccall libaravis.g_mem_chunk_reset(mem_chunk::Ptr{GMemChunk})::Cvoid
end

"""
    g_mem_chunk_print(mem_chunk)

### Prototype
```c
GLIB_DEPRECATED void g_mem_chunk_print (GMemChunk *mem_chunk);
```
"""
function g_mem_chunk_print(mem_chunk)
    @ccall libaravis.g_mem_chunk_print(mem_chunk::Ptr{GMemChunk})::Cvoid
end

"""
    g_mem_chunk_info()

### Prototype
```c
GLIB_DEPRECATED void g_mem_chunk_info (void);
```
"""
function g_mem_chunk_info()
    @ccall libaravis.g_mem_chunk_info()::Cvoid
end

"""
    g_blow_chunks()

### Prototype
```c
GLIB_DEPRECATED void g_blow_chunks (void);
```
"""
function g_blow_chunks()
    @ccall libaravis.g_blow_chunks()::Cvoid
end

"""
    g_allocator_new(name, n_preallocs)

### Prototype
```c
GLIB_DEPRECATED GAllocator * g_allocator_new (const gchar *name, guint n_preallocs);
```
"""
function g_allocator_new(name, n_preallocs)
    @ccall libaravis.g_allocator_new(name::Ptr{gchar}, n_preallocs::guint)::Ptr{GAllocator}
end

"""
    g_allocator_free(allocator)

### Prototype
```c
GLIB_DEPRECATED void g_allocator_free (GAllocator *allocator);
```
"""
function g_allocator_free(allocator)
    @ccall libaravis.g_allocator_free(allocator::Ptr{GAllocator})::Cvoid
end

"""
    g_list_push_allocator(allocator)

### Prototype
```c
GLIB_DEPRECATED void g_list_push_allocator (GAllocator *allocator);
```
"""
function g_list_push_allocator(allocator)
    @ccall libaravis.g_list_push_allocator(allocator::Ptr{GAllocator})::Cvoid
end

"""
    g_list_pop_allocator()

### Prototype
```c
GLIB_DEPRECATED void g_list_pop_allocator (void);
```
"""
function g_list_pop_allocator()
    @ccall libaravis.g_list_pop_allocator()::Cvoid
end

"""
    g_slist_push_allocator(allocator)

### Prototype
```c
GLIB_DEPRECATED void g_slist_push_allocator (GAllocator *allocator);
```
"""
function g_slist_push_allocator(allocator)
    @ccall libaravis.g_slist_push_allocator(allocator::Ptr{GAllocator})::Cvoid
end

"""
    g_slist_pop_allocator()

### Prototype
```c
GLIB_DEPRECATED void g_slist_pop_allocator (void);
```
"""
function g_slist_pop_allocator()
    @ccall libaravis.g_slist_pop_allocator()::Cvoid
end

"""
    g_node_push_allocator(allocator)

### Prototype
```c
GLIB_DEPRECATED void g_node_push_allocator (GAllocator *allocator);
```
"""
function g_node_push_allocator(allocator)
    @ccall libaravis.g_node_push_allocator(allocator::Ptr{GAllocator})::Cvoid
end

"""
    g_node_pop_allocator()

### Prototype
```c
GLIB_DEPRECATED void g_node_pop_allocator (void);
```
"""
function g_node_pop_allocator()
    @ccall libaravis.g_node_pop_allocator()::Cvoid
end

const _GCache = Cvoid

const GCache = _GCache

# typedef gpointer ( * GCacheNewFunc ) ( gpointer key )
const GCacheNewFunc = Ptr{Cvoid}

# typedef gpointer ( * GCacheDupFunc ) ( gpointer value )
const GCacheDupFunc = Ptr{Cvoid}

# typedef void ( * GCacheDestroyFunc ) ( gpointer value )
const GCacheDestroyFunc = Ptr{Cvoid}

"""
    g_cache_new(value_new_func, value_destroy_func, key_dup_func, key_destroy_func, hash_key_func, hash_value_func, key_equal_func)

### Prototype
```c
GLIB_DEPRECATED GCache* g_cache_new (GCacheNewFunc value_new_func, GCacheDestroyFunc value_destroy_func, GCacheDupFunc key_dup_func, GCacheDestroyFunc key_destroy_func, GHashFunc hash_key_func, GHashFunc hash_value_func, GEqualFunc key_equal_func);
```
"""
function g_cache_new(value_new_func, value_destroy_func, key_dup_func, key_destroy_func, hash_key_func, hash_value_func, key_equal_func)
    @ccall libaravis.g_cache_new(value_new_func::GCacheNewFunc, value_destroy_func::GCacheDestroyFunc, key_dup_func::GCacheDupFunc, key_destroy_func::GCacheDestroyFunc, hash_key_func::GHashFunc, hash_value_func::GHashFunc, key_equal_func::GEqualFunc)::Ptr{GCache}
end

"""
    g_cache_destroy(cache)

### Prototype
```c
GLIB_DEPRECATED void g_cache_destroy (GCache *cache);
```
"""
function g_cache_destroy(cache)
    @ccall libaravis.g_cache_destroy(cache::Ptr{GCache})::Cvoid
end

"""
    g_cache_insert(cache, key)

### Prototype
```c
GLIB_DEPRECATED gpointer g_cache_insert (GCache *cache, gpointer key);
```
"""
function g_cache_insert(cache, key)
    @ccall libaravis.g_cache_insert(cache::Ptr{GCache}, key::gpointer)::gpointer
end

"""
    g_cache_remove(cache, value)

### Prototype
```c
GLIB_DEPRECATED void g_cache_remove (GCache *cache, gconstpointer value);
```
"""
function g_cache_remove(cache, value)
    @ccall libaravis.g_cache_remove(cache::Ptr{GCache}, value::gconstpointer)::Cvoid
end

"""
    g_cache_key_foreach(cache, func, user_data)

### Prototype
```c
GLIB_DEPRECATED void g_cache_key_foreach (GCache *cache, GHFunc func, gpointer user_data);
```
"""
function g_cache_key_foreach(cache, func, user_data)
    @ccall libaravis.g_cache_key_foreach(cache::Ptr{GCache}, func::GHFunc, user_data::gpointer)::Cvoid
end

"""
    g_cache_value_foreach(cache, func, user_data)

### Prototype
```c
GLIB_DEPRECATED void g_cache_value_foreach (GCache *cache, GHFunc func, gpointer user_data);
```
"""
function g_cache_value_foreach(cache, func, user_data)
    @ccall libaravis.g_cache_value_foreach(cache::Ptr{GCache}, func::GHFunc, user_data::gpointer)::Cvoid
end

# typedef gchar * ( * GCompletionFunc ) ( gpointer item )
const GCompletionFunc = Ptr{Cvoid}

# typedef gint ( * GCompletionStrncmpFunc ) ( const gchar * s1 , const gchar * s2 , gsize n )
const GCompletionStrncmpFunc = Ptr{Cvoid}

struct _GCompletion
    items::Ptr{GList}
    func::GCompletionFunc
    prefix::Ptr{gchar}
    cache::Ptr{GList}
    strncmp_func::GCompletionStrncmpFunc
end

const GCompletion = _GCompletion

"""
    g_completion_new(func)

### Prototype
```c
GLIB_DEPRECATED_IN_2_26 GCompletion* g_completion_new (GCompletionFunc func);
```
"""
function g_completion_new(func)
    @ccall libaravis.g_completion_new(func::GCompletionFunc)::Ptr{GCompletion}
end

"""
    g_completion_add_items(cmp, items)

### Prototype
```c
GLIB_DEPRECATED_IN_2_26 void g_completion_add_items (GCompletion* cmp, GList* items);
```
"""
function g_completion_add_items(cmp, items)
    @ccall libaravis.g_completion_add_items(cmp::Ptr{GCompletion}, items::Ptr{GList})::Cvoid
end

"""
    g_completion_remove_items(cmp, items)

### Prototype
```c
GLIB_DEPRECATED_IN_2_26 void g_completion_remove_items (GCompletion* cmp, GList* items);
```
"""
function g_completion_remove_items(cmp, items)
    @ccall libaravis.g_completion_remove_items(cmp::Ptr{GCompletion}, items::Ptr{GList})::Cvoid
end

"""
    g_completion_clear_items(cmp)

### Prototype
```c
GLIB_DEPRECATED_IN_2_26 void g_completion_clear_items (GCompletion* cmp);
```
"""
function g_completion_clear_items(cmp)
    @ccall libaravis.g_completion_clear_items(cmp::Ptr{GCompletion})::Cvoid
end

"""
    g_completion_complete(cmp, prefix, new_prefix)

### Prototype
```c
GLIB_DEPRECATED_IN_2_26 GList* g_completion_complete (GCompletion* cmp, const gchar* prefix, gchar** new_prefix);
```
"""
function g_completion_complete(cmp, prefix, new_prefix)
    @ccall libaravis.g_completion_complete(cmp::Ptr{GCompletion}, prefix::Ptr{gchar}, new_prefix::Ptr{Ptr{gchar}})::Ptr{GList}
end

"""
    g_completion_complete_utf8(cmp, prefix, new_prefix)

### Prototype
```c
GLIB_DEPRECATED_IN_2_26 GList* g_completion_complete_utf8 (GCompletion *cmp, const gchar* prefix, gchar** new_prefix);
```
"""
function g_completion_complete_utf8(cmp, prefix, new_prefix)
    @ccall libaravis.g_completion_complete_utf8(cmp::Ptr{GCompletion}, prefix::Ptr{gchar}, new_prefix::Ptr{Ptr{gchar}})::Ptr{GList}
end

"""
    g_completion_set_compare(cmp, strncmp_func)

### Prototype
```c
GLIB_DEPRECATED_IN_2_26 void g_completion_set_compare (GCompletion *cmp, GCompletionStrncmpFunc strncmp_func);
```
"""
function g_completion_set_compare(cmp, strncmp_func)
    @ccall libaravis.g_completion_set_compare(cmp::Ptr{GCompletion}, strncmp_func::GCompletionStrncmpFunc)::Cvoid
end

"""
    g_completion_free(cmp)

### Prototype
```c
GLIB_DEPRECATED_IN_2_26 void g_completion_free (GCompletion* cmp);
```
"""
function g_completion_free(cmp)
    @ccall libaravis.g_completion_free(cmp::Ptr{GCompletion})::Cvoid
end

const _GRelation = Cvoid

const GRelation = _GRelation

struct _GTuples
    len::guint
end

const GTuples = _GTuples

"""
    g_relation_new(fields)

### Prototype
```c
GLIB_DEPRECATED_IN_2_26 GRelation* g_relation_new (gint fields);
```
"""
function g_relation_new(fields)
    @ccall libaravis.g_relation_new(fields::gint)::Ptr{GRelation}
end

"""
    g_relation_destroy(relation)

### Prototype
```c
GLIB_DEPRECATED_IN_2_26 void g_relation_destroy (GRelation *relation);
```
"""
function g_relation_destroy(relation)
    @ccall libaravis.g_relation_destroy(relation::Ptr{GRelation})::Cvoid
end

"""
    g_relation_index(relation, field, hash_func, key_equal_func)

### Prototype
```c
GLIB_DEPRECATED_IN_2_26 void g_relation_index (GRelation *relation, gint field, GHashFunc hash_func, GEqualFunc key_equal_func);
```
"""
function g_relation_index(relation, field, hash_func, key_equal_func)
    @ccall libaravis.g_relation_index(relation::Ptr{GRelation}, field::gint, hash_func::GHashFunc, key_equal_func::GEqualFunc)::Cvoid
end

"""
    g_relation_delete(relation, key, field)

### Prototype
```c
GLIB_DEPRECATED_IN_2_26 gint g_relation_delete (GRelation *relation, gconstpointer key, gint field);
```
"""
function g_relation_delete(relation, key, field)
    @ccall libaravis.g_relation_delete(relation::Ptr{GRelation}, key::gconstpointer, field::gint)::gint
end

"""
    g_relation_select(relation, key, field)

### Prototype
```c
GLIB_DEPRECATED_IN_2_26 GTuples* g_relation_select (GRelation *relation, gconstpointer key, gint field);
```
"""
function g_relation_select(relation, key, field)
    @ccall libaravis.g_relation_select(relation::Ptr{GRelation}, key::gconstpointer, field::gint)::Ptr{GTuples}
end

"""
    g_relation_count(relation, key, field)

### Prototype
```c
GLIB_DEPRECATED_IN_2_26 gint g_relation_count (GRelation *relation, gconstpointer key, gint field);
```
"""
function g_relation_count(relation, key, field)
    @ccall libaravis.g_relation_count(relation::Ptr{GRelation}, key::gconstpointer, field::gint)::gint
end

"""
    g_relation_print(relation)

### Prototype
```c
GLIB_DEPRECATED_IN_2_26 void g_relation_print (GRelation *relation);
```
"""
function g_relation_print(relation)
    @ccall libaravis.g_relation_print(relation::Ptr{GRelation})::Cvoid
end

"""
    g_tuples_destroy(tuples)

### Prototype
```c
GLIB_DEPRECATED_IN_2_26 void g_tuples_destroy (GTuples *tuples);
```
"""
function g_tuples_destroy(tuples)
    @ccall libaravis.g_tuples_destroy(tuples::Ptr{GTuples})::Cvoid
end

"""
    g_tuples_index(tuples, index_, field)

### Prototype
```c
GLIB_DEPRECATED_IN_2_26 gpointer g_tuples_index (GTuples *tuples, gint index_, gint field);
```
"""
function g_tuples_index(tuples, index_, field)
    @ccall libaravis.g_tuples_index(tuples::Ptr{GTuples}, index_::gint, field::gint)::gpointer
end

struct _GThreadFunctions
    data::NTuple{168, UInt8}
end

function Base.getproperty(x::Ptr{_GThreadFunctions}, f::Symbol)
    f === :mutex_new && return Ptr{Ptr{Cvoid}}(x + 0)
    f === :mutex_lock && return Ptr{Ptr{Cvoid}}(x + 8)
    f === :mutex_trylock && return Ptr{Ptr{Cvoid}}(x + 16)
    f === :mutex_unlock && return Ptr{Ptr{Cvoid}}(x + 24)
    f === :mutex_free && return Ptr{Ptr{Cvoid}}(x + 32)
    f === :cond_new && return Ptr{Ptr{Cvoid}}(x + 40)
    f === :cond_signal && return Ptr{Ptr{Cvoid}}(x + 48)
    f === :cond_broadcast && return Ptr{Ptr{Cvoid}}(x + 56)
    f === :cond_wait && return Ptr{Ptr{Cvoid}}(x + 64)
    f === :cond_timed_wait && return Ptr{Ptr{Cvoid}}(x + 72)
    f === :cond_free && return Ptr{Ptr{Cvoid}}(x + 80)
    f === :private_new && return Ptr{Ptr{Cvoid}}(x + 88)
    f === :private_get && return Ptr{Ptr{Cvoid}}(x + 96)
    f === :private_set && return Ptr{Ptr{Cvoid}}(x + 104)
    f === :thread_create && return Ptr{Ptr{Cvoid}}(x + 112)
    f === :thread_yield && return Ptr{Ptr{Cvoid}}(x + 120)
    f === :thread_join && return Ptr{Ptr{Cvoid}}(x + 128)
    f === :thread_exit && return Ptr{Ptr{Cvoid}}(x + 136)
    f === :thread_set_priority && return Ptr{Ptr{Cvoid}}(x + 144)
    f === :thread_self && return Ptr{Ptr{Cvoid}}(x + 152)
    f === :thread_equal && return Ptr{Ptr{Cvoid}}(x + 160)
    return getfield(x, f)
end

function Base.getproperty(x::_GThreadFunctions, f::Symbol)
    r = Ref{_GThreadFunctions}(x)
    ptr = Base.unsafe_convert(Ptr{_GThreadFunctions}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{_GThreadFunctions}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::_GThreadFunctions, private::Bool = false)
    (:mutex_new, :mutex_lock, :mutex_trylock, :mutex_unlock, :mutex_free, :cond_new, :cond_signal, :cond_broadcast, :cond_wait, :cond_timed_wait, :cond_free, :private_new, :private_get, :private_set, :thread_create, :thread_yield, :thread_join, :thread_exit, :thread_set_priority, :thread_self, :thread_equal, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

const GThreadFunctions = _GThreadFunctions

"""
    g_thread_create(func, data, joinable, error)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32_FOR(g_thread_new) GThread *g_thread_create (GThreadFunc func, gpointer data, gboolean joinable, GError **error);
```
"""
function g_thread_create(func, data, joinable, error)
    @ccall libaravis.g_thread_create(func::GThreadFunc, data::gpointer, joinable::gboolean, error::Ptr{Ptr{GError}})::Ptr{GThread}
end

"""
    g_thread_create_full(func, data, stack_size, joinable, bound, priority, error)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32_FOR(g_thread_new) GThread *g_thread_create_full (GThreadFunc func, gpointer data, gulong stack_size, gboolean joinable, gboolean bound, GThreadPriority priority, GError **error);
```
"""
function g_thread_create_full(func, data, stack_size, joinable, bound, priority, error)
    @ccall libaravis.g_thread_create_full(func::GThreadFunc, data::gpointer, stack_size::gulong, joinable::gboolean, bound::gboolean, priority::GThreadPriority, error::Ptr{Ptr{GError}})::Ptr{GThread}
end

"""
    g_thread_set_priority(thread, priority)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32 void g_thread_set_priority (GThread *thread, GThreadPriority priority);
```
"""
function g_thread_set_priority(thread, priority)
    @ccall libaravis.g_thread_set_priority(thread::Ptr{GThread}, priority::GThreadPriority)::Cvoid
end

"""
    g_thread_foreach(thread_func, user_data)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32 void g_thread_foreach (GFunc thread_func, gpointer user_data);
```
"""
function g_thread_foreach(thread_func, user_data)
    @ccall libaravis.g_thread_foreach(thread_func::GFunc, user_data::gpointer)::Cvoid
end

"""
    g_static_mutex_init(mutex)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32_FOR(g_mutex_init) void g_static_mutex_init (GStaticMutex *mutex);
```
"""
function g_static_mutex_init(mutex)
    @ccall libaravis.g_static_mutex_init(mutex::Ptr{GStaticMutex})::Cvoid
end

"""
    g_static_mutex_free(mutex)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32_FOR(g_mutex_clear) void g_static_mutex_free (GStaticMutex *mutex);
```
"""
function g_static_mutex_free(mutex)
    @ccall libaravis.g_static_mutex_free(mutex::Ptr{GStaticMutex})::Cvoid
end

struct __JL_Ctag_26
    data::NTuple{8, UInt8}
end

function Base.getproperty(x::Ptr{__JL_Ctag_26}, f::Symbol)
    f === :owner && return Ptr{pthread_t}(x + 0)
    f === :dummy && return Ptr{gdouble}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::__JL_Ctag_26, f::Symbol)
    r = Ref{__JL_Ctag_26}(x)
    ptr = Base.unsafe_convert(Ptr{__JL_Ctag_26}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{__JL_Ctag_26}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::__JL_Ctag_26, private::Bool = false)
    (:owner, :dummy, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

struct _GStaticRecMutex
    data::NTuple{64, UInt8}
end

function Base.getproperty(x::Ptr{_GStaticRecMutex}, f::Symbol)
    f === :mutex && return Ptr{GStaticMutex}(x + 0)
    f === :depth && return Ptr{guint}(x + 48)
    f === :unused && return Ptr{__JL_Ctag_26}(x + 56)
    return getfield(x, f)
end

function Base.getproperty(x::_GStaticRecMutex, f::Symbol)
    r = Ref{_GStaticRecMutex}(x)
    ptr = Base.unsafe_convert(Ptr{_GStaticRecMutex}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{_GStaticRecMutex}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::_GStaticRecMutex, private::Bool = false)
    (:mutex, :depth, :unused, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

const GStaticRecMutex = _GStaticRecMutex

"""
    g_static_rec_mutex_init(mutex)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32_FOR(g_rec_mutex_init) void g_static_rec_mutex_init (GStaticRecMutex *mutex);
```
"""
function g_static_rec_mutex_init(mutex)
    @ccall libaravis.g_static_rec_mutex_init(mutex::Ptr{GStaticRecMutex})::Cvoid
end

"""
    g_static_rec_mutex_lock(mutex)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32_FOR(g_rec_mutex_lock) void g_static_rec_mutex_lock (GStaticRecMutex *mutex);
```
"""
function g_static_rec_mutex_lock(mutex)
    @ccall libaravis.g_static_rec_mutex_lock(mutex::Ptr{GStaticRecMutex})::Cvoid
end

"""
    g_static_rec_mutex_trylock(mutex)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32_FOR(g_rec_mutex_try_lock) gboolean g_static_rec_mutex_trylock (GStaticRecMutex *mutex);
```
"""
function g_static_rec_mutex_trylock(mutex)
    @ccall libaravis.g_static_rec_mutex_trylock(mutex::Ptr{GStaticRecMutex})::gboolean
end

"""
    g_static_rec_mutex_unlock(mutex)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32_FOR(g_rec_mutex_unlock) void g_static_rec_mutex_unlock (GStaticRecMutex *mutex);
```
"""
function g_static_rec_mutex_unlock(mutex)
    @ccall libaravis.g_static_rec_mutex_unlock(mutex::Ptr{GStaticRecMutex})::Cvoid
end

"""
    g_static_rec_mutex_lock_full(mutex, depth)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32 void g_static_rec_mutex_lock_full (GStaticRecMutex *mutex, guint depth);
```
"""
function g_static_rec_mutex_lock_full(mutex, depth)
    @ccall libaravis.g_static_rec_mutex_lock_full(mutex::Ptr{GStaticRecMutex}, depth::guint)::Cvoid
end

"""
    g_static_rec_mutex_unlock_full(mutex)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32 guint g_static_rec_mutex_unlock_full (GStaticRecMutex *mutex);
```
"""
function g_static_rec_mutex_unlock_full(mutex)
    @ccall libaravis.g_static_rec_mutex_unlock_full(mutex::Ptr{GStaticRecMutex})::guint
end

"""
    g_static_rec_mutex_free(mutex)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32_FOR(g_rec_mutex_free) void g_static_rec_mutex_free (GStaticRecMutex *mutex);
```
"""
function g_static_rec_mutex_free(mutex)
    @ccall libaravis.g_static_rec_mutex_free(mutex::Ptr{GStaticRecMutex})::Cvoid
end

struct _GStaticRWLock
    data::NTuple{80, UInt8}
end

function Base.getproperty(x::Ptr{_GStaticRWLock}, f::Symbol)
    f === :mutex && return Ptr{GStaticMutex}(x + 0)
    f === :read_cond && return Ptr{Ptr{GCond}}(x + 48)
    f === :write_cond && return Ptr{Ptr{GCond}}(x + 56)
    f === :read_counter && return Ptr{guint}(x + 64)
    f === :have_writer && return Ptr{gboolean}(x + 68)
    f === :want_to_read && return Ptr{guint}(x + 72)
    f === :want_to_write && return Ptr{guint}(x + 76)
    return getfield(x, f)
end

function Base.getproperty(x::_GStaticRWLock, f::Symbol)
    r = Ref{_GStaticRWLock}(x)
    ptr = Base.unsafe_convert(Ptr{_GStaticRWLock}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{_GStaticRWLock}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::_GStaticRWLock, private::Bool = false)
    (:mutex, :read_cond, :write_cond, :read_counter, :have_writer, :want_to_read, :want_to_write, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

const GStaticRWLock = _GStaticRWLock

"""
    g_static_rw_lock_init(lock)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32_FOR(g_rw_lock_init) void g_static_rw_lock_init (GStaticRWLock *lock);
```
"""
function g_static_rw_lock_init(lock)
    @ccall libaravis.g_static_rw_lock_init(lock::Ptr{GStaticRWLock})::Cvoid
end

"""
    g_static_rw_lock_reader_lock(lock)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32_FOR(g_rw_lock_reader_lock) void g_static_rw_lock_reader_lock (GStaticRWLock *lock);
```
"""
function g_static_rw_lock_reader_lock(lock)
    @ccall libaravis.g_static_rw_lock_reader_lock(lock::Ptr{GStaticRWLock})::Cvoid
end

"""
    g_static_rw_lock_reader_trylock(lock)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32_FOR(g_rw_lock_reader_trylock) gboolean g_static_rw_lock_reader_trylock (GStaticRWLock *lock);
```
"""
function g_static_rw_lock_reader_trylock(lock)
    @ccall libaravis.g_static_rw_lock_reader_trylock(lock::Ptr{GStaticRWLock})::gboolean
end

"""
    g_static_rw_lock_reader_unlock(lock)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32_FOR(g_rw_lock_reader_unlock) void g_static_rw_lock_reader_unlock (GStaticRWLock *lock);
```
"""
function g_static_rw_lock_reader_unlock(lock)
    @ccall libaravis.g_static_rw_lock_reader_unlock(lock::Ptr{GStaticRWLock})::Cvoid
end

"""
    g_static_rw_lock_writer_lock(lock)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32_FOR(g_rw_lock_writer_lock) void g_static_rw_lock_writer_lock (GStaticRWLock *lock);
```
"""
function g_static_rw_lock_writer_lock(lock)
    @ccall libaravis.g_static_rw_lock_writer_lock(lock::Ptr{GStaticRWLock})::Cvoid
end

"""
    g_static_rw_lock_writer_trylock(lock)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32_FOR(g_rw_lock_writer_trylock) gboolean g_static_rw_lock_writer_trylock (GStaticRWLock *lock);
```
"""
function g_static_rw_lock_writer_trylock(lock)
    @ccall libaravis.g_static_rw_lock_writer_trylock(lock::Ptr{GStaticRWLock})::gboolean
end

"""
    g_static_rw_lock_writer_unlock(lock)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32_FOR(g_rw_lock_writer_unlock) void g_static_rw_lock_writer_unlock (GStaticRWLock *lock);
```
"""
function g_static_rw_lock_writer_unlock(lock)
    @ccall libaravis.g_static_rw_lock_writer_unlock(lock::Ptr{GStaticRWLock})::Cvoid
end

"""
    g_static_rw_lock_free(lock)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32_FOR(g_rw_lock_free) void g_static_rw_lock_free (GStaticRWLock *lock);
```
"""
function g_static_rw_lock_free(lock)
    @ccall libaravis.g_static_rw_lock_free(lock::Ptr{GStaticRWLock})::Cvoid
end

"""
    g_private_new(notify)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32 GPrivate * g_private_new (GDestroyNotify notify);
```
"""
function g_private_new(notify)
    @ccall libaravis.g_private_new(notify::GDestroyNotify)::Ptr{GPrivate}
end

struct _GStaticPrivate
    data::NTuple{4, UInt8}
end

function Base.getproperty(x::Ptr{_GStaticPrivate}, f::Symbol)
    f === :index && return Ptr{guint}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::_GStaticPrivate, f::Symbol)
    r = Ref{_GStaticPrivate}(x)
    ptr = Base.unsafe_convert(Ptr{_GStaticPrivate}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{_GStaticPrivate}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::_GStaticPrivate, private::Bool = false)
    (:index, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

const GStaticPrivate = _GStaticPrivate

"""
    g_static_private_init(private_key)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32 void g_static_private_init (GStaticPrivate *private_key);
```
"""
function g_static_private_init(private_key)
    @ccall libaravis.g_static_private_init(private_key::Ptr{GStaticPrivate})::Cvoid
end

"""
    g_static_private_get(private_key)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32_FOR(g_private_get) gpointer g_static_private_get (GStaticPrivate *private_key);
```
"""
function g_static_private_get(private_key)
    @ccall libaravis.g_static_private_get(private_key::Ptr{GStaticPrivate})::gpointer
end

"""
    g_static_private_set(private_key, data, notify)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32_FOR(g_private_set) void g_static_private_set (GStaticPrivate *private_key, gpointer data, GDestroyNotify notify);
```
"""
function g_static_private_set(private_key, data, notify)
    @ccall libaravis.g_static_private_set(private_key::Ptr{GStaticPrivate}, data::gpointer, notify::GDestroyNotify)::Cvoid
end

"""
    g_static_private_free(private_key)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32 void g_static_private_free (GStaticPrivate *private_key);
```
"""
function g_static_private_free(private_key)
    @ccall libaravis.g_static_private_free(private_key::Ptr{GStaticPrivate})::Cvoid
end

"""
    g_once_init_enter_impl(location)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32 gboolean g_once_init_enter_impl (volatile gsize *location);
```
"""
function g_once_init_enter_impl(location)
    @ccall libaravis.g_once_init_enter_impl(location::Ptr{gsize})::gboolean
end

"""
    g_thread_init(vtable)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32 void g_thread_init (gpointer vtable);
```
"""
function g_thread_init(vtable)
    @ccall libaravis.g_thread_init(vtable::gpointer)::Cvoid
end

"""
    g_thread_init_with_errorcheck_mutexes(vtable)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32 void g_thread_init_with_errorcheck_mutexes (gpointer vtable);
```
"""
function g_thread_init_with_errorcheck_mutexes(vtable)
    @ccall libaravis.g_thread_init_with_errorcheck_mutexes(vtable::gpointer)::Cvoid
end

"""
    g_thread_get_initialized()

### Prototype
```c
GLIB_DEPRECATED_IN_2_32 gboolean g_thread_get_initialized (void);
```
"""
function g_thread_get_initialized()
    @ccall libaravis.g_thread_get_initialized()::gboolean
end

"""
    g_mutex_new()

### Prototype
```c
GLIB_DEPRECATED_IN_2_32 GMutex * g_mutex_new (void);
```
"""
function g_mutex_new()
    @ccall libaravis.g_mutex_new()::Ptr{GMutex}
end

"""
    g_mutex_free(mutex)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32 void g_mutex_free (GMutex *mutex);
```
"""
function g_mutex_free(mutex)
    @ccall libaravis.g_mutex_free(mutex::Ptr{GMutex})::Cvoid
end

"""
    g_cond_new()

### Prototype
```c
GLIB_DEPRECATED_IN_2_32 GCond * g_cond_new (void);
```
"""
function g_cond_new()
    @ccall libaravis.g_cond_new()::Ptr{GCond}
end

"""
    g_cond_free(cond)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32 void g_cond_free (GCond *cond);
```
"""
function g_cond_free(cond)
    @ccall libaravis.g_cond_free(cond::Ptr{GCond})::Cvoid
end

"""
    g_cond_timed_wait(cond, mutex, abs_time)

### Prototype
```c
GLIB_DEPRECATED_IN_2_32 gboolean g_cond_timed_wait (GCond *cond, GMutex *mutex, GTimeVal *abs_time);
```
"""
function g_cond_timed_wait(cond, mutex, abs_time)
    @ccall libaravis.g_cond_timed_wait(cond::Ptr{GCond}, mutex::Ptr{GMutex}, abs_time::Ptr{GTimeVal})::gboolean
end

"""
    g_autoptr_cleanup_gstring_free(string)

### Prototype
```c
static inline void g_autoptr_cleanup_gstring_free (GString *string);
```
"""
function g_autoptr_cleanup_gstring_free(string)
    @ccall libaravis.g_autoptr_cleanup_gstring_free(string::Ptr{GString})::Cvoid
end

const GAsyncQueue_autoptr = Ptr{GAsyncQueue}

const GAsyncQueue_listautoptr = Ptr{GList}

const GAsyncQueue_slistautoptr = Ptr{GSList}

const GAsyncQueue_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GAsyncQueue(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAsyncQueue, g_async_queue_unref);
```
"""
function glib_autoptr_clear_GAsyncQueue(_ptr)
    @ccall libaravis.glib_autoptr_clear_GAsyncQueue(_ptr::Ptr{GAsyncQueue})::Cvoid
end

"""
    glib_autoptr_cleanup_GAsyncQueue(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAsyncQueue, g_async_queue_unref);
```
"""
function glib_autoptr_cleanup_GAsyncQueue(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GAsyncQueue(_ptr::Ptr{Ptr{GAsyncQueue}})::Cvoid
end

"""
    glib_autoptr_destroy_GAsyncQueue(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAsyncQueue, g_async_queue_unref);
```
"""
function glib_autoptr_destroy_GAsyncQueue(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GAsyncQueue(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GAsyncQueue(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAsyncQueue, g_async_queue_unref);
```
"""
function glib_listautoptr_cleanup_GAsyncQueue(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GAsyncQueue(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GAsyncQueue(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAsyncQueue, g_async_queue_unref);
```
"""
function glib_slistautoptr_cleanup_GAsyncQueue(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GAsyncQueue(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GAsyncQueue(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAsyncQueue, g_async_queue_unref);
```
"""
function glib_queueautoptr_cleanup_GAsyncQueue(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GAsyncQueue(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GBookmarkFile_autoptr = Ptr{GBookmarkFile}

const GBookmarkFile_listautoptr = Ptr{GList}

const GBookmarkFile_slistautoptr = Ptr{GSList}

const GBookmarkFile_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GBookmarkFile(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBookmarkFile, g_bookmark_file_free);
```
"""
function glib_autoptr_clear_GBookmarkFile(_ptr)
    @ccall libaravis.glib_autoptr_clear_GBookmarkFile(_ptr::Ptr{GBookmarkFile})::Cvoid
end

"""
    glib_autoptr_cleanup_GBookmarkFile(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBookmarkFile, g_bookmark_file_free);
```
"""
function glib_autoptr_cleanup_GBookmarkFile(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GBookmarkFile(_ptr::Ptr{Ptr{GBookmarkFile}})::Cvoid
end

"""
    glib_autoptr_destroy_GBookmarkFile(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBookmarkFile, g_bookmark_file_free);
```
"""
function glib_autoptr_destroy_GBookmarkFile(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GBookmarkFile(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GBookmarkFile(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBookmarkFile, g_bookmark_file_free);
```
"""
function glib_listautoptr_cleanup_GBookmarkFile(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GBookmarkFile(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GBookmarkFile(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBookmarkFile, g_bookmark_file_free);
```
"""
function glib_slistautoptr_cleanup_GBookmarkFile(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GBookmarkFile(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GBookmarkFile(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBookmarkFile, g_bookmark_file_free);
```
"""
function glib_queueautoptr_cleanup_GBookmarkFile(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GBookmarkFile(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GBytes_autoptr = Ptr{GBytes}

const GBytes_listautoptr = Ptr{GList}

const GBytes_slistautoptr = Ptr{GSList}

const GBytes_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GBytes(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBytes, g_bytes_unref);
```
"""
function glib_autoptr_clear_GBytes(_ptr)
    @ccall libaravis.glib_autoptr_clear_GBytes(_ptr::Ptr{GBytes})::Cvoid
end

"""
    glib_autoptr_cleanup_GBytes(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBytes, g_bytes_unref);
```
"""
function glib_autoptr_cleanup_GBytes(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GBytes(_ptr::Ptr{Ptr{GBytes}})::Cvoid
end

"""
    glib_autoptr_destroy_GBytes(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBytes, g_bytes_unref);
```
"""
function glib_autoptr_destroy_GBytes(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GBytes(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GBytes(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBytes, g_bytes_unref);
```
"""
function glib_listautoptr_cleanup_GBytes(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GBytes(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GBytes(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBytes, g_bytes_unref);
```
"""
function glib_slistautoptr_cleanup_GBytes(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GBytes(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GBytes(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBytes, g_bytes_unref);
```
"""
function glib_queueautoptr_cleanup_GBytes(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GBytes(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GChecksum_autoptr = Ptr{GChecksum}

const GChecksum_listautoptr = Ptr{GList}

const GChecksum_slistautoptr = Ptr{GSList}

const GChecksum_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GChecksum(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GChecksum, g_checksum_free);
```
"""
function glib_autoptr_clear_GChecksum(_ptr)
    @ccall libaravis.glib_autoptr_clear_GChecksum(_ptr::Ptr{GChecksum})::Cvoid
end

"""
    glib_autoptr_cleanup_GChecksum(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GChecksum, g_checksum_free);
```
"""
function glib_autoptr_cleanup_GChecksum(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GChecksum(_ptr::Ptr{Ptr{GChecksum}})::Cvoid
end

"""
    glib_autoptr_destroy_GChecksum(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GChecksum, g_checksum_free);
```
"""
function glib_autoptr_destroy_GChecksum(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GChecksum(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GChecksum(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GChecksum, g_checksum_free);
```
"""
function glib_listautoptr_cleanup_GChecksum(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GChecksum(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GChecksum(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GChecksum, g_checksum_free);
```
"""
function glib_slistautoptr_cleanup_GChecksum(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GChecksum(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GChecksum(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GChecksum, g_checksum_free);
```
"""
function glib_queueautoptr_cleanup_GChecksum(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GChecksum(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GDateTime_autoptr = Ptr{GDateTime}

const GDateTime_listautoptr = Ptr{GList}

const GDateTime_slistautoptr = Ptr{GSList}

const GDateTime_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GDateTime(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDateTime, g_date_time_unref);
```
"""
function glib_autoptr_clear_GDateTime(_ptr)
    @ccall libaravis.glib_autoptr_clear_GDateTime(_ptr::Ptr{GDateTime})::Cvoid
end

"""
    glib_autoptr_cleanup_GDateTime(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDateTime, g_date_time_unref);
```
"""
function glib_autoptr_cleanup_GDateTime(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GDateTime(_ptr::Ptr{Ptr{GDateTime}})::Cvoid
end

"""
    glib_autoptr_destroy_GDateTime(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDateTime, g_date_time_unref);
```
"""
function glib_autoptr_destroy_GDateTime(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GDateTime(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GDateTime(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDateTime, g_date_time_unref);
```
"""
function glib_listautoptr_cleanup_GDateTime(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GDateTime(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GDateTime(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDateTime, g_date_time_unref);
```
"""
function glib_slistautoptr_cleanup_GDateTime(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GDateTime(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GDateTime(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDateTime, g_date_time_unref);
```
"""
function glib_queueautoptr_cleanup_GDateTime(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GDateTime(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GDate_autoptr = Ptr{GDate}

const GDate_listautoptr = Ptr{GList}

const GDate_slistautoptr = Ptr{GSList}

const GDate_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GDate(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDate, g_date_free);
```
"""
function glib_autoptr_clear_GDate(_ptr)
    @ccall libaravis.glib_autoptr_clear_GDate(_ptr::Ptr{GDate})::Cvoid
end

"""
    glib_autoptr_cleanup_GDate(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDate, g_date_free);
```
"""
function glib_autoptr_cleanup_GDate(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GDate(_ptr::Ptr{Ptr{GDate}})::Cvoid
end

"""
    glib_autoptr_destroy_GDate(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDate, g_date_free);
```
"""
function glib_autoptr_destroy_GDate(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GDate(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GDate(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDate, g_date_free);
```
"""
function glib_listautoptr_cleanup_GDate(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GDate(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GDate(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDate, g_date_free);
```
"""
function glib_slistautoptr_cleanup_GDate(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GDate(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GDate(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDate, g_date_free);
```
"""
function glib_queueautoptr_cleanup_GDate(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GDate(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GDir_autoptr = Ptr{GDir}

const GDir_listautoptr = Ptr{GList}

const GDir_slistautoptr = Ptr{GSList}

const GDir_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GDir(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDir, g_dir_close);
```
"""
function glib_autoptr_clear_GDir(_ptr)
    @ccall libaravis.glib_autoptr_clear_GDir(_ptr::Ptr{GDir})::Cvoid
end

"""
    glib_autoptr_cleanup_GDir(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDir, g_dir_close);
```
"""
function glib_autoptr_cleanup_GDir(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GDir(_ptr::Ptr{Ptr{GDir}})::Cvoid
end

"""
    glib_autoptr_destroy_GDir(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDir, g_dir_close);
```
"""
function glib_autoptr_destroy_GDir(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GDir(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GDir(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDir, g_dir_close);
```
"""
function glib_listautoptr_cleanup_GDir(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GDir(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GDir(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDir, g_dir_close);
```
"""
function glib_slistautoptr_cleanup_GDir(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GDir(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GDir(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDir, g_dir_close);
```
"""
function glib_queueautoptr_cleanup_GDir(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GDir(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GError_autoptr = Ptr{GError}

const GError_listautoptr = Ptr{GList}

const GError_slistautoptr = Ptr{GSList}

const GError_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GError(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GError, g_error_free);
```
"""
function glib_autoptr_clear_GError(_ptr)
    @ccall libaravis.glib_autoptr_clear_GError(_ptr::Ptr{GError})::Cvoid
end

"""
    glib_autoptr_cleanup_GError(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GError, g_error_free);
```
"""
function glib_autoptr_cleanup_GError(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GError(_ptr::Ptr{Ptr{GError}})::Cvoid
end

"""
    glib_autoptr_destroy_GError(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GError, g_error_free);
```
"""
function glib_autoptr_destroy_GError(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GError(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GError(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GError, g_error_free);
```
"""
function glib_listautoptr_cleanup_GError(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GError(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GError(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GError, g_error_free);
```
"""
function glib_slistautoptr_cleanup_GError(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GError(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GError(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GError, g_error_free);
```
"""
function glib_queueautoptr_cleanup_GError(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GError(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GHashTable_autoptr = Ptr{GHashTable}

const GHashTable_listautoptr = Ptr{GList}

const GHashTable_slistautoptr = Ptr{GSList}

const GHashTable_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GHashTable(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GHashTable, g_hash_table_unref);
```
"""
function glib_autoptr_clear_GHashTable(_ptr)
    @ccall libaravis.glib_autoptr_clear_GHashTable(_ptr::Ptr{GHashTable})::Cvoid
end

"""
    glib_autoptr_cleanup_GHashTable(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GHashTable, g_hash_table_unref);
```
"""
function glib_autoptr_cleanup_GHashTable(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GHashTable(_ptr::Ptr{Ptr{GHashTable}})::Cvoid
end

"""
    glib_autoptr_destroy_GHashTable(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GHashTable, g_hash_table_unref);
```
"""
function glib_autoptr_destroy_GHashTable(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GHashTable(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GHashTable(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GHashTable, g_hash_table_unref);
```
"""
function glib_listautoptr_cleanup_GHashTable(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GHashTable(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GHashTable(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GHashTable, g_hash_table_unref);
```
"""
function glib_slistautoptr_cleanup_GHashTable(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GHashTable(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GHashTable(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GHashTable, g_hash_table_unref);
```
"""
function glib_queueautoptr_cleanup_GHashTable(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GHashTable(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GHmac_autoptr = Ptr{GHmac}

const GHmac_listautoptr = Ptr{GList}

const GHmac_slistautoptr = Ptr{GSList}

const GHmac_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GHmac(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GHmac, g_hmac_unref);
```
"""
function glib_autoptr_clear_GHmac(_ptr)
    @ccall libaravis.glib_autoptr_clear_GHmac(_ptr::Ptr{GHmac})::Cvoid
end

"""
    glib_autoptr_cleanup_GHmac(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GHmac, g_hmac_unref);
```
"""
function glib_autoptr_cleanup_GHmac(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GHmac(_ptr::Ptr{Ptr{GHmac}})::Cvoid
end

"""
    glib_autoptr_destroy_GHmac(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GHmac, g_hmac_unref);
```
"""
function glib_autoptr_destroy_GHmac(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GHmac(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GHmac(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GHmac, g_hmac_unref);
```
"""
function glib_listautoptr_cleanup_GHmac(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GHmac(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GHmac(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GHmac, g_hmac_unref);
```
"""
function glib_slistautoptr_cleanup_GHmac(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GHmac(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GHmac(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GHmac, g_hmac_unref);
```
"""
function glib_queueautoptr_cleanup_GHmac(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GHmac(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GIOChannel_autoptr = Ptr{GIOChannel}

const GIOChannel_listautoptr = Ptr{GList}

const GIOChannel_slistautoptr = Ptr{GSList}

const GIOChannel_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GIOChannel(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GIOChannel, g_io_channel_unref);
```
"""
function glib_autoptr_clear_GIOChannel(_ptr)
    @ccall libaravis.glib_autoptr_clear_GIOChannel(_ptr::Ptr{GIOChannel})::Cvoid
end

"""
    glib_autoptr_cleanup_GIOChannel(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GIOChannel, g_io_channel_unref);
```
"""
function glib_autoptr_cleanup_GIOChannel(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GIOChannel(_ptr::Ptr{Ptr{GIOChannel}})::Cvoid
end

"""
    glib_autoptr_destroy_GIOChannel(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GIOChannel, g_io_channel_unref);
```
"""
function glib_autoptr_destroy_GIOChannel(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GIOChannel(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GIOChannel(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GIOChannel, g_io_channel_unref);
```
"""
function glib_listautoptr_cleanup_GIOChannel(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GIOChannel(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GIOChannel(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GIOChannel, g_io_channel_unref);
```
"""
function glib_slistautoptr_cleanup_GIOChannel(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GIOChannel(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GIOChannel(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GIOChannel, g_io_channel_unref);
```
"""
function glib_queueautoptr_cleanup_GIOChannel(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GIOChannel(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GKeyFile_autoptr = Ptr{GKeyFile}

const GKeyFile_listautoptr = Ptr{GList}

const GKeyFile_slistautoptr = Ptr{GSList}

const GKeyFile_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GKeyFile(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GKeyFile, g_key_file_unref);
```
"""
function glib_autoptr_clear_GKeyFile(_ptr)
    @ccall libaravis.glib_autoptr_clear_GKeyFile(_ptr::Ptr{GKeyFile})::Cvoid
end

"""
    glib_autoptr_cleanup_GKeyFile(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GKeyFile, g_key_file_unref);
```
"""
function glib_autoptr_cleanup_GKeyFile(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GKeyFile(_ptr::Ptr{Ptr{GKeyFile}})::Cvoid
end

"""
    glib_autoptr_destroy_GKeyFile(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GKeyFile, g_key_file_unref);
```
"""
function glib_autoptr_destroy_GKeyFile(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GKeyFile(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GKeyFile(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GKeyFile, g_key_file_unref);
```
"""
function glib_listautoptr_cleanup_GKeyFile(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GKeyFile(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GKeyFile(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GKeyFile, g_key_file_unref);
```
"""
function glib_slistautoptr_cleanup_GKeyFile(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GKeyFile(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GKeyFile(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GKeyFile, g_key_file_unref);
```
"""
function glib_queueautoptr_cleanup_GKeyFile(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GKeyFile(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GList_autoptr = Ptr{GList}

const GList_listautoptr = Ptr{GList}

const GList_slistautoptr = Ptr{GSList}

const GList_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GList(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GList, g_list_free);
```
"""
function glib_autoptr_clear_GList(_ptr)
    @ccall libaravis.glib_autoptr_clear_GList(_ptr::Ptr{GList})::Cvoid
end

"""
    glib_autoptr_cleanup_GList(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GList, g_list_free);
```
"""
function glib_autoptr_cleanup_GList(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GList(_ptr::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_autoptr_destroy_GList(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GList, g_list_free);
```
"""
function glib_autoptr_destroy_GList(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GList(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GList(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GList, g_list_free);
```
"""
function glib_listautoptr_cleanup_GList(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GList(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GList(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GList, g_list_free);
```
"""
function glib_slistautoptr_cleanup_GList(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GList(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GList(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GList, g_list_free);
```
"""
function glib_queueautoptr_cleanup_GList(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GList(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GArray_autoptr = Ptr{GArray}

const GArray_listautoptr = Ptr{GList}

const GArray_slistautoptr = Ptr{GSList}

const GArray_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GArray(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GArray, g_array_unref);
```
"""
function glib_autoptr_clear_GArray(_ptr)
    @ccall libaravis.glib_autoptr_clear_GArray(_ptr::Ptr{GArray})::Cvoid
end

"""
    glib_autoptr_cleanup_GArray(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GArray, g_array_unref);
```
"""
function glib_autoptr_cleanup_GArray(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GArray(_ptr::Ptr{Ptr{GArray}})::Cvoid
end

"""
    glib_autoptr_destroy_GArray(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GArray, g_array_unref);
```
"""
function glib_autoptr_destroy_GArray(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GArray(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GArray(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GArray, g_array_unref);
```
"""
function glib_listautoptr_cleanup_GArray(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GArray(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GArray(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GArray, g_array_unref);
```
"""
function glib_slistautoptr_cleanup_GArray(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GArray(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GArray(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GArray, g_array_unref);
```
"""
function glib_queueautoptr_cleanup_GArray(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GArray(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GPtrArray_autoptr = Ptr{GPtrArray}

const GPtrArray_listautoptr = Ptr{GList}

const GPtrArray_slistautoptr = Ptr{GSList}

const GPtrArray_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GPtrArray(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPtrArray, g_ptr_array_unref);
```
"""
function glib_autoptr_clear_GPtrArray(_ptr)
    @ccall libaravis.glib_autoptr_clear_GPtrArray(_ptr::Ptr{GPtrArray})::Cvoid
end

"""
    glib_autoptr_cleanup_GPtrArray(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPtrArray, g_ptr_array_unref);
```
"""
function glib_autoptr_cleanup_GPtrArray(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GPtrArray(_ptr::Ptr{Ptr{GPtrArray}})::Cvoid
end

"""
    glib_autoptr_destroy_GPtrArray(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPtrArray, g_ptr_array_unref);
```
"""
function glib_autoptr_destroy_GPtrArray(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GPtrArray(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GPtrArray(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPtrArray, g_ptr_array_unref);
```
"""
function glib_listautoptr_cleanup_GPtrArray(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GPtrArray(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GPtrArray(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPtrArray, g_ptr_array_unref);
```
"""
function glib_slistautoptr_cleanup_GPtrArray(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GPtrArray(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GPtrArray(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPtrArray, g_ptr_array_unref);
```
"""
function glib_queueautoptr_cleanup_GPtrArray(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GPtrArray(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GByteArray_autoptr = Ptr{GByteArray}

const GByteArray_listautoptr = Ptr{GList}

const GByteArray_slistautoptr = Ptr{GSList}

const GByteArray_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GByteArray(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GByteArray, g_byte_array_unref);
```
"""
function glib_autoptr_clear_GByteArray(_ptr)
    @ccall libaravis.glib_autoptr_clear_GByteArray(_ptr::Ptr{GByteArray})::Cvoid
end

"""
    glib_autoptr_cleanup_GByteArray(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GByteArray, g_byte_array_unref);
```
"""
function glib_autoptr_cleanup_GByteArray(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GByteArray(_ptr::Ptr{Ptr{GByteArray}})::Cvoid
end

"""
    glib_autoptr_destroy_GByteArray(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GByteArray, g_byte_array_unref);
```
"""
function glib_autoptr_destroy_GByteArray(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GByteArray(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GByteArray(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GByteArray, g_byte_array_unref);
```
"""
function glib_listautoptr_cleanup_GByteArray(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GByteArray(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GByteArray(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GByteArray, g_byte_array_unref);
```
"""
function glib_slistautoptr_cleanup_GByteArray(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GByteArray(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GByteArray(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GByteArray, g_byte_array_unref);
```
"""
function glib_queueautoptr_cleanup_GByteArray(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GByteArray(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GMainContext_autoptr = Ptr{GMainContext}

const GMainContext_listautoptr = Ptr{GList}

const GMainContext_slistautoptr = Ptr{GSList}

const GMainContext_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GMainContext(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMainContext, g_main_context_unref);
```
"""
function glib_autoptr_clear_GMainContext(_ptr)
    @ccall libaravis.glib_autoptr_clear_GMainContext(_ptr::Ptr{GMainContext})::Cvoid
end

"""
    glib_autoptr_cleanup_GMainContext(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMainContext, g_main_context_unref);
```
"""
function glib_autoptr_cleanup_GMainContext(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GMainContext(_ptr::Ptr{Ptr{GMainContext}})::Cvoid
end

"""
    glib_autoptr_destroy_GMainContext(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMainContext, g_main_context_unref);
```
"""
function glib_autoptr_destroy_GMainContext(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GMainContext(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GMainContext(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMainContext, g_main_context_unref);
```
"""
function glib_listautoptr_cleanup_GMainContext(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GMainContext(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GMainContext(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMainContext, g_main_context_unref);
```
"""
function glib_slistautoptr_cleanup_GMainContext(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GMainContext(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GMainContext(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMainContext, g_main_context_unref);
```
"""
function glib_queueautoptr_cleanup_GMainContext(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GMainContext(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GMainContextPusher_autoptr = Ptr{GMainContextPusher}

const GMainContextPusher_listautoptr = Ptr{GList}

const GMainContextPusher_slistautoptr = Ptr{GSList}

const GMainContextPusher_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GMainContextPusher(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMainContextPusher, g_main_context_pusher_free);
```
"""
function glib_autoptr_clear_GMainContextPusher(_ptr)
    @ccall libaravis.glib_autoptr_clear_GMainContextPusher(_ptr::Ptr{GMainContextPusher})::Cvoid
end

"""
    glib_autoptr_cleanup_GMainContextPusher(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMainContextPusher, g_main_context_pusher_free);
```
"""
function glib_autoptr_cleanup_GMainContextPusher(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GMainContextPusher(_ptr::Ptr{Ptr{GMainContextPusher}})::Cvoid
end

"""
    glib_autoptr_destroy_GMainContextPusher(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMainContextPusher, g_main_context_pusher_free);
```
"""
function glib_autoptr_destroy_GMainContextPusher(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GMainContextPusher(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GMainContextPusher(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMainContextPusher, g_main_context_pusher_free);
```
"""
function glib_listautoptr_cleanup_GMainContextPusher(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GMainContextPusher(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GMainContextPusher(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMainContextPusher, g_main_context_pusher_free);
```
"""
function glib_slistautoptr_cleanup_GMainContextPusher(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GMainContextPusher(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GMainContextPusher(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMainContextPusher, g_main_context_pusher_free);
```
"""
function glib_queueautoptr_cleanup_GMainContextPusher(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GMainContextPusher(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GMainLoop_autoptr = Ptr{GMainLoop}

const GMainLoop_listautoptr = Ptr{GList}

const GMainLoop_slistautoptr = Ptr{GSList}

const GMainLoop_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GMainLoop(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMainLoop, g_main_loop_unref);
```
"""
function glib_autoptr_clear_GMainLoop(_ptr)
    @ccall libaravis.glib_autoptr_clear_GMainLoop(_ptr::Ptr{GMainLoop})::Cvoid
end

"""
    glib_autoptr_cleanup_GMainLoop(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMainLoop, g_main_loop_unref);
```
"""
function glib_autoptr_cleanup_GMainLoop(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GMainLoop(_ptr::Ptr{Ptr{GMainLoop}})::Cvoid
end

"""
    glib_autoptr_destroy_GMainLoop(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMainLoop, g_main_loop_unref);
```
"""
function glib_autoptr_destroy_GMainLoop(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GMainLoop(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GMainLoop(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMainLoop, g_main_loop_unref);
```
"""
function glib_listautoptr_cleanup_GMainLoop(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GMainLoop(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GMainLoop(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMainLoop, g_main_loop_unref);
```
"""
function glib_slistautoptr_cleanup_GMainLoop(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GMainLoop(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GMainLoop(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMainLoop, g_main_loop_unref);
```
"""
function glib_queueautoptr_cleanup_GMainLoop(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GMainLoop(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GSource_autoptr = Ptr{GSource}

const GSource_listautoptr = Ptr{GList}

const GSource_slistautoptr = Ptr{GSList}

const GSource_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GSource(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSource, g_source_unref);
```
"""
function glib_autoptr_clear_GSource(_ptr)
    @ccall libaravis.glib_autoptr_clear_GSource(_ptr::Ptr{GSource})::Cvoid
end

"""
    glib_autoptr_cleanup_GSource(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSource, g_source_unref);
```
"""
function glib_autoptr_cleanup_GSource(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GSource(_ptr::Ptr{Ptr{GSource}})::Cvoid
end

"""
    glib_autoptr_destroy_GSource(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSource, g_source_unref);
```
"""
function glib_autoptr_destroy_GSource(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GSource(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GSource(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSource, g_source_unref);
```
"""
function glib_listautoptr_cleanup_GSource(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GSource(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GSource(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSource, g_source_unref);
```
"""
function glib_slistautoptr_cleanup_GSource(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GSource(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GSource(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSource, g_source_unref);
```
"""
function glib_queueautoptr_cleanup_GSource(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GSource(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GMappedFile_autoptr = Ptr{GMappedFile}

const GMappedFile_listautoptr = Ptr{GList}

const GMappedFile_slistautoptr = Ptr{GSList}

const GMappedFile_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GMappedFile(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMappedFile, g_mapped_file_unref);
```
"""
function glib_autoptr_clear_GMappedFile(_ptr)
    @ccall libaravis.glib_autoptr_clear_GMappedFile(_ptr::Ptr{GMappedFile})::Cvoid
end

"""
    glib_autoptr_cleanup_GMappedFile(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMappedFile, g_mapped_file_unref);
```
"""
function glib_autoptr_cleanup_GMappedFile(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GMappedFile(_ptr::Ptr{Ptr{GMappedFile}})::Cvoid
end

"""
    glib_autoptr_destroy_GMappedFile(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMappedFile, g_mapped_file_unref);
```
"""
function glib_autoptr_destroy_GMappedFile(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GMappedFile(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GMappedFile(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMappedFile, g_mapped_file_unref);
```
"""
function glib_listautoptr_cleanup_GMappedFile(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GMappedFile(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GMappedFile(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMappedFile, g_mapped_file_unref);
```
"""
function glib_slistautoptr_cleanup_GMappedFile(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GMappedFile(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GMappedFile(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMappedFile, g_mapped_file_unref);
```
"""
function glib_queueautoptr_cleanup_GMappedFile(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GMappedFile(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GMarkupParseContext_autoptr = Ptr{GMarkupParseContext}

const GMarkupParseContext_listautoptr = Ptr{GList}

const GMarkupParseContext_slistautoptr = Ptr{GSList}

const GMarkupParseContext_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GMarkupParseContext(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMarkupParseContext, g_markup_parse_context_unref);
```
"""
function glib_autoptr_clear_GMarkupParseContext(_ptr)
    @ccall libaravis.glib_autoptr_clear_GMarkupParseContext(_ptr::Ptr{GMarkupParseContext})::Cvoid
end

"""
    glib_autoptr_cleanup_GMarkupParseContext(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMarkupParseContext, g_markup_parse_context_unref);
```
"""
function glib_autoptr_cleanup_GMarkupParseContext(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GMarkupParseContext(_ptr::Ptr{Ptr{GMarkupParseContext}})::Cvoid
end

"""
    glib_autoptr_destroy_GMarkupParseContext(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMarkupParseContext, g_markup_parse_context_unref);
```
"""
function glib_autoptr_destroy_GMarkupParseContext(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GMarkupParseContext(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GMarkupParseContext(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMarkupParseContext, g_markup_parse_context_unref);
```
"""
function glib_listautoptr_cleanup_GMarkupParseContext(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GMarkupParseContext(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GMarkupParseContext(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMarkupParseContext, g_markup_parse_context_unref);
```
"""
function glib_slistautoptr_cleanup_GMarkupParseContext(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GMarkupParseContext(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GMarkupParseContext(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMarkupParseContext, g_markup_parse_context_unref);
```
"""
function glib_queueautoptr_cleanup_GMarkupParseContext(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GMarkupParseContext(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GNode_autoptr = Ptr{GNode}

const GNode_listautoptr = Ptr{GList}

const GNode_slistautoptr = Ptr{GSList}

const GNode_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GNode(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNode, g_node_destroy);
```
"""
function glib_autoptr_clear_GNode(_ptr)
    @ccall libaravis.glib_autoptr_clear_GNode(_ptr::Ptr{GNode})::Cvoid
end

"""
    glib_autoptr_cleanup_GNode(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNode, g_node_destroy);
```
"""
function glib_autoptr_cleanup_GNode(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GNode(_ptr::Ptr{Ptr{GNode}})::Cvoid
end

"""
    glib_autoptr_destroy_GNode(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNode, g_node_destroy);
```
"""
function glib_autoptr_destroy_GNode(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GNode(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GNode(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNode, g_node_destroy);
```
"""
function glib_listautoptr_cleanup_GNode(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GNode(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GNode(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNode, g_node_destroy);
```
"""
function glib_slistautoptr_cleanup_GNode(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GNode(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GNode(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNode, g_node_destroy);
```
"""
function glib_queueautoptr_cleanup_GNode(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GNode(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GOptionContext_autoptr = Ptr{GOptionContext}

const GOptionContext_listautoptr = Ptr{GList}

const GOptionContext_slistautoptr = Ptr{GSList}

const GOptionContext_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GOptionContext(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GOptionContext, g_option_context_free);
```
"""
function glib_autoptr_clear_GOptionContext(_ptr)
    @ccall libaravis.glib_autoptr_clear_GOptionContext(_ptr::Ptr{GOptionContext})::Cvoid
end

"""
    glib_autoptr_cleanup_GOptionContext(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GOptionContext, g_option_context_free);
```
"""
function glib_autoptr_cleanup_GOptionContext(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GOptionContext(_ptr::Ptr{Ptr{GOptionContext}})::Cvoid
end

"""
    glib_autoptr_destroy_GOptionContext(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GOptionContext, g_option_context_free);
```
"""
function glib_autoptr_destroy_GOptionContext(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GOptionContext(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GOptionContext(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GOptionContext, g_option_context_free);
```
"""
function glib_listautoptr_cleanup_GOptionContext(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GOptionContext(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GOptionContext(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GOptionContext, g_option_context_free);
```
"""
function glib_slistautoptr_cleanup_GOptionContext(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GOptionContext(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GOptionContext(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GOptionContext, g_option_context_free);
```
"""
function glib_queueautoptr_cleanup_GOptionContext(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GOptionContext(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GOptionGroup_autoptr = Ptr{GOptionGroup}

const GOptionGroup_listautoptr = Ptr{GList}

const GOptionGroup_slistautoptr = Ptr{GSList}

const GOptionGroup_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GOptionGroup(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GOptionGroup, g_option_group_unref);
```
"""
function glib_autoptr_clear_GOptionGroup(_ptr)
    @ccall libaravis.glib_autoptr_clear_GOptionGroup(_ptr::Ptr{GOptionGroup})::Cvoid
end

"""
    glib_autoptr_cleanup_GOptionGroup(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GOptionGroup, g_option_group_unref);
```
"""
function glib_autoptr_cleanup_GOptionGroup(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GOptionGroup(_ptr::Ptr{Ptr{GOptionGroup}})::Cvoid
end

"""
    glib_autoptr_destroy_GOptionGroup(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GOptionGroup, g_option_group_unref);
```
"""
function glib_autoptr_destroy_GOptionGroup(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GOptionGroup(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GOptionGroup(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GOptionGroup, g_option_group_unref);
```
"""
function glib_listautoptr_cleanup_GOptionGroup(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GOptionGroup(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GOptionGroup(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GOptionGroup, g_option_group_unref);
```
"""
function glib_slistautoptr_cleanup_GOptionGroup(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GOptionGroup(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GOptionGroup(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GOptionGroup, g_option_group_unref);
```
"""
function glib_queueautoptr_cleanup_GOptionGroup(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GOptionGroup(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GPatternSpec_autoptr = Ptr{GPatternSpec}

const GPatternSpec_listautoptr = Ptr{GList}

const GPatternSpec_slistautoptr = Ptr{GSList}

const GPatternSpec_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GPatternSpec(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPatternSpec, g_pattern_spec_free);
```
"""
function glib_autoptr_clear_GPatternSpec(_ptr)
    @ccall libaravis.glib_autoptr_clear_GPatternSpec(_ptr::Ptr{GPatternSpec})::Cvoid
end

"""
    glib_autoptr_cleanup_GPatternSpec(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPatternSpec, g_pattern_spec_free);
```
"""
function glib_autoptr_cleanup_GPatternSpec(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GPatternSpec(_ptr::Ptr{Ptr{GPatternSpec}})::Cvoid
end

"""
    glib_autoptr_destroy_GPatternSpec(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPatternSpec, g_pattern_spec_free);
```
"""
function glib_autoptr_destroy_GPatternSpec(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GPatternSpec(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GPatternSpec(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPatternSpec, g_pattern_spec_free);
```
"""
function glib_listautoptr_cleanup_GPatternSpec(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GPatternSpec(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GPatternSpec(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPatternSpec, g_pattern_spec_free);
```
"""
function glib_slistautoptr_cleanup_GPatternSpec(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GPatternSpec(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GPatternSpec(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPatternSpec, g_pattern_spec_free);
```
"""
function glib_queueautoptr_cleanup_GPatternSpec(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GPatternSpec(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GQueue_autoptr = Ptr{GQueue}

const GQueue_listautoptr = Ptr{GList}

const GQueue_slistautoptr = Ptr{GSList}

const GQueue_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GQueue(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GQueue, g_queue_free);
```
"""
function glib_autoptr_clear_GQueue(_ptr)
    @ccall libaravis.glib_autoptr_clear_GQueue(_ptr::Ptr{GQueue})::Cvoid
end

"""
    glib_autoptr_cleanup_GQueue(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GQueue, g_queue_free);
```
"""
function glib_autoptr_cleanup_GQueue(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GQueue(_ptr::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    glib_autoptr_destroy_GQueue(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GQueue, g_queue_free);
```
"""
function glib_autoptr_destroy_GQueue(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GQueue(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GQueue(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GQueue, g_queue_free);
```
"""
function glib_listautoptr_cleanup_GQueue(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GQueue(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GQueue(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GQueue, g_queue_free);
```
"""
function glib_slistautoptr_cleanup_GQueue(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GQueue(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GQueue(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GQueue, g_queue_free);
```
"""
function glib_queueautoptr_cleanup_GQueue(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GQueue(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    glib_auto_cleanup_GQueue(_ptr)

### Prototype
```c
G_DEFINE_AUTO_CLEANUP_CLEAR_FUNC(GQueue, g_queue_clear);
```
"""
function glib_auto_cleanup_GQueue(_ptr)
    @ccall libaravis.glib_auto_cleanup_GQueue(_ptr::Ptr{GQueue})::Cvoid
end

const GRand_autoptr = Ptr{GRand}

const GRand_listautoptr = Ptr{GList}

const GRand_slistautoptr = Ptr{GSList}

const GRand_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GRand(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRand, g_rand_free);
```
"""
function glib_autoptr_clear_GRand(_ptr)
    @ccall libaravis.glib_autoptr_clear_GRand(_ptr::Ptr{GRand})::Cvoid
end

"""
    glib_autoptr_cleanup_GRand(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRand, g_rand_free);
```
"""
function glib_autoptr_cleanup_GRand(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GRand(_ptr::Ptr{Ptr{GRand}})::Cvoid
end

"""
    glib_autoptr_destroy_GRand(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRand, g_rand_free);
```
"""
function glib_autoptr_destroy_GRand(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GRand(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GRand(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRand, g_rand_free);
```
"""
function glib_listautoptr_cleanup_GRand(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GRand(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GRand(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRand, g_rand_free);
```
"""
function glib_slistautoptr_cleanup_GRand(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GRand(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GRand(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRand, g_rand_free);
```
"""
function glib_queueautoptr_cleanup_GRand(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GRand(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GRegex_autoptr = Ptr{GRegex}

const GRegex_listautoptr = Ptr{GList}

const GRegex_slistautoptr = Ptr{GSList}

const GRegex_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GRegex(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRegex, g_regex_unref);
```
"""
function glib_autoptr_clear_GRegex(_ptr)
    @ccall libaravis.glib_autoptr_clear_GRegex(_ptr::Ptr{GRegex})::Cvoid
end

"""
    glib_autoptr_cleanup_GRegex(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRegex, g_regex_unref);
```
"""
function glib_autoptr_cleanup_GRegex(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GRegex(_ptr::Ptr{Ptr{GRegex}})::Cvoid
end

"""
    glib_autoptr_destroy_GRegex(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRegex, g_regex_unref);
```
"""
function glib_autoptr_destroy_GRegex(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GRegex(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GRegex(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRegex, g_regex_unref);
```
"""
function glib_listautoptr_cleanup_GRegex(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GRegex(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GRegex(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRegex, g_regex_unref);
```
"""
function glib_slistautoptr_cleanup_GRegex(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GRegex(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GRegex(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRegex, g_regex_unref);
```
"""
function glib_queueautoptr_cleanup_GRegex(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GRegex(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GMatchInfo_autoptr = Ptr{GMatchInfo}

const GMatchInfo_listautoptr = Ptr{GList}

const GMatchInfo_slistautoptr = Ptr{GSList}

const GMatchInfo_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GMatchInfo(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMatchInfo, g_match_info_unref);
```
"""
function glib_autoptr_clear_GMatchInfo(_ptr)
    @ccall libaravis.glib_autoptr_clear_GMatchInfo(_ptr::Ptr{GMatchInfo})::Cvoid
end

"""
    glib_autoptr_cleanup_GMatchInfo(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMatchInfo, g_match_info_unref);
```
"""
function glib_autoptr_cleanup_GMatchInfo(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GMatchInfo(_ptr::Ptr{Ptr{GMatchInfo}})::Cvoid
end

"""
    glib_autoptr_destroy_GMatchInfo(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMatchInfo, g_match_info_unref);
```
"""
function glib_autoptr_destroy_GMatchInfo(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GMatchInfo(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GMatchInfo(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMatchInfo, g_match_info_unref);
```
"""
function glib_listautoptr_cleanup_GMatchInfo(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GMatchInfo(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GMatchInfo(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMatchInfo, g_match_info_unref);
```
"""
function glib_slistautoptr_cleanup_GMatchInfo(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GMatchInfo(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GMatchInfo(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMatchInfo, g_match_info_unref);
```
"""
function glib_queueautoptr_cleanup_GMatchInfo(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GMatchInfo(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GScanner_autoptr = Ptr{GScanner}

const GScanner_listautoptr = Ptr{GList}

const GScanner_slistautoptr = Ptr{GSList}

const GScanner_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GScanner(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GScanner, g_scanner_destroy);
```
"""
function glib_autoptr_clear_GScanner(_ptr)
    @ccall libaravis.glib_autoptr_clear_GScanner(_ptr::Ptr{GScanner})::Cvoid
end

"""
    glib_autoptr_cleanup_GScanner(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GScanner, g_scanner_destroy);
```
"""
function glib_autoptr_cleanup_GScanner(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GScanner(_ptr::Ptr{Ptr{GScanner}})::Cvoid
end

"""
    glib_autoptr_destroy_GScanner(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GScanner, g_scanner_destroy);
```
"""
function glib_autoptr_destroy_GScanner(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GScanner(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GScanner(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GScanner, g_scanner_destroy);
```
"""
function glib_listautoptr_cleanup_GScanner(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GScanner(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GScanner(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GScanner, g_scanner_destroy);
```
"""
function glib_slistautoptr_cleanup_GScanner(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GScanner(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GScanner(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GScanner, g_scanner_destroy);
```
"""
function glib_queueautoptr_cleanup_GScanner(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GScanner(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GSequence_autoptr = Ptr{GSequence}

const GSequence_listautoptr = Ptr{GList}

const GSequence_slistautoptr = Ptr{GSList}

const GSequence_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GSequence(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSequence, g_sequence_free);
```
"""
function glib_autoptr_clear_GSequence(_ptr)
    @ccall libaravis.glib_autoptr_clear_GSequence(_ptr::Ptr{GSequence})::Cvoid
end

"""
    glib_autoptr_cleanup_GSequence(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSequence, g_sequence_free);
```
"""
function glib_autoptr_cleanup_GSequence(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GSequence(_ptr::Ptr{Ptr{GSequence}})::Cvoid
end

"""
    glib_autoptr_destroy_GSequence(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSequence, g_sequence_free);
```
"""
function glib_autoptr_destroy_GSequence(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GSequence(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GSequence(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSequence, g_sequence_free);
```
"""
function glib_listautoptr_cleanup_GSequence(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GSequence(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GSequence(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSequence, g_sequence_free);
```
"""
function glib_slistautoptr_cleanup_GSequence(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GSequence(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GSequence(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSequence, g_sequence_free);
```
"""
function glib_queueautoptr_cleanup_GSequence(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GSequence(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GSList_autoptr = Ptr{GSList}

const GSList_listautoptr = Ptr{GList}

const GSList_slistautoptr = Ptr{GSList}

const GSList_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GSList(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSList, g_slist_free);
```
"""
function glib_autoptr_clear_GSList(_ptr)
    @ccall libaravis.glib_autoptr_clear_GSList(_ptr::Ptr{GSList})::Cvoid
end

"""
    glib_autoptr_cleanup_GSList(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSList, g_slist_free);
```
"""
function glib_autoptr_cleanup_GSList(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GSList(_ptr::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_autoptr_destroy_GSList(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSList, g_slist_free);
```
"""
function glib_autoptr_destroy_GSList(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GSList(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GSList(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSList, g_slist_free);
```
"""
function glib_listautoptr_cleanup_GSList(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GSList(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GSList(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSList, g_slist_free);
```
"""
function glib_slistautoptr_cleanup_GSList(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GSList(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GSList(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSList, g_slist_free);
```
"""
function glib_queueautoptr_cleanup_GSList(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GSList(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GString_autoptr = Ptr{GString}

const GString_listautoptr = Ptr{GList}

const GString_slistautoptr = Ptr{GSList}

const GString_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GString(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GString, g_autoptr_cleanup_gstring_free);
```
"""
function glib_autoptr_clear_GString(_ptr)
    @ccall libaravis.glib_autoptr_clear_GString(_ptr::Ptr{GString})::Cvoid
end

"""
    glib_autoptr_cleanup_GString(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GString, g_autoptr_cleanup_gstring_free);
```
"""
function glib_autoptr_cleanup_GString(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GString(_ptr::Ptr{Ptr{GString}})::Cvoid
end

"""
    glib_autoptr_destroy_GString(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GString, g_autoptr_cleanup_gstring_free);
```
"""
function glib_autoptr_destroy_GString(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GString(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GString(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GString, g_autoptr_cleanup_gstring_free);
```
"""
function glib_listautoptr_cleanup_GString(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GString(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GString(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GString, g_autoptr_cleanup_gstring_free);
```
"""
function glib_slistautoptr_cleanup_GString(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GString(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GString(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GString, g_autoptr_cleanup_gstring_free);
```
"""
function glib_queueautoptr_cleanup_GString(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GString(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GStringChunk_autoptr = Ptr{GStringChunk}

const GStringChunk_listautoptr = Ptr{GList}

const GStringChunk_slistautoptr = Ptr{GSList}

const GStringChunk_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GStringChunk(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GStringChunk, g_string_chunk_free);
```
"""
function glib_autoptr_clear_GStringChunk(_ptr)
    @ccall libaravis.glib_autoptr_clear_GStringChunk(_ptr::Ptr{GStringChunk})::Cvoid
end

"""
    glib_autoptr_cleanup_GStringChunk(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GStringChunk, g_string_chunk_free);
```
"""
function glib_autoptr_cleanup_GStringChunk(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GStringChunk(_ptr::Ptr{Ptr{GStringChunk}})::Cvoid
end

"""
    glib_autoptr_destroy_GStringChunk(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GStringChunk, g_string_chunk_free);
```
"""
function glib_autoptr_destroy_GStringChunk(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GStringChunk(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GStringChunk(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GStringChunk, g_string_chunk_free);
```
"""
function glib_listautoptr_cleanup_GStringChunk(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GStringChunk(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GStringChunk(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GStringChunk, g_string_chunk_free);
```
"""
function glib_slistautoptr_cleanup_GStringChunk(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GStringChunk(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GStringChunk(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GStringChunk, g_string_chunk_free);
```
"""
function glib_queueautoptr_cleanup_GStringChunk(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GStringChunk(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GStrvBuilder_autoptr = Ptr{GStrvBuilder}

const GStrvBuilder_listautoptr = Ptr{GList}

const GStrvBuilder_slistautoptr = Ptr{GSList}

const GStrvBuilder_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GStrvBuilder(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GStrvBuilder, g_strv_builder_unref);
```
"""
function glib_autoptr_clear_GStrvBuilder(_ptr)
    @ccall libaravis.glib_autoptr_clear_GStrvBuilder(_ptr::Ptr{GStrvBuilder})::Cvoid
end

"""
    glib_autoptr_cleanup_GStrvBuilder(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GStrvBuilder, g_strv_builder_unref);
```
"""
function glib_autoptr_cleanup_GStrvBuilder(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GStrvBuilder(_ptr::Ptr{Ptr{GStrvBuilder}})::Cvoid
end

"""
    glib_autoptr_destroy_GStrvBuilder(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GStrvBuilder, g_strv_builder_unref);
```
"""
function glib_autoptr_destroy_GStrvBuilder(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GStrvBuilder(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GStrvBuilder(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GStrvBuilder, g_strv_builder_unref);
```
"""
function glib_listautoptr_cleanup_GStrvBuilder(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GStrvBuilder(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GStrvBuilder(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GStrvBuilder, g_strv_builder_unref);
```
"""
function glib_slistautoptr_cleanup_GStrvBuilder(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GStrvBuilder(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GStrvBuilder(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GStrvBuilder, g_strv_builder_unref);
```
"""
function glib_queueautoptr_cleanup_GStrvBuilder(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GStrvBuilder(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GThread_autoptr = Ptr{GThread}

const GThread_listautoptr = Ptr{GList}

const GThread_slistautoptr = Ptr{GSList}

const GThread_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GThread(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GThread, g_thread_unref);
```
"""
function glib_autoptr_clear_GThread(_ptr)
    @ccall libaravis.glib_autoptr_clear_GThread(_ptr::Ptr{GThread})::Cvoid
end

"""
    glib_autoptr_cleanup_GThread(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GThread, g_thread_unref);
```
"""
function glib_autoptr_cleanup_GThread(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GThread(_ptr::Ptr{Ptr{GThread}})::Cvoid
end

"""
    glib_autoptr_destroy_GThread(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GThread, g_thread_unref);
```
"""
function glib_autoptr_destroy_GThread(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GThread(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GThread(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GThread, g_thread_unref);
```
"""
function glib_listautoptr_cleanup_GThread(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GThread(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GThread(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GThread, g_thread_unref);
```
"""
function glib_slistautoptr_cleanup_GThread(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GThread(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GThread(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GThread, g_thread_unref);
```
"""
function glib_queueautoptr_cleanup_GThread(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GThread(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    glib_auto_cleanup_GMutex(_ptr)

### Prototype
```c
G_DEFINE_AUTO_CLEANUP_CLEAR_FUNC(GMutex, g_mutex_clear);
```
"""
function glib_auto_cleanup_GMutex(_ptr)
    @ccall libaravis.glib_auto_cleanup_GMutex(_ptr::Ptr{GMutex})::Cvoid
end

const GMutexLocker_autoptr = Ptr{GMutexLocker}

const GMutexLocker_listautoptr = Ptr{GList}

const GMutexLocker_slistautoptr = Ptr{GSList}

const GMutexLocker_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GMutexLocker(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMutexLocker, g_mutex_locker_free);
```
"""
function glib_autoptr_clear_GMutexLocker(_ptr)
    @ccall libaravis.glib_autoptr_clear_GMutexLocker(_ptr::Ptr{GMutexLocker})::Cvoid
end

"""
    glib_autoptr_cleanup_GMutexLocker(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMutexLocker, g_mutex_locker_free);
```
"""
function glib_autoptr_cleanup_GMutexLocker(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GMutexLocker(_ptr::Ptr{Ptr{GMutexLocker}})::Cvoid
end

"""
    glib_autoptr_destroy_GMutexLocker(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMutexLocker, g_mutex_locker_free);
```
"""
function glib_autoptr_destroy_GMutexLocker(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GMutexLocker(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GMutexLocker(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMutexLocker, g_mutex_locker_free);
```
"""
function glib_listautoptr_cleanup_GMutexLocker(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GMutexLocker(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GMutexLocker(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMutexLocker, g_mutex_locker_free);
```
"""
function glib_slistautoptr_cleanup_GMutexLocker(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GMutexLocker(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GMutexLocker(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMutexLocker, g_mutex_locker_free);
```
"""
function glib_queueautoptr_cleanup_GMutexLocker(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GMutexLocker(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GRecMutexLocker_autoptr = Ptr{GRecMutexLocker}

const GRecMutexLocker_listautoptr = Ptr{GList}

const GRecMutexLocker_slistautoptr = Ptr{GSList}

const GRecMutexLocker_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GRecMutexLocker(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRecMutexLocker, g_rec_mutex_locker_free);
```
"""
function glib_autoptr_clear_GRecMutexLocker(_ptr)
    @ccall libaravis.glib_autoptr_clear_GRecMutexLocker(_ptr::Ptr{GRecMutexLocker})::Cvoid
end

"""
    glib_autoptr_cleanup_GRecMutexLocker(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRecMutexLocker, g_rec_mutex_locker_free);
```
"""
function glib_autoptr_cleanup_GRecMutexLocker(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GRecMutexLocker(_ptr::Ptr{Ptr{GRecMutexLocker}})::Cvoid
end

"""
    glib_autoptr_destroy_GRecMutexLocker(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRecMutexLocker, g_rec_mutex_locker_free);
```
"""
function glib_autoptr_destroy_GRecMutexLocker(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GRecMutexLocker(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GRecMutexLocker(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRecMutexLocker, g_rec_mutex_locker_free);
```
"""
function glib_listautoptr_cleanup_GRecMutexLocker(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GRecMutexLocker(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GRecMutexLocker(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRecMutexLocker, g_rec_mutex_locker_free);
```
"""
function glib_slistautoptr_cleanup_GRecMutexLocker(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GRecMutexLocker(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GRecMutexLocker(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRecMutexLocker, g_rec_mutex_locker_free);
```
"""
function glib_queueautoptr_cleanup_GRecMutexLocker(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GRecMutexLocker(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GRWLockWriterLocker_autoptr = Ptr{GRWLockWriterLocker}

const GRWLockWriterLocker_listautoptr = Ptr{GList}

const GRWLockWriterLocker_slistautoptr = Ptr{GSList}

const GRWLockWriterLocker_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GRWLockWriterLocker(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRWLockWriterLocker, g_rw_lock_writer_locker_free);
```
"""
function glib_autoptr_clear_GRWLockWriterLocker(_ptr)
    @ccall libaravis.glib_autoptr_clear_GRWLockWriterLocker(_ptr::Ptr{GRWLockWriterLocker})::Cvoid
end

"""
    glib_autoptr_cleanup_GRWLockWriterLocker(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRWLockWriterLocker, g_rw_lock_writer_locker_free);
```
"""
function glib_autoptr_cleanup_GRWLockWriterLocker(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GRWLockWriterLocker(_ptr::Ptr{Ptr{GRWLockWriterLocker}})::Cvoid
end

"""
    glib_autoptr_destroy_GRWLockWriterLocker(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRWLockWriterLocker, g_rw_lock_writer_locker_free);
```
"""
function glib_autoptr_destroy_GRWLockWriterLocker(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GRWLockWriterLocker(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GRWLockWriterLocker(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRWLockWriterLocker, g_rw_lock_writer_locker_free);
```
"""
function glib_listautoptr_cleanup_GRWLockWriterLocker(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GRWLockWriterLocker(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GRWLockWriterLocker(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRWLockWriterLocker, g_rw_lock_writer_locker_free);
```
"""
function glib_slistautoptr_cleanup_GRWLockWriterLocker(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GRWLockWriterLocker(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GRWLockWriterLocker(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRWLockWriterLocker, g_rw_lock_writer_locker_free);
```
"""
function glib_queueautoptr_cleanup_GRWLockWriterLocker(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GRWLockWriterLocker(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GRWLockReaderLocker_autoptr = Ptr{GRWLockReaderLocker}

const GRWLockReaderLocker_listautoptr = Ptr{GList}

const GRWLockReaderLocker_slistautoptr = Ptr{GSList}

const GRWLockReaderLocker_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GRWLockReaderLocker(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRWLockReaderLocker, g_rw_lock_reader_locker_free);
```
"""
function glib_autoptr_clear_GRWLockReaderLocker(_ptr)
    @ccall libaravis.glib_autoptr_clear_GRWLockReaderLocker(_ptr::Ptr{GRWLockReaderLocker})::Cvoid
end

"""
    glib_autoptr_cleanup_GRWLockReaderLocker(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRWLockReaderLocker, g_rw_lock_reader_locker_free);
```
"""
function glib_autoptr_cleanup_GRWLockReaderLocker(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GRWLockReaderLocker(_ptr::Ptr{Ptr{GRWLockReaderLocker}})::Cvoid
end

"""
    glib_autoptr_destroy_GRWLockReaderLocker(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRWLockReaderLocker, g_rw_lock_reader_locker_free);
```
"""
function glib_autoptr_destroy_GRWLockReaderLocker(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GRWLockReaderLocker(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GRWLockReaderLocker(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRWLockReaderLocker, g_rw_lock_reader_locker_free);
```
"""
function glib_listautoptr_cleanup_GRWLockReaderLocker(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GRWLockReaderLocker(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GRWLockReaderLocker(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRWLockReaderLocker, g_rw_lock_reader_locker_free);
```
"""
function glib_slistautoptr_cleanup_GRWLockReaderLocker(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GRWLockReaderLocker(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GRWLockReaderLocker(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRWLockReaderLocker, g_rw_lock_reader_locker_free);
```
"""
function glib_queueautoptr_cleanup_GRWLockReaderLocker(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GRWLockReaderLocker(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    glib_auto_cleanup_GCond(_ptr)

### Prototype
```c
G_DEFINE_AUTO_CLEANUP_CLEAR_FUNC(GCond, g_cond_clear);
```
"""
function glib_auto_cleanup_GCond(_ptr)
    @ccall libaravis.glib_auto_cleanup_GCond(_ptr::Ptr{GCond})::Cvoid
end

const GTimer_autoptr = Ptr{GTimer}

const GTimer_listautoptr = Ptr{GList}

const GTimer_slistautoptr = Ptr{GSList}

const GTimer_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GTimer(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTimer, g_timer_destroy);
```
"""
function glib_autoptr_clear_GTimer(_ptr)
    @ccall libaravis.glib_autoptr_clear_GTimer(_ptr::Ptr{GTimer})::Cvoid
end

"""
    glib_autoptr_cleanup_GTimer(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTimer, g_timer_destroy);
```
"""
function glib_autoptr_cleanup_GTimer(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GTimer(_ptr::Ptr{Ptr{GTimer}})::Cvoid
end

"""
    glib_autoptr_destroy_GTimer(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTimer, g_timer_destroy);
```
"""
function glib_autoptr_destroy_GTimer(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GTimer(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GTimer(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTimer, g_timer_destroy);
```
"""
function glib_listautoptr_cleanup_GTimer(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GTimer(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GTimer(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTimer, g_timer_destroy);
```
"""
function glib_slistautoptr_cleanup_GTimer(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GTimer(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GTimer(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTimer, g_timer_destroy);
```
"""
function glib_queueautoptr_cleanup_GTimer(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GTimer(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GTimeZone_autoptr = Ptr{GTimeZone}

const GTimeZone_listautoptr = Ptr{GList}

const GTimeZone_slistautoptr = Ptr{GSList}

const GTimeZone_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GTimeZone(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTimeZone, g_time_zone_unref);
```
"""
function glib_autoptr_clear_GTimeZone(_ptr)
    @ccall libaravis.glib_autoptr_clear_GTimeZone(_ptr::Ptr{GTimeZone})::Cvoid
end

"""
    glib_autoptr_cleanup_GTimeZone(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTimeZone, g_time_zone_unref);
```
"""
function glib_autoptr_cleanup_GTimeZone(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GTimeZone(_ptr::Ptr{Ptr{GTimeZone}})::Cvoid
end

"""
    glib_autoptr_destroy_GTimeZone(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTimeZone, g_time_zone_unref);
```
"""
function glib_autoptr_destroy_GTimeZone(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GTimeZone(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GTimeZone(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTimeZone, g_time_zone_unref);
```
"""
function glib_listautoptr_cleanup_GTimeZone(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GTimeZone(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GTimeZone(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTimeZone, g_time_zone_unref);
```
"""
function glib_slistautoptr_cleanup_GTimeZone(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GTimeZone(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GTimeZone(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTimeZone, g_time_zone_unref);
```
"""
function glib_queueautoptr_cleanup_GTimeZone(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GTimeZone(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GTree_autoptr = Ptr{GTree}

const GTree_listautoptr = Ptr{GList}

const GTree_slistautoptr = Ptr{GSList}

const GTree_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GTree(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTree, g_tree_unref);
```
"""
function glib_autoptr_clear_GTree(_ptr)
    @ccall libaravis.glib_autoptr_clear_GTree(_ptr::Ptr{GTree})::Cvoid
end

"""
    glib_autoptr_cleanup_GTree(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTree, g_tree_unref);
```
"""
function glib_autoptr_cleanup_GTree(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GTree(_ptr::Ptr{Ptr{GTree}})::Cvoid
end

"""
    glib_autoptr_destroy_GTree(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTree, g_tree_unref);
```
"""
function glib_autoptr_destroy_GTree(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GTree(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GTree(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTree, g_tree_unref);
```
"""
function glib_listautoptr_cleanup_GTree(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GTree(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GTree(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTree, g_tree_unref);
```
"""
function glib_slistautoptr_cleanup_GTree(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GTree(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GTree(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTree, g_tree_unref);
```
"""
function glib_queueautoptr_cleanup_GTree(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GTree(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GVariant_autoptr = Ptr{GVariant}

const GVariant_listautoptr = Ptr{GList}

const GVariant_slistautoptr = Ptr{GSList}

const GVariant_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GVariant(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariant, g_variant_unref);
```
"""
function glib_autoptr_clear_GVariant(_ptr)
    @ccall libaravis.glib_autoptr_clear_GVariant(_ptr::Ptr{GVariant})::Cvoid
end

"""
    glib_autoptr_cleanup_GVariant(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariant, g_variant_unref);
```
"""
function glib_autoptr_cleanup_GVariant(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GVariant(_ptr::Ptr{Ptr{GVariant}})::Cvoid
end

"""
    glib_autoptr_destroy_GVariant(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariant, g_variant_unref);
```
"""
function glib_autoptr_destroy_GVariant(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GVariant(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GVariant(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariant, g_variant_unref);
```
"""
function glib_listautoptr_cleanup_GVariant(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GVariant(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GVariant(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariant, g_variant_unref);
```
"""
function glib_slistautoptr_cleanup_GVariant(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GVariant(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GVariant(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariant, g_variant_unref);
```
"""
function glib_queueautoptr_cleanup_GVariant(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GVariant(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GVariantBuilder_autoptr = Ptr{GVariantBuilder}

const GVariantBuilder_listautoptr = Ptr{GList}

const GVariantBuilder_slistautoptr = Ptr{GSList}

const GVariantBuilder_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GVariantBuilder(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariantBuilder, g_variant_builder_unref);
```
"""
function glib_autoptr_clear_GVariantBuilder(_ptr)
    @ccall libaravis.glib_autoptr_clear_GVariantBuilder(_ptr::Ptr{GVariantBuilder})::Cvoid
end

"""
    glib_autoptr_cleanup_GVariantBuilder(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariantBuilder, g_variant_builder_unref);
```
"""
function glib_autoptr_cleanup_GVariantBuilder(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GVariantBuilder(_ptr::Ptr{Ptr{GVariantBuilder}})::Cvoid
end

"""
    glib_autoptr_destroy_GVariantBuilder(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariantBuilder, g_variant_builder_unref);
```
"""
function glib_autoptr_destroy_GVariantBuilder(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GVariantBuilder(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GVariantBuilder(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariantBuilder, g_variant_builder_unref);
```
"""
function glib_listautoptr_cleanup_GVariantBuilder(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GVariantBuilder(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GVariantBuilder(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariantBuilder, g_variant_builder_unref);
```
"""
function glib_slistautoptr_cleanup_GVariantBuilder(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GVariantBuilder(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GVariantBuilder(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariantBuilder, g_variant_builder_unref);
```
"""
function glib_queueautoptr_cleanup_GVariantBuilder(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GVariantBuilder(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    glib_auto_cleanup_GVariantBuilder(_ptr)

### Prototype
```c
G_DEFINE_AUTO_CLEANUP_CLEAR_FUNC(GVariantBuilder, g_variant_builder_clear);
```
"""
function glib_auto_cleanup_GVariantBuilder(_ptr)
    @ccall libaravis.glib_auto_cleanup_GVariantBuilder(_ptr::Ptr{GVariantBuilder})::Cvoid
end

const GVariantIter_autoptr = Ptr{GVariantIter}

const GVariantIter_listautoptr = Ptr{GList}

const GVariantIter_slistautoptr = Ptr{GSList}

const GVariantIter_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GVariantIter(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariantIter, g_variant_iter_free);
```
"""
function glib_autoptr_clear_GVariantIter(_ptr)
    @ccall libaravis.glib_autoptr_clear_GVariantIter(_ptr::Ptr{GVariantIter})::Cvoid
end

"""
    glib_autoptr_cleanup_GVariantIter(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariantIter, g_variant_iter_free);
```
"""
function glib_autoptr_cleanup_GVariantIter(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GVariantIter(_ptr::Ptr{Ptr{GVariantIter}})::Cvoid
end

"""
    glib_autoptr_destroy_GVariantIter(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariantIter, g_variant_iter_free);
```
"""
function glib_autoptr_destroy_GVariantIter(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GVariantIter(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GVariantIter(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariantIter, g_variant_iter_free);
```
"""
function glib_listautoptr_cleanup_GVariantIter(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GVariantIter(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GVariantIter(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariantIter, g_variant_iter_free);
```
"""
function glib_slistautoptr_cleanup_GVariantIter(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GVariantIter(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GVariantIter(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariantIter, g_variant_iter_free);
```
"""
function glib_queueautoptr_cleanup_GVariantIter(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GVariantIter(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GVariantDict_autoptr = Ptr{GVariantDict}

const GVariantDict_listautoptr = Ptr{GList}

const GVariantDict_slistautoptr = Ptr{GSList}

const GVariantDict_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GVariantDict(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariantDict, g_variant_dict_unref);
```
"""
function glib_autoptr_clear_GVariantDict(_ptr)
    @ccall libaravis.glib_autoptr_clear_GVariantDict(_ptr::Ptr{GVariantDict})::Cvoid
end

"""
    glib_autoptr_cleanup_GVariantDict(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariantDict, g_variant_dict_unref);
```
"""
function glib_autoptr_cleanup_GVariantDict(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GVariantDict(_ptr::Ptr{Ptr{GVariantDict}})::Cvoid
end

"""
    glib_autoptr_destroy_GVariantDict(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariantDict, g_variant_dict_unref);
```
"""
function glib_autoptr_destroy_GVariantDict(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GVariantDict(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GVariantDict(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariantDict, g_variant_dict_unref);
```
"""
function glib_listautoptr_cleanup_GVariantDict(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GVariantDict(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GVariantDict(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariantDict, g_variant_dict_unref);
```
"""
function glib_slistautoptr_cleanup_GVariantDict(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GVariantDict(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GVariantDict(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariantDict, g_variant_dict_unref);
```
"""
function glib_queueautoptr_cleanup_GVariantDict(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GVariantDict(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    glib_auto_cleanup_GVariantDict(_ptr)

### Prototype
```c
G_DEFINE_AUTO_CLEANUP_CLEAR_FUNC(GVariantDict, g_variant_dict_clear);
```
"""
function glib_auto_cleanup_GVariantDict(_ptr)
    @ccall libaravis.glib_auto_cleanup_GVariantDict(_ptr::Ptr{GVariantDict})::Cvoid
end

const GVariantType_autoptr = Ptr{GVariantType}

const GVariantType_listautoptr = Ptr{GList}

const GVariantType_slistautoptr = Ptr{GSList}

const GVariantType_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GVariantType(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariantType, g_variant_type_free);
```
"""
function glib_autoptr_clear_GVariantType(_ptr)
    @ccall libaravis.glib_autoptr_clear_GVariantType(_ptr::Ptr{GVariantType})::Cvoid
end

"""
    glib_autoptr_cleanup_GVariantType(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariantType, g_variant_type_free);
```
"""
function glib_autoptr_cleanup_GVariantType(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GVariantType(_ptr::Ptr{Ptr{GVariantType}})::Cvoid
end

"""
    glib_autoptr_destroy_GVariantType(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariantType, g_variant_type_free);
```
"""
function glib_autoptr_destroy_GVariantType(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GVariantType(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GVariantType(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariantType, g_variant_type_free);
```
"""
function glib_listautoptr_cleanup_GVariantType(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GVariantType(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GVariantType(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariantType, g_variant_type_free);
```
"""
function glib_slistautoptr_cleanup_GVariantType(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GVariantType(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GVariantType(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVariantType, g_variant_type_free);
```
"""
function glib_queueautoptr_cleanup_GVariantType(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GVariantType(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    glib_auto_cleanup_GStrv(_ptr)

### Prototype
```c
G_DEFINE_AUTO_CLEANUP_FREE_FUNC(GStrv, g_strfreev, NULL);
```
"""
function glib_auto_cleanup_GStrv(_ptr)
    @ccall libaravis.glib_auto_cleanup_GStrv(_ptr::Ptr{GStrv})::Cvoid
end

const GRefString_autoptr = Ptr{GRefString}

const GRefString_listautoptr = Ptr{GList}

const GRefString_slistautoptr = Ptr{GSList}

const GRefString_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GRefString(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRefString, g_ref_string_release);
```
"""
function glib_autoptr_clear_GRefString(_ptr)
    @ccall libaravis.glib_autoptr_clear_GRefString(_ptr::Ptr{GRefString})::Cvoid
end

"""
    glib_autoptr_cleanup_GRefString(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRefString, g_ref_string_release);
```
"""
function glib_autoptr_cleanup_GRefString(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GRefString(_ptr::Ptr{Ptr{GRefString}})::Cvoid
end

"""
    glib_autoptr_destroy_GRefString(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRefString, g_ref_string_release);
```
"""
function glib_autoptr_destroy_GRefString(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GRefString(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GRefString(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRefString, g_ref_string_release);
```
"""
function glib_listautoptr_cleanup_GRefString(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GRefString(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GRefString(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRefString, g_ref_string_release);
```
"""
function glib_slistautoptr_cleanup_GRefString(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GRefString(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GRefString(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRefString, g_ref_string_release);
```
"""
function glib_queueautoptr_cleanup_GRefString(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GRefString(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GUri_autoptr = Ptr{GUri}

const GUri_listautoptr = Ptr{GList}

const GUri_slistautoptr = Ptr{GSList}

const GUri_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GUri(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUri, g_uri_unref);
```
"""
function glib_autoptr_clear_GUri(_ptr)
    @ccall libaravis.glib_autoptr_clear_GUri(_ptr::Ptr{GUri})::Cvoid
end

"""
    glib_autoptr_cleanup_GUri(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUri, g_uri_unref);
```
"""
function glib_autoptr_cleanup_GUri(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GUri(_ptr::Ptr{Ptr{GUri}})::Cvoid
end

"""
    glib_autoptr_destroy_GUri(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUri, g_uri_unref);
```
"""
function glib_autoptr_destroy_GUri(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GUri(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GUri(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUri, g_uri_unref);
```
"""
function glib_listautoptr_cleanup_GUri(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GUri(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GUri(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUri, g_uri_unref);
```
"""
function glib_slistautoptr_cleanup_GUri(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GUri(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GUri(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUri, g_uri_unref);
```
"""
function glib_queueautoptr_cleanup_GUri(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GUri(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GPathBuf_autoptr = Ptr{GPathBuf}

const GPathBuf_listautoptr = Ptr{GList}

const GPathBuf_slistautoptr = Ptr{GSList}

const GPathBuf_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GPathBuf(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC (GPathBuf, g_path_buf_free);
```
"""
function glib_autoptr_clear_GPathBuf(_ptr)
    @ccall libaravis.glib_autoptr_clear_GPathBuf(_ptr::Ptr{GPathBuf})::Cvoid
end

"""
    glib_autoptr_cleanup_GPathBuf(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC (GPathBuf, g_path_buf_free);
```
"""
function glib_autoptr_cleanup_GPathBuf(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GPathBuf(_ptr::Ptr{Ptr{GPathBuf}})::Cvoid
end

"""
    glib_autoptr_destroy_GPathBuf(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC (GPathBuf, g_path_buf_free);
```
"""
function glib_autoptr_destroy_GPathBuf(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GPathBuf(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GPathBuf(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC (GPathBuf, g_path_buf_free);
```
"""
function glib_listautoptr_cleanup_GPathBuf(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GPathBuf(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GPathBuf(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC (GPathBuf, g_path_buf_free);
```
"""
function glib_slistautoptr_cleanup_GPathBuf(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GPathBuf(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GPathBuf(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC (GPathBuf, g_path_buf_free);
```
"""
function glib_queueautoptr_cleanup_GPathBuf(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GPathBuf(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    glib_auto_cleanup_GPathBuf(_ptr)

### Prototype
```c
G_DEFINE_AUTO_CLEANUP_CLEAR_FUNC (GPathBuf, g_path_buf_clear);
```
"""
function glib_auto_cleanup_GPathBuf(_ptr)
    @ccall libaravis.glib_auto_cleanup_GPathBuf(_ptr::Ptr{GPathBuf})::Cvoid
end

const _GTypeCValue = Cvoid

const GTypeCValue = _GTypeCValue

"""
    GTypeFundamentalFlags

[`GTypeFundamentalFlags`](@ref): \\_TYPE\\_FLAG\\_CLASSED: Indicates a classed type \\_TYPE\\_FLAG\\_INSTANTIATABLE: Indicates an instantiatable type (implies classed) \\_TYPE\\_FLAG\\_DERIVABLE: Indicates a flat derivable type \\_TYPE\\_FLAG\\_DEEP\\_DERIVABLE: Indicates a deep derivable type (implies derivable)

Bit masks used to check or determine specific characteristics of a fundamental type.
"""
@cenum GTypeFundamentalFlags::UInt32 begin
    G_TYPE_FLAG_CLASSED = 1
    G_TYPE_FLAG_INSTANTIATABLE = 2
    G_TYPE_FLAG_DERIVABLE = 4
    G_TYPE_FLAG_DEEP_DERIVABLE = 8
end

"""
    _GTypeFundamentalInfo

[`GTypeFundamentalInfo`](@ref): \\_flags: #[`GTypeFundamentalFlags`](@ref) describing the characteristics of the fundamental type

A structure that provides information to the type system which is used specifically for managing fundamental types.
"""
struct _GTypeFundamentalInfo
    type_flags::GTypeFundamentalFlags
end

"""
[`GTypeFundamentalInfo`](@ref): \\_flags: #[`GTypeFundamentalFlags`](@ref) describing the characteristics of the fundamental type

A structure that provides information to the type system which is used specifically for managing fundamental types.
"""
const GTypeFundamentalInfo = _GTypeFundamentalInfo

"""
    _GTypeQuery

[`GTypeQuery`](@ref): : the #[`GType`](@ref) value of the type \\_name: the name of the type

`_size: the size of the class structure`

\\_size: the size of the instance structure

A structure holding information for a specific type.

See also: [`g_type_query`](@ref)()
"""
struct _GTypeQuery
    type::GType
    type_name::Ptr{gchar}
    class_size::guint
    instance_size::guint
end

"""
[`GTypeQuery`](@ref): : the #[`GType`](@ref) value of the type \\_name: the name of the type

`_size: the size of the class structure`

\\_size: the size of the instance structure

A structure holding information for a specific type.

See also: [`g_type_query`](@ref)()
"""
const GTypeQuery = _GTypeQuery

"""
    GTypeDebugFlags

[`GTypeDebugFlags`](@ref): \\_TYPE\\_DEBUG\\_NONE: Print no messages \\_TYPE\\_DEBUG\\_OBJECTS: Print messages about object bookkeeping \\_TYPE\\_DEBUG\\_SIGNALS: Print messages about signal emissions \\_TYPE\\_DEBUG\\_MASK: Mask covering all debug flags \\_TYPE\\_DEBUG\\_INSTANCE\\_COUNT: Keep a count of instances of each type

These flags used to be passed to [`g_type_init_with_debug_flags`](@ref)() which is now deprecated.

If you need to enable debugging features, use the `GOBJECT_DEBUG` environment variable.

Deprecated: 2.36: [`g_type_init`](@ref)() is now done automatically
"""
@cenum GTypeDebugFlags::UInt32 begin
    G_TYPE_DEBUG_NONE = 0
    G_TYPE_DEBUG_OBJECTS = 1
    G_TYPE_DEBUG_SIGNALS = 2
    G_TYPE_DEBUG_INSTANCE_COUNT = 4
    G_TYPE_DEBUG_MASK = 7
end

"""
    g_type_init()

### Prototype
```c
GOBJECT_DEPRECATED_IN_2_36 void g_type_init (void);
```
"""
function g_type_init()
    @ccall libaravis.g_type_init()::Cvoid
end

"""
    g_type_init_with_debug_flags(debug_flags)

### Prototype
```c
GOBJECT_DEPRECATED_IN_2_36 void g_type_init_with_debug_flags (GTypeDebugFlags debug_flags);
```
"""
function g_type_init_with_debug_flags(debug_flags)
    @ccall libaravis.g_type_init_with_debug_flags(debug_flags::GTypeDebugFlags)::Cvoid
end

"""
    g_type_qname(type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GQuark g_type_qname (GType type);
```
"""
function g_type_qname(type)
    @ccall libaravis.g_type_qname(type::GType)::GQuark
end

"""
    g_type_from_name(name)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_type_from_name (const gchar *name);
```
"""
function g_type_from_name(name)
    @ccall libaravis.g_type_from_name(name::Ptr{gchar})::GType
end

"""
    g_type_parent(type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_type_parent (GType type);
```
"""
function g_type_parent(type)
    @ccall libaravis.g_type_parent(type::GType)::GType
end

"""
    g_type_depth(type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL guint g_type_depth (GType type);
```
"""
function g_type_depth(type)
    @ccall libaravis.g_type_depth(type::GType)::guint
end

"""
    g_type_next_base(leaf_type, root_type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_type_next_base (GType leaf_type, GType root_type);
```
"""
function g_type_next_base(leaf_type, root_type)
    @ccall libaravis.g_type_next_base(leaf_type::GType, root_type::GType)::GType
end

"""
    g_type_class_get(type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_84 gpointer g_type_class_get (GType type);
```
"""
function g_type_class_get(type)
    @ccall libaravis.g_type_class_get(type::GType)::gpointer
end

"""
    g_type_class_ref(type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gpointer g_type_class_ref (GType type);
```
"""
function g_type_class_ref(type)
    @ccall libaravis.g_type_class_ref(type::GType)::gpointer
end

"""
    g_type_class_peek(type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gpointer g_type_class_peek (GType type);
```
"""
function g_type_class_peek(type)
    @ccall libaravis.g_type_class_peek(type::GType)::gpointer
end

"""
    g_type_class_peek_static(type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gpointer g_type_class_peek_static (GType type);
```
"""
function g_type_class_peek_static(type)
    @ccall libaravis.g_type_class_peek_static(type::GType)::gpointer
end

"""
    g_type_interface_peek_parent(g_iface)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gpointer g_type_interface_peek_parent (gpointer g_iface);
```
"""
function g_type_interface_peek_parent(g_iface)
    @ccall libaravis.g_type_interface_peek_parent(g_iface::gpointer)::gpointer
end

"""
    g_type_default_interface_get(g_type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_84 gpointer g_type_default_interface_get (GType g_type);
```
"""
function g_type_default_interface_get(g_type)
    @ccall libaravis.g_type_default_interface_get(g_type::GType)::gpointer
end

"""
    g_type_default_interface_ref(g_type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gpointer g_type_default_interface_ref (GType g_type);
```
"""
function g_type_default_interface_ref(g_type)
    @ccall libaravis.g_type_default_interface_ref(g_type::GType)::gpointer
end

"""
    g_type_default_interface_peek(g_type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gpointer g_type_default_interface_peek (GType g_type);
```
"""
function g_type_default_interface_peek(g_type)
    @ccall libaravis.g_type_default_interface_peek(g_type::GType)::gpointer
end

"""
    g_type_default_interface_unref(g_iface)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_type_default_interface_unref (gpointer g_iface);
```
"""
function g_type_default_interface_unref(g_iface)
    @ccall libaravis.g_type_default_interface_unref(g_iface::gpointer)::Cvoid
end

"""
    g_type_children(type, n_children)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType* g_type_children (GType type, guint *n_children);
```
"""
function g_type_children(type, n_children)
    @ccall libaravis.g_type_children(type::GType, n_children::Ptr{guint})::Ptr{GType}
end

"""
    g_type_interfaces(type, n_interfaces)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType* g_type_interfaces (GType type, guint *n_interfaces);
```
"""
function g_type_interfaces(type, n_interfaces)
    @ccall libaravis.g_type_interfaces(type::GType, n_interfaces::Ptr{guint})::Ptr{GType}
end

"""
    g_type_set_qdata(type, quark, data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_type_set_qdata (GType type, GQuark quark, gpointer data);
```
"""
function g_type_set_qdata(type, quark, data)
    @ccall libaravis.g_type_set_qdata(type::GType, quark::GQuark, data::gpointer)::Cvoid
end

"""
    g_type_get_qdata(type, quark)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gpointer g_type_get_qdata (GType type, GQuark quark);
```
"""
function g_type_get_qdata(type, quark)
    @ccall libaravis.g_type_get_qdata(type::GType, quark::GQuark)::gpointer
end

"""
    g_type_query(type, query)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_type_query (GType type, GTypeQuery *query);
```
"""
function g_type_query(type, query)
    @ccall libaravis.g_type_query(type::GType, query::Ptr{GTypeQuery})::Cvoid
end

"""
    g_type_get_instance_count(type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_44 int g_type_get_instance_count (GType type);
```
"""
function g_type_get_instance_count(type)
    @ccall libaravis.g_type_get_instance_count(type::GType)::Cint
end

# typedef gboolean ( * GTypeClassCacheFunc ) ( gpointer cache_data , GTypeClass * g_class )
"""
[`GTypeClassCacheFunc`](@ref): \\_data: data that was given to the [`g_type_add_class_cache_func`](@ref)() call \\_class: (type [`GObject`](@ref).TypeClass): The #[`GTypeClass`](@ref) structure which is unreferenced

A callback function which is called when the reference count of a class  drops to zero.

It may use [`g_type_class_ref`](@ref)() to prevent the class from being freed. You should not call [`g_type_class_unref`](@ref)() from a #[`GTypeClassCacheFunc`](@ref) function to prevent infinite recursion, use [`g_type_class_unref_uncached`](@ref)() instead.

The functions have to check the class id passed in to figure  whether they actually want to cache the class of this type, since all classes are routed through the same #[`GTypeClassCacheFunc`](@ref) chain.

Returns: TRUE to stop further #GTypeClassCacheFuncs from being  called, FALSE to continue
"""
const GTypeClassCacheFunc = Ptr{Cvoid}

# typedef void ( * GTypeInterfaceCheckFunc ) ( gpointer check_data , gpointer g_iface )
"""
[`GTypeInterfaceCheckFunc`](@ref): \\_data: data passed to [`g_type_add_interface_check`](@ref)() \\_iface: (type [`GObject`](@ref).TypeInterface): the interface that has been initialized

A callback called after an interface vtable is initialized.

See [`g_type_add_interface_check`](@ref)().

Since: 2.4
"""
const GTypeInterfaceCheckFunc = Ptr{Cvoid}

"""
    g_type_register_static(parent_type, type_name, info, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_type_register_static (GType parent_type, const gchar *type_name, const GTypeInfo *info, GTypeFlags flags);
```
"""
function g_type_register_static(parent_type, type_name, info, flags)
    @ccall libaravis.g_type_register_static(parent_type::GType, type_name::Ptr{gchar}, info::Ptr{GTypeInfo}, flags::GTypeFlags)::GType
end

"""
    g_type_register_dynamic(parent_type, type_name, plugin, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_type_register_dynamic (GType parent_type, const gchar *type_name, GTypePlugin *plugin, GTypeFlags flags);
```
"""
function g_type_register_dynamic(parent_type, type_name, plugin, flags)
    @ccall libaravis.g_type_register_dynamic(parent_type::GType, type_name::Ptr{gchar}, plugin::Ptr{GTypePlugin}, flags::GTypeFlags)::GType
end

"""
    g_type_register_fundamental(type_id, type_name, info, finfo, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_type_register_fundamental (GType type_id, const gchar *type_name, const GTypeInfo *info, const GTypeFundamentalInfo *finfo, GTypeFlags flags);
```
"""
function g_type_register_fundamental(type_id, type_name, info, finfo, flags)
    @ccall libaravis.g_type_register_fundamental(type_id::GType, type_name::Ptr{gchar}, info::Ptr{GTypeInfo}, finfo::Ptr{GTypeFundamentalInfo}, flags::GTypeFlags)::GType
end

"""
    g_type_add_interface_dynamic(instance_type, interface_type, plugin)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_type_add_interface_dynamic (GType instance_type, GType interface_type, GTypePlugin *plugin);
```
"""
function g_type_add_interface_dynamic(instance_type, interface_type, plugin)
    @ccall libaravis.g_type_add_interface_dynamic(instance_type::GType, interface_type::GType, plugin::Ptr{GTypePlugin})::Cvoid
end

"""
    g_type_interface_prerequisites(interface_type, n_prerequisites)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType*g_type_interface_prerequisites (GType interface_type, guint *n_prerequisites);
```
"""
function g_type_interface_prerequisites(interface_type, n_prerequisites)
    @ccall libaravis.g_type_interface_prerequisites(interface_type::GType, n_prerequisites::Ptr{guint})::Ptr{GType}
end

"""
    g_type_interface_instantiatable_prerequisite(interface_type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_68 GType g_type_interface_instantiatable_prerequisite (GType interface_type);
```
"""
function g_type_interface_instantiatable_prerequisite(interface_type)
    @ccall libaravis.g_type_interface_instantiatable_prerequisite(interface_type::GType)::GType
end

"""
    g_type_class_add_private(g_class, private_size)

### Prototype
```c
GOBJECT_DEPRECATED_IN_2_58 void g_type_class_add_private (gpointer g_class, gsize private_size);
```
"""
function g_type_class_add_private(g_class, private_size)
    @ccall libaravis.g_type_class_add_private(g_class::gpointer, private_size::gsize)::Cvoid
end

"""
    g_type_add_class_private(class_type, private_size)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_type_add_class_private (GType class_type, gsize private_size);
```
"""
function g_type_add_class_private(class_type, private_size)
    @ccall libaravis.g_type_add_class_private(class_type::GType, private_size::gsize)::Cvoid
end

"""
    g_type_class_get_instance_private_offset(g_class)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_38 gint g_type_class_get_instance_private_offset (gpointer g_class);
```
"""
function g_type_class_get_instance_private_offset(g_class)
    @ccall libaravis.g_type_class_get_instance_private_offset(g_class::gpointer)::gint
end

"""
    g_type_ensure(type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_34 void g_type_ensure (GType type);
```
"""
function g_type_ensure(type)
    @ccall libaravis.g_type_ensure(type::GType)::Cvoid
end

"""
    g_type_get_type_registration_serial()

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_36 guint g_type_get_type_registration_serial (void);
```
"""
function g_type_get_type_registration_serial()
    @ccall libaravis.g_type_get_type_registration_serial()::guint
end

"""
    g_type_get_plugin(type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GTypePlugin* g_type_get_plugin (GType type);
```
"""
function g_type_get_plugin(type)
    @ccall libaravis.g_type_get_plugin(type::GType)::Ptr{GTypePlugin}
end

"""
    g_type_interface_get_plugin(instance_type, interface_type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GTypePlugin* g_type_interface_get_plugin (GType instance_type, GType interface_type);
```
"""
function g_type_interface_get_plugin(instance_type, interface_type)
    @ccall libaravis.g_type_interface_get_plugin(instance_type::GType, interface_type::GType)::Ptr{GTypePlugin}
end

"""
    g_type_fundamental_next()

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_type_fundamental_next (void);
```
"""
function g_type_fundamental_next()
    @ccall libaravis.g_type_fundamental_next()::GType
end

"""
    g_type_create_instance(type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GTypeInstance* g_type_create_instance (GType type);
```
"""
function g_type_create_instance(type)
    @ccall libaravis.g_type_create_instance(type::GType)::Ptr{GTypeInstance}
end

"""
    g_type_free_instance(instance)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_type_free_instance (GTypeInstance *instance);
```
"""
function g_type_free_instance(instance)
    @ccall libaravis.g_type_free_instance(instance::Ptr{GTypeInstance})::Cvoid
end

"""
    g_type_add_class_cache_func(cache_data, cache_func)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_type_add_class_cache_func (gpointer cache_data, GTypeClassCacheFunc cache_func);
```
"""
function g_type_add_class_cache_func(cache_data, cache_func)
    @ccall libaravis.g_type_add_class_cache_func(cache_data::gpointer, cache_func::GTypeClassCacheFunc)::Cvoid
end

"""
    g_type_remove_class_cache_func(cache_data, cache_func)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_type_remove_class_cache_func (gpointer cache_data, GTypeClassCacheFunc cache_func);
```
"""
function g_type_remove_class_cache_func(cache_data, cache_func)
    @ccall libaravis.g_type_remove_class_cache_func(cache_data::gpointer, cache_func::GTypeClassCacheFunc)::Cvoid
end

"""
    g_type_class_unref_uncached(g_class)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_type_class_unref_uncached (gpointer g_class);
```
"""
function g_type_class_unref_uncached(g_class)
    @ccall libaravis.g_type_class_unref_uncached(g_class::gpointer)::Cvoid
end

"""
    g_type_add_interface_check(check_data, check_func)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_type_add_interface_check (gpointer check_data, GTypeInterfaceCheckFunc check_func);
```
"""
function g_type_add_interface_check(check_data, check_func)
    @ccall libaravis.g_type_add_interface_check(check_data::gpointer, check_func::GTypeInterfaceCheckFunc)::Cvoid
end

"""
    g_type_remove_interface_check(check_data, check_func)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_type_remove_interface_check (gpointer check_data, GTypeInterfaceCheckFunc check_func);
```
"""
function g_type_remove_interface_check(check_data, check_func)
    @ccall libaravis.g_type_remove_interface_check(check_data::gpointer, check_func::GTypeInterfaceCheckFunc)::Cvoid
end

"""
    g_type_name_from_instance(instance)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL const gchar * g_type_name_from_instance (GTypeInstance *instance);
```
"""
function g_type_name_from_instance(instance)
    @ccall libaravis.g_type_name_from_instance(instance::Ptr{GTypeInstance})::Ptr{gchar}
end

"""
    g_type_name_from_class(g_class)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL const gchar * g_type_name_from_class (GTypeClass *g_class);
```
"""
function g_type_name_from_class(g_class)
    @ccall libaravis.g_type_name_from_class(g_class::Ptr{GTypeClass})::Ptr{gchar}
end

# typedef void ( * GValueTransform ) ( const GValue * src_value , GValue * dest_value )
"""
[`GValueTransform`](@ref): \\_value: source value

\\test \\_value: target value

The type of value transformation functions which can be registered with [func.Value.register\\_transform\\_func].

\\test \\_value will be initialized to the correct destination type.
"""
const GValueTransform = Ptr{Cvoid}

"""
    g_value_init(value, g_type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GValue* g_value_init (GValue *value, GType g_type);
```
"""
function g_value_init(value, g_type)
    @ccall libaravis.g_value_init(value::Ptr{GValue}, g_type::GType)::Ptr{GValue}
end

"""
    g_value_copy(src_value, dest_value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_copy (const GValue *src_value, GValue *dest_value);
```
"""
function g_value_copy(src_value, dest_value)
    @ccall libaravis.g_value_copy(src_value::Ptr{GValue}, dest_value::Ptr{GValue})::Cvoid
end

"""
    g_value_reset(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GValue* g_value_reset (GValue *value);
```
"""
function g_value_reset(value)
    @ccall libaravis.g_value_reset(value::Ptr{GValue})::Ptr{GValue}
end

"""
    g_value_unset(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_unset (GValue *value);
```
"""
function g_value_unset(value)
    @ccall libaravis.g_value_unset(value::Ptr{GValue})::Cvoid
end

"""
    g_value_set_instance(value, instance)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_set_instance (GValue *value, gpointer instance);
```
"""
function g_value_set_instance(value, instance)
    @ccall libaravis.g_value_set_instance(value::Ptr{GValue}, instance::gpointer)::Cvoid
end

"""
    g_value_init_from_instance(value, instance)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_42 void g_value_init_from_instance (GValue *value, gpointer instance);
```
"""
function g_value_init_from_instance(value, instance)
    @ccall libaravis.g_value_init_from_instance(value::Ptr{GValue}, instance::gpointer)::Cvoid
end

"""
    g_value_fits_pointer(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gboolean g_value_fits_pointer (const GValue *value);
```
"""
function g_value_fits_pointer(value)
    @ccall libaravis.g_value_fits_pointer(value::Ptr{GValue})::gboolean
end

"""
    g_value_peek_pointer(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gpointer g_value_peek_pointer (const GValue *value);
```
"""
function g_value_peek_pointer(value)
    @ccall libaravis.g_value_peek_pointer(value::Ptr{GValue})::gpointer
end

"""
    g_value_type_compatible(src_type, dest_type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gboolean g_value_type_compatible (GType src_type, GType dest_type);
```
"""
function g_value_type_compatible(src_type, dest_type)
    @ccall libaravis.g_value_type_compatible(src_type::GType, dest_type::GType)::gboolean
end

"""
    g_value_type_transformable(src_type, dest_type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gboolean g_value_type_transformable (GType src_type, GType dest_type);
```
"""
function g_value_type_transformable(src_type, dest_type)
    @ccall libaravis.g_value_type_transformable(src_type::GType, dest_type::GType)::gboolean
end

"""
    g_value_transform(src_value, dest_value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gboolean g_value_transform (const GValue *src_value, GValue *dest_value);
```
"""
function g_value_transform(src_value, dest_value)
    @ccall libaravis.g_value_transform(src_value::Ptr{GValue}, dest_value::Ptr{GValue})::gboolean
end

"""
    g_value_register_transform_func(src_type, dest_type, transform_func)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_register_transform_func (GType src_type, GType dest_type, GValueTransform transform_func);
```
"""
function g_value_register_transform_func(src_type, dest_type, transform_func)
    @ccall libaravis.g_value_register_transform_func(src_type::GType, dest_type::GType, transform_func::GValueTransform)::Cvoid
end

"""
    _GParameter

[`GParameter`](@ref):

`: the parameter name`

: the parameter value

The [`GParameter`](@ref) struct is an auxiliary structure used to hand parameter name/value pairs to [`g_object_newv`](@ref)().

Deprecated: 2.54: This type is not introspectable.
"""
struct _GParameter
    data::NTuple{32, UInt8}
end

function Base.getproperty(x::Ptr{_GParameter}, f::Symbol)
    f === :name && return Ptr{Ptr{gchar}}(x + 0)
    f === :value && return Ptr{GValue}(x + 8)
    return getfield(x, f)
end

function Base.getproperty(x::_GParameter, f::Symbol)
    r = Ref{_GParameter}(x)
    ptr = Base.unsafe_convert(Ptr{_GParameter}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{_GParameter}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::_GParameter, private::Bool = false)
    (:name, :value, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

"""
[`GParameter`](@ref):

`: the parameter name`

: the parameter value

The [`GParameter`](@ref) struct is an auxiliary structure used to hand parameter name/value pairs to [`g_object_newv`](@ref)().

Deprecated: 2.54: This type is not introspectable.
"""
const GParameter = _GParameter

const _GParamSpecPool = Cvoid

const GParamSpecPool = _GParamSpecPool

"""
    g_param_spec_ref(pspec)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_param_spec_ref (GParamSpec *pspec);
```
"""
function g_param_spec_ref(pspec)
    @ccall libaravis.g_param_spec_ref(pspec::Ptr{GParamSpec})::Ptr{GParamSpec}
end

"""
    g_param_spec_unref(pspec)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_param_spec_unref (GParamSpec *pspec);
```
"""
function g_param_spec_unref(pspec)
    @ccall libaravis.g_param_spec_unref(pspec::Ptr{GParamSpec})::Cvoid
end

"""
    g_param_spec_sink(pspec)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_param_spec_sink (GParamSpec *pspec);
```
"""
function g_param_spec_sink(pspec)
    @ccall libaravis.g_param_spec_sink(pspec::Ptr{GParamSpec})::Cvoid
end

"""
    g_param_spec_ref_sink(pspec)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_param_spec_ref_sink (GParamSpec *pspec);
```
"""
function g_param_spec_ref_sink(pspec)
    @ccall libaravis.g_param_spec_ref_sink(pspec::Ptr{GParamSpec})::Ptr{GParamSpec}
end

"""
    g_param_spec_get_qdata(pspec, quark)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gpointer g_param_spec_get_qdata (GParamSpec *pspec, GQuark quark);
```
"""
function g_param_spec_get_qdata(pspec, quark)
    @ccall libaravis.g_param_spec_get_qdata(pspec::Ptr{GParamSpec}, quark::GQuark)::gpointer
end

"""
    g_param_spec_set_qdata(pspec, quark, data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_param_spec_set_qdata (GParamSpec *pspec, GQuark quark, gpointer data);
```
"""
function g_param_spec_set_qdata(pspec, quark, data)
    @ccall libaravis.g_param_spec_set_qdata(pspec::Ptr{GParamSpec}, quark::GQuark, data::gpointer)::Cvoid
end

"""
    g_param_spec_set_qdata_full(pspec, quark, data, destroy)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_param_spec_set_qdata_full (GParamSpec *pspec, GQuark quark, gpointer data, GDestroyNotify destroy);
```
"""
function g_param_spec_set_qdata_full(pspec, quark, data, destroy)
    @ccall libaravis.g_param_spec_set_qdata_full(pspec::Ptr{GParamSpec}, quark::GQuark, data::gpointer, destroy::GDestroyNotify)::Cvoid
end

"""
    g_param_spec_steal_qdata(pspec, quark)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gpointer g_param_spec_steal_qdata (GParamSpec *pspec, GQuark quark);
```
"""
function g_param_spec_steal_qdata(pspec, quark)
    @ccall libaravis.g_param_spec_steal_qdata(pspec::Ptr{GParamSpec}, quark::GQuark)::gpointer
end

"""
    g_param_spec_get_redirect_target(pspec)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_param_spec_get_redirect_target (GParamSpec *pspec);
```
"""
function g_param_spec_get_redirect_target(pspec)
    @ccall libaravis.g_param_spec_get_redirect_target(pspec::Ptr{GParamSpec})::Ptr{GParamSpec}
end

"""
    g_param_value_set_default(pspec, value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_param_value_set_default (GParamSpec *pspec, GValue *value);
```
"""
function g_param_value_set_default(pspec, value)
    @ccall libaravis.g_param_value_set_default(pspec::Ptr{GParamSpec}, value::Ptr{GValue})::Cvoid
end

"""
    g_param_value_defaults(pspec, value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gboolean g_param_value_defaults (GParamSpec *pspec, const GValue *value);
```
"""
function g_param_value_defaults(pspec, value)
    @ccall libaravis.g_param_value_defaults(pspec::Ptr{GParamSpec}, value::Ptr{GValue})::gboolean
end

"""
    g_param_value_validate(pspec, value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gboolean g_param_value_validate (GParamSpec *pspec, GValue *value);
```
"""
function g_param_value_validate(pspec, value)
    @ccall libaravis.g_param_value_validate(pspec::Ptr{GParamSpec}, value::Ptr{GValue})::gboolean
end

"""
    g_param_value_is_valid(pspec, value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_74 gboolean g_param_value_is_valid (GParamSpec *pspec, const GValue *value);
```
"""
function g_param_value_is_valid(pspec, value)
    @ccall libaravis.g_param_value_is_valid(pspec::Ptr{GParamSpec}, value::Ptr{GValue})::gboolean
end

"""
    g_param_value_convert(pspec, src_value, dest_value, strict_validation)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gboolean g_param_value_convert (GParamSpec *pspec, const GValue *src_value, GValue *dest_value, gboolean strict_validation);
```
"""
function g_param_value_convert(pspec, src_value, dest_value, strict_validation)
    @ccall libaravis.g_param_value_convert(pspec::Ptr{GParamSpec}, src_value::Ptr{GValue}, dest_value::Ptr{GValue}, strict_validation::gboolean)::gboolean
end

"""
    g_param_values_cmp(pspec, value1, value2)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gint g_param_values_cmp (GParamSpec *pspec, const GValue *value1, const GValue *value2);
```
"""
function g_param_values_cmp(pspec, value1, value2)
    @ccall libaravis.g_param_values_cmp(pspec::Ptr{GParamSpec}, value1::Ptr{GValue}, value2::Ptr{GValue})::gint
end

"""
    g_param_spec_get_name(pspec)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL const gchar * g_param_spec_get_name (GParamSpec *pspec);
```
"""
function g_param_spec_get_name(pspec)
    @ccall libaravis.g_param_spec_get_name(pspec::Ptr{GParamSpec})::Ptr{gchar}
end

"""
    g_param_spec_get_nick(pspec)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL const gchar * g_param_spec_get_nick (GParamSpec *pspec);
```
"""
function g_param_spec_get_nick(pspec)
    @ccall libaravis.g_param_spec_get_nick(pspec::Ptr{GParamSpec})::Ptr{gchar}
end

"""
    g_param_spec_get_blurb(pspec)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL const gchar * g_param_spec_get_blurb (GParamSpec *pspec);
```
"""
function g_param_spec_get_blurb(pspec)
    @ccall libaravis.g_param_spec_get_blurb(pspec::Ptr{GParamSpec})::Ptr{gchar}
end

"""
    g_value_set_param(value, param)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_set_param (GValue *value, GParamSpec *param);
```
"""
function g_value_set_param(value, param)
    @ccall libaravis.g_value_set_param(value::Ptr{GValue}, param::Ptr{GParamSpec})::Cvoid
end

"""
    g_value_get_param(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_value_get_param (const GValue *value);
```
"""
function g_value_get_param(value)
    @ccall libaravis.g_value_get_param(value::Ptr{GValue})::Ptr{GParamSpec}
end

"""
    g_value_dup_param(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_value_dup_param (const GValue *value);
```
"""
function g_value_dup_param(value)
    @ccall libaravis.g_value_dup_param(value::Ptr{GValue})::Ptr{GParamSpec}
end

"""
    g_value_take_param(value, param)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_take_param (GValue *value, GParamSpec *param);
```
"""
function g_value_take_param(value, param)
    @ccall libaravis.g_value_take_param(value::Ptr{GValue}, param::Ptr{GParamSpec})::Cvoid
end

"""
    g_value_set_param_take_ownership(value, param)

### Prototype
```c
GOBJECT_DEPRECATED_FOR(g_value_take_param) void g_value_set_param_take_ownership (GValue *value, GParamSpec *param);
```
"""
function g_value_set_param_take_ownership(value, param)
    @ccall libaravis.g_value_set_param_take_ownership(value::Ptr{GValue}, param::Ptr{GParamSpec})::Cvoid
end

"""
    g_param_spec_get_default_value(pspec)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_36 const GValue * g_param_spec_get_default_value (GParamSpec *pspec);
```
"""
function g_param_spec_get_default_value(pspec)
    @ccall libaravis.g_param_spec_get_default_value(pspec::Ptr{GParamSpec})::Ptr{GValue}
end

"""
    g_param_spec_get_name_quark(pspec)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_46 GQuark g_param_spec_get_name_quark (GParamSpec *pspec);
```
"""
function g_param_spec_get_name_quark(pspec)
    @ccall libaravis.g_param_spec_get_name_quark(pspec::Ptr{GParamSpec})::GQuark
end

"""
    _GParamSpecTypeInfo

[`GParamSpecTypeInfo`](@ref): \\_size: Size of the instance (object) structure. \\_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10, it is ignored, since instances are allocated with the [slice allocator][glib-Memory-Slices] now. \\_init: Location of the instance initialization function (optional). \\_type: The #[`GType`](@ref) of values conforming to this #[`GParamSpec`](@ref) : The instance finalization function (optional). \\_set\\_default: Resets a  to the default value for   (recommended, the default is [`g_value_reset`](@ref)()), see  [`g_param_value_set_default`](@ref)(). \\_validate: Ensures that the contents of  comply with the  specifications set out by  (optional), see  [`g_param_value_validate`](@ref)(). \\_cmp: Compares  with  according to   (recommended, the default is memcmp()), see [`g_param_values_cmp`](@ref)().

This structure is used to provide the type system with the information required to initialize and destruct (finalize) a parameter's class and instances thereof.

The initialized structure is passed to the [`g_param_type_register_static`](@ref)()  The type system will perform a deep copy of this structure, so its memory  does not need to be persistent across invocation of  [`g_param_type_register_static`](@ref)().
"""
struct _GParamSpecTypeInfo
    instance_size::guint16
    n_preallocs::guint16
    instance_init::Ptr{Cvoid}
    value_type::GType
    finalize::Ptr{Cvoid}
    value_set_default::Ptr{Cvoid}
    value_validate::Ptr{Cvoid}
    values_cmp::Ptr{Cvoid}
end

"""
[`GParamSpecTypeInfo`](@ref): \\_size: Size of the instance (object) structure. \\_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10, it is ignored, since instances are allocated with the [slice allocator][glib-Memory-Slices] now. \\_init: Location of the instance initialization function (optional). \\_type: The #[`GType`](@ref) of values conforming to this #[`GParamSpec`](@ref) : The instance finalization function (optional). \\_set\\_default: Resets a  to the default value for   (recommended, the default is [`g_value_reset`](@ref)()), see  [`g_param_value_set_default`](@ref)(). \\_validate: Ensures that the contents of  comply with the  specifications set out by  (optional), see  [`g_param_value_validate`](@ref)(). \\_cmp: Compares  with  according to   (recommended, the default is memcmp()), see [`g_param_values_cmp`](@ref)().

This structure is used to provide the type system with the information required to initialize and destruct (finalize) a parameter's class and instances thereof.

The initialized structure is passed to the [`g_param_type_register_static`](@ref)()  The type system will perform a deep copy of this structure, so its memory  does not need to be persistent across invocation of  [`g_param_type_register_static`](@ref)().
"""
const GParamSpecTypeInfo = _GParamSpecTypeInfo

"""
    g_param_type_register_static(name, pspec_info)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_param_type_register_static (const gchar *name, const GParamSpecTypeInfo *pspec_info);
```
"""
function g_param_type_register_static(name, pspec_info)
    @ccall libaravis.g_param_type_register_static(name::Ptr{gchar}, pspec_info::Ptr{GParamSpecTypeInfo})::GType
end

"""
    g_param_spec_is_valid_name(name)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_66 gboolean g_param_spec_is_valid_name (const gchar *name);
```
"""
function g_param_spec_is_valid_name(name)
    @ccall libaravis.g_param_spec_is_valid_name(name::Ptr{gchar})::gboolean
end

"""
    _g_param_type_register_static_constant(name, pspec_info, opt_type)

### Prototype
```c
GType _g_param_type_register_static_constant (const gchar *name, const GParamSpecTypeInfo *pspec_info, GType opt_type);
```
"""
function _g_param_type_register_static_constant(name, pspec_info, opt_type)
    @ccall libaravis._g_param_type_register_static_constant(name::Ptr{gchar}, pspec_info::Ptr{GParamSpecTypeInfo}, opt_type::GType)::GType
end

"""
    g_param_spec_internal(param_type, name, nick, blurb, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gpointer g_param_spec_internal (GType param_type, const gchar *name, const gchar *nick, const gchar *blurb, GParamFlags flags);
```
"""
function g_param_spec_internal(param_type, name, nick, blurb, flags)
    @ccall libaravis.g_param_spec_internal(param_type::GType, name::Ptr{gchar}, nick::Ptr{gchar}, blurb::Ptr{gchar}, flags::GParamFlags)::gpointer
end

"""
    g_param_spec_pool_new(type_prefixing)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpecPool* g_param_spec_pool_new (gboolean type_prefixing);
```
"""
function g_param_spec_pool_new(type_prefixing)
    @ccall libaravis.g_param_spec_pool_new(type_prefixing::gboolean)::Ptr{GParamSpecPool}
end

"""
    g_param_spec_pool_insert(pool, pspec, owner_type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_param_spec_pool_insert (GParamSpecPool *pool, GParamSpec *pspec, GType owner_type);
```
"""
function g_param_spec_pool_insert(pool, pspec, owner_type)
    @ccall libaravis.g_param_spec_pool_insert(pool::Ptr{GParamSpecPool}, pspec::Ptr{GParamSpec}, owner_type::GType)::Cvoid
end

"""
    g_param_spec_pool_remove(pool, pspec)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_param_spec_pool_remove (GParamSpecPool *pool, GParamSpec *pspec);
```
"""
function g_param_spec_pool_remove(pool, pspec)
    @ccall libaravis.g_param_spec_pool_remove(pool::Ptr{GParamSpecPool}, pspec::Ptr{GParamSpec})::Cvoid
end

"""
    g_param_spec_pool_lookup(pool, param_name, owner_type, walk_ancestors)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_param_spec_pool_lookup (GParamSpecPool *pool, const gchar *param_name, GType owner_type, gboolean walk_ancestors);
```
"""
function g_param_spec_pool_lookup(pool, param_name, owner_type, walk_ancestors)
    @ccall libaravis.g_param_spec_pool_lookup(pool::Ptr{GParamSpecPool}, param_name::Ptr{gchar}, owner_type::GType, walk_ancestors::gboolean)::Ptr{GParamSpec}
end

"""
    g_param_spec_pool_list_owned(pool, owner_type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GList* g_param_spec_pool_list_owned (GParamSpecPool *pool, GType owner_type);
```
"""
function g_param_spec_pool_list_owned(pool, owner_type)
    @ccall libaravis.g_param_spec_pool_list_owned(pool::Ptr{GParamSpecPool}, owner_type::GType)::Ptr{GList}
end

"""
    g_param_spec_pool_list(pool, owner_type, n_pspecs_p)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec** g_param_spec_pool_list (GParamSpecPool *pool, GType owner_type, guint *n_pspecs_p);
```
"""
function g_param_spec_pool_list(pool, owner_type, n_pspecs_p)
    @ccall libaravis.g_param_spec_pool_list(pool::Ptr{GParamSpecPool}, owner_type::GType, n_pspecs_p::Ptr{guint})::Ptr{Ptr{GParamSpec}}
end

"""
    g_param_spec_pool_free(pool)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_80 void g_param_spec_pool_free (GParamSpecPool *pool);
```
"""
function g_param_spec_pool_free(pool)
    @ccall libaravis.g_param_spec_pool_free(pool::Ptr{GParamSpecPool})::Cvoid
end

# typedef void ( * GClosureMarshal ) ( GClosure * closure , GValue * return_value , guint n_param_values , const GValue * param_values , gpointer invocation_hint , gpointer marshal_data )
"""
[`GClosureMarshal`](@ref): : the #[`GClosure`](@ref) to which the marshaller belongs

The type used for marshaller functions.

# Arguments
* `_values`: array
* `_values:`: (array length=n\\_param\\_values): an array of #GValues holding the arguments on which to invoke the callback of  \\_hint: (nullable): the invocation hint given as the last argument to [`g_closure_invoke`](@ref)() \\_data: (nullable): additional data specified when registering the marshaller, see [`g_closure_set_marshal`](@ref)() and [`g_closure_set_meta_marshal`](@ref)()
# Returns
\\_value: (nullable): a #[`GValue`](@ref) to store the return value. May be NULL if the callback of  doesn't return a value. \\_param\\_values: the length of the
"""
const GClosureMarshal = Ptr{Cvoid}

# typedef void ( * GVaClosureMarshal ) ( GClosure * closure , GValue * return_value , gpointer instance , va_list args , gpointer marshal_data , int n_params , GType * param_types )
"""
[`GVaClosureMarshal`](@ref): : the #[`GClosure`](@ref) to which the marshaller belongs

* : va\\_list of arguments to be passed to the closure. \\_data: (nullable): additional data specified when registering the marshaller, see [`g_closure_set_marshal`](@ref)() and [`g_closure_set_meta_marshal`](@ref)() \\_params: the length of the

* .

This is the signature of va\\_list marshaller functions, an optional marshaller that can be used in some situations to avoid marshalling the signal argument into GValues.

# Arguments
* `_types`: array
* `_types:`: (array length=n\\_params): the #[`GType`](@ref) of each argument from
# Returns
\\_value: (nullable): a #[`GValue`](@ref) to store the return value. May be NULL if the callback of  doesn't return a value. : (type [`GObject`](@ref).TypeInstance): the instance on which the closure is invoked.
"""
const GVaClosureMarshal = Ptr{Cvoid}

struct _GCClosure
    data::NTuple{40, UInt8}
end

function Base.getproperty(x::Ptr{_GCClosure}, f::Symbol)
    f === :closure && return Ptr{GClosure}(x + 0)
    f === :callback && return Ptr{gpointer}(x + 32)
    return getfield(x, f)
end

function Base.getproperty(x::_GCClosure, f::Symbol)
    r = Ref{_GCClosure}(x)
    ptr = Base.unsafe_convert(Ptr{_GCClosure}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{_GCClosure}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::_GCClosure, private::Bool = false)
    (:closure, :callback, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

"""
[`GCClosure`](@ref): : the #[`GClosure`](@ref)

`: the callback function`

A #[`GCClosure`](@ref) is a specialization of #[`GClosure`](@ref) for C function callbacks.
"""
const GCClosure = _GCClosure

"""
    g_cclosure_new(callback_func, user_data, destroy_data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GClosure* g_cclosure_new (GCallback callback_func, gpointer user_data, GClosureNotify destroy_data);
```
"""
function g_cclosure_new(callback_func, user_data, destroy_data)
    @ccall libaravis.g_cclosure_new(callback_func::GCallback, user_data::gpointer, destroy_data::GClosureNotify)::Ptr{GClosure}
end

"""
    g_cclosure_new_swap(callback_func, user_data, destroy_data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GClosure* g_cclosure_new_swap (GCallback callback_func, gpointer user_data, GClosureNotify destroy_data);
```
"""
function g_cclosure_new_swap(callback_func, user_data, destroy_data)
    @ccall libaravis.g_cclosure_new_swap(callback_func::GCallback, user_data::gpointer, destroy_data::GClosureNotify)::Ptr{GClosure}
end

"""
    g_signal_type_cclosure_new(itype, struct_offset)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GClosure* g_signal_type_cclosure_new (GType itype, guint struct_offset);
```
"""
function g_signal_type_cclosure_new(itype, struct_offset)
    @ccall libaravis.g_signal_type_cclosure_new(itype::GType, struct_offset::guint)::Ptr{GClosure}
end

"""
    g_closure_ref(closure)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GClosure* g_closure_ref (GClosure *closure);
```
"""
function g_closure_ref(closure)
    @ccall libaravis.g_closure_ref(closure::Ptr{GClosure})::Ptr{GClosure}
end

"""
    g_closure_sink(closure)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_closure_sink (GClosure *closure);
```
"""
function g_closure_sink(closure)
    @ccall libaravis.g_closure_sink(closure::Ptr{GClosure})::Cvoid
end

"""
    g_closure_unref(closure)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_closure_unref (GClosure *closure);
```
"""
function g_closure_unref(closure)
    @ccall libaravis.g_closure_unref(closure::Ptr{GClosure})::Cvoid
end

"""
    g_closure_new_simple(sizeof_closure, data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GClosure* g_closure_new_simple (guint sizeof_closure, gpointer data);
```
"""
function g_closure_new_simple(sizeof_closure, data)
    @ccall libaravis.g_closure_new_simple(sizeof_closure::guint, data::gpointer)::Ptr{GClosure}
end

"""
    g_closure_add_finalize_notifier(closure, notify_data, notify_func)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_closure_add_finalize_notifier (GClosure *closure, gpointer notify_data, GClosureNotify notify_func);
```
"""
function g_closure_add_finalize_notifier(closure, notify_data, notify_func)
    @ccall libaravis.g_closure_add_finalize_notifier(closure::Ptr{GClosure}, notify_data::gpointer, notify_func::GClosureNotify)::Cvoid
end

"""
    g_closure_remove_finalize_notifier(closure, notify_data, notify_func)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_closure_remove_finalize_notifier (GClosure *closure, gpointer notify_data, GClosureNotify notify_func);
```
"""
function g_closure_remove_finalize_notifier(closure, notify_data, notify_func)
    @ccall libaravis.g_closure_remove_finalize_notifier(closure::Ptr{GClosure}, notify_data::gpointer, notify_func::GClosureNotify)::Cvoid
end

"""
    g_closure_add_invalidate_notifier(closure, notify_data, notify_func)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_closure_add_invalidate_notifier (GClosure *closure, gpointer notify_data, GClosureNotify notify_func);
```
"""
function g_closure_add_invalidate_notifier(closure, notify_data, notify_func)
    @ccall libaravis.g_closure_add_invalidate_notifier(closure::Ptr{GClosure}, notify_data::gpointer, notify_func::GClosureNotify)::Cvoid
end

"""
    g_closure_remove_invalidate_notifier(closure, notify_data, notify_func)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_closure_remove_invalidate_notifier (GClosure *closure, gpointer notify_data, GClosureNotify notify_func);
```
"""
function g_closure_remove_invalidate_notifier(closure, notify_data, notify_func)
    @ccall libaravis.g_closure_remove_invalidate_notifier(closure::Ptr{GClosure}, notify_data::gpointer, notify_func::GClosureNotify)::Cvoid
end

"""
    g_closure_add_marshal_guards(closure, pre_marshal_data, pre_marshal_notify, post_marshal_data, post_marshal_notify)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_closure_add_marshal_guards (GClosure *closure, gpointer pre_marshal_data, GClosureNotify pre_marshal_notify, gpointer post_marshal_data, GClosureNotify post_marshal_notify);
```
"""
function g_closure_add_marshal_guards(closure, pre_marshal_data, pre_marshal_notify, post_marshal_data, post_marshal_notify)
    @ccall libaravis.g_closure_add_marshal_guards(closure::Ptr{GClosure}, pre_marshal_data::gpointer, pre_marshal_notify::GClosureNotify, post_marshal_data::gpointer, post_marshal_notify::GClosureNotify)::Cvoid
end

"""
    g_closure_set_marshal(closure, marshal)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_closure_set_marshal (GClosure *closure, GClosureMarshal marshal);
```
"""
function g_closure_set_marshal(closure, marshal)
    @ccall libaravis.g_closure_set_marshal(closure::Ptr{GClosure}, marshal::GClosureMarshal)::Cvoid
end

"""
    g_closure_set_meta_marshal(closure, marshal_data, meta_marshal)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_closure_set_meta_marshal (GClosure *closure, gpointer marshal_data, GClosureMarshal meta_marshal);
```
"""
function g_closure_set_meta_marshal(closure, marshal_data, meta_marshal)
    @ccall libaravis.g_closure_set_meta_marshal(closure::Ptr{GClosure}, marshal_data::gpointer, meta_marshal::GClosureMarshal)::Cvoid
end

"""
    g_closure_invalidate(closure)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_closure_invalidate (GClosure *closure);
```
"""
function g_closure_invalidate(closure)
    @ccall libaravis.g_closure_invalidate(closure::Ptr{GClosure})::Cvoid
end

"""
    g_closure_invoke(closure, return_value, n_param_values, param_values, invocation_hint)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_closure_invoke (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint);
```
"""
function g_closure_invoke(closure, return_value, n_param_values, param_values, invocation_hint)
    @ccall libaravis.g_closure_invoke(closure::Ptr{GClosure}, return_value::Ptr{GValue}, n_param_values::guint, param_values::Ptr{GValue}, invocation_hint::gpointer)::Cvoid
end

"""
    g_cclosure_marshal_generic(closure, return_gvalue, n_param_values, param_values, invocation_hint, marshal_data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_cclosure_marshal_generic (GClosure *closure, GValue *return_gvalue, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
```
"""
function g_cclosure_marshal_generic(closure, return_gvalue, n_param_values, param_values, invocation_hint, marshal_data)
    @ccall libaravis.g_cclosure_marshal_generic(closure::Ptr{GClosure}, return_gvalue::Ptr{GValue}, n_param_values::guint, param_values::Ptr{GValue}, invocation_hint::gpointer, marshal_data::gpointer)::Cvoid
end

"""
    g_cclosure_marshal_VOID__VOID(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_cclosure_marshal_VOID__VOID (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
```
"""
function g_cclosure_marshal_VOID__VOID(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)
    @ccall libaravis.g_cclosure_marshal_VOID__VOID(closure::Ptr{GClosure}, return_value::Ptr{GValue}, n_param_values::guint, param_values::Ptr{GValue}, invocation_hint::gpointer, marshal_data::gpointer)::Cvoid
end

"""
    g_cclosure_marshal_VOID__BOOLEAN(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_cclosure_marshal_VOID__BOOLEAN (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
```
"""
function g_cclosure_marshal_VOID__BOOLEAN(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)
    @ccall libaravis.g_cclosure_marshal_VOID__BOOLEAN(closure::Ptr{GClosure}, return_value::Ptr{GValue}, n_param_values::guint, param_values::Ptr{GValue}, invocation_hint::gpointer, marshal_data::gpointer)::Cvoid
end

"""
    g_cclosure_marshal_VOID__CHAR(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_cclosure_marshal_VOID__CHAR (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
```
"""
function g_cclosure_marshal_VOID__CHAR(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)
    @ccall libaravis.g_cclosure_marshal_VOID__CHAR(closure::Ptr{GClosure}, return_value::Ptr{GValue}, n_param_values::guint, param_values::Ptr{GValue}, invocation_hint::gpointer, marshal_data::gpointer)::Cvoid
end

"""
    g_cclosure_marshal_VOID__UCHAR(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_cclosure_marshal_VOID__UCHAR (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
```
"""
function g_cclosure_marshal_VOID__UCHAR(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)
    @ccall libaravis.g_cclosure_marshal_VOID__UCHAR(closure::Ptr{GClosure}, return_value::Ptr{GValue}, n_param_values::guint, param_values::Ptr{GValue}, invocation_hint::gpointer, marshal_data::gpointer)::Cvoid
end

"""
    g_cclosure_marshal_VOID__INT(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_cclosure_marshal_VOID__INT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
```
"""
function g_cclosure_marshal_VOID__INT(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)
    @ccall libaravis.g_cclosure_marshal_VOID__INT(closure::Ptr{GClosure}, return_value::Ptr{GValue}, n_param_values::guint, param_values::Ptr{GValue}, invocation_hint::gpointer, marshal_data::gpointer)::Cvoid
end

"""
    g_cclosure_marshal_VOID__UINT(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_cclosure_marshal_VOID__UINT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
```
"""
function g_cclosure_marshal_VOID__UINT(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)
    @ccall libaravis.g_cclosure_marshal_VOID__UINT(closure::Ptr{GClosure}, return_value::Ptr{GValue}, n_param_values::guint, param_values::Ptr{GValue}, invocation_hint::gpointer, marshal_data::gpointer)::Cvoid
end

"""
    g_cclosure_marshal_VOID__LONG(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_cclosure_marshal_VOID__LONG (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
```
"""
function g_cclosure_marshal_VOID__LONG(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)
    @ccall libaravis.g_cclosure_marshal_VOID__LONG(closure::Ptr{GClosure}, return_value::Ptr{GValue}, n_param_values::guint, param_values::Ptr{GValue}, invocation_hint::gpointer, marshal_data::gpointer)::Cvoid
end

"""
    g_cclosure_marshal_VOID__ULONG(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_cclosure_marshal_VOID__ULONG (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
```
"""
function g_cclosure_marshal_VOID__ULONG(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)
    @ccall libaravis.g_cclosure_marshal_VOID__ULONG(closure::Ptr{GClosure}, return_value::Ptr{GValue}, n_param_values::guint, param_values::Ptr{GValue}, invocation_hint::gpointer, marshal_data::gpointer)::Cvoid
end

"""
    g_cclosure_marshal_VOID__ENUM(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_cclosure_marshal_VOID__ENUM (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
```
"""
function g_cclosure_marshal_VOID__ENUM(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)
    @ccall libaravis.g_cclosure_marshal_VOID__ENUM(closure::Ptr{GClosure}, return_value::Ptr{GValue}, n_param_values::guint, param_values::Ptr{GValue}, invocation_hint::gpointer, marshal_data::gpointer)::Cvoid
end

"""
    g_cclosure_marshal_VOID__FLAGS(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_cclosure_marshal_VOID__FLAGS (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
```
"""
function g_cclosure_marshal_VOID__FLAGS(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)
    @ccall libaravis.g_cclosure_marshal_VOID__FLAGS(closure::Ptr{GClosure}, return_value::Ptr{GValue}, n_param_values::guint, param_values::Ptr{GValue}, invocation_hint::gpointer, marshal_data::gpointer)::Cvoid
end

"""
    g_cclosure_marshal_VOID__FLOAT(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_cclosure_marshal_VOID__FLOAT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
```
"""
function g_cclosure_marshal_VOID__FLOAT(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)
    @ccall libaravis.g_cclosure_marshal_VOID__FLOAT(closure::Ptr{GClosure}, return_value::Ptr{GValue}, n_param_values::guint, param_values::Ptr{GValue}, invocation_hint::gpointer, marshal_data::gpointer)::Cvoid
end

"""
    g_cclosure_marshal_VOID__DOUBLE(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_cclosure_marshal_VOID__DOUBLE (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
```
"""
function g_cclosure_marshal_VOID__DOUBLE(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)
    @ccall libaravis.g_cclosure_marshal_VOID__DOUBLE(closure::Ptr{GClosure}, return_value::Ptr{GValue}, n_param_values::guint, param_values::Ptr{GValue}, invocation_hint::gpointer, marshal_data::gpointer)::Cvoid
end

"""
    g_cclosure_marshal_VOID__STRING(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_cclosure_marshal_VOID__STRING (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
```
"""
function g_cclosure_marshal_VOID__STRING(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)
    @ccall libaravis.g_cclosure_marshal_VOID__STRING(closure::Ptr{GClosure}, return_value::Ptr{GValue}, n_param_values::guint, param_values::Ptr{GValue}, invocation_hint::gpointer, marshal_data::gpointer)::Cvoid
end

"""
    g_cclosure_marshal_VOID__PARAM(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_cclosure_marshal_VOID__PARAM (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
```
"""
function g_cclosure_marshal_VOID__PARAM(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)
    @ccall libaravis.g_cclosure_marshal_VOID__PARAM(closure::Ptr{GClosure}, return_value::Ptr{GValue}, n_param_values::guint, param_values::Ptr{GValue}, invocation_hint::gpointer, marshal_data::gpointer)::Cvoid
end

"""
    g_cclosure_marshal_VOID__BOXED(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_cclosure_marshal_VOID__BOXED (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
```
"""
function g_cclosure_marshal_VOID__BOXED(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)
    @ccall libaravis.g_cclosure_marshal_VOID__BOXED(closure::Ptr{GClosure}, return_value::Ptr{GValue}, n_param_values::guint, param_values::Ptr{GValue}, invocation_hint::gpointer, marshal_data::gpointer)::Cvoid
end

"""
    g_cclosure_marshal_VOID__POINTER(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_cclosure_marshal_VOID__POINTER (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
```
"""
function g_cclosure_marshal_VOID__POINTER(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)
    @ccall libaravis.g_cclosure_marshal_VOID__POINTER(closure::Ptr{GClosure}, return_value::Ptr{GValue}, n_param_values::guint, param_values::Ptr{GValue}, invocation_hint::gpointer, marshal_data::gpointer)::Cvoid
end

"""
    g_cclosure_marshal_VOID__OBJECT(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_cclosure_marshal_VOID__OBJECT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
```
"""
function g_cclosure_marshal_VOID__OBJECT(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)
    @ccall libaravis.g_cclosure_marshal_VOID__OBJECT(closure::Ptr{GClosure}, return_value::Ptr{GValue}, n_param_values::guint, param_values::Ptr{GValue}, invocation_hint::gpointer, marshal_data::gpointer)::Cvoid
end

"""
    g_cclosure_marshal_VOID__VARIANT(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_cclosure_marshal_VOID__VARIANT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
```
"""
function g_cclosure_marshal_VOID__VARIANT(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)
    @ccall libaravis.g_cclosure_marshal_VOID__VARIANT(closure::Ptr{GClosure}, return_value::Ptr{GValue}, n_param_values::guint, param_values::Ptr{GValue}, invocation_hint::gpointer, marshal_data::gpointer)::Cvoid
end

"""
    g_cclosure_marshal_VOID__UINT_POINTER(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_cclosure_marshal_VOID__UINT_POINTER (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
```
"""
function g_cclosure_marshal_VOID__UINT_POINTER(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)
    @ccall libaravis.g_cclosure_marshal_VOID__UINT_POINTER(closure::Ptr{GClosure}, return_value::Ptr{GValue}, n_param_values::guint, param_values::Ptr{GValue}, invocation_hint::gpointer, marshal_data::gpointer)::Cvoid
end

"""
    g_cclosure_marshal_STRING__OBJECT_POINTER(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_cclosure_marshal_STRING__OBJECT_POINTER (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
```
"""
function g_cclosure_marshal_STRING__OBJECT_POINTER(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data)
    @ccall libaravis.g_cclosure_marshal_STRING__OBJECT_POINTER(closure::Ptr{GClosure}, return_value::Ptr{GValue}, n_param_values::guint, param_values::Ptr{GValue}, invocation_hint::gpointer, marshal_data::gpointer)::Cvoid
end

"""
    GSignalFlags

[`GSignalFlags`](@ref): \\_SIGNAL\\_RUN\\_FIRST: Invoke the object method handler in the first emission stage. \\_SIGNAL\\_RUN\\_LAST: Invoke the object method handler in the third emission stage. \\_SIGNAL\\_RUN\\_CLEANUP: Invoke the object method handler in the last emission stage. \\_SIGNAL\\_NO\\_RECURSE: Signals being emitted for an object while currently being in emission for this very object will not be emitted recursively, but instead cause the first emission to be restarted. \\_SIGNAL\\_DETAILED: This signal supports "::detail" appendices to the signal name upon handler connections and emissions. \\_SIGNAL\\_ACTION: Action signals are signals that may freely be emitted on alive objects from user code via [`g_signal_emit`](@ref)() and friends, without the need of being embedded into extra code that performs pre or post emission adjustments on the object. They can also be thought of as object methods which can be called generically by  third-party code. \\_SIGNAL\\_NO\\_HOOKS: No emissions hooks are supported for this signal.

The signal flags are used to specify a signal's behaviour.
"""
@cenum GSignalFlags::UInt32 begin
    G_SIGNAL_RUN_FIRST = 1
    G_SIGNAL_RUN_LAST = 2
    G_SIGNAL_RUN_CLEANUP = 4
    G_SIGNAL_NO_RECURSE = 8
    G_SIGNAL_DETAILED = 16
    G_SIGNAL_ACTION = 32
    G_SIGNAL_NO_HOOKS = 64
    G_SIGNAL_MUST_COLLECT = 128
    G_SIGNAL_DEPRECATED = 256
    G_SIGNAL_ACCUMULATOR_FIRST_RUN = 131072
end

"""
    _GSignalQuery

[`GSignalQuery`](@ref): \\_id: The signal id of the signal being queried, or 0 if the signal to be queried was unknown. \\_name: The signal name. : The interface/instance type that this signal can be emitted for. \\_flags: The signal flags as passed in to [`g_signal_new`](@ref)().

A structure holding in-depth information for a specific signal.

See also: [`g_signal_query`](@ref)()

# Arguments
* `_types:`: (array length=n\\_params): The individual parameter types for user callbacks, note that the effective callback signature is: |[<!-- language="C" -->
# Returns
\\_type callback (#[`gpointer`](@ref) data1, [param\\_types param\\_names,] [`gpointer`](@ref) data2); ]|
"""
struct _GSignalQuery
    signal_id::guint
    signal_name::Ptr{gchar}
    itype::GType
    signal_flags::GSignalFlags
    return_type::GType
    n_params::guint
    param_types::Ptr{GType}
end

"""
[`GSignalQuery`](@ref): \\_id: The signal id of the signal being queried, or 0 if the signal to be queried was unknown. \\_name: The signal name. : The interface/instance type that this signal can be emitted for. \\_flags: The signal flags as passed in to [`g_signal_new`](@ref)().

A structure holding in-depth information for a specific signal.

See also: [`g_signal_query`](@ref)()

# Arguments
* `_types:`: (array length=n\\_params): The individual parameter types for user callbacks, note that the effective callback signature is: |[<!-- language="C" -->
# Returns
\\_type callback (#[`gpointer`](@ref) data1, [param\\_types param\\_names,] [`gpointer`](@ref) data2); ]|
"""
const GSignalQuery = _GSignalQuery

"""
    _GSignalInvocationHint

[`GSignalInvocationHint`](@ref): \\_id: The signal id of the signal invoking the callback

: The detail passed on for this emission \\_type: The stage the signal emission is currently in, this field will contain one of G\\_SIGNAL\\_RUN\\_FIRST, G\\_SIGNAL\\_RUN\\_LAST or G\\_SIGNAL\\_RUN\\_CLEANUP and G\\_SIGNAL\\_ACCUMULATOR\\_FIRST\\_RUN. G\\_SIGNAL\\_ACCUMULATOR\\_FIRST\\_RUN is only set for the first run of the accumulator function for a signal emission.

The #[`GSignalInvocationHint`](@ref) structure is used to pass on additional information to callbacks during a signal emission.
"""
struct _GSignalInvocationHint
    signal_id::guint
    detail::GQuark
    run_type::GSignalFlags
end

"""
[`GSignalInvocationHint`](@ref): \\_id: The signal id of the signal invoking the callback

: The detail passed on for this emission \\_type: The stage the signal emission is currently in, this field will contain one of G\\_SIGNAL\\_RUN\\_FIRST, G\\_SIGNAL\\_RUN\\_LAST or G\\_SIGNAL\\_RUN\\_CLEANUP and G\\_SIGNAL\\_ACCUMULATOR\\_FIRST\\_RUN. G\\_SIGNAL\\_ACCUMULATOR\\_FIRST\\_RUN is only set for the first run of the accumulator function for a signal emission.

The #[`GSignalInvocationHint`](@ref) structure is used to pass on additional information to callbacks during a signal emission.
"""
const GSignalInvocationHint = _GSignalInvocationHint

"""
[`GSignalCMarshaller`](@ref):

This is the signature of marshaller functions, required to marshall arrays of parameter values to signal emissions into C language callback invocations.

It is merely an alias to #[`GClosureMarshal`](@ref) since the #[`GClosure`](@ref) mechanism takes over responsibility of actual function invocation for the signal system.
"""
const GSignalCMarshaller = GClosureMarshal

"""
[`GSignalCVaMarshaller`](@ref):

This is the signature of va\\_list marshaller functions, an optional marshaller that can be used in some situations to avoid marshalling the signal argument into GValues.
"""
const GSignalCVaMarshaller = GVaClosureMarshal

# typedef gboolean ( * GSignalEmissionHook ) ( GSignalInvocationHint * ihint , guint n_param_values , const GValue * param_values , gpointer data )
"""
[`GSignalEmissionHook`](@ref): : Signal invocation hint, see #[`GSignalInvocationHint`](@ref). \\_param\\_values: the number of parameters to the function, including the instance on which the signal was emitted.

\\date : user data associated with the hook.

A simple function pointer to get invoked when the signal is emitted.

Emission hooks allow you to tie a hook to the signal type, so that it will trap all emissions of that signal, from any object.

You may not attach these to signals created with the G\\_SIGNAL\\_NO\\_HOOKS flag.

Returns: whether it wants to stay connected. If it returns FALSE, the signal  hook is disconnected (and destroyed).

# Arguments
* `_values:`: (array length=n\\_param\\_values): the instance on which the signal was emitted, followed by the parameters of the emission.
"""
const GSignalEmissionHook = Ptr{Cvoid}

# typedef gboolean ( * GSignalAccumulator ) ( GSignalInvocationHint * ihint , GValue * return_accu , const GValue * handler_return , gpointer data )
"""
[`GSignalAccumulator`](@ref): : Signal invocation hint, see #[`GSignalInvocationHint`](@ref).

\\date : Callback data that was specified when creating the signal.

The signal accumulator is a special callback function that can be used to collect return values of the various callbacks that are called during a signal emission.

The signal accumulator is specified at signal creation time, if it is left NULL, no accumulation of callback return values is performed. The return value of signal emissions is then the value returned by the last callback.

Returns: The accumulator function returns whether the signal emission should be aborted. Returning TRUE will continue with the signal emission. Returning FALSE will abort the current emission. Since 2.62, returning FALSE will skip to the CLEANUP stage. In this case, emission will occur as normal in the CLEANUP stage and the handler's return value will be accumulated.

# Returns
\\_accu: Accumulator to collect callback return values in, this is the return value of the current signal emission. \\_return: A #[`GValue`](@ref) holding the return value of the signal handler.
"""
const GSignalAccumulator = Ptr{Cvoid}

"""
    g_signal_newv(signal_name, itype, signal_flags, class_closure, accumulator, accu_data, c_marshaller, return_type, n_params, param_types)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL guint g_signal_newv (const gchar *signal_name, GType itype, GSignalFlags signal_flags, GClosure *class_closure, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, GType *param_types);
```
"""
function g_signal_newv(signal_name, itype, signal_flags, class_closure, accumulator, accu_data, c_marshaller, return_type, n_params, param_types)
    @ccall libaravis.g_signal_newv(signal_name::Ptr{gchar}, itype::GType, signal_flags::GSignalFlags, class_closure::Ptr{GClosure}, accumulator::GSignalAccumulator, accu_data::gpointer, c_marshaller::GSignalCMarshaller, return_type::GType, n_params::guint, param_types::Ptr{GType})::guint
end

"""
    g_signal_set_va_marshaller(signal_id, instance_type, va_marshaller)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_signal_set_va_marshaller (guint signal_id, GType instance_type, GSignalCVaMarshaller va_marshaller);
```
"""
function g_signal_set_va_marshaller(signal_id, instance_type, va_marshaller)
    @ccall libaravis.g_signal_set_va_marshaller(signal_id::guint, instance_type::GType, va_marshaller::GSignalCVaMarshaller)::Cvoid
end

"""
    g_signal_emitv(instance_and_params, signal_id, detail, return_value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_signal_emitv (const GValue *instance_and_params, guint signal_id, GQuark detail, GValue *return_value);
```
"""
function g_signal_emitv(instance_and_params, signal_id, detail, return_value)
    @ccall libaravis.g_signal_emitv(instance_and_params::Ptr{GValue}, signal_id::guint, detail::GQuark, return_value::Ptr{GValue})::Cvoid
end

"""
    g_signal_lookup(name, itype)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL guint g_signal_lookup (const gchar *name, GType itype);
```
"""
function g_signal_lookup(name, itype)
    @ccall libaravis.g_signal_lookup(name::Ptr{gchar}, itype::GType)::guint
end

"""
    g_signal_name(signal_id)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL const gchar * g_signal_name (guint signal_id);
```
"""
function g_signal_name(signal_id)
    @ccall libaravis.g_signal_name(signal_id::guint)::Ptr{gchar}
end

"""
    g_signal_query(signal_id, query)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_signal_query (guint signal_id, GSignalQuery *query);
```
"""
function g_signal_query(signal_id, query)
    @ccall libaravis.g_signal_query(signal_id::guint, query::Ptr{GSignalQuery})::Cvoid
end

"""
    g_signal_list_ids(itype, n_ids)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL guint* g_signal_list_ids (GType itype, guint *n_ids);
```
"""
function g_signal_list_ids(itype, n_ids)
    @ccall libaravis.g_signal_list_ids(itype::GType, n_ids::Ptr{guint})::Ptr{guint}
end

"""
    g_signal_is_valid_name(name)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_66 gboolean g_signal_is_valid_name (const gchar *name);
```
"""
function g_signal_is_valid_name(name)
    @ccall libaravis.g_signal_is_valid_name(name::Ptr{gchar})::gboolean
end

"""
    g_signal_parse_name(detailed_signal, itype, signal_id_p, detail_p, force_detail_quark)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gboolean g_signal_parse_name (const gchar *detailed_signal, GType itype, guint *signal_id_p, GQuark *detail_p, gboolean force_detail_quark);
```
"""
function g_signal_parse_name(detailed_signal, itype, signal_id_p, detail_p, force_detail_quark)
    @ccall libaravis.g_signal_parse_name(detailed_signal::Ptr{gchar}, itype::GType, signal_id_p::Ptr{guint}, detail_p::Ptr{GQuark}, force_detail_quark::gboolean)::gboolean
end

"""
    g_signal_get_invocation_hint(instance)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GSignalInvocationHint* g_signal_get_invocation_hint (gpointer instance);
```
"""
function g_signal_get_invocation_hint(instance)
    @ccall libaravis.g_signal_get_invocation_hint(instance::gpointer)::Ptr{GSignalInvocationHint}
end

"""
    g_signal_stop_emission(instance, signal_id, detail)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_signal_stop_emission (gpointer instance, guint signal_id, GQuark detail);
```
"""
function g_signal_stop_emission(instance, signal_id, detail)
    @ccall libaravis.g_signal_stop_emission(instance::gpointer, signal_id::guint, detail::GQuark)::Cvoid
end

"""
    g_signal_stop_emission_by_name(instance, detailed_signal)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_signal_stop_emission_by_name (gpointer instance, const gchar *detailed_signal);
```
"""
function g_signal_stop_emission_by_name(instance, detailed_signal)
    @ccall libaravis.g_signal_stop_emission_by_name(instance::gpointer, detailed_signal::Ptr{gchar})::Cvoid
end

"""
    g_signal_add_emission_hook(signal_id, detail, hook_func, hook_data, data_destroy)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gulong g_signal_add_emission_hook (guint signal_id, GQuark detail, GSignalEmissionHook hook_func, gpointer hook_data, GDestroyNotify data_destroy);
```
"""
function g_signal_add_emission_hook(signal_id, detail, hook_func, hook_data, data_destroy)
    @ccall libaravis.g_signal_add_emission_hook(signal_id::guint, detail::GQuark, hook_func::GSignalEmissionHook, hook_data::gpointer, data_destroy::GDestroyNotify)::gulong
end

"""
    g_signal_remove_emission_hook(signal_id, hook_id)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_signal_remove_emission_hook (guint signal_id, gulong hook_id);
```
"""
function g_signal_remove_emission_hook(signal_id, hook_id)
    @ccall libaravis.g_signal_remove_emission_hook(signal_id::guint, hook_id::gulong)::Cvoid
end

"""
    g_signal_has_handler_pending(instance, signal_id, detail, may_be_blocked)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gboolean g_signal_has_handler_pending (gpointer instance, guint signal_id, GQuark detail, gboolean may_be_blocked);
```
"""
function g_signal_has_handler_pending(instance, signal_id, detail, may_be_blocked)
    @ccall libaravis.g_signal_has_handler_pending(instance::gpointer, signal_id::guint, detail::GQuark, may_be_blocked::gboolean)::gboolean
end

"""
    g_signal_connect_closure_by_id(instance, signal_id, detail, closure, after)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gulong g_signal_connect_closure_by_id (gpointer instance, guint signal_id, GQuark detail, GClosure *closure, gboolean after);
```
"""
function g_signal_connect_closure_by_id(instance, signal_id, detail, closure, after)
    @ccall libaravis.g_signal_connect_closure_by_id(instance::gpointer, signal_id::guint, detail::GQuark, closure::Ptr{GClosure}, after::gboolean)::gulong
end

"""
    g_signal_connect_closure(instance, detailed_signal, closure, after)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gulong g_signal_connect_closure (gpointer instance, const gchar *detailed_signal, GClosure *closure, gboolean after);
```
"""
function g_signal_connect_closure(instance, detailed_signal, closure, after)
    @ccall libaravis.g_signal_connect_closure(instance::gpointer, detailed_signal::Ptr{gchar}, closure::Ptr{GClosure}, after::gboolean)::gulong
end

"""
    g_signal_handler_block(instance, handler_id)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_signal_handler_block (gpointer instance, gulong handler_id);
```
"""
function g_signal_handler_block(instance, handler_id)
    @ccall libaravis.g_signal_handler_block(instance::gpointer, handler_id::gulong)::Cvoid
end

"""
    g_signal_handler_unblock(instance, handler_id)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_signal_handler_unblock (gpointer instance, gulong handler_id);
```
"""
function g_signal_handler_unblock(instance, handler_id)
    @ccall libaravis.g_signal_handler_unblock(instance::gpointer, handler_id::gulong)::Cvoid
end

"""
    g_signal_handler_is_connected(instance, handler_id)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gboolean g_signal_handler_is_connected (gpointer instance, gulong handler_id);
```
"""
function g_signal_handler_is_connected(instance, handler_id)
    @ccall libaravis.g_signal_handler_is_connected(instance::gpointer, handler_id::gulong)::gboolean
end

"""
    g_signal_handler_find(instance, mask, signal_id, detail, closure, func, data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gulong g_signal_handler_find (gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data);
```
"""
function g_signal_handler_find(instance, mask, signal_id, detail, closure, func, data)
    @ccall libaravis.g_signal_handler_find(instance::gpointer, mask::GSignalMatchType, signal_id::guint, detail::GQuark, closure::Ptr{GClosure}, func::gpointer, data::gpointer)::gulong
end

"""
    g_signal_override_class_closure(signal_id, instance_type, class_closure)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_signal_override_class_closure (guint signal_id, GType instance_type, GClosure *class_closure);
```
"""
function g_signal_override_class_closure(signal_id, instance_type, class_closure)
    @ccall libaravis.g_signal_override_class_closure(signal_id::guint, instance_type::GType, class_closure::Ptr{GClosure})::Cvoid
end

"""
    g_signal_override_class_handler(signal_name, instance_type, class_handler)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_signal_override_class_handler (const gchar *signal_name, GType instance_type, GCallback class_handler);
```
"""
function g_signal_override_class_handler(signal_name, instance_type, class_handler)
    @ccall libaravis.g_signal_override_class_handler(signal_name::Ptr{gchar}, instance_type::GType, class_handler::GCallback)::Cvoid
end

"""
    g_signal_chain_from_overridden(instance_and_params, return_value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_signal_chain_from_overridden (const GValue *instance_and_params, GValue *return_value);
```
"""
function g_signal_chain_from_overridden(instance_and_params, return_value)
    @ccall libaravis.g_signal_chain_from_overridden(instance_and_params::Ptr{GValue}, return_value::Ptr{GValue})::Cvoid
end

"""
    g_signal_accumulator_true_handled(ihint, return_accu, handler_return, dummy)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gboolean g_signal_accumulator_true_handled (GSignalInvocationHint *ihint, GValue *return_accu, const GValue *handler_return, gpointer dummy);
```
"""
function g_signal_accumulator_true_handled(ihint, return_accu, handler_return, dummy)
    @ccall libaravis.g_signal_accumulator_true_handled(ihint::Ptr{GSignalInvocationHint}, return_accu::Ptr{GValue}, handler_return::Ptr{GValue}, dummy::gpointer)::gboolean
end

"""
    g_signal_accumulator_first_wins(ihint, return_accu, handler_return, dummy)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gboolean g_signal_accumulator_first_wins (GSignalInvocationHint *ihint, GValue *return_accu, const GValue *handler_return, gpointer dummy);
```
"""
function g_signal_accumulator_first_wins(ihint, return_accu, handler_return, dummy)
    @ccall libaravis.g_signal_accumulator_first_wins(ihint::Ptr{GSignalInvocationHint}, return_accu::Ptr{GValue}, handler_return::Ptr{GValue}, dummy::gpointer)::gboolean
end

"""
    g_signal_handlers_destroy(instance)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_signal_handlers_destroy (gpointer instance);
```
"""
function g_signal_handlers_destroy(instance)
    @ccall libaravis.g_signal_handlers_destroy(instance::gpointer)::Cvoid
end

"""
    _g_signals_destroy(itype)

### Prototype
```c
void _g_signals_destroy (GType itype);
```
"""
function _g_signals_destroy(itype)
    @ccall libaravis._g_signals_destroy(itype::GType)::Cvoid
end

"""
    g_variant_get_gtype()

### Prototype
```c
GOBJECT_DEPRECATED_FOR('G_TYPE_VARIANT') GType g_variant_get_gtype (void) G_GNUC_CONST;
```
"""
function g_variant_get_gtype()
    @ccall libaravis.g_variant_get_gtype()::GType
end

"""
    g_boxed_copy(boxed_type, src_boxed)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gpointer g_boxed_copy (GType boxed_type, gconstpointer src_boxed);
```
"""
function g_boxed_copy(boxed_type, src_boxed)
    @ccall libaravis.g_boxed_copy(boxed_type::GType, src_boxed::gconstpointer)::gpointer
end

"""
    g_boxed_free(boxed_type, boxed)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_boxed_free (GType boxed_type, gpointer boxed);
```
"""
function g_boxed_free(boxed_type, boxed)
    @ccall libaravis.g_boxed_free(boxed_type::GType, boxed::gpointer)::Cvoid
end

"""
    g_value_set_boxed(value, v_boxed)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_set_boxed (GValue *value, gconstpointer v_boxed);
```
"""
function g_value_set_boxed(value, v_boxed)
    @ccall libaravis.g_value_set_boxed(value::Ptr{GValue}, v_boxed::gconstpointer)::Cvoid
end

"""
    g_value_set_static_boxed(value, v_boxed)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_set_static_boxed (GValue *value, gconstpointer v_boxed);
```
"""
function g_value_set_static_boxed(value, v_boxed)
    @ccall libaravis.g_value_set_static_boxed(value::Ptr{GValue}, v_boxed::gconstpointer)::Cvoid
end

"""
    g_value_take_boxed(value, v_boxed)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_take_boxed (GValue *value, gconstpointer v_boxed);
```
"""
function g_value_take_boxed(value, v_boxed)
    @ccall libaravis.g_value_take_boxed(value::Ptr{GValue}, v_boxed::gconstpointer)::Cvoid
end

"""
    g_value_set_boxed_take_ownership(value, v_boxed)

### Prototype
```c
GOBJECT_DEPRECATED_FOR(g_value_take_boxed) void g_value_set_boxed_take_ownership (GValue *value, gconstpointer v_boxed);
```
"""
function g_value_set_boxed_take_ownership(value, v_boxed)
    @ccall libaravis.g_value_set_boxed_take_ownership(value::Ptr{GValue}, v_boxed::gconstpointer)::Cvoid
end

"""
    g_value_get_boxed(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gpointer g_value_get_boxed (const GValue *value);
```
"""
function g_value_get_boxed(value)
    @ccall libaravis.g_value_get_boxed(value::Ptr{GValue})::gpointer
end

"""
    g_value_dup_boxed(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gpointer g_value_dup_boxed (const GValue *value);
```
"""
function g_value_dup_boxed(value)
    @ccall libaravis.g_value_dup_boxed(value::Ptr{GValue})::gpointer
end

"""
    _GObjectConstructParam

[`GObjectConstructParam`](@ref): : the #[`GParamSpec`](@ref) of the construct parameter : the value to set the parameter to

The [`GObjectConstructParam`](@ref) struct is an auxiliary structure used to hand #[`GParamSpec`](@ref)/#[`GValue`](@ref) pairs to the  of a #[`GObjectClass`](@ref).
"""
struct _GObjectConstructParam
    pspec::Ptr{GParamSpec}
    value::Ptr{GValue}
end

"""
[`GObjectConstructParam`](@ref): : the #[`GParamSpec`](@ref) of the construct parameter : the value to set the parameter to

The [`GObjectConstructParam`](@ref) struct is an auxiliary structure used to hand #[`GParamSpec`](@ref)/#[`GValue`](@ref) pairs to the  of a #[`GObjectClass`](@ref).
"""
const GObjectConstructParam = _GObjectConstructParam

# typedef void ( * GObjectGetPropertyFunc ) ( GObject * object , guint property_id , GValue * value , GParamSpec * pspec )
"""
[`GObjectGetPropertyFunc`](@ref): : a #[`GObject`](@ref)

`_id: the numeric id under which the property was registered with`

[`g_object_class_install_property`](@ref)(). : a #[`GValue`](@ref) to return the property value in : the #[`GParamSpec`](@ref) describing the property

The type of the \\_property function of #[`GObjectClass`](@ref).
"""
const GObjectGetPropertyFunc = Ptr{Cvoid}

# typedef void ( * GObjectSetPropertyFunc ) ( GObject * object , guint property_id , const GValue * value , GParamSpec * pspec )
"""
[`GObjectSetPropertyFunc`](@ref): : a #[`GObject`](@ref)

`_id: the numeric id under which the property was registered with`

[`g_object_class_install_property`](@ref)(). : the new value for the property : the #[`GParamSpec`](@ref) describing the property

The type of the

# See also
\\_property function of #[`GObjectClass`](@ref).
"""
const GObjectSetPropertyFunc = Ptr{Cvoid}

# typedef void ( * GObjectFinalizeFunc ) ( GObject * object )
"""
[`GObjectFinalizeFunc`](@ref): : the #[`GObject`](@ref) being finalized

The type of the  function of #[`GObjectClass`](@ref).
"""
const GObjectFinalizeFunc = Ptr{Cvoid}

# typedef void ( * GWeakNotify ) ( gpointer data , GObject * where_the_object_was )
"""
[`GWeakNotify`](@ref):

\\date : data that was provided when the weak reference was established \\_the\\_object\\_was: the object being disposed

A #[`GWeakNotify`](@ref) function can be added to an object as a callback that gets triggered when the object is finalized.

Since the object is already being disposed when the #[`GWeakNotify`](@ref) is called, there's not much you could do with the object, apart from e.g. using its address as hash-index or the like.

In particular, this means its invalid to call [`g_object_ref`](@ref)(), [`g_weak_ref_init`](@ref)(), [`g_weak_ref_set`](@ref)(), [`g_object_add_toggle_ref`](@ref)(), [`g_object_weak_ref`](@ref)(), [`g_object_add_weak_pointer`](@ref)() or any function which calls them on the object from this callback.
"""
const GWeakNotify = Ptr{Cvoid}

"""
    g_object_class_install_property(oclass, property_id, pspec)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_object_class_install_property (GObjectClass *oclass, guint property_id, GParamSpec *pspec);
```
"""
function g_object_class_install_property(oclass, property_id, pspec)
    @ccall libaravis.g_object_class_install_property(oclass::Ptr{GObjectClass}, property_id::guint, pspec::Ptr{GParamSpec})::Cvoid
end

"""
    g_object_class_find_property(oclass, property_name)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_object_class_find_property (GObjectClass *oclass, const gchar *property_name);
```
"""
function g_object_class_find_property(oclass, property_name)
    @ccall libaravis.g_object_class_find_property(oclass::Ptr{GObjectClass}, property_name::Ptr{gchar})::Ptr{GParamSpec}
end

"""
    g_object_class_list_properties(oclass, n_properties)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec**g_object_class_list_properties (GObjectClass *oclass, guint *n_properties);
```
"""
function g_object_class_list_properties(oclass, n_properties)
    @ccall libaravis.g_object_class_list_properties(oclass::Ptr{GObjectClass}, n_properties::Ptr{guint})::Ptr{Ptr{GParamSpec}}
end

"""
    g_object_class_override_property(oclass, property_id, name)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_object_class_override_property (GObjectClass *oclass, guint property_id, const gchar *name);
```
"""
function g_object_class_override_property(oclass, property_id, name)
    @ccall libaravis.g_object_class_override_property(oclass::Ptr{GObjectClass}, property_id::guint, name::Ptr{gchar})::Cvoid
end

"""
    g_object_class_install_properties(oclass, n_pspecs, pspecs)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_object_class_install_properties (GObjectClass *oclass, guint n_pspecs, GParamSpec **pspecs);
```
"""
function g_object_class_install_properties(oclass, n_pspecs, pspecs)
    @ccall libaravis.g_object_class_install_properties(oclass::Ptr{GObjectClass}, n_pspecs::guint, pspecs::Ptr{Ptr{GParamSpec}})::Cvoid
end

"""
    g_object_interface_install_property(g_iface, pspec)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_object_interface_install_property (gpointer g_iface, GParamSpec *pspec);
```
"""
function g_object_interface_install_property(g_iface, pspec)
    @ccall libaravis.g_object_interface_install_property(g_iface::gpointer, pspec::Ptr{GParamSpec})::Cvoid
end

"""
    g_object_interface_find_property(g_iface, property_name)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_object_interface_find_property (gpointer g_iface, const gchar *property_name);
```
"""
function g_object_interface_find_property(g_iface, property_name)
    @ccall libaravis.g_object_interface_find_property(g_iface::gpointer, property_name::Ptr{gchar})::Ptr{GParamSpec}
end

"""
    g_object_interface_list_properties(g_iface, n_properties_p)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec**g_object_interface_list_properties (gpointer g_iface, guint *n_properties_p);
```
"""
function g_object_interface_list_properties(g_iface, n_properties_p)
    @ccall libaravis.g_object_interface_list_properties(g_iface::gpointer, n_properties_p::Ptr{guint})::Ptr{Ptr{GParamSpec}}
end

"""
    g_object_get_type()

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_object_get_type (void) G_GNUC_CONST;
```
"""
function g_object_get_type()
    @ccall libaravis.g_object_get_type()::GType
end

"""
    g_object_new_with_properties(object_type, n_properties, names, values)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_54 GObject* g_object_new_with_properties (GType object_type, guint n_properties, const char *names[], const GValue values[]);
```
"""
function g_object_new_with_properties(object_type, n_properties, names, values)
    @ccall libaravis.g_object_new_with_properties(object_type::GType, n_properties::guint, names::Ptr{Cstring}, values::Ptr{GValue})::Ptr{GObject}
end

"""
    g_object_newv(object_type, n_parameters, parameters)

### Prototype
```c
GOBJECT_DEPRECATED_IN_2_54_FOR(g_object_new_with_properties) gpointer g_object_newv (GType object_type, guint n_parameters, GParameter *parameters);
```
"""
function g_object_newv(object_type, n_parameters, parameters)
    @ccall libaravis.g_object_newv(object_type::GType, n_parameters::guint, parameters::Ptr{GParameter})::gpointer
end

"""
    g_object_setv(object, n_properties, names, values)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_54 void g_object_setv (GObject *object, guint n_properties, const gchar *names[], const GValue values[]);
```
"""
function g_object_setv(object, n_properties, names, values)
    @ccall libaravis.g_object_setv(object::Ptr{GObject}, n_properties::guint, names::Ptr{Ptr{gchar}}, values::Ptr{GValue})::Cvoid
end

"""
    g_object_getv(object, n_properties, names, values)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_54 void g_object_getv (GObject *object, guint n_properties, const gchar *names[], GValue values[]);
```
"""
function g_object_getv(object, n_properties, names, values)
    @ccall libaravis.g_object_getv(object::Ptr{GObject}, n_properties::guint, names::Ptr{Ptr{gchar}}, values::Ptr{GValue})::Cvoid
end

"""
    g_object_set_property(object, property_name, value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_object_set_property (GObject *object, const gchar *property_name, const GValue *value);
```
"""
function g_object_set_property(object, property_name, value)
    @ccall libaravis.g_object_set_property(object::Ptr{GObject}, property_name::Ptr{gchar}, value::Ptr{GValue})::Cvoid
end

"""
    g_object_get_property(object, property_name, value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_object_get_property (GObject *object, const gchar *property_name, GValue *value);
```
"""
function g_object_get_property(object, property_name, value)
    @ccall libaravis.g_object_get_property(object::Ptr{GObject}, property_name::Ptr{gchar}, value::Ptr{GValue})::Cvoid
end

"""
    g_object_freeze_notify(object)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_object_freeze_notify (GObject *object);
```
"""
function g_object_freeze_notify(object)
    @ccall libaravis.g_object_freeze_notify(object::Ptr{GObject})::Cvoid
end

"""
    g_object_notify(object, property_name)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_object_notify (GObject *object, const gchar *property_name);
```
"""
function g_object_notify(object, property_name)
    @ccall libaravis.g_object_notify(object::Ptr{GObject}, property_name::Ptr{gchar})::Cvoid
end

"""
    g_object_notify_by_pspec(object, pspec)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_object_notify_by_pspec (GObject *object, GParamSpec *pspec);
```
"""
function g_object_notify_by_pspec(object, pspec)
    @ccall libaravis.g_object_notify_by_pspec(object::Ptr{GObject}, pspec::Ptr{GParamSpec})::Cvoid
end

"""
    g_object_thaw_notify(object)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_object_thaw_notify (GObject *object);
```
"""
function g_object_thaw_notify(object)
    @ccall libaravis.g_object_thaw_notify(object::Ptr{GObject})::Cvoid
end

"""
    g_object_is_floating(object)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gboolean g_object_is_floating (gpointer object);
```
"""
function g_object_is_floating(object)
    @ccall libaravis.g_object_is_floating(object::gpointer)::gboolean
end

"""
    g_object_take_ref(object)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_70 gpointer g_object_take_ref (gpointer object);
```
"""
function g_object_take_ref(object)
    @ccall libaravis.g_object_take_ref(object::gpointer)::gpointer
end

"""
    g_object_weak_ref(object, notify, data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_object_weak_ref (GObject *object, GWeakNotify notify, gpointer data);
```
"""
function g_object_weak_ref(object, notify, data)
    @ccall libaravis.g_object_weak_ref(object::Ptr{GObject}, notify::GWeakNotify, data::gpointer)::Cvoid
end

"""
    g_object_weak_unref(object, notify, data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_object_weak_unref (GObject *object, GWeakNotify notify, gpointer data);
```
"""
function g_object_weak_unref(object, notify, data)
    @ccall libaravis.g_object_weak_unref(object::Ptr{GObject}, notify::GWeakNotify, data::gpointer)::Cvoid
end

"""
    g_object_add_weak_pointer(object, weak_pointer_location)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_object_add_weak_pointer (GObject *object, gpointer *weak_pointer_location);
```
"""
function g_object_add_weak_pointer(object, weak_pointer_location)
    @ccall libaravis.g_object_add_weak_pointer(object::Ptr{GObject}, weak_pointer_location::Ptr{gpointer})::Cvoid
end

"""
    g_object_remove_weak_pointer(object, weak_pointer_location)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_object_remove_weak_pointer (GObject *object, gpointer *weak_pointer_location);
```
"""
function g_object_remove_weak_pointer(object, weak_pointer_location)
    @ccall libaravis.g_object_remove_weak_pointer(object::Ptr{GObject}, weak_pointer_location::Ptr{gpointer})::Cvoid
end

# typedef void ( * GToggleNotify ) ( gpointer data , GObject * object , gboolean is_last_ref )
"""
[`GToggleNotify`](@ref):

\\date : Callback data passed to [`g_object_add_toggle_ref`](@ref)() : The object on which [`g_object_add_toggle_ref`](@ref)() was called.

`_last_ref: %TRUE if the toggle reference is now the`

last reference to the object. FALSE if the toggle reference was the last reference and there are now other references.

A callback function used for notification when the state of a toggle reference changes.

See also: [`g_object_add_toggle_ref`](@ref)()
"""
const GToggleNotify = Ptr{Cvoid}

"""
    g_object_add_toggle_ref(object, notify, data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_object_add_toggle_ref (GObject *object, GToggleNotify notify, gpointer data);
```
"""
function g_object_add_toggle_ref(object, notify, data)
    @ccall libaravis.g_object_add_toggle_ref(object::Ptr{GObject}, notify::GToggleNotify, data::gpointer)::Cvoid
end

"""
    g_object_remove_toggle_ref(object, notify, data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_object_remove_toggle_ref (GObject *object, GToggleNotify notify, gpointer data);
```
"""
function g_object_remove_toggle_ref(object, notify, data)
    @ccall libaravis.g_object_remove_toggle_ref(object::Ptr{GObject}, notify::GToggleNotify, data::gpointer)::Cvoid
end

"""
    g_object_get_qdata(object, quark)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gpointer g_object_get_qdata (GObject *object, GQuark quark);
```
"""
function g_object_get_qdata(object, quark)
    @ccall libaravis.g_object_get_qdata(object::Ptr{GObject}, quark::GQuark)::gpointer
end

"""
    g_object_set_qdata(object, quark, data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_object_set_qdata (GObject *object, GQuark quark, gpointer data);
```
"""
function g_object_set_qdata(object, quark, data)
    @ccall libaravis.g_object_set_qdata(object::Ptr{GObject}, quark::GQuark, data::gpointer)::Cvoid
end

"""
    g_object_set_qdata_full(object, quark, data, destroy)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_object_set_qdata_full (GObject *object, GQuark quark, gpointer data, GDestroyNotify destroy);
```
"""
function g_object_set_qdata_full(object, quark, data, destroy)
    @ccall libaravis.g_object_set_qdata_full(object::Ptr{GObject}, quark::GQuark, data::gpointer, destroy::GDestroyNotify)::Cvoid
end

"""
    g_object_steal_qdata(object, quark)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gpointer g_object_steal_qdata (GObject *object, GQuark quark);
```
"""
function g_object_steal_qdata(object, quark)
    @ccall libaravis.g_object_steal_qdata(object::Ptr{GObject}, quark::GQuark)::gpointer
end

"""
    g_object_dup_qdata(object, quark, dup_func, user_data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_34 gpointer g_object_dup_qdata (GObject *object, GQuark quark, GDuplicateFunc dup_func, gpointer user_data);
```
"""
function g_object_dup_qdata(object, quark, dup_func, user_data)
    @ccall libaravis.g_object_dup_qdata(object::Ptr{GObject}, quark::GQuark, dup_func::GDuplicateFunc, user_data::gpointer)::gpointer
end

"""
    g_object_replace_qdata(object, quark, oldval, newval, destroy, old_destroy)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_34 gboolean g_object_replace_qdata (GObject *object, GQuark quark, gpointer oldval, gpointer newval, GDestroyNotify destroy, GDestroyNotify *old_destroy);
```
"""
function g_object_replace_qdata(object, quark, oldval, newval, destroy, old_destroy)
    @ccall libaravis.g_object_replace_qdata(object::Ptr{GObject}, quark::GQuark, oldval::gpointer, newval::gpointer, destroy::GDestroyNotify, old_destroy::Ptr{GDestroyNotify})::gboolean
end

"""
    g_object_get_data(object, key)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gpointer g_object_get_data (GObject *object, const gchar *key);
```
"""
function g_object_get_data(object, key)
    @ccall libaravis.g_object_get_data(object::Ptr{GObject}, key::Ptr{gchar})::gpointer
end

"""
    g_object_set_data(object, key, data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_object_set_data (GObject *object, const gchar *key, gpointer data);
```
"""
function g_object_set_data(object, key, data)
    @ccall libaravis.g_object_set_data(object::Ptr{GObject}, key::Ptr{gchar}, data::gpointer)::Cvoid
end

"""
    g_object_set_data_full(object, key, data, destroy)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_object_set_data_full (GObject *object, const gchar *key, gpointer data, GDestroyNotify destroy);
```
"""
function g_object_set_data_full(object, key, data, destroy)
    @ccall libaravis.g_object_set_data_full(object::Ptr{GObject}, key::Ptr{gchar}, data::gpointer, destroy::GDestroyNotify)::Cvoid
end

"""
    g_object_steal_data(object, key)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gpointer g_object_steal_data (GObject *object, const gchar *key);
```
"""
function g_object_steal_data(object, key)
    @ccall libaravis.g_object_steal_data(object::Ptr{GObject}, key::Ptr{gchar})::gpointer
end

"""
    g_object_dup_data(object, key, dup_func, user_data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_34 gpointer g_object_dup_data (GObject *object, const gchar *key, GDuplicateFunc dup_func, gpointer user_data);
```
"""
function g_object_dup_data(object, key, dup_func, user_data)
    @ccall libaravis.g_object_dup_data(object::Ptr{GObject}, key::Ptr{gchar}, dup_func::GDuplicateFunc, user_data::gpointer)::gpointer
end

"""
    g_object_replace_data(object, key, oldval, newval, destroy, old_destroy)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_34 gboolean g_object_replace_data (GObject *object, const gchar *key, gpointer oldval, gpointer newval, GDestroyNotify destroy, GDestroyNotify *old_destroy);
```
"""
function g_object_replace_data(object, key, oldval, newval, destroy, old_destroy)
    @ccall libaravis.g_object_replace_data(object::Ptr{GObject}, key::Ptr{gchar}, oldval::gpointer, newval::gpointer, destroy::GDestroyNotify, old_destroy::Ptr{GDestroyNotify})::gboolean
end

"""
    g_object_watch_closure(object, closure)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_object_watch_closure (GObject *object, GClosure *closure);
```
"""
function g_object_watch_closure(object, closure)
    @ccall libaravis.g_object_watch_closure(object::Ptr{GObject}, closure::Ptr{GClosure})::Cvoid
end

"""
    g_cclosure_new_object(callback_func, object)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GClosure* g_cclosure_new_object (GCallback callback_func, GObject *object);
```
"""
function g_cclosure_new_object(callback_func, object)
    @ccall libaravis.g_cclosure_new_object(callback_func::GCallback, object::Ptr{GObject})::Ptr{GClosure}
end

"""
    g_cclosure_new_object_swap(callback_func, object)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GClosure* g_cclosure_new_object_swap (GCallback callback_func, GObject *object);
```
"""
function g_cclosure_new_object_swap(callback_func, object)
    @ccall libaravis.g_cclosure_new_object_swap(callback_func::GCallback, object::Ptr{GObject})::Ptr{GClosure}
end

"""
    g_closure_new_object(sizeof_closure, object)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GClosure* g_closure_new_object (guint sizeof_closure, GObject *object);
```
"""
function g_closure_new_object(sizeof_closure, object)
    @ccall libaravis.g_closure_new_object(sizeof_closure::guint, object::Ptr{GObject})::Ptr{GClosure}
end

"""
    g_value_set_object(value, v_object)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_set_object (GValue *value, gpointer v_object);
```
"""
function g_value_set_object(value, v_object)
    @ccall libaravis.g_value_set_object(value::Ptr{GValue}, v_object::gpointer)::Cvoid
end

"""
    g_value_get_object(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gpointer g_value_get_object (const GValue *value);
```
"""
function g_value_get_object(value)
    @ccall libaravis.g_value_get_object(value::Ptr{GValue})::gpointer
end

"""
    g_value_dup_object(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gpointer g_value_dup_object (const GValue *value);
```
"""
function g_value_dup_object(value)
    @ccall libaravis.g_value_dup_object(value::Ptr{GValue})::gpointer
end

"""
    g_signal_connect_object(instance, detailed_signal, c_handler, gobject, connect_flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gulong g_signal_connect_object (gpointer instance, const gchar *detailed_signal, GCallback c_handler, gpointer gobject, GConnectFlags connect_flags);
```
"""
function g_signal_connect_object(instance, detailed_signal, c_handler, gobject, connect_flags)
    @ccall libaravis.g_signal_connect_object(instance::gpointer, detailed_signal::Ptr{gchar}, c_handler::GCallback, gobject::gpointer, connect_flags::GConnectFlags)::gulong
end

"""
    g_object_force_floating(object)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_object_force_floating (GObject *object);
```
"""
function g_object_force_floating(object)
    @ccall libaravis.g_object_force_floating(object::Ptr{GObject})::Cvoid
end

"""
    g_object_run_dispose(object)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_object_run_dispose (GObject *object);
```
"""
function g_object_run_dispose(object)
    @ccall libaravis.g_object_run_dispose(object::Ptr{GObject})::Cvoid
end

"""
    g_value_take_object(value, v_object)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_take_object (GValue *value, gpointer v_object);
```
"""
function g_value_take_object(value, v_object)
    @ccall libaravis.g_value_take_object(value::Ptr{GValue}, v_object::gpointer)::Cvoid
end

"""
    g_value_set_object_take_ownership(value, v_object)

### Prototype
```c
GOBJECT_DEPRECATED_FOR(g_value_take_object) void g_value_set_object_take_ownership (GValue *value, gpointer v_object);
```
"""
function g_value_set_object_take_ownership(value, v_object)
    @ccall libaravis.g_value_set_object_take_ownership(value::Ptr{GValue}, v_object::gpointer)::Cvoid
end

"""
    g_object_compat_control(what, data)

### Prototype
```c
GOBJECT_DEPRECATED gsize g_object_compat_control (gsize what, gpointer data);
```
"""
function g_object_compat_control(what, data)
    @ccall libaravis.g_object_compat_control(what::gsize, data::gpointer)::gsize
end

struct __JL_Ctag_28
    data::NTuple{8, UInt8}
end

function Base.getproperty(x::Ptr{__JL_Ctag_28}, f::Symbol)
    f === :p && return Ptr{gpointer}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::__JL_Ctag_28, f::Symbol)
    r = Ref{__JL_Ctag_28}(x)
    ptr = Base.unsafe_convert(Ptr{__JL_Ctag_28}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{__JL_Ctag_28}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::__JL_Ctag_28, private::Bool = false)
    (:p, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

struct GWeakRef
    data::NTuple{8, UInt8}
end

function Base.getproperty(x::Ptr{GWeakRef}, f::Symbol)
    f === :priv && return Ptr{__JL_Ctag_28}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::GWeakRef, f::Symbol)
    r = Ref{GWeakRef}(x)
    ptr = Base.unsafe_convert(Ptr{GWeakRef}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{GWeakRef}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

function Base.propertynames(x::GWeakRef, private::Bool = false)
    (:priv, if private
            fieldnames(typeof(x))
        else
            ()
        end...)
end

"""
    g_weak_ref_init(weak_ref, object)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_weak_ref_init (GWeakRef *weak_ref, gpointer object);
```
"""
function g_weak_ref_init(weak_ref, object)
    @ccall libaravis.g_weak_ref_init(weak_ref::Ptr{GWeakRef}, object::gpointer)::Cvoid
end

"""
    g_weak_ref_clear(weak_ref)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_weak_ref_clear (GWeakRef *weak_ref);
```
"""
function g_weak_ref_clear(weak_ref)
    @ccall libaravis.g_weak_ref_clear(weak_ref::Ptr{GWeakRef})::Cvoid
end

"""
    g_weak_ref_get(weak_ref)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gpointer g_weak_ref_get (GWeakRef *weak_ref);
```
"""
function g_weak_ref_get(weak_ref)
    @ccall libaravis.g_weak_ref_get(weak_ref::Ptr{GWeakRef})::gpointer
end

"""
    g_weak_ref_set(weak_ref, object)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_weak_ref_set (GWeakRef *weak_ref, gpointer object);
```
"""
function g_weak_ref_set(weak_ref, object)
    @ccall libaravis.g_weak_ref_set(weak_ref::Ptr{GWeakRef}, object::gpointer)::Cvoid
end

# typedef gboolean ( * GBindingTransformFunc ) ( GBinding * binding , const GValue * from_value , GValue * to_value , gpointer user_data )
"""
[`GBindingTransformFunc`](@ref): : a #[`GBinding`](@ref) \\_value: the #[`GValue`](@ref) containing the value to transform \\_value: the #[`GValue`](@ref) in which to store the transformed value \\_data: data passed to the transform function

A function to be called to transform \\_value to \\_value.

If this is the \\_to function of a binding, then \\_value is the \\_property on the  object, and \\_value is the \\_property on the  object. If this is the \\_from function of a G\\_BINDING\\_BIDIRECTIONAL binding, then those roles are reversed.

Returns: TRUE if the transformation was successful, and FALSE otherwise

Since: 2.26
"""
const GBindingTransformFunc = Ptr{Cvoid}

"""
    GBindingFlags

[`GBindingFlags`](@ref): \\_BINDING\\_DEFAULT: The default binding; if the source property changes, the target property is updated with its value. \\_BINDING\\_BIDIRECTIONAL: Bidirectional binding; if either the property of the source or the property of the target changes, the other is updated. \\_BINDING\\_SYNC\\_CREATE: Synchronize the values of the source and target properties when creating the binding; the direction of the synchronization is always from the source to the target. \\_BINDING\\_INVERT\\_BOOLEAN: If the two properties being bound are booleans, setting one to TRUE will result in the other being set to FALSE and vice versa. This flag will only work for boolean properties, and cannot be used when passing custom transformation functions to [`g_object_bind_property_full`](@ref)().

Flags to be passed to [`g_object_bind_property`](@ref)() or [`g_object_bind_property_full`](@ref)().

This enumeration can be extended at later date.

Since: 2.26
"""
@cenum GBindingFlags::UInt32 begin
    G_BINDING_DEFAULT = 0
    G_BINDING_BIDIRECTIONAL = 1
    G_BINDING_SYNC_CREATE = 2
    G_BINDING_INVERT_BOOLEAN = 4
end

"""
    g_binding_get_flags(binding)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GBindingFlags g_binding_get_flags (GBinding *binding);
```
"""
function g_binding_get_flags(binding)
    @ccall libaravis.g_binding_get_flags(binding::Ptr{GBinding})::GBindingFlags
end

"""
    g_binding_get_source(binding)

### Prototype
```c
GOBJECT_DEPRECATED_IN_2_68_FOR(g_binding_dup_source) GObject * g_binding_get_source (GBinding *binding);
```
"""
function g_binding_get_source(binding)
    @ccall libaravis.g_binding_get_source(binding::Ptr{GBinding})::Ptr{GObject}
end

"""
    g_binding_dup_source(binding)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_68 GObject * g_binding_dup_source (GBinding *binding);
```
"""
function g_binding_dup_source(binding)
    @ccall libaravis.g_binding_dup_source(binding::Ptr{GBinding})::Ptr{GObject}
end

"""
    g_binding_get_target(binding)

### Prototype
```c
GOBJECT_DEPRECATED_IN_2_68_FOR(g_binding_dup_target) GObject * g_binding_get_target (GBinding *binding);
```
"""
function g_binding_get_target(binding)
    @ccall libaravis.g_binding_get_target(binding::Ptr{GBinding})::Ptr{GObject}
end

"""
    g_binding_dup_target(binding)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_68 GObject * g_binding_dup_target (GBinding *binding);
```
"""
function g_binding_dup_target(binding)
    @ccall libaravis.g_binding_dup_target(binding::Ptr{GBinding})::Ptr{GObject}
end

"""
    g_binding_get_source_property(binding)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL const gchar * g_binding_get_source_property (GBinding *binding);
```
"""
function g_binding_get_source_property(binding)
    @ccall libaravis.g_binding_get_source_property(binding::Ptr{GBinding})::Ptr{gchar}
end

"""
    g_binding_get_target_property(binding)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL const gchar * g_binding_get_target_property (GBinding *binding);
```
"""
function g_binding_get_target_property(binding)
    @ccall libaravis.g_binding_get_target_property(binding::Ptr{GBinding})::Ptr{gchar}
end

"""
    g_binding_unbind(binding)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_38 void g_binding_unbind (GBinding *binding);
```
"""
function g_binding_unbind(binding)
    @ccall libaravis.g_binding_unbind(binding::Ptr{GBinding})::Cvoid
end

"""
    g_object_bind_property(source, source_property, target, target_property, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GBinding *g_object_bind_property (gpointer source, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags);
```
"""
function g_object_bind_property(source, source_property, target, target_property, flags)
    @ccall libaravis.g_object_bind_property(source::gpointer, source_property::Ptr{gchar}, target::gpointer, target_property::Ptr{gchar}, flags::GBindingFlags)::Ptr{GBinding}
end

"""
    g_object_bind_property_full(source, source_property, target, target_property, flags, transform_to, transform_from, user_data, notify)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GBinding *g_object_bind_property_full (gpointer source, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags, GBindingTransformFunc transform_to, GBindingTransformFunc transform_from, gpointer user_data, GDestroyNotify notify);
```
"""
function g_object_bind_property_full(source, source_property, target, target_property, flags, transform_to, transform_from, user_data, notify)
    @ccall libaravis.g_object_bind_property_full(source::gpointer, source_property::Ptr{gchar}, target::gpointer, target_property::Ptr{gchar}, flags::GBindingFlags, transform_to::GBindingTransformFunc, transform_from::GBindingTransformFunc, user_data::gpointer, notify::GDestroyNotify)::Ptr{GBinding}
end

"""
    g_object_bind_property_with_closures(source, source_property, target, target_property, flags, transform_to, transform_from)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GBinding *g_object_bind_property_with_closures (gpointer source, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags, GClosure *transform_to, GClosure *transform_from);
```
"""
function g_object_bind_property_with_closures(source, source_property, target, target_property, flags, transform_to, transform_from)
    @ccall libaravis.g_object_bind_property_with_closures(source::gpointer, source_property::Ptr{gchar}, target::gpointer, target_property::Ptr{gchar}, flags::GBindingFlags, transform_to::Ptr{GClosure}, transform_from::Ptr{GClosure})::Ptr{GBinding}
end

"""
    g_binding_group_new()

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_72 GBindingGroup *g_binding_group_new (void);
```
"""
function g_binding_group_new()
    @ccall libaravis.g_binding_group_new()::Ptr{GBindingGroup}
end

"""
    g_binding_group_dup_source(self)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_72 gpointer g_binding_group_dup_source (GBindingGroup *self);
```
"""
function g_binding_group_dup_source(self)
    @ccall libaravis.g_binding_group_dup_source(self::Ptr{GBindingGroup})::gpointer
end

"""
    g_binding_group_set_source(self, source)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_72 void g_binding_group_set_source (GBindingGroup *self, gpointer source);
```
"""
function g_binding_group_set_source(self, source)
    @ccall libaravis.g_binding_group_set_source(self::Ptr{GBindingGroup}, source::gpointer)::Cvoid
end

"""
    g_binding_group_bind(self, source_property, target, target_property, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_72 void g_binding_group_bind (GBindingGroup *self, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags);
```
"""
function g_binding_group_bind(self, source_property, target, target_property, flags)
    @ccall libaravis.g_binding_group_bind(self::Ptr{GBindingGroup}, source_property::Ptr{gchar}, target::gpointer, target_property::Ptr{gchar}, flags::GBindingFlags)::Cvoid
end

"""
    g_binding_group_bind_full(self, source_property, target, target_property, flags, transform_to, transform_from, user_data, user_data_destroy)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_72 void g_binding_group_bind_full (GBindingGroup *self, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags, GBindingTransformFunc transform_to, GBindingTransformFunc transform_from, gpointer user_data, GDestroyNotify user_data_destroy);
```
"""
function g_binding_group_bind_full(self, source_property, target, target_property, flags, transform_to, transform_from, user_data, user_data_destroy)
    @ccall libaravis.g_binding_group_bind_full(self::Ptr{GBindingGroup}, source_property::Ptr{gchar}, target::gpointer, target_property::Ptr{gchar}, flags::GBindingFlags, transform_to::GBindingTransformFunc, transform_from::GBindingTransformFunc, user_data::gpointer, user_data_destroy::GDestroyNotify)::Cvoid
end

"""
    g_binding_group_bind_with_closures(self, source_property, target, target_property, flags, transform_to, transform_from)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_72 void g_binding_group_bind_with_closures (GBindingGroup *self, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags, GClosure *transform_to, GClosure *transform_from);
```
"""
function g_binding_group_bind_with_closures(self, source_property, target, target_property, flags, transform_to, transform_from)
    @ccall libaravis.g_binding_group_bind_with_closures(self::Ptr{GBindingGroup}, source_property::Ptr{gchar}, target::gpointer, target_property::Ptr{gchar}, flags::GBindingFlags, transform_to::Ptr{GClosure}, transform_from::Ptr{GClosure})::Cvoid
end

"""
    g_enum_get_value(enum_class, value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GEnumValue* g_enum_get_value (GEnumClass *enum_class, gint value);
```
"""
function g_enum_get_value(enum_class, value)
    @ccall libaravis.g_enum_get_value(enum_class::Ptr{GEnumClass}, value::gint)::Ptr{GEnumValue}
end

"""
    g_enum_get_value_by_name(enum_class, name)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GEnumValue* g_enum_get_value_by_name (GEnumClass *enum_class, const gchar *name);
```
"""
function g_enum_get_value_by_name(enum_class, name)
    @ccall libaravis.g_enum_get_value_by_name(enum_class::Ptr{GEnumClass}, name::Ptr{gchar})::Ptr{GEnumValue}
end

"""
    g_enum_get_value_by_nick(enum_class, nick)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GEnumValue* g_enum_get_value_by_nick (GEnumClass *enum_class, const gchar *nick);
```
"""
function g_enum_get_value_by_nick(enum_class, nick)
    @ccall libaravis.g_enum_get_value_by_nick(enum_class::Ptr{GEnumClass}, nick::Ptr{gchar})::Ptr{GEnumValue}
end

"""
    g_flags_get_first_value(flags_class, value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GFlagsValue* g_flags_get_first_value (GFlagsClass *flags_class, guint value);
```
"""
function g_flags_get_first_value(flags_class, value)
    @ccall libaravis.g_flags_get_first_value(flags_class::Ptr{GFlagsClass}, value::guint)::Ptr{GFlagsValue}
end

"""
    g_flags_get_value_by_name(flags_class, name)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GFlagsValue* g_flags_get_value_by_name (GFlagsClass *flags_class, const gchar *name);
```
"""
function g_flags_get_value_by_name(flags_class, name)
    @ccall libaravis.g_flags_get_value_by_name(flags_class::Ptr{GFlagsClass}, name::Ptr{gchar})::Ptr{GFlagsValue}
end

"""
    g_flags_get_value_by_nick(flags_class, nick)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GFlagsValue* g_flags_get_value_by_nick (GFlagsClass *flags_class, const gchar *nick);
```
"""
function g_flags_get_value_by_nick(flags_class, nick)
    @ccall libaravis.g_flags_get_value_by_nick(flags_class::Ptr{GFlagsClass}, nick::Ptr{gchar})::Ptr{GFlagsValue}
end

"""
    g_enum_to_string(g_enum_type, value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_54 gchar *g_enum_to_string (GType g_enum_type, gint value);
```
"""
function g_enum_to_string(g_enum_type, value)
    @ccall libaravis.g_enum_to_string(g_enum_type::GType, value::gint)::Ptr{gchar}
end

"""
    g_flags_to_string(flags_type, value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_54 gchar *g_flags_to_string (GType flags_type, guint value);
```
"""
function g_flags_to_string(flags_type, value)
    @ccall libaravis.g_flags_to_string(flags_type::GType, value::guint)::Ptr{gchar}
end

"""
    g_value_set_enum(value, v_enum)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_set_enum (GValue *value, gint v_enum);
```
"""
function g_value_set_enum(value, v_enum)
    @ccall libaravis.g_value_set_enum(value::Ptr{GValue}, v_enum::gint)::Cvoid
end

"""
    g_value_get_enum(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gint g_value_get_enum (const GValue *value);
```
"""
function g_value_get_enum(value)
    @ccall libaravis.g_value_get_enum(value::Ptr{GValue})::gint
end

"""
    g_value_set_flags(value, v_flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_set_flags (GValue *value, guint v_flags);
```
"""
function g_value_set_flags(value, v_flags)
    @ccall libaravis.g_value_set_flags(value::Ptr{GValue}, v_flags::guint)::Cvoid
end

"""
    g_value_get_flags(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL guint g_value_get_flags (const GValue *value);
```
"""
function g_value_get_flags(value)
    @ccall libaravis.g_value_get_flags(value::Ptr{GValue})::guint
end

"""
    g_enum_complete_type_info(g_enum_type, info, const_values)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_enum_complete_type_info (GType g_enum_type, GTypeInfo *info, const GEnumValue *const_values);
```
"""
function g_enum_complete_type_info(g_enum_type, info, const_values)
    @ccall libaravis.g_enum_complete_type_info(g_enum_type::GType, info::Ptr{GTypeInfo}, const_values::Ptr{GEnumValue})::Cvoid
end

"""
    g_flags_complete_type_info(g_flags_type, info, const_values)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_flags_complete_type_info (GType g_flags_type, GTypeInfo *info, const GFlagsValue *const_values);
```
"""
function g_flags_complete_type_info(g_flags_type, info, const_values)
    @ccall libaravis.g_flags_complete_type_info(g_flags_type::GType, info::Ptr{GTypeInfo}, const_values::Ptr{GFlagsValue})::Cvoid
end

"""
    g_param_spec_char(name, nick, blurb, minimum, maximum, default_value, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_param_spec_char (const gchar *name, const gchar *nick, const gchar *blurb, gint8 minimum, gint8 maximum, gint8 default_value, GParamFlags flags);
```
"""
function g_param_spec_char(name, nick, blurb, minimum, maximum, default_value, flags)
    @ccall libaravis.g_param_spec_char(name::Ptr{gchar}, nick::Ptr{gchar}, blurb::Ptr{gchar}, minimum::gint8, maximum::gint8, default_value::gint8, flags::GParamFlags)::Ptr{GParamSpec}
end

"""
    g_param_spec_uchar(name, nick, blurb, minimum, maximum, default_value, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_param_spec_uchar (const gchar *name, const gchar *nick, const gchar *blurb, guint8 minimum, guint8 maximum, guint8 default_value, GParamFlags flags);
```
"""
function g_param_spec_uchar(name, nick, blurb, minimum, maximum, default_value, flags)
    @ccall libaravis.g_param_spec_uchar(name::Ptr{gchar}, nick::Ptr{gchar}, blurb::Ptr{gchar}, minimum::guint8, maximum::guint8, default_value::guint8, flags::GParamFlags)::Ptr{GParamSpec}
end

"""
    g_param_spec_boolean(name, nick, blurb, default_value, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_param_spec_boolean (const gchar *name, const gchar *nick, const gchar *blurb, gboolean default_value, GParamFlags flags);
```
"""
function g_param_spec_boolean(name, nick, blurb, default_value, flags)
    @ccall libaravis.g_param_spec_boolean(name::Ptr{gchar}, nick::Ptr{gchar}, blurb::Ptr{gchar}, default_value::gboolean, flags::GParamFlags)::Ptr{GParamSpec}
end

"""
    g_param_spec_int(name, nick, blurb, minimum, maximum, default_value, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_param_spec_int (const gchar *name, const gchar *nick, const gchar *blurb, gint minimum, gint maximum, gint default_value, GParamFlags flags);
```
"""
function g_param_spec_int(name, nick, blurb, minimum, maximum, default_value, flags)
    @ccall libaravis.g_param_spec_int(name::Ptr{gchar}, nick::Ptr{gchar}, blurb::Ptr{gchar}, minimum::gint, maximum::gint, default_value::gint, flags::GParamFlags)::Ptr{GParamSpec}
end

"""
    g_param_spec_uint(name, nick, blurb, minimum, maximum, default_value, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_param_spec_uint (const gchar *name, const gchar *nick, const gchar *blurb, guint minimum, guint maximum, guint default_value, GParamFlags flags);
```
"""
function g_param_spec_uint(name, nick, blurb, minimum, maximum, default_value, flags)
    @ccall libaravis.g_param_spec_uint(name::Ptr{gchar}, nick::Ptr{gchar}, blurb::Ptr{gchar}, minimum::guint, maximum::guint, default_value::guint, flags::GParamFlags)::Ptr{GParamSpec}
end

"""
    g_param_spec_long(name, nick, blurb, minimum, maximum, default_value, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_param_spec_long (const gchar *name, const gchar *nick, const gchar *blurb, glong minimum, glong maximum, glong default_value, GParamFlags flags);
```
"""
function g_param_spec_long(name, nick, blurb, minimum, maximum, default_value, flags)
    @ccall libaravis.g_param_spec_long(name::Ptr{gchar}, nick::Ptr{gchar}, blurb::Ptr{gchar}, minimum::glong, maximum::glong, default_value::glong, flags::GParamFlags)::Ptr{GParamSpec}
end

"""
    g_param_spec_ulong(name, nick, blurb, minimum, maximum, default_value, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_param_spec_ulong (const gchar *name, const gchar *nick, const gchar *blurb, gulong minimum, gulong maximum, gulong default_value, GParamFlags flags);
```
"""
function g_param_spec_ulong(name, nick, blurb, minimum, maximum, default_value, flags)
    @ccall libaravis.g_param_spec_ulong(name::Ptr{gchar}, nick::Ptr{gchar}, blurb::Ptr{gchar}, minimum::gulong, maximum::gulong, default_value::gulong, flags::GParamFlags)::Ptr{GParamSpec}
end

"""
    g_param_spec_int64(name, nick, blurb, minimum, maximum, default_value, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_param_spec_int64 (const gchar *name, const gchar *nick, const gchar *blurb, gint64 minimum, gint64 maximum, gint64 default_value, GParamFlags flags);
```
"""
function g_param_spec_int64(name, nick, blurb, minimum, maximum, default_value, flags)
    @ccall libaravis.g_param_spec_int64(name::Ptr{gchar}, nick::Ptr{gchar}, blurb::Ptr{gchar}, minimum::gint64, maximum::gint64, default_value::gint64, flags::GParamFlags)::Ptr{GParamSpec}
end

"""
    g_param_spec_uint64(name, nick, blurb, minimum, maximum, default_value, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_param_spec_uint64 (const gchar *name, const gchar *nick, const gchar *blurb, guint64 minimum, guint64 maximum, guint64 default_value, GParamFlags flags);
```
"""
function g_param_spec_uint64(name, nick, blurb, minimum, maximum, default_value, flags)
    @ccall libaravis.g_param_spec_uint64(name::Ptr{gchar}, nick::Ptr{gchar}, blurb::Ptr{gchar}, minimum::guint64, maximum::guint64, default_value::guint64, flags::GParamFlags)::Ptr{GParamSpec}
end

"""
    g_param_spec_unichar(name, nick, blurb, default_value, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_param_spec_unichar (const gchar *name, const gchar *nick, const gchar *blurb, gunichar default_value, GParamFlags flags);
```
"""
function g_param_spec_unichar(name, nick, blurb, default_value, flags)
    @ccall libaravis.g_param_spec_unichar(name::Ptr{gchar}, nick::Ptr{gchar}, blurb::Ptr{gchar}, default_value::gunichar, flags::GParamFlags)::Ptr{GParamSpec}
end

"""
    g_param_spec_enum(name, nick, blurb, enum_type, default_value, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_param_spec_enum (const gchar *name, const gchar *nick, const gchar *blurb, GType enum_type, gint default_value, GParamFlags flags);
```
"""
function g_param_spec_enum(name, nick, blurb, enum_type, default_value, flags)
    @ccall libaravis.g_param_spec_enum(name::Ptr{gchar}, nick::Ptr{gchar}, blurb::Ptr{gchar}, enum_type::GType, default_value::gint, flags::GParamFlags)::Ptr{GParamSpec}
end

"""
    g_param_spec_flags(name, nick, blurb, flags_type, default_value, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_param_spec_flags (const gchar *name, const gchar *nick, const gchar *blurb, GType flags_type, guint default_value, GParamFlags flags);
```
"""
function g_param_spec_flags(name, nick, blurb, flags_type, default_value, flags)
    @ccall libaravis.g_param_spec_flags(name::Ptr{gchar}, nick::Ptr{gchar}, blurb::Ptr{gchar}, flags_type::GType, default_value::guint, flags::GParamFlags)::Ptr{GParamSpec}
end

"""
    g_param_spec_float(name, nick, blurb, minimum, maximum, default_value, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_param_spec_float (const gchar *name, const gchar *nick, const gchar *blurb, gfloat minimum, gfloat maximum, gfloat default_value, GParamFlags flags);
```
"""
function g_param_spec_float(name, nick, blurb, minimum, maximum, default_value, flags)
    @ccall libaravis.g_param_spec_float(name::Ptr{gchar}, nick::Ptr{gchar}, blurb::Ptr{gchar}, minimum::gfloat, maximum::gfloat, default_value::gfloat, flags::GParamFlags)::Ptr{GParamSpec}
end

"""
    g_param_spec_double(name, nick, blurb, minimum, maximum, default_value, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_param_spec_double (const gchar *name, const gchar *nick, const gchar *blurb, gdouble minimum, gdouble maximum, gdouble default_value, GParamFlags flags);
```
"""
function g_param_spec_double(name, nick, blurb, minimum, maximum, default_value, flags)
    @ccall libaravis.g_param_spec_double(name::Ptr{gchar}, nick::Ptr{gchar}, blurb::Ptr{gchar}, minimum::gdouble, maximum::gdouble, default_value::gdouble, flags::GParamFlags)::Ptr{GParamSpec}
end

"""
    g_param_spec_string(name, nick, blurb, default_value, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_param_spec_string (const gchar *name, const gchar *nick, const gchar *blurb, const gchar *default_value, GParamFlags flags);
```
"""
function g_param_spec_string(name, nick, blurb, default_value, flags)
    @ccall libaravis.g_param_spec_string(name::Ptr{gchar}, nick::Ptr{gchar}, blurb::Ptr{gchar}, default_value::Ptr{gchar}, flags::GParamFlags)::Ptr{GParamSpec}
end

"""
    g_param_spec_param(name, nick, blurb, param_type, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_param_spec_param (const gchar *name, const gchar *nick, const gchar *blurb, GType param_type, GParamFlags flags);
```
"""
function g_param_spec_param(name, nick, blurb, param_type, flags)
    @ccall libaravis.g_param_spec_param(name::Ptr{gchar}, nick::Ptr{gchar}, blurb::Ptr{gchar}, param_type::GType, flags::GParamFlags)::Ptr{GParamSpec}
end

"""
    g_param_spec_boxed(name, nick, blurb, boxed_type, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_param_spec_boxed (const gchar *name, const gchar *nick, const gchar *blurb, GType boxed_type, GParamFlags flags);
```
"""
function g_param_spec_boxed(name, nick, blurb, boxed_type, flags)
    @ccall libaravis.g_param_spec_boxed(name::Ptr{gchar}, nick::Ptr{gchar}, blurb::Ptr{gchar}, boxed_type::GType, flags::GParamFlags)::Ptr{GParamSpec}
end

"""
    g_param_spec_pointer(name, nick, blurb, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_param_spec_pointer (const gchar *name, const gchar *nick, const gchar *blurb, GParamFlags flags);
```
"""
function g_param_spec_pointer(name, nick, blurb, flags)
    @ccall libaravis.g_param_spec_pointer(name::Ptr{gchar}, nick::Ptr{gchar}, blurb::Ptr{gchar}, flags::GParamFlags)::Ptr{GParamSpec}
end

"""
    g_param_spec_value_array(name, nick, blurb, element_spec, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_param_spec_value_array (const gchar *name, const gchar *nick, const gchar *blurb, GParamSpec *element_spec, GParamFlags flags);
```
"""
function g_param_spec_value_array(name, nick, blurb, element_spec, flags)
    @ccall libaravis.g_param_spec_value_array(name::Ptr{gchar}, nick::Ptr{gchar}, blurb::Ptr{gchar}, element_spec::Ptr{GParamSpec}, flags::GParamFlags)::Ptr{GParamSpec}
end

"""
    g_param_spec_object(name, nick, blurb, object_type, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_param_spec_object (const gchar *name, const gchar *nick, const gchar *blurb, GType object_type, GParamFlags flags);
```
"""
function g_param_spec_object(name, nick, blurb, object_type, flags)
    @ccall libaravis.g_param_spec_object(name::Ptr{gchar}, nick::Ptr{gchar}, blurb::Ptr{gchar}, object_type::GType, flags::GParamFlags)::Ptr{GParamSpec}
end

"""
    g_param_spec_override(name, overridden)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_param_spec_override (const gchar *name, GParamSpec *overridden);
```
"""
function g_param_spec_override(name, overridden)
    @ccall libaravis.g_param_spec_override(name::Ptr{gchar}, overridden::Ptr{GParamSpec})::Ptr{GParamSpec}
end

"""
    g_param_spec_gtype(name, nick, blurb, is_a_type, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_param_spec_gtype (const gchar *name, const gchar *nick, const gchar *blurb, GType is_a_type, GParamFlags flags);
```
"""
function g_param_spec_gtype(name, nick, blurb, is_a_type, flags)
    @ccall libaravis.g_param_spec_gtype(name::Ptr{gchar}, nick::Ptr{gchar}, blurb::Ptr{gchar}, is_a_type::GType, flags::GParamFlags)::Ptr{GParamSpec}
end

"""
    g_param_spec_variant(name, nick, blurb, type, default_value, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GParamSpec* g_param_spec_variant (const gchar *name, const gchar *nick, const gchar *blurb, const GVariantType *type, GVariant *default_value, GParamFlags flags);
```
"""
function g_param_spec_variant(name, nick, blurb, type, default_value, flags)
    @ccall libaravis.g_param_spec_variant(name::Ptr{gchar}, nick::Ptr{gchar}, blurb::Ptr{gchar}, type::Ptr{GVariantType}, default_value::Ptr{GVariant}, flags::GParamFlags)::Ptr{GParamSpec}
end

"""
    g_signal_group_new(target_type)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_72 GSignalGroup *g_signal_group_new (GType target_type);
```
"""
function g_signal_group_new(target_type)
    @ccall libaravis.g_signal_group_new(target_type::GType)::Ptr{GSignalGroup}
end

"""
    g_signal_group_set_target(self, target)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_72 void g_signal_group_set_target (GSignalGroup *self, gpointer target);
```
"""
function g_signal_group_set_target(self, target)
    @ccall libaravis.g_signal_group_set_target(self::Ptr{GSignalGroup}, target::gpointer)::Cvoid
end

"""
    g_signal_group_dup_target(self)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_72 gpointer g_signal_group_dup_target (GSignalGroup *self);
```
"""
function g_signal_group_dup_target(self)
    @ccall libaravis.g_signal_group_dup_target(self::Ptr{GSignalGroup})::gpointer
end

"""
    g_signal_group_block(self)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_72 void g_signal_group_block (GSignalGroup *self);
```
"""
function g_signal_group_block(self)
    @ccall libaravis.g_signal_group_block(self::Ptr{GSignalGroup})::Cvoid
end

"""
    g_signal_group_unblock(self)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_72 void g_signal_group_unblock (GSignalGroup *self);
```
"""
function g_signal_group_unblock(self)
    @ccall libaravis.g_signal_group_unblock(self::Ptr{GSignalGroup})::Cvoid
end

"""
    g_signal_group_connect_closure(self, detailed_signal, closure, after)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_74 void g_signal_group_connect_closure (GSignalGroup *self, const gchar *detailed_signal, GClosure *closure, gboolean after);
```
"""
function g_signal_group_connect_closure(self, detailed_signal, closure, after)
    @ccall libaravis.g_signal_group_connect_closure(self::Ptr{GSignalGroup}, detailed_signal::Ptr{gchar}, closure::Ptr{GClosure}, after::gboolean)::Cvoid
end

"""
    g_signal_group_connect_object(self, detailed_signal, c_handler, object, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_72 void g_signal_group_connect_object (GSignalGroup *self, const gchar *detailed_signal, GCallback c_handler, gpointer object, GConnectFlags flags);
```
"""
function g_signal_group_connect_object(self, detailed_signal, c_handler, object, flags)
    @ccall libaravis.g_signal_group_connect_object(self::Ptr{GSignalGroup}, detailed_signal::Ptr{gchar}, c_handler::GCallback, object::gpointer, flags::GConnectFlags)::Cvoid
end

"""
    g_signal_group_connect_data(self, detailed_signal, c_handler, data, notify, flags)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_72 void g_signal_group_connect_data (GSignalGroup *self, const gchar *detailed_signal, GCallback c_handler, gpointer data, GClosureNotify notify, GConnectFlags flags);
```
"""
function g_signal_group_connect_data(self, detailed_signal, c_handler, data, notify, flags)
    @ccall libaravis.g_signal_group_connect_data(self::Ptr{GSignalGroup}, detailed_signal::Ptr{gchar}, c_handler::GCallback, data::gpointer, notify::GClosureNotify, flags::GConnectFlags)::Cvoid
end

"""
    g_signal_group_connect(self, detailed_signal, c_handler, data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_72 void g_signal_group_connect (GSignalGroup *self, const gchar *detailed_signal, GCallback c_handler, gpointer data);
```
"""
function g_signal_group_connect(self, detailed_signal, c_handler, data)
    @ccall libaravis.g_signal_group_connect(self::Ptr{GSignalGroup}, detailed_signal::Ptr{gchar}, c_handler::GCallback, data::gpointer)::Cvoid
end

"""
    g_signal_group_connect_after(self, detailed_signal, c_handler, data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_72 void g_signal_group_connect_after (GSignalGroup *self, const gchar *detailed_signal, GCallback c_handler, gpointer data);
```
"""
function g_signal_group_connect_after(self, detailed_signal, c_handler, data)
    @ccall libaravis.g_signal_group_connect_after(self::Ptr{GSignalGroup}, detailed_signal::Ptr{gchar}, c_handler::GCallback, data::gpointer)::Cvoid
end

"""
    g_signal_group_connect_swapped(self, detailed_signal, c_handler, data)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_72 void g_signal_group_connect_swapped (GSignalGroup *self, const gchar *detailed_signal, GCallback c_handler, gpointer data);
```
"""
function g_signal_group_connect_swapped(self, detailed_signal, c_handler, data)
    @ccall libaravis.g_signal_group_connect_swapped(self::Ptr{GSignalGroup}, detailed_signal::Ptr{gchar}, c_handler::GCallback, data::gpointer)::Cvoid
end

"""
    g_source_set_closure(source, closure)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_source_set_closure (GSource *source, GClosure *closure);
```
"""
function g_source_set_closure(source, closure)
    @ccall libaravis.g_source_set_closure(source::Ptr{GSource}, closure::Ptr{GClosure})::Cvoid
end

"""
    g_source_set_dummy_callback(source)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_source_set_dummy_callback (GSource *source);
```
"""
function g_source_set_dummy_callback(source)
    @ccall libaravis.g_source_set_dummy_callback(source::Ptr{GSource})::Cvoid
end

const GTypeModule_autoptr = Ptr{GTypeModule}

const GTypeModule_listautoptr = Ptr{GList}

const GTypeModule_slistautoptr = Ptr{GSList}

const GTypeModule_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GTypeModule(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTypeModule, g_object_unref);
```
"""
function glib_autoptr_clear_GTypeModule(_ptr)
    @ccall libaravis.glib_autoptr_clear_GTypeModule(_ptr::Ptr{GTypeModule})::Cvoid
end

"""
    glib_autoptr_cleanup_GTypeModule(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTypeModule, g_object_unref);
```
"""
function glib_autoptr_cleanup_GTypeModule(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GTypeModule(_ptr::Ptr{Ptr{GTypeModule}})::Cvoid
end

"""
    glib_autoptr_destroy_GTypeModule(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTypeModule, g_object_unref);
```
"""
function glib_autoptr_destroy_GTypeModule(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GTypeModule(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GTypeModule(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTypeModule, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GTypeModule(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GTypeModule(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GTypeModule(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTypeModule, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GTypeModule(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GTypeModule(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GTypeModule(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTypeModule, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GTypeModule(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GTypeModule(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    g_type_module_use(_module)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gboolean g_type_module_use (GTypeModule *module);
```
"""
function g_type_module_use(_module)
    @ccall libaravis.g_type_module_use(_module::Ptr{GTypeModule})::gboolean
end

"""
    g_type_module_unuse(_module)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_type_module_unuse (GTypeModule *module);
```
"""
function g_type_module_unuse(_module)
    @ccall libaravis.g_type_module_unuse(_module::Ptr{GTypeModule})::Cvoid
end

"""
    g_type_module_set_name(_module, name)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_type_module_set_name (GTypeModule *module, const gchar *name);
```
"""
function g_type_module_set_name(_module, name)
    @ccall libaravis.g_type_module_set_name(_module::Ptr{GTypeModule}, name::Ptr{gchar})::Cvoid
end

"""
    g_type_module_register_enum(_module, name, const_static_values)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_type_module_register_enum (GTypeModule *module, const gchar *name, const GEnumValue *const_static_values);
```
"""
function g_type_module_register_enum(_module, name, const_static_values)
    @ccall libaravis.g_type_module_register_enum(_module::Ptr{GTypeModule}, name::Ptr{gchar}, const_static_values::Ptr{GEnumValue})::GType
end

"""
    g_type_module_register_flags(_module, name, const_static_values)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_type_module_register_flags (GTypeModule *module, const gchar *name, const GFlagsValue *const_static_values);
```
"""
function g_type_module_register_flags(_module, name, const_static_values)
    @ccall libaravis.g_type_module_register_flags(_module::Ptr{GTypeModule}, name::Ptr{gchar}, const_static_values::Ptr{GFlagsValue})::GType
end

"""
    g_type_plugin_use(plugin)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_type_plugin_use (GTypePlugin *plugin);
```
"""
function g_type_plugin_use(plugin)
    @ccall libaravis.g_type_plugin_use(plugin::Ptr{GTypePlugin})::Cvoid
end

"""
    g_type_plugin_unuse(plugin)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_type_plugin_unuse (GTypePlugin *plugin);
```
"""
function g_type_plugin_unuse(plugin)
    @ccall libaravis.g_type_plugin_unuse(plugin::Ptr{GTypePlugin})::Cvoid
end

"""
    g_type_plugin_complete_type_info(plugin, g_type, info, value_table)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_type_plugin_complete_type_info (GTypePlugin *plugin, GType g_type, GTypeInfo *info, GTypeValueTable *value_table);
```
"""
function g_type_plugin_complete_type_info(plugin, g_type, info, value_table)
    @ccall libaravis.g_type_plugin_complete_type_info(plugin::Ptr{GTypePlugin}, g_type::GType, info::Ptr{GTypeInfo}, value_table::Ptr{GTypeValueTable})::Cvoid
end

"""
    g_type_plugin_complete_interface_info(plugin, instance_type, interface_type, info)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_type_plugin_complete_interface_info (GTypePlugin *plugin, GType instance_type, GType interface_type, GInterfaceInfo *info);
```
"""
function g_type_plugin_complete_interface_info(plugin, instance_type, interface_type, info)
    @ccall libaravis.g_type_plugin_complete_interface_info(plugin::Ptr{GTypePlugin}, instance_type::GType, interface_type::GType, info::Ptr{GInterfaceInfo})::Cvoid
end

struct _GValueArray
    n_values::guint
    values::Ptr{GValue}
    n_prealloced::guint
end

const GValueArray = _GValueArray

"""
    g_value_array_get_nth(value_array, index_)

### Prototype
```c
GOBJECT_DEPRECATED_IN_2_32_FOR(GArray) GValue* g_value_array_get_nth (GValueArray *value_array, guint index_);
```
"""
function g_value_array_get_nth(value_array, index_)
    @ccall libaravis.g_value_array_get_nth(value_array::Ptr{GValueArray}, index_::guint)::Ptr{GValue}
end

"""
    g_value_array_new(n_prealloced)

### Prototype
```c
GOBJECT_DEPRECATED_IN_2_32_FOR(GArray) GValueArray* g_value_array_new (guint n_prealloced);
```
"""
function g_value_array_new(n_prealloced)
    @ccall libaravis.g_value_array_new(n_prealloced::guint)::Ptr{GValueArray}
end

"""
    g_value_array_free(value_array)

### Prototype
```c
GOBJECT_DEPRECATED_IN_2_32_FOR(GArray) void g_value_array_free (GValueArray *value_array);
```
"""
function g_value_array_free(value_array)
    @ccall libaravis.g_value_array_free(value_array::Ptr{GValueArray})::Cvoid
end

"""
    g_value_array_copy(value_array)

### Prototype
```c
GOBJECT_DEPRECATED_IN_2_32_FOR(GArray) GValueArray* g_value_array_copy (const GValueArray *value_array);
```
"""
function g_value_array_copy(value_array)
    @ccall libaravis.g_value_array_copy(value_array::Ptr{GValueArray})::Ptr{GValueArray}
end

"""
    g_value_array_prepend(value_array, value)

### Prototype
```c
GOBJECT_DEPRECATED_IN_2_32_FOR(GArray) GValueArray* g_value_array_prepend (GValueArray *value_array, const GValue *value);
```
"""
function g_value_array_prepend(value_array, value)
    @ccall libaravis.g_value_array_prepend(value_array::Ptr{GValueArray}, value::Ptr{GValue})::Ptr{GValueArray}
end

"""
    g_value_array_append(value_array, value)

### Prototype
```c
GOBJECT_DEPRECATED_IN_2_32_FOR(GArray) GValueArray* g_value_array_append (GValueArray *value_array, const GValue *value);
```
"""
function g_value_array_append(value_array, value)
    @ccall libaravis.g_value_array_append(value_array::Ptr{GValueArray}, value::Ptr{GValue})::Ptr{GValueArray}
end

"""
    g_value_array_insert(value_array, index_, value)

### Prototype
```c
GOBJECT_DEPRECATED_IN_2_32_FOR(GArray) GValueArray* g_value_array_insert (GValueArray *value_array, guint index_, const GValue *value);
```
"""
function g_value_array_insert(value_array, index_, value)
    @ccall libaravis.g_value_array_insert(value_array::Ptr{GValueArray}, index_::guint, value::Ptr{GValue})::Ptr{GValueArray}
end

"""
    g_value_array_remove(value_array, index_)

### Prototype
```c
GOBJECT_DEPRECATED_IN_2_32_FOR(GArray) GValueArray* g_value_array_remove (GValueArray *value_array, guint index_);
```
"""
function g_value_array_remove(value_array, index_)
    @ccall libaravis.g_value_array_remove(value_array::Ptr{GValueArray}, index_::guint)::Ptr{GValueArray}
end

"""
    g_value_array_sort(value_array, compare_func)

### Prototype
```c
GOBJECT_DEPRECATED_IN_2_32_FOR(GArray) GValueArray* g_value_array_sort (GValueArray *value_array, GCompareFunc compare_func);
```
"""
function g_value_array_sort(value_array, compare_func)
    @ccall libaravis.g_value_array_sort(value_array::Ptr{GValueArray}, compare_func::GCompareFunc)::Ptr{GValueArray}
end

"""
    g_value_array_sort_with_data(value_array, compare_func, user_data)

### Prototype
```c
GOBJECT_DEPRECATED_IN_2_32_FOR(GArray) GValueArray* g_value_array_sort_with_data (GValueArray *value_array, GCompareDataFunc compare_func, gpointer user_data);
```
"""
function g_value_array_sort_with_data(value_array, compare_func, user_data)
    @ccall libaravis.g_value_array_sort_with_data(value_array::Ptr{GValueArray}, compare_func::GCompareDataFunc, user_data::gpointer)::Ptr{GValueArray}
end

"""
    g_value_set_char(value, v_char)

### Prototype
```c
GOBJECT_DEPRECATED_IN_2_32_FOR(g_value_set_schar) void g_value_set_char (GValue *value, gchar v_char);
```
"""
function g_value_set_char(value, v_char)
    @ccall libaravis.g_value_set_char(value::Ptr{GValue}, v_char::gchar)::Cvoid
end

"""
    g_value_get_char(value)

### Prototype
```c
GOBJECT_DEPRECATED_IN_2_32_FOR(g_value_get_schar) gchar g_value_get_char (const GValue *value);
```
"""
function g_value_get_char(value)
    @ccall libaravis.g_value_get_char(value::Ptr{GValue})::gchar
end

"""
    g_value_set_schar(value, v_char)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_set_schar (GValue *value, gint8 v_char);
```
"""
function g_value_set_schar(value, v_char)
    @ccall libaravis.g_value_set_schar(value::Ptr{GValue}, v_char::gint8)::Cvoid
end

"""
    g_value_get_schar(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gint8 g_value_get_schar (const GValue *value);
```
"""
function g_value_get_schar(value)
    @ccall libaravis.g_value_get_schar(value::Ptr{GValue})::gint8
end

"""
    g_value_set_uchar(value, v_uchar)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_set_uchar (GValue *value, guchar v_uchar);
```
"""
function g_value_set_uchar(value, v_uchar)
    @ccall libaravis.g_value_set_uchar(value::Ptr{GValue}, v_uchar::guchar)::Cvoid
end

"""
    g_value_get_uchar(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL guchar g_value_get_uchar (const GValue *value);
```
"""
function g_value_get_uchar(value)
    @ccall libaravis.g_value_get_uchar(value::Ptr{GValue})::guchar
end

"""
    g_value_set_boolean(value, v_boolean)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_set_boolean (GValue *value, gboolean v_boolean);
```
"""
function g_value_set_boolean(value, v_boolean)
    @ccall libaravis.g_value_set_boolean(value::Ptr{GValue}, v_boolean::gboolean)::Cvoid
end

"""
    g_value_get_boolean(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gboolean g_value_get_boolean (const GValue *value);
```
"""
function g_value_get_boolean(value)
    @ccall libaravis.g_value_get_boolean(value::Ptr{GValue})::gboolean
end

"""
    g_value_set_int(value, v_int)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_set_int (GValue *value, gint v_int);
```
"""
function g_value_set_int(value, v_int)
    @ccall libaravis.g_value_set_int(value::Ptr{GValue}, v_int::gint)::Cvoid
end

"""
    g_value_get_int(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gint g_value_get_int (const GValue *value);
```
"""
function g_value_get_int(value)
    @ccall libaravis.g_value_get_int(value::Ptr{GValue})::gint
end

"""
    g_value_set_uint(value, v_uint)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_set_uint (GValue *value, guint v_uint);
```
"""
function g_value_set_uint(value, v_uint)
    @ccall libaravis.g_value_set_uint(value::Ptr{GValue}, v_uint::guint)::Cvoid
end

"""
    g_value_get_uint(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL guint g_value_get_uint (const GValue *value);
```
"""
function g_value_get_uint(value)
    @ccall libaravis.g_value_get_uint(value::Ptr{GValue})::guint
end

"""
    g_value_set_long(value, v_long)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_set_long (GValue *value, glong v_long);
```
"""
function g_value_set_long(value, v_long)
    @ccall libaravis.g_value_set_long(value::Ptr{GValue}, v_long::glong)::Cvoid
end

"""
    g_value_get_long(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL glong g_value_get_long (const GValue *value);
```
"""
function g_value_get_long(value)
    @ccall libaravis.g_value_get_long(value::Ptr{GValue})::glong
end

"""
    g_value_set_ulong(value, v_ulong)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_set_ulong (GValue *value, gulong v_ulong);
```
"""
function g_value_set_ulong(value, v_ulong)
    @ccall libaravis.g_value_set_ulong(value::Ptr{GValue}, v_ulong::gulong)::Cvoid
end

"""
    g_value_get_ulong(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gulong g_value_get_ulong (const GValue *value);
```
"""
function g_value_get_ulong(value)
    @ccall libaravis.g_value_get_ulong(value::Ptr{GValue})::gulong
end

"""
    g_value_set_int64(value, v_int64)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_set_int64 (GValue *value, gint64 v_int64);
```
"""
function g_value_set_int64(value, v_int64)
    @ccall libaravis.g_value_set_int64(value::Ptr{GValue}, v_int64::gint64)::Cvoid
end

"""
    g_value_get_int64(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gint64 g_value_get_int64 (const GValue *value);
```
"""
function g_value_get_int64(value)
    @ccall libaravis.g_value_get_int64(value::Ptr{GValue})::gint64
end

"""
    g_value_set_uint64(value, v_uint64)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_set_uint64 (GValue *value, guint64 v_uint64);
```
"""
function g_value_set_uint64(value, v_uint64)
    @ccall libaravis.g_value_set_uint64(value::Ptr{GValue}, v_uint64::guint64)::Cvoid
end

"""
    g_value_get_uint64(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL guint64 g_value_get_uint64 (const GValue *value);
```
"""
function g_value_get_uint64(value)
    @ccall libaravis.g_value_get_uint64(value::Ptr{GValue})::guint64
end

"""
    g_value_set_float(value, v_float)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_set_float (GValue *value, gfloat v_float);
```
"""
function g_value_set_float(value, v_float)
    @ccall libaravis.g_value_set_float(value::Ptr{GValue}, v_float::gfloat)::Cvoid
end

"""
    g_value_get_float(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gfloat g_value_get_float (const GValue *value);
```
"""
function g_value_get_float(value)
    @ccall libaravis.g_value_get_float(value::Ptr{GValue})::gfloat
end

"""
    g_value_set_double(value, v_double)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_set_double (GValue *value, gdouble v_double);
```
"""
function g_value_set_double(value, v_double)
    @ccall libaravis.g_value_set_double(value::Ptr{GValue}, v_double::gdouble)::Cvoid
end

"""
    g_value_get_double(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gdouble g_value_get_double (const GValue *value);
```
"""
function g_value_get_double(value)
    @ccall libaravis.g_value_get_double(value::Ptr{GValue})::gdouble
end

"""
    g_value_set_string(value, v_string)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_set_string (GValue *value, const gchar *v_string);
```
"""
function g_value_set_string(value, v_string)
    @ccall libaravis.g_value_set_string(value::Ptr{GValue}, v_string::Ptr{gchar})::Cvoid
end

"""
    g_value_set_static_string(value, v_string)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_set_static_string (GValue *value, const gchar *v_string);
```
"""
function g_value_set_static_string(value, v_string)
    @ccall libaravis.g_value_set_static_string(value::Ptr{GValue}, v_string::Ptr{gchar})::Cvoid
end

"""
    g_value_set_interned_string(value, v_string)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_66 void g_value_set_interned_string (GValue *value, const gchar *v_string);
```
"""
function g_value_set_interned_string(value, v_string)
    @ccall libaravis.g_value_set_interned_string(value::Ptr{GValue}, v_string::Ptr{gchar})::Cvoid
end

"""
    g_value_get_string(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL const gchar * g_value_get_string (const GValue *value);
```
"""
function g_value_get_string(value)
    @ccall libaravis.g_value_get_string(value::Ptr{GValue})::Ptr{gchar}
end

"""
    g_value_dup_string(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gchar* g_value_dup_string (const GValue *value);
```
"""
function g_value_dup_string(value)
    @ccall libaravis.g_value_dup_string(value::Ptr{GValue})::Ptr{gchar}
end

"""
    g_value_steal_string(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_2_80 gchar* g_value_steal_string (GValue *value);
```
"""
function g_value_steal_string(value)
    @ccall libaravis.g_value_steal_string(value::Ptr{GValue})::Ptr{gchar}
end

"""
    g_value_set_pointer(value, v_pointer)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_set_pointer (GValue *value, gpointer v_pointer);
```
"""
function g_value_set_pointer(value, v_pointer)
    @ccall libaravis.g_value_set_pointer(value::Ptr{GValue}, v_pointer::gpointer)::Cvoid
end

"""
    g_value_get_pointer(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gpointer g_value_get_pointer (const GValue *value);
```
"""
function g_value_get_pointer(value)
    @ccall libaravis.g_value_get_pointer(value::Ptr{GValue})::gpointer
end

"""
    g_value_set_gtype(value, v_gtype)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_set_gtype (GValue *value, GType v_gtype);
```
"""
function g_value_set_gtype(value, v_gtype)
    @ccall libaravis.g_value_set_gtype(value::Ptr{GValue}, v_gtype::GType)::Cvoid
end

"""
    g_value_get_gtype(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GType g_value_get_gtype (const GValue *value);
```
"""
function g_value_get_gtype(value)
    @ccall libaravis.g_value_get_gtype(value::Ptr{GValue})::GType
end

"""
    g_value_set_variant(value, variant)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_set_variant (GValue *value, GVariant *variant);
```
"""
function g_value_set_variant(value, variant)
    @ccall libaravis.g_value_set_variant(value::Ptr{GValue}, variant::Ptr{GVariant})::Cvoid
end

"""
    g_value_take_variant(value, variant)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_take_variant (GValue *value, GVariant *variant);
```
"""
function g_value_take_variant(value, variant)
    @ccall libaravis.g_value_take_variant(value::Ptr{GValue}, variant::Ptr{GVariant})::Cvoid
end

"""
    g_value_get_variant(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GVariant* g_value_get_variant (const GValue *value);
```
"""
function g_value_get_variant(value)
    @ccall libaravis.g_value_get_variant(value::Ptr{GValue})::Ptr{GVariant}
end

"""
    g_value_dup_variant(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL GVariant* g_value_dup_variant (const GValue *value);
```
"""
function g_value_dup_variant(value)
    @ccall libaravis.g_value_dup_variant(value::Ptr{GValue})::Ptr{GVariant}
end

"""
    g_strdup_value_contents(value)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL gchar* g_strdup_value_contents (const GValue *value);
```
"""
function g_strdup_value_contents(value)
    @ccall libaravis.g_strdup_value_contents(value::Ptr{GValue})::Ptr{gchar}
end

"""
    g_value_take_string(value, v_string)

### Prototype
```c
GOBJECT_AVAILABLE_IN_ALL void g_value_take_string (GValue *value, gchar *v_string);
```
"""
function g_value_take_string(value, v_string)
    @ccall libaravis.g_value_take_string(value::Ptr{GValue}, v_string::Ptr{gchar})::Cvoid
end

"""
    g_value_set_string_take_ownership(value, v_string)

### Prototype
```c
GOBJECT_DEPRECATED_FOR(g_value_take_string) void g_value_set_string_take_ownership (GValue *value, gchar *v_string);
```
"""
function g_value_set_string_take_ownership(value, v_string)
    @ccall libaravis.g_value_set_string_take_ownership(value::Ptr{GValue}, v_string::Ptr{gchar})::Cvoid
end

"""
[`gchararray`](@ref):

A C representable type name for G\\_TYPE\\_STRING.
"""
const gchararray = Ptr{gchar}

const GClosure_autoptr = Ptr{GClosure}

const GClosure_listautoptr = Ptr{GList}

const GClosure_slistautoptr = Ptr{GSList}

const GClosure_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GClosure(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GClosure, g_closure_unref);
```
"""
function glib_autoptr_clear_GClosure(_ptr)
    @ccall libaravis.glib_autoptr_clear_GClosure(_ptr::Ptr{GClosure})::Cvoid
end

"""
    glib_autoptr_cleanup_GClosure(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GClosure, g_closure_unref);
```
"""
function glib_autoptr_cleanup_GClosure(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GClosure(_ptr::Ptr{Ptr{GClosure}})::Cvoid
end

"""
    glib_autoptr_destroy_GClosure(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GClosure, g_closure_unref);
```
"""
function glib_autoptr_destroy_GClosure(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GClosure(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GClosure(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GClosure, g_closure_unref);
```
"""
function glib_listautoptr_cleanup_GClosure(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GClosure(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GClosure(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GClosure, g_closure_unref);
```
"""
function glib_slistautoptr_cleanup_GClosure(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GClosure(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GClosure(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GClosure, g_closure_unref);
```
"""
function glib_queueautoptr_cleanup_GClosure(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GClosure(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GEnumClass_autoptr = Ptr{GEnumClass}

const GEnumClass_listautoptr = Ptr{GList}

const GEnumClass_slistautoptr = Ptr{GSList}

const GEnumClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GEnumClass(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GEnumClass, g_type_class_unref);
```
"""
function glib_autoptr_clear_GEnumClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_GEnumClass(_ptr::Ptr{GEnumClass})::Cvoid
end

"""
    glib_autoptr_cleanup_GEnumClass(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GEnumClass, g_type_class_unref);
```
"""
function glib_autoptr_cleanup_GEnumClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GEnumClass(_ptr::Ptr{Ptr{GEnumClass}})::Cvoid
end

"""
    glib_autoptr_destroy_GEnumClass(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GEnumClass, g_type_class_unref);
```
"""
function glib_autoptr_destroy_GEnumClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GEnumClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GEnumClass(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GEnumClass, g_type_class_unref);
```
"""
function glib_listautoptr_cleanup_GEnumClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GEnumClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GEnumClass(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GEnumClass, g_type_class_unref);
```
"""
function glib_slistautoptr_cleanup_GEnumClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GEnumClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GEnumClass(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GEnumClass, g_type_class_unref);
```
"""
function glib_queueautoptr_cleanup_GEnumClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GEnumClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GFlagsClass_autoptr = Ptr{GFlagsClass}

const GFlagsClass_listautoptr = Ptr{GList}

const GFlagsClass_slistautoptr = Ptr{GSList}

const GFlagsClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GFlagsClass(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFlagsClass, g_type_class_unref);
```
"""
function glib_autoptr_clear_GFlagsClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_GFlagsClass(_ptr::Ptr{GFlagsClass})::Cvoid
end

"""
    glib_autoptr_cleanup_GFlagsClass(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFlagsClass, g_type_class_unref);
```
"""
function glib_autoptr_cleanup_GFlagsClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GFlagsClass(_ptr::Ptr{Ptr{GFlagsClass}})::Cvoid
end

"""
    glib_autoptr_destroy_GFlagsClass(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFlagsClass, g_type_class_unref);
```
"""
function glib_autoptr_destroy_GFlagsClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GFlagsClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GFlagsClass(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFlagsClass, g_type_class_unref);
```
"""
function glib_listautoptr_cleanup_GFlagsClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GFlagsClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GFlagsClass(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFlagsClass, g_type_class_unref);
```
"""
function glib_slistautoptr_cleanup_GFlagsClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GFlagsClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GFlagsClass(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFlagsClass, g_type_class_unref);
```
"""
function glib_queueautoptr_cleanup_GFlagsClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GFlagsClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GObject_autoptr = Ptr{GObject}

const GObject_listautoptr = Ptr{GList}

const GObject_slistautoptr = Ptr{GSList}

const GObject_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GObject(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GObject, g_object_unref);
```
"""
function glib_autoptr_clear_GObject(_ptr)
    @ccall libaravis.glib_autoptr_clear_GObject(_ptr::Ptr{GObject})::Cvoid
end

"""
    glib_autoptr_cleanup_GObject(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GObject, g_object_unref);
```
"""
function glib_autoptr_cleanup_GObject(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GObject(_ptr::Ptr{Ptr{GObject}})::Cvoid
end

"""
    glib_autoptr_destroy_GObject(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GObject, g_object_unref);
```
"""
function glib_autoptr_destroy_GObject(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GObject(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GObject(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GObject, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GObject(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GObject(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GObject(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GObject, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GObject(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GObject(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GObject(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GObject, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GObject(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GObject(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GInitiallyUnowned_autoptr = Ptr{GInitiallyUnowned}

const GInitiallyUnowned_listautoptr = Ptr{GList}

const GInitiallyUnowned_slistautoptr = Ptr{GSList}

const GInitiallyUnowned_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GInitiallyUnowned(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInitiallyUnowned, g_object_unref);
```
"""
function glib_autoptr_clear_GInitiallyUnowned(_ptr)
    @ccall libaravis.glib_autoptr_clear_GInitiallyUnowned(_ptr::Ptr{GInitiallyUnowned})::Cvoid
end

"""
    glib_autoptr_cleanup_GInitiallyUnowned(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInitiallyUnowned, g_object_unref);
```
"""
function glib_autoptr_cleanup_GInitiallyUnowned(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GInitiallyUnowned(_ptr::Ptr{Ptr{GInitiallyUnowned}})::Cvoid
end

"""
    glib_autoptr_destroy_GInitiallyUnowned(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInitiallyUnowned, g_object_unref);
```
"""
function glib_autoptr_destroy_GInitiallyUnowned(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GInitiallyUnowned(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GInitiallyUnowned(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInitiallyUnowned, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GInitiallyUnowned(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GInitiallyUnowned(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GInitiallyUnowned(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInitiallyUnowned, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GInitiallyUnowned(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GInitiallyUnowned(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GInitiallyUnowned(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInitiallyUnowned, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GInitiallyUnowned(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GInitiallyUnowned(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GParamSpec_autoptr = Ptr{GParamSpec}

const GParamSpec_listautoptr = Ptr{GList}

const GParamSpec_slistautoptr = Ptr{GSList}

const GParamSpec_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GParamSpec(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GParamSpec, g_param_spec_unref);
```
"""
function glib_autoptr_clear_GParamSpec(_ptr)
    @ccall libaravis.glib_autoptr_clear_GParamSpec(_ptr::Ptr{GParamSpec})::Cvoid
end

"""
    glib_autoptr_cleanup_GParamSpec(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GParamSpec, g_param_spec_unref);
```
"""
function glib_autoptr_cleanup_GParamSpec(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GParamSpec(_ptr::Ptr{Ptr{GParamSpec}})::Cvoid
end

"""
    glib_autoptr_destroy_GParamSpec(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GParamSpec, g_param_spec_unref);
```
"""
function glib_autoptr_destroy_GParamSpec(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GParamSpec(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GParamSpec(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GParamSpec, g_param_spec_unref);
```
"""
function glib_listautoptr_cleanup_GParamSpec(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GParamSpec(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GParamSpec(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GParamSpec, g_param_spec_unref);
```
"""
function glib_slistautoptr_cleanup_GParamSpec(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GParamSpec(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GParamSpec(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GParamSpec, g_param_spec_unref);
```
"""
function glib_queueautoptr_cleanup_GParamSpec(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GParamSpec(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GTypeClass_autoptr = Ptr{GTypeClass}

const GTypeClass_listautoptr = Ptr{GList}

const GTypeClass_slistautoptr = Ptr{GSList}

const GTypeClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GTypeClass(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTypeClass, g_type_class_unref);
```
"""
function glib_autoptr_clear_GTypeClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_GTypeClass(_ptr::Ptr{GTypeClass})::Cvoid
end

"""
    glib_autoptr_cleanup_GTypeClass(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTypeClass, g_type_class_unref);
```
"""
function glib_autoptr_cleanup_GTypeClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GTypeClass(_ptr::Ptr{Ptr{GTypeClass}})::Cvoid
end

"""
    glib_autoptr_destroy_GTypeClass(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTypeClass, g_type_class_unref);
```
"""
function glib_autoptr_destroy_GTypeClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GTypeClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GTypeClass(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTypeClass, g_type_class_unref);
```
"""
function glib_listautoptr_cleanup_GTypeClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GTypeClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GTypeClass(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTypeClass, g_type_class_unref);
```
"""
function glib_slistautoptr_cleanup_GTypeClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GTypeClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GTypeClass(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTypeClass, g_type_class_unref);
```
"""
function glib_queueautoptr_cleanup_GTypeClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GTypeClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    glib_auto_cleanup_GValue(_ptr)

### Prototype
```c
G_DEFINE_AUTO_CLEANUP_CLEAR_FUNC(GValue, g_value_unset);
```
"""
function glib_auto_cleanup_GValue(_ptr)
    @ccall libaravis.glib_auto_cleanup_GValue(_ptr::Ptr{GValue})::Cvoid
end

"""
    ArvAuto

[`ArvAuto`](@ref): \\_AUTO\\_OFF: manual setting \\_AUTO\\_ONCE: automatic setting done once, then returns to manual \\_AUTO\\_CONTINUOUS: setting is adjusted continuously
"""
@cenum ArvAuto::UInt32 begin
    ARV_AUTO_OFF = 0
    ARV_AUTO_ONCE = 1
    ARV_AUTO_CONTINUOUS = 2
end

"""
    arv_auto_to_string(value)

### Prototype
```c
ARV_API const char * arv_auto_to_string (ArvAuto value);
```
"""
function arv_auto_to_string(value)
    @ccall libaravis.arv_auto_to_string(value::ArvAuto)::Cstring
end

"""
    arv_auto_from_string(string)

### Prototype
```c
ARV_API ArvAuto arv_auto_from_string (const char *string);
```
"""
function arv_auto_from_string(string)
    @ccall libaravis.arv_auto_from_string(string::Cstring)::ArvAuto
end

"""
    ArvAcquisitionMode

[`ArvAcquisitionMode`](@ref): \\_ACQUISITION\\_MODE\\_CONTINUOUS: frames are captured continuously until stopped with the AcquisitionStop command. \\_ACQUISITION\\_MODE\\_SINGLE\\_FRAME: only one frame will be acquired \\_ACQUISITION\\_MODE\\_MULTI\\_FRAME: the number of frames specified by AcquisitionFrameCount is captured.
"""
@cenum ArvAcquisitionMode::UInt32 begin
    ARV_ACQUISITION_MODE_CONTINUOUS = 0
    ARV_ACQUISITION_MODE_SINGLE_FRAME = 1
    ARV_ACQUISITION_MODE_MULTI_FRAME = 2
end

"""
    arv_acquisition_mode_to_string(value)

### Prototype
```c
ARV_API const char * arv_acquisition_mode_to_string (ArvAcquisitionMode value);
```
"""
function arv_acquisition_mode_to_string(value)
    @ccall libaravis.arv_acquisition_mode_to_string(value::ArvAcquisitionMode)::Cstring
end

"""
    arv_acquisition_mode_from_string(string)

### Prototype
```c
ARV_API ArvAcquisitionMode arv_acquisition_mode_from_string (const char *string);
```
"""
function arv_acquisition_mode_from_string(string)
    @ccall libaravis.arv_acquisition_mode_from_string(string::Cstring)::ArvAcquisitionMode
end

"""
    ArvExposureMode

[`ArvExposureMode`](@ref): \\_EXPOSURE\\_MODE\\_OFF: disables the Exposure and let the shutter open. \\_EXPOSURE\\_MODE\\_TIMED: timed exposure. The exposure duration time is set using the ExposureTime or ExposureAuto features and the exposure starts with the FrameStart or LineStart. \\_EXPOSURE\\_MODE\\_TRIGGER\\_WIDTH: uses the width of the current Frame or Line trigger signal(s) pulse to control the exposure duration. Note that if the Frame or Line TriggerActivation is RisingEdge or LevelHigh, the exposure duration will be the time the trigger stays High. If TriggerActivation is FallingEdge or LevelLow, the exposure time will last as long as the trigger stays Low. \\_EXPOSURE\\_MODE\\_TRIGGER\\_CONTROLLED: uses one or more trigger signal(s) to control the exposure duration independently from the current Frame or Line triggers. See ExposureStart, ExposureEnd and ExposureActive of the TriggerSelector feature.
"""
@cenum ArvExposureMode::UInt32 begin
    ARV_EXPOSURE_MODE_OFF = 0
    ARV_EXPOSURE_MODE_TIMED = 1
    ARV_EXPOSURE_MODE_TRIGGER_WIDTH = 2
    ARV_EXPOSURE_MODE_TRIGGER_CONTROLLED = 3
end

"""
    arv_exposure_mode_to_string(value)

### Prototype
```c
ARV_API const char * arv_exposure_mode_to_string (ArvExposureMode value);
```
"""
function arv_exposure_mode_to_string(value)
    @ccall libaravis.arv_exposure_mode_to_string(value::ArvExposureMode)::Cstring
end

"""
    arv_exposure_mode_from_string(string)

### Prototype
```c
ARV_API ArvExposureMode arv_exposure_mode_from_string (const char *string);
```
"""
function arv_exposure_mode_from_string(string)
    @ccall libaravis.arv_exposure_mode_from_string(string::Cstring)::ArvExposureMode
end

"""
    ArvUvUsbMode

[`ArvUvUsbMode`](@ref): \\_UV\\_USB\\_MODE\\_SYNC: utilize libusb synchronous device I/O API \\_UV\\_USB\\_MODE\\_ASYNC: utilize libusb asynchronous device I/O API \\_UV\\_USB\\_MODE\\_DEFAULT: default usb mode
"""
@cenum ArvUvUsbMode::UInt32 begin
    ARV_UV_USB_MODE_SYNC = 0
    ARV_UV_USB_MODE_ASYNC = 1
    ARV_UV_USB_MODE_DEFAULT = 1
end

struct _ArvCamera
    parent_instance::GObject
end

const ArvCamera = _ArvCamera

const _ArvEvaluator = Cvoid

const ArvEvaluator = _ArvEvaluator

struct _ArvDomNode
    parent_instance::GObject
end

const ArvDomNode = _ArvDomNode

struct _ArvDomNodeList
    parent_instance::GObject
end

const ArvDomNodeList = _ArvDomNodeList

struct _ArvDomNamedNodeMap
    parent_instance::GObject
end

const ArvDomNamedNodeMap = _ArvDomNamedNodeMap

struct _ArvDomElement
    parent_instance::ArvDomNode
end

const ArvDomElement = _ArvDomElement

struct _ArvDomDocument
    parent_instance::ArvDomNode
end

const ArvDomDocument = _ArvDomDocument

struct _ArvDomDocumentFragment
    parent_instance::ArvDomNode
end

const ArvDomDocumentFragment = _ArvDomDocumentFragment

struct _ArvDomCharacterData
    parent_instance::ArvDomNode
end

const ArvDomCharacterData = _ArvDomCharacterData

struct _ArvDomText
    parent_instance::ArvDomCharacterData
end

const ArvDomText = _ArvDomText

const _ArvGc = Cvoid

const ArvGc = _ArvGc

struct _ArvGcNode
    parent_instance::ArvDomElement
end

const ArvGcNode = _ArvGcNode

struct _ArvGcPropertyNode
    parent_instance::ArvGcNode
end

const ArvGcPropertyNode = _ArvGcPropertyNode

const _ArvGcIndexNode = Cvoid

const ArvGcIndexNode = _ArvGcIndexNode

const _ArvGcValueIndexedNode = Cvoid

const ArvGcValueIndexedNode = _ArvGcValueIndexedNode

const _ArvGcInvalidatorNode = Cvoid

const ArvGcInvalidatorNode = _ArvGcInvalidatorNode

struct _ArvGcFeatureNode
    parent_instance::ArvGcNode
end

const ArvGcFeatureNode = _ArvGcFeatureNode

const _ArvGcRegisterDescriptionNode = Cvoid

const ArvGcRegisterDescriptionNode = _ArvGcRegisterDescriptionNode

const _ArvGcGroupNode = Cvoid

const ArvGcGroupNode = _ArvGcGroupNode

const _ArvGcCategory = Cvoid

const ArvGcCategory = _ArvGcCategory

const _ArvGcBoolean = Cvoid

const ArvGcBoolean = _ArvGcBoolean

const _ArvGcEnumeration = Cvoid

const ArvGcEnumeration = _ArvGcEnumeration

const _ArvGcEnumEntry = Cvoid

const ArvGcEnumEntry = _ArvGcEnumEntry

const _ArvGcIntegerNode = Cvoid

const ArvGcIntegerNode = _ArvGcIntegerNode

const _ArvGcFloatNode = Cvoid

const ArvGcFloatNode = _ArvGcFloatNode

struct _ArvGcRegisterNode
    parent_instance::ArvGcFeatureNode
end

const ArvGcRegisterNode = _ArvGcRegisterNode

const _ArvGcStructEntryNode = Cvoid

const ArvGcStructEntryNode = _ArvGcStructEntryNode

const _ArvGcCommand = Cvoid

const ArvGcCommand = _ArvGcCommand

struct _ArvGcSwissKnife
    parent_instance::ArvGcFeatureNode
end

const ArvGcSwissKnife = _ArvGcSwissKnife

struct _ArvGcConverter
    parent_instance::ArvGcFeatureNode
end

const ArvGcConverter = _ArvGcConverter

const _ArvGcConverterNode = Cvoid

const ArvGcConverterNode = _ArvGcConverterNode

const _ArvGcIntConverterNode = Cvoid

const ArvGcIntConverterNode = _ArvGcIntConverterNode

const _ArvGcPort = Cvoid

const ArvGcPort = _ArvGcPort

const _ArvGcRegister = Cvoid

const ArvGcRegister = _ArvGcRegister

const _ArvGcInteger = Cvoid

const ArvGcInteger = _ArvGcInteger

const _ArvGcFloat = Cvoid

const ArvGcFloat = _ArvGcFloat

const _ArvGcString = Cvoid

const ArvGcString = _ArvGcString

const _ArvGcSelector = Cvoid

const ArvGcSelector = _ArvGcSelector

struct _ArvInterface
    parent_instance::GObject
end

const ArvInterface = _ArvInterface

struct _ArvDevice
    parent_instance::GObject
end

const ArvDevice = _ArvDevice

struct _ArvStream
    parent_instance::GObject
end

const ArvStream = _ArvStream

const _ArvChunkParser = Cvoid

const ArvChunkParser = _ArvChunkParser

const _ArvGvInterface = Cvoid

const ArvGvInterface = _ArvGvInterface

const _ArvGvDevice = Cvoid

const ArvGvDevice = _ArvGvDevice

const _ArvGvStream = Cvoid

const ArvGvStream = _ArvGvStream

const _ArvUvInterface = Cvoid

const ArvUvInterface = _ArvUvInterface

const _ArvUvDevice = Cvoid

const ArvUvDevice = _ArvUvDevice

const _ArvUvStream = Cvoid

const ArvUvStream = _ArvUvStream

const _ArvFakeCamera = Cvoid

const ArvFakeCamera = _ArvFakeCamera

const _ArvGvFakeCamera = Cvoid

const ArvGvFakeCamera = _ArvGvFakeCamera

const _ArvZip = Cvoid

const ArvZip = _ArvZip

const _ArvZipFile = Cvoid

const ArvZipFile = _ArvZipFile

"""
    ArvBufferStatus

[`ArvBufferStatus`](@ref): \\_BUFFER\\_STATUS\\_UNKNOWN: unknown status \\_BUFFER\\_STATUS\\_SUCCESS: the buffer contains a valid image \\_BUFFER\\_STATUS\\_CLEARED: the buffer is cleared \\_BUFFER\\_STATUS\\_TIMEOUT: timeout was reached before all packets are received \\_BUFFER\\_STATUS\\_MISSING\\_PACKETS: stream has missing packets \\_BUFFER\\_STATUS\\_WRONG\\_PACKET\\_ID: stream has packet with wrong id \\_BUFFER\\_STATUS\\_SIZE\\_MISMATCH: the received image didn't fit in the buffer data space \\_BUFFER\\_STATUS\\_FILLING: the image is currently being filled \\_BUFFER\\_STATUS\\_ABORTED: the filling was aborted before completion \\_BUFFER\\_STATUS\\_PAYLOAD\\_NOT\\_SUPPORTED: payload not yet supported
"""
@cenum ArvBufferStatus::Int32 begin
    ARV_BUFFER_STATUS_UNKNOWN = -1
    ARV_BUFFER_STATUS_SUCCESS = 0
    ARV_BUFFER_STATUS_CLEARED = 1
    ARV_BUFFER_STATUS_TIMEOUT = 2
    ARV_BUFFER_STATUS_MISSING_PACKETS = 3
    ARV_BUFFER_STATUS_WRONG_PACKET_ID = 4
    ARV_BUFFER_STATUS_SIZE_MISMATCH = 5
    ARV_BUFFER_STATUS_FILLING = 6
    ARV_BUFFER_STATUS_ABORTED = 7
    ARV_BUFFER_STATUS_PAYLOAD_NOT_SUPPORTED = 8
end

"""
    ArvBufferPayloadType

[`ArvBufferPayloadType`](@ref): \\_BUFFER\\_PAYLOAD\\_TYPE\\_UNKNOWN: unknown payload type \\_BUFFER\\_PAYLOAD\\_TYPE\\_NO\\_DATA: no data \\_BUFFER\\_PAYLOAD\\_TYPE\\_IMAGE: image data \\_BUFFER\\_PAYLOAD\\_TYPE\\_RAWDATA: raw data (not supported) \\_BUFFER\\_PAYLOAD\\_TYPE\\_FILE: file (not supported) \\_BUFFER\\_PAYLOAD\\_TYPE\\_CHUNK\\_DATA: chunk data (not supported) \\_BUFFER\\_PAYLOAD\\_TYPE\\_EXTENDED\\_CHUNK\\_DATA: extended chunk data \\_BUFFER\\_PAYLOAD\\_TYPE\\_JPEG: JPEG data (not supported) \\_BUFFER\\_PAYLOAD\\_TYPE\\_JPEG2000: JPEG2000 data (not supported) \\_BUFFER\\_PAYLOAD\\_TYPE\\_H264: h264 data (not supported) \\_BUFFER\\_PAYLOAD\\_TYPE\\_MULTIZONE\\_IMAGE: multizone image (not supported) \\_BUFFER\\_PAYLOAD\\_TYPE\\_MULTIPART: multipart data
"""
@cenum ArvBufferPayloadType::Int32 begin
    ARV_BUFFER_PAYLOAD_TYPE_UNKNOWN = -1
    ARV_BUFFER_PAYLOAD_TYPE_NO_DATA = 0
    ARV_BUFFER_PAYLOAD_TYPE_IMAGE = 1
    ARV_BUFFER_PAYLOAD_TYPE_RAWDATA = 2
    ARV_BUFFER_PAYLOAD_TYPE_FILE = 3
    ARV_BUFFER_PAYLOAD_TYPE_CHUNK_DATA = 4
    ARV_BUFFER_PAYLOAD_TYPE_EXTENDED_CHUNK_DATA = 5
    ARV_BUFFER_PAYLOAD_TYPE_JPEG = 6
    ARV_BUFFER_PAYLOAD_TYPE_JPEG2000 = 7
    ARV_BUFFER_PAYLOAD_TYPE_H264 = 8
    ARV_BUFFER_PAYLOAD_TYPE_MULTIZONE_IMAGE = 9
    ARV_BUFFER_PAYLOAD_TYPE_MULTIPART = 10
    ARV_BUFFER_PAYLOAD_TYPE_GENDC_CONTAINER = 11
    ARV_BUFFER_PAYLOAD_TYPE_GENDC_COMPONENT_DATA = 12
end

@cenum ArvBufferPartDataType::Int32 begin
    ARV_BUFFER_PART_DATA_TYPE_UNKNOWN = -1
    ARV_BUFFER_PART_DATA_TYPE_2D_IMAGE = 1
    ARV_BUFFER_PART_DATA_TYPE_2D_PLANE_BIPLANAR = 2
    ARV_BUFFER_PART_DATA_TYPE_2D_PLANE_TRIPLANAR = 3
    ARV_BUFFER_PART_DATA_TYPE_2D_PLANE_QUADPLANAR = 4
    ARV_BUFFER_PART_DATA_TYPE_3D_IMAGE = 5
    ARV_BUFFER_PART_DATA_TYPE_3D_PLANE_BIPLANAR = 6
    ARV_BUFFER_PART_DATA_TYPE_3D_PLANE_TRIPLANAR = 7
    ARV_BUFFER_PART_DATA_TYPE_3D_PLANE_QUADPLANAR = 8
    ARV_BUFFER_PART_DATA_TYPE_CONFIDENCE_MAP = 9
    ARV_BUFFER_PART_DATA_TYPE_CHUNK_DATA = 10
    ARV_BUFFER_PART_DATA_TYPE_JPEG = 11
    ARV_BUFFER_PART_DATA_TYPE_JPEG2000 = 12
    ARV_BUFFER_PART_DATA_TYPE_DEVICE_SPECIFIC = 32768
end

const _ArvBuffer = Cvoid

const ArvBuffer = _ArvBuffer

struct ArvBufferClass
    parent_class::GObjectClass
end

const ArvBuffer_autoptr = Ptr{ArvBuffer}

const ArvBuffer_listautoptr = Ptr{GList}

const ArvBuffer_slistautoptr = Ptr{GSList}

const ArvBuffer_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvBuffer(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvBuffer, arv_buffer, ARV, BUFFER, GObject);
```
"""
function glib_autoptr_clear_ArvBuffer(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvBuffer(_ptr::Ptr{ArvBuffer})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvBuffer(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvBuffer, arv_buffer, ARV, BUFFER, GObject);
```
"""
function glib_autoptr_cleanup_ArvBuffer(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvBuffer(_ptr::Ptr{Ptr{ArvBuffer}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvBuffer(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvBuffer, arv_buffer, ARV, BUFFER, GObject);
```
"""
function glib_autoptr_destroy_ArvBuffer(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvBuffer(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvBuffer(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvBuffer, arv_buffer, ARV, BUFFER, GObject);
```
"""
function glib_listautoptr_cleanup_ArvBuffer(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvBuffer(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvBuffer(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvBuffer, arv_buffer, ARV, BUFFER, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvBuffer(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvBuffer(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvBuffer(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvBuffer, arv_buffer, ARV, BUFFER, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvBuffer(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvBuffer(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvBufferClass_autoptr = Ptr{ArvBufferClass}

const ArvBufferClass_listautoptr = Ptr{GList}

const ArvBufferClass_slistautoptr = Ptr{GSList}

const ArvBufferClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvBufferClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvBuffer, arv_buffer, ARV, BUFFER, GObject);
```
"""
function glib_autoptr_clear_ArvBufferClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvBufferClass(_ptr::Ptr{ArvBufferClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvBufferClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvBuffer, arv_buffer, ARV, BUFFER, GObject);
```
"""
function glib_autoptr_cleanup_ArvBufferClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvBufferClass(_ptr::Ptr{Ptr{ArvBufferClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvBufferClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvBuffer, arv_buffer, ARV, BUFFER, GObject);
```
"""
function glib_autoptr_destroy_ArvBufferClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvBufferClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvBufferClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvBuffer, arv_buffer, ARV, BUFFER, GObject);
```
"""
function glib_listautoptr_cleanup_ArvBufferClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvBufferClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvBufferClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvBuffer, arv_buffer, ARV, BUFFER, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvBufferClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvBufferClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvBufferClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvBuffer, arv_buffer, ARV, BUFFER, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvBufferClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvBufferClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_BUFFER(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvBuffer, arv_buffer, ARV, BUFFER, GObject);
```
"""
function ARV_BUFFER(ptr)
    @ccall libaravis.ARV_BUFFER(ptr::gpointer)::Ptr{ArvBuffer}
end

"""
    ARV_IS_BUFFER(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvBuffer, arv_buffer, ARV, BUFFER, GObject);
```
"""
function ARV_IS_BUFFER(ptr)
    @ccall libaravis.ARV_IS_BUFFER(ptr::gpointer)::gboolean
end

"""
    arv_buffer_new_allocate(size)

### Prototype
```c
ARV_API ArvBuffer * arv_buffer_new_allocate (size_t size);
```
"""
function arv_buffer_new_allocate(size)
    @ccall libaravis.arv_buffer_new_allocate(size::Csize_t)::Ptr{ArvBuffer}
end

"""
    arv_buffer_new(size, preallocated)

### Prototype
```c
ARV_API ArvBuffer * arv_buffer_new (size_t size, void *preallocated);
```
"""
function arv_buffer_new(size, preallocated)
    @ccall libaravis.arv_buffer_new(size::Csize_t, preallocated::Ptr{Cvoid})::Ptr{ArvBuffer}
end

"""
    arv_buffer_new_full(size, preallocated, user_data, user_data_destroy_func)

### Prototype
```c
ARV_API ArvBuffer * arv_buffer_new_full (size_t size, void *preallocated, void *user_data, GDestroyNotify user_data_destroy_func);
```
"""
function arv_buffer_new_full(size, preallocated, user_data, user_data_destroy_func)
    @ccall libaravis.arv_buffer_new_full(size::Csize_t, preallocated::Ptr{Cvoid}, user_data::Ptr{Cvoid}, user_data_destroy_func::GDestroyNotify)::Ptr{ArvBuffer}
end

"""
    arv_buffer_get_status(buffer)

### Prototype
```c
ARV_API ArvBufferStatus arv_buffer_get_status (ArvBuffer *buffer);
```
"""
function arv_buffer_get_status(buffer)
    @ccall libaravis.arv_buffer_get_status(buffer::Ptr{ArvBuffer})::ArvBufferStatus
end

"""
    arv_buffer_get_user_data(buffer)

### Prototype
```c
ARV_API const void * arv_buffer_get_user_data (ArvBuffer *buffer);
```
"""
function arv_buffer_get_user_data(buffer)
    @ccall libaravis.arv_buffer_get_user_data(buffer::Ptr{ArvBuffer})::Ptr{Cvoid}
end

"""
    arv_buffer_get_payload_type(buffer)

### Prototype
```c
ARV_API ArvBufferPayloadType arv_buffer_get_payload_type (ArvBuffer *buffer);
```
"""
function arv_buffer_get_payload_type(buffer)
    @ccall libaravis.arv_buffer_get_payload_type(buffer::Ptr{ArvBuffer})::ArvBufferPayloadType
end

"""
    arv_buffer_get_timestamp(buffer)

### Prototype
```c
ARV_API guint64 arv_buffer_get_timestamp (ArvBuffer *buffer);
```
"""
function arv_buffer_get_timestamp(buffer)
    @ccall libaravis.arv_buffer_get_timestamp(buffer::Ptr{ArvBuffer})::guint64
end

"""
    arv_buffer_set_timestamp(buffer, timestamp_ns)

### Prototype
```c
ARV_API void arv_buffer_set_timestamp (ArvBuffer *buffer, guint64 timestamp_ns);
```
"""
function arv_buffer_set_timestamp(buffer, timestamp_ns)
    @ccall libaravis.arv_buffer_set_timestamp(buffer::Ptr{ArvBuffer}, timestamp_ns::guint64)::Cvoid
end

"""
    arv_buffer_get_system_timestamp(buffer)

### Prototype
```c
ARV_API guint64 arv_buffer_get_system_timestamp (ArvBuffer *buffer);
```
"""
function arv_buffer_get_system_timestamp(buffer)
    @ccall libaravis.arv_buffer_get_system_timestamp(buffer::Ptr{ArvBuffer})::guint64
end

"""
    arv_buffer_set_system_timestamp(buffer, timestamp_ns)

### Prototype
```c
ARV_API void arv_buffer_set_system_timestamp (ArvBuffer *buffer, guint64 timestamp_ns);
```
"""
function arv_buffer_set_system_timestamp(buffer, timestamp_ns)
    @ccall libaravis.arv_buffer_set_system_timestamp(buffer::Ptr{ArvBuffer}, timestamp_ns::guint64)::Cvoid
end

"""
    arv_buffer_set_frame_id(buffer, frame_id)

### Prototype
```c
ARV_API void arv_buffer_set_frame_id (ArvBuffer *buffer, guint64 frame_id);
```
"""
function arv_buffer_set_frame_id(buffer, frame_id)
    @ccall libaravis.arv_buffer_set_frame_id(buffer::Ptr{ArvBuffer}, frame_id::guint64)::Cvoid
end

"""
    arv_buffer_get_frame_id(buffer)

### Prototype
```c
ARV_API guint64 arv_buffer_get_frame_id (ArvBuffer *buffer);
```
"""
function arv_buffer_get_frame_id(buffer)
    @ccall libaravis.arv_buffer_get_frame_id(buffer::Ptr{ArvBuffer})::guint64
end

"""
    arv_buffer_get_data(buffer, size)

### Prototype
```c
ARV_API const void * arv_buffer_get_data (ArvBuffer *buffer, size_t *size);
```
"""
function arv_buffer_get_data(buffer, size)
    @ccall libaravis.arv_buffer_get_data(buffer::Ptr{ArvBuffer}, size::Ptr{Csize_t})::Ptr{Cvoid}
end

"""
    arv_buffer_get_n_parts(buffer)

### Prototype
```c
ARV_API guint arv_buffer_get_n_parts (ArvBuffer *buffer);
```
"""
function arv_buffer_get_n_parts(buffer)
    @ccall libaravis.arv_buffer_get_n_parts(buffer::Ptr{ArvBuffer})::guint
end

"""
    arv_buffer_find_component(buffer, component_id)

### Prototype
```c
ARV_API gint arv_buffer_find_component (ArvBuffer *buffer, guint component_id);
```
"""
function arv_buffer_find_component(buffer, component_id)
    @ccall libaravis.arv_buffer_find_component(buffer::Ptr{ArvBuffer}, component_id::guint)::gint
end

"""
    arv_buffer_get_part_data(buffer, part_id, size)

### Prototype
```c
ARV_API const void * arv_buffer_get_part_data (ArvBuffer *buffer, guint part_id, size_t *size);
```
"""
function arv_buffer_get_part_data(buffer, part_id, size)
    @ccall libaravis.arv_buffer_get_part_data(buffer::Ptr{ArvBuffer}, part_id::guint, size::Ptr{Csize_t})::Ptr{Cvoid}
end

"""
    arv_buffer_get_part_component_id(buffer, part_id)

### Prototype
```c
ARV_API guint arv_buffer_get_part_component_id (ArvBuffer *buffer, guint part_id);
```
"""
function arv_buffer_get_part_component_id(buffer, part_id)
    @ccall libaravis.arv_buffer_get_part_component_id(buffer::Ptr{ArvBuffer}, part_id::guint)::guint
end

"""
    arv_buffer_get_part_data_type(buffer, part_id)

### Prototype
```c
ARV_API ArvBufferPartDataType arv_buffer_get_part_data_type (ArvBuffer *buffer, guint part_id);
```
"""
function arv_buffer_get_part_data_type(buffer, part_id)
    @ccall libaravis.arv_buffer_get_part_data_type(buffer::Ptr{ArvBuffer}, part_id::guint)::ArvBufferPartDataType
end

"""
    arv_buffer_get_part_pixel_format(buffer, part_id)

### Prototype
```c
ARV_API ArvPixelFormat arv_buffer_get_part_pixel_format (ArvBuffer *buffer, guint part_id);
```
"""
function arv_buffer_get_part_pixel_format(buffer, part_id)
    @ccall libaravis.arv_buffer_get_part_pixel_format(buffer::Ptr{ArvBuffer}, part_id::guint)::ArvPixelFormat
end

"""
    arv_buffer_get_part_region(buffer, part_id, x, y, width, height)

### Prototype
```c
ARV_API void arv_buffer_get_part_region (ArvBuffer *buffer, guint part_id, gint *x, gint *y, gint *width, gint *height);
```
"""
function arv_buffer_get_part_region(buffer, part_id, x, y, width, height)
    @ccall libaravis.arv_buffer_get_part_region(buffer::Ptr{ArvBuffer}, part_id::guint, x::Ptr{gint}, y::Ptr{gint}, width::Ptr{gint}, height::Ptr{gint})::Cvoid
end

"""
    arv_buffer_get_part_padding(buffer, part_id, x_padding, y_padding)

### Prototype
```c
ARV_API void arv_buffer_get_part_padding (ArvBuffer *buffer, guint part_id, gint *x_padding, gint *y_padding);
```
"""
function arv_buffer_get_part_padding(buffer, part_id, x_padding, y_padding)
    @ccall libaravis.arv_buffer_get_part_padding(buffer::Ptr{ArvBuffer}, part_id::guint, x_padding::Ptr{gint}, y_padding::Ptr{gint})::Cvoid
end

"""
    arv_buffer_get_part_width(buffer, part_id)

### Prototype
```c
ARV_API gint arv_buffer_get_part_width (ArvBuffer *buffer, guint part_id);
```
"""
function arv_buffer_get_part_width(buffer, part_id)
    @ccall libaravis.arv_buffer_get_part_width(buffer::Ptr{ArvBuffer}, part_id::guint)::gint
end

"""
    arv_buffer_get_part_height(buffer, part_id)

### Prototype
```c
ARV_API gint arv_buffer_get_part_height (ArvBuffer *buffer, guint part_id);
```
"""
function arv_buffer_get_part_height(buffer, part_id)
    @ccall libaravis.arv_buffer_get_part_height(buffer::Ptr{ArvBuffer}, part_id::guint)::gint
end

"""
    arv_buffer_get_part_x(buffer, part_id)

### Prototype
```c
ARV_API gint arv_buffer_get_part_x (ArvBuffer *buffer, guint part_id);
```
"""
function arv_buffer_get_part_x(buffer, part_id)
    @ccall libaravis.arv_buffer_get_part_x(buffer::Ptr{ArvBuffer}, part_id::guint)::gint
end

"""
    arv_buffer_get_part_y(buffer, part_id)

### Prototype
```c
ARV_API gint arv_buffer_get_part_y (ArvBuffer *buffer, guint part_id);
```
"""
function arv_buffer_get_part_y(buffer, part_id)
    @ccall libaravis.arv_buffer_get_part_y(buffer::Ptr{ArvBuffer}, part_id::guint)::gint
end

"""
    arv_buffer_get_image_data(buffer, size)

### Prototype
```c
ARV_API const void * arv_buffer_get_image_data (ArvBuffer *buffer, size_t *size);
```
"""
function arv_buffer_get_image_data(buffer, size)
    @ccall libaravis.arv_buffer_get_image_data(buffer::Ptr{ArvBuffer}, size::Ptr{Csize_t})::Ptr{Cvoid}
end

"""
    arv_buffer_get_image_pixel_format(buffer)

### Prototype
```c
ARV_API ArvPixelFormat arv_buffer_get_image_pixel_format (ArvBuffer *buffer);
```
"""
function arv_buffer_get_image_pixel_format(buffer)
    @ccall libaravis.arv_buffer_get_image_pixel_format(buffer::Ptr{ArvBuffer})::ArvPixelFormat
end

"""
    arv_buffer_get_image_region(buffer, x, y, width, height)

### Prototype
```c
ARV_API void arv_buffer_get_image_region (ArvBuffer *buffer, gint *x, gint *y, gint *width, gint *height);
```
"""
function arv_buffer_get_image_region(buffer, x, y, width, height)
    @ccall libaravis.arv_buffer_get_image_region(buffer::Ptr{ArvBuffer}, x::Ptr{gint}, y::Ptr{gint}, width::Ptr{gint}, height::Ptr{gint})::Cvoid
end

"""
    arv_buffer_get_image_padding(buffer, x_padding, y_padding)

### Prototype
```c
ARV_API void arv_buffer_get_image_padding (ArvBuffer *buffer, gint *x_padding, gint *y_padding);
```
"""
function arv_buffer_get_image_padding(buffer, x_padding, y_padding)
    @ccall libaravis.arv_buffer_get_image_padding(buffer::Ptr{ArvBuffer}, x_padding::Ptr{gint}, y_padding::Ptr{gint})::Cvoid
end

"""
    arv_buffer_get_image_width(buffer)

### Prototype
```c
ARV_API gint arv_buffer_get_image_width (ArvBuffer *buffer);
```
"""
function arv_buffer_get_image_width(buffer)
    @ccall libaravis.arv_buffer_get_image_width(buffer::Ptr{ArvBuffer})::gint
end

"""
    arv_buffer_get_image_height(buffer)

### Prototype
```c
ARV_API gint arv_buffer_get_image_height (ArvBuffer *buffer);
```
"""
function arv_buffer_get_image_height(buffer)
    @ccall libaravis.arv_buffer_get_image_height(buffer::Ptr{ArvBuffer})::gint
end

"""
    arv_buffer_get_image_x(buffer)

### Prototype
```c
ARV_API gint arv_buffer_get_image_x (ArvBuffer *buffer);
```
"""
function arv_buffer_get_image_x(buffer)
    @ccall libaravis.arv_buffer_get_image_x(buffer::Ptr{ArvBuffer})::gint
end

"""
    arv_buffer_get_image_y(buffer)

### Prototype
```c
ARV_API gint arv_buffer_get_image_y (ArvBuffer *buffer);
```
"""
function arv_buffer_get_image_y(buffer)
    @ccall libaravis.arv_buffer_get_image_y(buffer::Ptr{ArvBuffer})::gint
end

"""
    arv_buffer_has_chunks(buffer)

### Prototype
```c
ARV_API gboolean arv_buffer_has_chunks (ArvBuffer *buffer);
```
"""
function arv_buffer_has_chunks(buffer)
    @ccall libaravis.arv_buffer_has_chunks(buffer::Ptr{ArvBuffer})::gboolean
end

"""
    arv_buffer_get_chunk_data(buffer, chunk_id, size)

### Prototype
```c
ARV_API const void * arv_buffer_get_chunk_data (ArvBuffer *buffer, guint64 chunk_id, size_t *size);
```
"""
function arv_buffer_get_chunk_data(buffer, chunk_id, size)
    @ccall libaravis.arv_buffer_get_chunk_data(buffer::Ptr{ArvBuffer}, chunk_id::guint64, size::Ptr{Csize_t})::Ptr{Cvoid}
end

"""
    arv_buffer_has_gendc(buffer)

### Prototype
```c
ARV_API gboolean arv_buffer_has_gendc (ArvBuffer *buffer);
```
"""
function arv_buffer_has_gendc(buffer)
    @ccall libaravis.arv_buffer_has_gendc(buffer::Ptr{ArvBuffer})::gboolean
end

"""
    arv_buffer_get_gendc_data(buffer, size)

### Prototype
```c
ARV_API const void * arv_buffer_get_gendc_data (ArvBuffer *buffer, size_t *size);
```
"""
function arv_buffer_get_gendc_data(buffer, size)
    @ccall libaravis.arv_buffer_get_gendc_data(buffer::Ptr{ArvBuffer}, size::Ptr{Csize_t})::Ptr{Cvoid}
end

"""
    arv_buffer_get_gendc_descriptor(buffer, size)

### Prototype
```c
ARV_API const void * arv_buffer_get_gendc_descriptor (ArvBuffer *buffer, size_t *size);
```
"""
function arv_buffer_get_gendc_descriptor(buffer, size)
    @ccall libaravis.arv_buffer_get_gendc_descriptor(buffer::Ptr{ArvBuffer}, size::Ptr{Csize_t})::Ptr{Cvoid}
end

"""
    ArvStreamCallbackType

[`ArvStreamCallbackType`](@ref): \\_STREAM\\_CALLBACK\\_TYPE\\_INIT: thread initialization, happens once \\_STREAM\\_CALLBACK\\_TYPE\\_EXIT: thread end, happens once \\_STREAM\\_CALLBACK\\_TYPE\\_START\\_BUFFER: buffer filling start, happens at each frame \\_STREAM\\_CALLBACK\\_TYPE\\_BUFFER\\_DONE: buffer filled, happens at each frame

Describes when the reason the stream callback is called. You are probably more interested in \\_STREAM\\_CALLBACK\\_TYPE\\_INIT and \\_STREAM\\_CALLBACK\\_TYPE\\_BUFFER\\_DONE.
"""
@cenum ArvStreamCallbackType::UInt32 begin
    ARV_STREAM_CALLBACK_TYPE_INIT = 0
    ARV_STREAM_CALLBACK_TYPE_EXIT = 1
    ARV_STREAM_CALLBACK_TYPE_START_BUFFER = 2
    ARV_STREAM_CALLBACK_TYPE_BUFFER_DONE = 3
end

struct _ArvStreamClass
    parent_class::GObjectClass
    start_thread::Ptr{Cvoid}
    stop_thread::Ptr{Cvoid}
    new_buffer::Ptr{Cvoid}
end

const ArvStreamClass = _ArvStreamClass

const ArvStream_autoptr = Ptr{ArvStream}

const ArvStream_listautoptr = Ptr{GList}

const ArvStream_slistautoptr = Ptr{GSList}

const ArvStream_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvStream(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvStream, arv_stream, ARV, STREAM, GObject);
```
"""
function glib_autoptr_clear_ArvStream(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvStream(_ptr::Ptr{ArvStream})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvStream(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvStream, arv_stream, ARV, STREAM, GObject);
```
"""
function glib_autoptr_cleanup_ArvStream(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvStream(_ptr::Ptr{Ptr{ArvStream}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvStream(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvStream, arv_stream, ARV, STREAM, GObject);
```
"""
function glib_autoptr_destroy_ArvStream(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvStream(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvStream(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvStream, arv_stream, ARV, STREAM, GObject);
```
"""
function glib_listautoptr_cleanup_ArvStream(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvStream(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvStream(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvStream, arv_stream, ARV, STREAM, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvStream(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvStream(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvStream(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvStream, arv_stream, ARV, STREAM, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvStream(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvStream(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvStreamClass_autoptr = Ptr{ArvStreamClass}

const ArvStreamClass_listautoptr = Ptr{GList}

const ArvStreamClass_slistautoptr = Ptr{GSList}

const ArvStreamClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvStreamClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvStream, arv_stream, ARV, STREAM, GObject);
```
"""
function glib_autoptr_clear_ArvStreamClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvStreamClass(_ptr::Ptr{ArvStreamClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvStreamClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvStream, arv_stream, ARV, STREAM, GObject);
```
"""
function glib_autoptr_cleanup_ArvStreamClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvStreamClass(_ptr::Ptr{Ptr{ArvStreamClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvStreamClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvStream, arv_stream, ARV, STREAM, GObject);
```
"""
function glib_autoptr_destroy_ArvStreamClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvStreamClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvStreamClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvStream, arv_stream, ARV, STREAM, GObject);
```
"""
function glib_listautoptr_cleanup_ArvStreamClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvStreamClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvStreamClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvStream, arv_stream, ARV, STREAM, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvStreamClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvStreamClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvStreamClass(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvStream, arv_stream, ARV, STREAM, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvStreamClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvStreamClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_STREAM(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvStream, arv_stream, ARV, STREAM, GObject);
```
"""
function ARV_STREAM(ptr)
    @ccall libaravis.ARV_STREAM(ptr::gpointer)::Ptr{ArvStream}
end

"""
    ARV_STREAM_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvStream, arv_stream, ARV, STREAM, GObject);
```
"""
function ARV_STREAM_CLASS(ptr)
    @ccall libaravis.ARV_STREAM_CLASS(ptr::gpointer)::Ptr{ArvStreamClass}
end

"""
    ARV_IS_STREAM(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvStream, arv_stream, ARV, STREAM, GObject);
```
"""
function ARV_IS_STREAM(ptr)
    @ccall libaravis.ARV_IS_STREAM(ptr::gpointer)::gboolean
end

"""
    ARV_IS_STREAM_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvStream, arv_stream, ARV, STREAM, GObject);
```
"""
function ARV_IS_STREAM_CLASS(ptr)
    @ccall libaravis.ARV_IS_STREAM_CLASS(ptr::gpointer)::gboolean
end

"""
    ARV_STREAM_GET_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvStream, arv_stream, ARV, STREAM, GObject);
```
"""
function ARV_STREAM_GET_CLASS(ptr)
    @ccall libaravis.ARV_STREAM_GET_CLASS(ptr::gpointer)::Ptr{ArvStreamClass}
end

# typedef void ( * ArvStreamCallback ) ( void * user_data , ArvStreamCallbackType type , ArvBuffer * buffer )
"""
[`ArvStreamCallback`](@ref): \\_data: a pointer to user data associated to this callback : reason of the callback call : a [class] object

This is the signature of the callback passed on an #[`ArvStream`](@ref) instantiation, which will be called on the stream receiving thread initialization and finalization, and on every received buffer, once when the buffer is pulled from the buffer queue, and one more when the buffer is done (successfully or not).

is assured to be a valid #[`ArvBuffer`](@ref) object only when type is \\_STREAM\\_CALLBACK\\_TYPE\\_START\\_BUFFER or \\_STREAM\\_CALLBACK\\_TYPE\\_BUFFER\\_DONE.

The callback is awaken from the stream receiving thread, which means it is forbidden to access to the camera instance, except if you take care to protect the instance access from concurrent access. It also means all the time spent in the callback is less time available for the incoming data handling. CPU intensive image processing should happen elsewhere.
"""
const ArvStreamCallback = Ptr{Cvoid}

"""
    arv_stream_push_buffer(stream, buffer)

### Prototype
```c
ARV_API void arv_stream_push_buffer (ArvStream *stream, ArvBuffer *buffer);
```
"""
function arv_stream_push_buffer(stream, buffer)
    @ccall libaravis.arv_stream_push_buffer(stream::Ptr{ArvStream}, buffer::Ptr{ArvBuffer})::Cvoid
end

"""
    arv_stream_pop_buffer(stream)

### Prototype
```c
ARV_API ArvBuffer * arv_stream_pop_buffer (ArvStream *stream);
```
"""
function arv_stream_pop_buffer(stream)
    @ccall libaravis.arv_stream_pop_buffer(stream::Ptr{ArvStream})::Ptr{ArvBuffer}
end

"""
    arv_stream_try_pop_buffer(stream)

### Prototype
```c
ARV_API ArvBuffer * arv_stream_try_pop_buffer (ArvStream *stream);
```
"""
function arv_stream_try_pop_buffer(stream)
    @ccall libaravis.arv_stream_try_pop_buffer(stream::Ptr{ArvStream})::Ptr{ArvBuffer}
end

"""
    arv_stream_timeout_pop_buffer(stream, timeout)

### Prototype
```c
ARV_API ArvBuffer * arv_stream_timeout_pop_buffer (ArvStream *stream, guint64 timeout);
```
"""
function arv_stream_timeout_pop_buffer(stream, timeout)
    @ccall libaravis.arv_stream_timeout_pop_buffer(stream::Ptr{ArvStream}, timeout::guint64)::Ptr{ArvBuffer}
end

"""
    arv_stream_get_n_buffers(stream, n_input_buffers, n_output_buffers)

### Prototype
```c
ARV_API void arv_stream_get_n_buffers (ArvStream *stream, gint *n_input_buffers, gint *n_output_buffers);
```
"""
function arv_stream_get_n_buffers(stream, n_input_buffers, n_output_buffers)
    @ccall libaravis.arv_stream_get_n_buffers(stream::Ptr{ArvStream}, n_input_buffers::Ptr{gint}, n_output_buffers::Ptr{gint})::Cvoid
end

"""
    arv_stream_start_thread(stream)

### Prototype
```c
ARV_API void arv_stream_start_thread (ArvStream *stream);
```
"""
function arv_stream_start_thread(stream)
    @ccall libaravis.arv_stream_start_thread(stream::Ptr{ArvStream})::Cvoid
end

"""
    arv_stream_stop_thread(stream, delete_buffers)

### Prototype
```c
ARV_API unsigned int arv_stream_stop_thread (ArvStream *stream, gboolean delete_buffers);
```
"""
function arv_stream_stop_thread(stream, delete_buffers)
    @ccall libaravis.arv_stream_stop_thread(stream::Ptr{ArvStream}, delete_buffers::gboolean)::Cuint
end

"""
    arv_stream_get_statistics(stream, n_completed_buffers, n_failures, n_underruns)

### Prototype
```c
ARV_API void arv_stream_get_statistics (ArvStream *stream, guint64 *n_completed_buffers, guint64 *n_failures, guint64 *n_underruns);
```
"""
function arv_stream_get_statistics(stream, n_completed_buffers, n_failures, n_underruns)
    @ccall libaravis.arv_stream_get_statistics(stream::Ptr{ArvStream}, n_completed_buffers::Ptr{guint64}, n_failures::Ptr{guint64}, n_underruns::Ptr{guint64})::Cvoid
end

"""
    arv_stream_get_n_infos(stream)

### Prototype
```c
ARV_API guint arv_stream_get_n_infos (ArvStream *stream);
```
"""
function arv_stream_get_n_infos(stream)
    @ccall libaravis.arv_stream_get_n_infos(stream::Ptr{ArvStream})::guint
end

"""
    arv_stream_get_info_name(stream, id)

### Prototype
```c
ARV_API const char * arv_stream_get_info_name (ArvStream *stream, guint id);
```
"""
function arv_stream_get_info_name(stream, id)
    @ccall libaravis.arv_stream_get_info_name(stream::Ptr{ArvStream}, id::guint)::Cstring
end

"""
    arv_stream_get_info_type(stream, id)

### Prototype
```c
ARV_API GType arv_stream_get_info_type (ArvStream *stream, guint id);
```
"""
function arv_stream_get_info_type(stream, id)
    @ccall libaravis.arv_stream_get_info_type(stream::Ptr{ArvStream}, id::guint)::GType
end

"""
    arv_stream_get_info_uint64(stream, id)

### Prototype
```c
ARV_API guint64 arv_stream_get_info_uint64 (ArvStream *stream, guint id);
```
"""
function arv_stream_get_info_uint64(stream, id)
    @ccall libaravis.arv_stream_get_info_uint64(stream::Ptr{ArvStream}, id::guint)::guint64
end

"""
    arv_stream_get_info_double(stream, id)

### Prototype
```c
ARV_API double arv_stream_get_info_double (ArvStream *stream, guint id);
```
"""
function arv_stream_get_info_double(stream, id)
    @ccall libaravis.arv_stream_get_info_double(stream::Ptr{ArvStream}, id::guint)::Cdouble
end

"""
    arv_stream_get_info_uint64_by_name(stream, name)

### Prototype
```c
ARV_API guint64 arv_stream_get_info_uint64_by_name (ArvStream *stream, const char *name);
```
"""
function arv_stream_get_info_uint64_by_name(stream, name)
    @ccall libaravis.arv_stream_get_info_uint64_by_name(stream::Ptr{ArvStream}, name::Cstring)::guint64
end

"""
    arv_stream_get_info_double_by_name(stream, name)

### Prototype
```c
ARV_API double arv_stream_get_info_double_by_name (ArvStream *stream, const char *name);
```
"""
function arv_stream_get_info_double_by_name(stream, name)
    @ccall libaravis.arv_stream_get_info_double_by_name(stream::Ptr{ArvStream}, name::Cstring)::Cdouble
end

"""
    arv_stream_set_emit_signals(stream, emit_signals)

### Prototype
```c
ARV_API void arv_stream_set_emit_signals (ArvStream *stream, gboolean emit_signals);
```
"""
function arv_stream_set_emit_signals(stream, emit_signals)
    @ccall libaravis.arv_stream_set_emit_signals(stream::Ptr{ArvStream}, emit_signals::gboolean)::Cvoid
end

"""
    arv_stream_get_emit_signals(stream)

### Prototype
```c
ARV_API gboolean arv_stream_get_emit_signals (ArvStream *stream);
```
"""
function arv_stream_get_emit_signals(stream)
    @ccall libaravis.arv_stream_get_emit_signals(stream::Ptr{ArvStream})::gboolean
end

"""
    ArvGvStreamOption

[`ArvGvStreamOption`](@ref): \\_GV\\_STREAM\\_OPTION\\_NONE: no option specified \\_GV\\_STREAM\\_OPTION\\_PACKET\\_SOCKET\\_DISABLED: use of packet socket is disabled
"""
@cenum ArvGvStreamOption::UInt32 begin
    ARV_GV_STREAM_OPTION_NONE = 0
    ARV_GV_STREAM_OPTION_PACKET_SOCKET_DISABLED = 1
end

"""
    ArvGvStreamSocketBuffer

[`ArvGvStreamSocketBuffer`](@ref): \\_GV\\_STREAM\\_SOCKET\\_BUFFER\\_FIXED: socket buffer is set using [property.GvStream:socket-buffer-size] value \\_GV\\_STREAM\\_SOCKET\\_BUFFER\\_AUTO: socket buffer size is set to the payload size if [property.GvStream:socket-buffer-size] is not strictly positive, or the minimum of both values
"""
@cenum ArvGvStreamSocketBuffer::UInt32 begin
    ARV_GV_STREAM_SOCKET_BUFFER_FIXED = 0
    ARV_GV_STREAM_SOCKET_BUFFER_AUTO = 1
end

"""
    ArvGvStreamPacketResend

[`ArvGvStreamPacketResend`](@ref): \\_GV\\_STREAM\\_PACKET\\_RESEND\\_NEVER: never request a packet resend \\_GV\\_STREAM\\_PACKET\\_RESEND\\_ALWAYS: request a packet resend if a packet was missing
"""
@cenum ArvGvStreamPacketResend::UInt32 begin
    ARV_GV_STREAM_PACKET_RESEND_NEVER = 0
    ARV_GV_STREAM_PACKET_RESEND_ALWAYS = 1
end

struct ArvGvStreamClass
    parent_class::ArvStreamClass
end

const ArvGvStream_autoptr = Ptr{ArvGvStream}

const ArvGvStream_listautoptr = Ptr{GList}

const ArvGvStream_slistautoptr = Ptr{GSList}

const ArvGvStream_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGvStream(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvStream, arv_gv_stream, ARV, GV_STREAM, ArvStream);
```
"""
function glib_autoptr_clear_ArvGvStream(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGvStream(_ptr::Ptr{ArvGvStream})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGvStream(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvStream, arv_gv_stream, ARV, GV_STREAM, ArvStream);
```
"""
function glib_autoptr_cleanup_ArvGvStream(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGvStream(_ptr::Ptr{Ptr{ArvGvStream}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGvStream(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvStream, arv_gv_stream, ARV, GV_STREAM, ArvStream);
```
"""
function glib_autoptr_destroy_ArvGvStream(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGvStream(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGvStream(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvStream, arv_gv_stream, ARV, GV_STREAM, ArvStream);
```
"""
function glib_listautoptr_cleanup_ArvGvStream(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGvStream(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGvStream(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvStream, arv_gv_stream, ARV, GV_STREAM, ArvStream);
```
"""
function glib_slistautoptr_cleanup_ArvGvStream(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGvStream(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGvStream(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvStream, arv_gv_stream, ARV, GV_STREAM, ArvStream);
```
"""
function glib_queueautoptr_cleanup_ArvGvStream(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGvStream(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGvStreamClass_autoptr = Ptr{ArvGvStreamClass}

const ArvGvStreamClass_listautoptr = Ptr{GList}

const ArvGvStreamClass_slistautoptr = Ptr{GSList}

const ArvGvStreamClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGvStreamClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvStream, arv_gv_stream, ARV, GV_STREAM, ArvStream);
```
"""
function glib_autoptr_clear_ArvGvStreamClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGvStreamClass(_ptr::Ptr{ArvGvStreamClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGvStreamClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvStream, arv_gv_stream, ARV, GV_STREAM, ArvStream);
```
"""
function glib_autoptr_cleanup_ArvGvStreamClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGvStreamClass(_ptr::Ptr{Ptr{ArvGvStreamClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGvStreamClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvStream, arv_gv_stream, ARV, GV_STREAM, ArvStream);
```
"""
function glib_autoptr_destroy_ArvGvStreamClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGvStreamClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGvStreamClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvStream, arv_gv_stream, ARV, GV_STREAM, ArvStream);
```
"""
function glib_listautoptr_cleanup_ArvGvStreamClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGvStreamClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGvStreamClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvStream, arv_gv_stream, ARV, GV_STREAM, ArvStream);
```
"""
function glib_slistautoptr_cleanup_ArvGvStreamClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGvStreamClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGvStreamClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvStream, arv_gv_stream, ARV, GV_STREAM, ArvStream);
```
"""
function glib_queueautoptr_cleanup_ArvGvStreamClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGvStreamClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GV_STREAM(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvStream, arv_gv_stream, ARV, GV_STREAM, ArvStream);
```
"""
function ARV_GV_STREAM(ptr)
    @ccall libaravis.ARV_GV_STREAM(ptr::gpointer)::Ptr{ArvGvStream}
end

"""
    ARV_IS_GV_STREAM(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvStream, arv_gv_stream, ARV, GV_STREAM, ArvStream);
```
"""
function ARV_IS_GV_STREAM(ptr)
    @ccall libaravis.ARV_IS_GV_STREAM(ptr::gpointer)::gboolean
end

"""
    arv_gv_stream_get_port(gv_stream)

### Prototype
```c
ARV_API guint16 arv_gv_stream_get_port (ArvGvStream *gv_stream);
```
"""
function arv_gv_stream_get_port(gv_stream)
    @ccall libaravis.arv_gv_stream_get_port(gv_stream::Ptr{ArvGvStream})::guint16
end

"""
    arv_gv_stream_get_statistics(gv_stream, n_resent_packets, n_missing_packets)

### Prototype
```c
ARV_API void arv_gv_stream_get_statistics (ArvGvStream *gv_stream, guint64 *n_resent_packets, guint64 *n_missing_packets);
```
"""
function arv_gv_stream_get_statistics(gv_stream, n_resent_packets, n_missing_packets)
    @ccall libaravis.arv_gv_stream_get_statistics(gv_stream::Ptr{ArvGvStream}, n_resent_packets::Ptr{guint64}, n_missing_packets::Ptr{guint64})::Cvoid
end

"""
    ArvGcNameSpace

[`ArvGcNameSpace`](@ref): \\_GC\\_NAME\\_SPACE\\_UNDEFINED: undefined name space \\_GC\\_NAME\\_SPACE\\_STANDARD: Genicam standardized name space \\_GC\\_NAME\\_SPACE\\_CUSTOM: non-standardized name space

Specifies feature node or register name space type. Standard name space features are listed in Genicam materials. Any other vendor-specific features should use custom name space type.
"""
@cenum ArvGcNameSpace::Int32 begin
    ARV_GC_NAME_SPACE_UNDEFINED = -1
    ARV_GC_NAME_SPACE_STANDARD = 0
    ARV_GC_NAME_SPACE_CUSTOM = 1
end

"""
    ArvGcAccessMode

[`ArvGcAccessMode`](@ref): \\_GC\\_ACCESS\\_MODE\\_UNDEFINED: undefined access mode \\_GC\\_ACCESS\\_MODE\\_RO: read-only access \\_GC\\_ACCESS\\_MODE\\_WO: write-only access \\_GC\\_ACCESS\\_MODE\\_RW: read and write access

Specifies access mode for feature nodes and registers.
"""
@cenum ArvGcAccessMode::Int32 begin
    ARV_GC_ACCESS_MODE_UNDEFINED = -1
    ARV_GC_ACCESS_MODE_RO = 0
    ARV_GC_ACCESS_MODE_WO = 1
    ARV_GC_ACCESS_MODE_RW = 2
end

"""
    arv_gc_access_mode_to_string(value)

### Prototype
```c
ARV_API const char * arv_gc_access_mode_to_string (ArvGcAccessMode value);
```
"""
function arv_gc_access_mode_to_string(value)
    @ccall libaravis.arv_gc_access_mode_to_string(value::ArvGcAccessMode)::Cstring
end

"""
    arv_gc_access_mode_from_string(string)

### Prototype
```c
ARV_API ArvGcAccessMode arv_gc_access_mode_from_string (const char *string);
```
"""
function arv_gc_access_mode_from_string(string)
    @ccall libaravis.arv_gc_access_mode_from_string(string::Cstring)::ArvGcAccessMode
end

"""
    ArvGcCachable

[`ArvGcCachable`](@ref): \\_GC\\_CACHABLE\\_UNDEFINED: undefined cache mode \\_GC\\_CACHABLE\\_NO\\_CACHE: no value caching \\_GC\\_CACHABLE\\_WRITE\\_THROUGH: write-through cache mode \\_GC\\_CACHABLE\\_WRITE\\_AROUND: write-around cache mode

Specifies caching mode for register values.
"""
@cenum ArvGcCachable::Int32 begin
    ARV_GC_CACHABLE_UNDEFINED = -1
    ARV_GC_CACHABLE_NO_CACHE = 0
    ARV_GC_CACHABLE_WRITE_THROUGH = 1
    ARV_GC_CACHABLE_WRITE_AROUND = 2
end

"""
    ArvGcSignedness

[`ArvGcSignedness`](@ref): \\_GC\\_SIGNEDNESS\\_UNDEFINED: undefined sign \\_GC\\_SIGNEDNESS\\_SIGNED: signed integer \\_GC\\_SIGNEDNESS\\_UNSIGNED: unsigned integer

Specifies signedness of integer registers. Per standard Genicam internally uses signed 64-bit signed integers for representing all integer registers. Therefore unsigned 64-bit integers are not available.
"""
@cenum ArvGcSignedness::Int32 begin
    ARV_GC_SIGNEDNESS_UNDEFINED = -1
    ARV_GC_SIGNEDNESS_SIGNED = 0
    ARV_GC_SIGNEDNESS_UNSIGNED = 1
end

"""
    ArvGcIsLinear

[`ArvGcIsLinear`](@ref): \\_GC\\_IS\\_LINEAR\\_UNDEFINED: undefined relationship between variables \\_GC\\_IS\\_LINEAR\\_NO: non-linear relationship between variables \\_GC\\_IS\\_LINEAR\\_YES: linear relationship between variables

Describes relationship between TO and FROM variables in Converter feature nodes.
"""
@cenum ArvGcIsLinear::Int32 begin
    ARV_GC_IS_LINEAR_UNDEFINED = -1
    ARV_GC_IS_LINEAR_NO = 0
    ARV_GC_IS_LINEAR_YES = 1
end

"""
    ArvGcVisibility

[`ArvGcVisibility`](@ref): \\_GC\\_VISIBILITY\\_UNDEFINED: undefined feature visibility level \\_GC\\_VISIBILITY\\_INVISIBLE: feature should be not be visible in user interface \\_GC\\_VISIBILITY\\_GURU: very advanced feature to be shown to very experienced users \\_GC\\_VISIBILITY\\_EXPERT: advanced feature to be shown to expert users \\_GC\\_VISIBILITY\\_BEGINNER: basic feature to be shown to all users

Specifies feature node recommended visibility in user interfaces.
"""
@cenum ArvGcVisibility::Int32 begin
    ARV_GC_VISIBILITY_UNDEFINED = -1
    ARV_GC_VISIBILITY_INVISIBLE = 0
    ARV_GC_VISIBILITY_GURU = 1
    ARV_GC_VISIBILITY_EXPERT = 2
    ARV_GC_VISIBILITY_BEGINNER = 3
end

"""
    ArvGcRepresentation

[`ArvGcRepresentation`](@ref): \\_GC\\_REPRESENTATION\\_UNDEFINED: undefined representation \\_GC\\_REPRESENTATION\\_LINEAR: number presented on linear scale (e.g. on a linear slider) \\_GC\\_REPRESENTATION\\_LOGARITHMIC: number presented on logarithmic scale (e.g. on a logarithmic slider) \\_GC\\_REPRESENTATION\\_BOOLEAN: binary choice (e.g. a checkbox) \\_GC\\_REPRESENTATION\\_PURE\\_NUMBER: number presented in an editable field (e.g. a spinbox) \\_GC\\_REPRESENTATION\\_HEX\\_NUMBER: number presented in hexadecimal format \\_GC\\_REPRESENTATION\\_IPV4\\_ADDRESS: IPv4 address \\_GC\\_REPRESENTATION\\_MAC\\_ADDRESS: MAC address

Number representation formats.

Since: 0.8.0
"""
@cenum ArvGcRepresentation::Int32 begin
    ARV_GC_REPRESENTATION_UNDEFINED = -1
    ARV_GC_REPRESENTATION_LINEAR = 0
    ARV_GC_REPRESENTATION_LOGARITHMIC = 1
    ARV_GC_REPRESENTATION_BOOLEAN = 2
    ARV_GC_REPRESENTATION_PURE_NUMBER = 3
    ARV_GC_REPRESENTATION_HEX_NUMBER = 4
    ARV_GC_REPRESENTATION_IPV4_ADDRESS = 5
    ARV_GC_REPRESENTATION_MAC_ADDRESS = 6
end

"""
    ArvGcDisplayNotation

[`ArvGcDisplayNotation`](@ref): \\_GC\\_DISPLAY\\_NOTATION\\_UNDEFINED: undefined number notation \\_GC\\_DISPLAY\\_NOTATION\\_AUTOMATIC: automatically detect whether to use fixed or scientific number notation \\_GC\\_DISPLAY\\_NOTATION\\_FIXED: used fixed (i.e. decimal) notation for displaying numbers \\_GC\\_DISPLAY\\_NOTATION\\_SCIENTIFIC: use scientific notation for displaying numbers

Number display notations for showing numbers in user interfaces.

Since: 0.8.0
"""
@cenum ArvGcDisplayNotation::Int32 begin
    ARV_GC_DISPLAY_NOTATION_UNDEFINED = -1
    ARV_GC_DISPLAY_NOTATION_AUTOMATIC = 0
    ARV_GC_DISPLAY_NOTATION_FIXED = 1
    ARV_GC_DISPLAY_NOTATION_SCIENTIFIC = 2
end

"""
    ArvGcStreamable

[`ArvGcStreamable`](@ref): \\_GC\\_STREAMABLE\\_UNDEFINED: undefined streamable \\_GC\\_STREAMABLE\\_NO: the feature can't be used for camera state persistence \\_GC\\_STREAMABLE\\_YES: the feature can be used for camera state persistence

Denotes that the corresponding feature is prepared to be stored to and loaded from a file via the node tree. The idea is to persist the state of a camera by storing the features marked as Streamable and restore the state by writing those features back to the node tree.

Since: 0.8.8
"""
@cenum ArvGcStreamable::Int32 begin
    ARV_GC_STREAMABLE_UNDEFINED = -1
    ARV_GC_STREAMABLE_NO = 0
    ARV_GC_STREAMABLE_YES = 1
end

"""
    GAppInfoCreateFlags

[`GAppInfoCreateFlags`](@ref): \\_APP\\_INFO\\_CREATE\\_NONE: No flags. \\_APP\\_INFO\\_CREATE\\_NEEDS\\_TERMINAL: Application opens in a terminal window. \\_APP\\_INFO\\_CREATE\\_SUPPORTS\\_URIS: Application supports URI arguments. \\_APP\\_INFO\\_CREATE\\_SUPPORTS\\_STARTUP\\_NOTIFICATION: Application supports startup notification. Since 2.26

Flags used when creating a #[`GAppInfo`](@ref).
"""
@cenum GAppInfoCreateFlags::UInt32 begin
    G_APP_INFO_CREATE_NONE = 0
    G_APP_INFO_CREATE_NEEDS_TERMINAL = 1
    G_APP_INFO_CREATE_SUPPORTS_URIS = 2
    G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION = 4
end

"""
    GConverterFlags

[`GConverterFlags`](@ref): \\_CONVERTER\\_NO\\_FLAGS: No flags. \\_CONVERTER\\_INPUT\\_AT\\_END: At end of input data \\_CONVERTER\\_FLUSH: Flush data

Flags used when calling a [`g_converter_convert`](@ref)().

Since: 2.24
"""
@cenum GConverterFlags::UInt32 begin
    G_CONVERTER_NO_FLAGS = 0
    G_CONVERTER_INPUT_AT_END = 1
    G_CONVERTER_FLUSH = 2
end

"""
    GConverterResult

[`GConverterResult`](@ref): \\_CONVERTER\\_ERROR: There was an error during conversion. \\_CONVERTER\\_CONVERTED: Some data was consumed or produced \\_CONVERTER\\_FINISHED: The conversion is finished \\_CONVERTER\\_FLUSHED: Flushing is finished

Results returned from [`g_converter_convert`](@ref)().

Since: 2.24
"""
@cenum GConverterResult::UInt32 begin
    G_CONVERTER_ERROR = 0
    G_CONVERTER_CONVERTED = 1
    G_CONVERTER_FINISHED = 2
    G_CONVERTER_FLUSHED = 3
end

"""
    GDataStreamByteOrder

[`GDataStreamByteOrder`](@ref): \\_DATA\\_STREAM\\_BYTE\\_ORDER\\_BIG\\_ENDIAN: Selects Big Endian byte order. \\_DATA\\_STREAM\\_BYTE\\_ORDER\\_LITTLE\\_ENDIAN: Selects Little Endian byte order. \\_DATA\\_STREAM\\_BYTE\\_ORDER\\_HOST\\_ENDIAN: Selects endianness based on host machine's architecture.

#[`GDataStreamByteOrder`](@ref) is used to ensure proper endianness of streaming data sources across various machine architectures.
"""
@cenum GDataStreamByteOrder::UInt32 begin
    G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN = 0
    G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN = 1
    G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN = 2
end

"""
    GDataStreamNewlineType

[`GDataStreamNewlineType`](@ref): \\_DATA\\_STREAM\\_NEWLINE\\_TYPE\\_LF: Selects "LF" line endings, common on most modern UNIX platforms. \\_DATA\\_STREAM\\_NEWLINE\\_TYPE\\_CR: Selects "CR" line endings. \\_DATA\\_STREAM\\_NEWLINE\\_TYPE\\_CR\\_LF: Selects "CR, LF" line ending, common on Microsoft Windows. \\_DATA\\_STREAM\\_NEWLINE\\_TYPE\\_ANY: Automatically try to handle any line ending type.

#[`GDataStreamNewlineType`](@ref) is used when checking for or setting the line endings for a given file.
"""
@cenum GDataStreamNewlineType::UInt32 begin
    G_DATA_STREAM_NEWLINE_TYPE_LF = 0
    G_DATA_STREAM_NEWLINE_TYPE_CR = 1
    G_DATA_STREAM_NEWLINE_TYPE_CR_LF = 2
    G_DATA_STREAM_NEWLINE_TYPE_ANY = 3
end

"""
    GFileAttributeType

[`GFileAttributeType`](@ref): \\_FILE\\_ATTRIBUTE\\_TYPE\\_INVALID: indicates an invalid or uninitialized type. \\_FILE\\_ATTRIBUTE\\_TYPE\\_STRING: a null terminated UTF8 string. \\_FILE\\_ATTRIBUTE\\_TYPE\\_BYTE\\_STRING: a zero terminated string of non-zero bytes. \\_FILE\\_ATTRIBUTE\\_TYPE\\_BOOLEAN: a boolean value. \\_FILE\\_ATTRIBUTE\\_TYPE\\_UINT32: an unsigned 4-byte/32-bit integer. \\_FILE\\_ATTRIBUTE\\_TYPE\\_INT32: a signed 4-byte/32-bit integer. \\_FILE\\_ATTRIBUTE\\_TYPE\\_UINT64: an unsigned 8-byte/64-bit integer. \\_FILE\\_ATTRIBUTE\\_TYPE\\_INT64: a signed 8-byte/64-bit integer. \\_FILE\\_ATTRIBUTE\\_TYPE\\_OBJECT: a #[`GObject`](@ref). \\_FILE\\_ATTRIBUTE\\_TYPE\\_STRINGV: a NULL terminated char **. Since 2.22

The data types for file attributes.
"""
@cenum GFileAttributeType::UInt32 begin
    G_FILE_ATTRIBUTE_TYPE_INVALID = 0
    G_FILE_ATTRIBUTE_TYPE_STRING = 1
    G_FILE_ATTRIBUTE_TYPE_BYTE_STRING = 2
    G_FILE_ATTRIBUTE_TYPE_BOOLEAN = 3
    G_FILE_ATTRIBUTE_TYPE_UINT32 = 4
    G_FILE_ATTRIBUTE_TYPE_INT32 = 5
    G_FILE_ATTRIBUTE_TYPE_UINT64 = 6
    G_FILE_ATTRIBUTE_TYPE_INT64 = 7
    G_FILE_ATTRIBUTE_TYPE_OBJECT = 8
    G_FILE_ATTRIBUTE_TYPE_STRINGV = 9
end

"""
    GFileAttributeInfoFlags

[`GFileAttributeInfoFlags`](@ref): \\_FILE\\_ATTRIBUTE\\_INFO\\_NONE: no flags set. \\_FILE\\_ATTRIBUTE\\_INFO\\_COPY\\_WITH\\_FILE: copy the attribute values when the file is copied. \\_FILE\\_ATTRIBUTE\\_INFO\\_COPY\\_WHEN\\_MOVED: copy the attribute values when the file is moved.

Flags specifying the behaviour of an attribute.
"""
@cenum GFileAttributeInfoFlags::UInt32 begin
    G_FILE_ATTRIBUTE_INFO_NONE = 0
    G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE = 1
    G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED = 2
end

"""
    GFileAttributeStatus

[`GFileAttributeStatus`](@ref): \\_FILE\\_ATTRIBUTE\\_STATUS\\_UNSET: Attribute value is unset (empty). \\_FILE\\_ATTRIBUTE\\_STATUS\\_SET: Attribute value is set. \\_FILE\\_ATTRIBUTE\\_STATUS\\_ERROR\\_SETTING: Indicates an error in setting the value.

Used by [`g_file_set_attributes_from_info`](@ref)() when setting file attributes.
"""
@cenum GFileAttributeStatus::UInt32 begin
    G_FILE_ATTRIBUTE_STATUS_UNSET = 0
    G_FILE_ATTRIBUTE_STATUS_SET = 1
    G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING = 2
end

"""
    GFileQueryInfoFlags

[`GFileQueryInfoFlags`](@ref): \\_FILE\\_QUERY\\_INFO\\_NONE: No flags set. \\_FILE\\_QUERY\\_INFO\\_NOFOLLOW\\_SYMLINKS: Don't follow symlinks.

Flags used when querying a #[`GFileInfo`](@ref).
"""
@cenum GFileQueryInfoFlags::UInt32 begin
    G_FILE_QUERY_INFO_NONE = 0
    G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS = 1
end

"""
    GFileCreateFlags

[`GFileCreateFlags`](@ref): \\_FILE\\_CREATE\\_NONE: No flags set. \\_FILE\\_CREATE\\_PRIVATE: Create a file that can only be accessed by the current user. \\_FILE\\_CREATE\\_REPLACE\\_DESTINATION: Replace the destination as if it didn't exist before. Don't try to keep any old permissions, replace instead of following links. This is generally useful if you're doing a "copy over" rather than a "save new version of" replace operation. You can think of it as "unlink destination" before writing to it, although the implementation may not be exactly like that. This flag can only be used with [`g_file_replace`](@ref)() and its variants, including [`g_file_replace_contents`](@ref)(). Since 2.20

Flags used when an operation may create a file.
"""
@cenum GFileCreateFlags::UInt32 begin
    G_FILE_CREATE_NONE = 0
    G_FILE_CREATE_PRIVATE = 1
    G_FILE_CREATE_REPLACE_DESTINATION = 2
end

"""
    GFileMeasureFlags

[`GFileMeasureFlags`](@ref): \\_FILE\\_MEASURE\\_NONE: No flags set. \\_FILE\\_MEASURE\\_REPORT\\_ANY\\_ERROR: Report any error encountered while traversing the directory tree. Normally errors are only reported for the toplevel file. \\_FILE\\_MEASURE\\_APPARENT\\_SIZE: Tally usage based on apparent file sizes. Normally, the block-size is used, if available, as this is a more accurate representation of disk space used. Compare with `du --apparent-size`. Since GLib 2.78. and similarly to `du` since GNU Coreutils 9.2, this will ignore the sizes of file types other than regular files and links, as the sizes of other file types are not specified in a standard way. \\_FILE\\_MEASURE\\_NO\\_XDEV: Do not cross mount point boundaries. Compare with `du -x`.

Flags that can be used with [`g_file_measure_disk_usage`](@ref)().

Since: 2.38
"""
@cenum GFileMeasureFlags::UInt32 begin
    G_FILE_MEASURE_NONE = 0
    G_FILE_MEASURE_REPORT_ANY_ERROR = 2
    G_FILE_MEASURE_APPARENT_SIZE = 4
    G_FILE_MEASURE_NO_XDEV = 8
end

"""
    GMountMountFlags

[`GMountMountFlags`](@ref): \\_MOUNT\\_MOUNT\\_NONE: No flags set.

Flags used when mounting a mount.
"""
@cenum GMountMountFlags::UInt32 begin
    G_MOUNT_MOUNT_NONE = 0
end

"""
    GMountUnmountFlags

[`GMountUnmountFlags`](@ref): \\_MOUNT\\_UNMOUNT\\_NONE: No flags set. \\_MOUNT\\_UNMOUNT\\_FORCE: Unmount even if there are outstanding file operations on the mount.

Flags used when an unmounting a mount.
"""
@cenum GMountUnmountFlags::UInt32 begin
    G_MOUNT_UNMOUNT_NONE = 0
    G_MOUNT_UNMOUNT_FORCE = 1
end

"""
    GDriveStartFlags

[`GDriveStartFlags`](@ref): \\_DRIVE\\_START\\_NONE: No flags set.

Flags used when starting a drive.

Since: 2.22
"""
@cenum GDriveStartFlags::UInt32 begin
    G_DRIVE_START_NONE = 0
end

"""
    GDriveStartStopType

[`GDriveStartStopType`](@ref): \\_DRIVE\\_START\\_STOP\\_TYPE\\_UNKNOWN: Unknown or drive doesn't support start/stop. \\_DRIVE\\_START\\_STOP\\_TYPE\\_SHUTDOWN: The stop method will physically shut down the drive and e.g. power down the port the drive is attached to. \\_DRIVE\\_START\\_STOP\\_TYPE\\_NETWORK: The start/stop methods are used for connecting/disconnect to the drive over the network. \\_DRIVE\\_START\\_STOP\\_TYPE\\_MULTIDISK: The start/stop methods will assemble/disassemble a virtual drive from several physical drives. \\_DRIVE\\_START\\_STOP\\_TYPE\\_PASSWORD: The start/stop methods will unlock/lock the disk (for example using the ATA `SECURITY UNLOCK DEVICE` command)

Enumeration describing how a drive can be started/stopped.

Since: 2.22
"""
@cenum GDriveStartStopType::UInt32 begin
    G_DRIVE_START_STOP_TYPE_UNKNOWN = 0
    G_DRIVE_START_STOP_TYPE_SHUTDOWN = 1
    G_DRIVE_START_STOP_TYPE_NETWORK = 2
    G_DRIVE_START_STOP_TYPE_MULTIDISK = 3
    G_DRIVE_START_STOP_TYPE_PASSWORD = 4
end

"""
    GFileCopyFlags

[`GFileCopyFlags`](@ref): \\_FILE\\_COPY\\_NONE: No flags set. \\_FILE\\_COPY\\_OVERWRITE: Overwrite any existing files \\_FILE\\_COPY\\_BACKUP: Make a backup of any existing files. \\_FILE\\_COPY\\_NOFOLLOW\\_SYMLINKS: Don't follow symlinks. \\_FILE\\_COPY\\_ALL\\_METADATA: Copy all file metadata instead of just default set used for copy (see #[`GFileInfo`](@ref)). \\_FILE\\_COPY\\_NO\\_FALLBACK\\_FOR\\_MOVE: Don't use copy and delete fallback if native move not supported. \\_FILE\\_COPY\\_TARGET\\_DEFAULT\\_PERMS: Leaves target file with default perms, instead of setting the source file perms. \\_FILE\\_COPY\\_TARGET\\_DEFAULT\\_MODIFIED\\_TIME: Use default modification timestamps instead of copying them from the source file. Since 2.80

Flags used when copying or moving files.
"""
@cenum GFileCopyFlags::UInt32 begin
    G_FILE_COPY_NONE = 0
    G_FILE_COPY_OVERWRITE = 1
    G_FILE_COPY_BACKUP = 2
    G_FILE_COPY_NOFOLLOW_SYMLINKS = 4
    G_FILE_COPY_ALL_METADATA = 8
    G_FILE_COPY_NO_FALLBACK_FOR_MOVE = 16
    G_FILE_COPY_TARGET_DEFAULT_PERMS = 32
    G_FILE_COPY_TARGET_DEFAULT_MODIFIED_TIME = 64
end

"""
    GFileMonitorFlags

[`GFileMonitorFlags`](@ref): \\_FILE\\_MONITOR\\_NONE: No flags set. \\_FILE\\_MONITOR\\_WATCH\\_MOUNTS: Watch for mount events. \\_FILE\\_MONITOR\\_SEND\\_MOVED: Pair DELETED and CREATED events caused by file renames (moves) and send a single G\\_FILE\\_MONITOR\\_EVENT\\_MOVED event instead (NB: not supported on all backends; the default behaviour -without specifying this flag- is to send single DELETED and CREATED events). Deprecated since 2.46: use G\\_FILE\\_MONITOR\\_WATCH\\_MOVES instead. \\_FILE\\_MONITOR\\_WATCH\\_HARD\\_LINKS: Watch for changes to the file made via another hard link. Since 2.36. \\_FILE\\_MONITOR\\_WATCH\\_MOVES: Watch for rename operations on a monitored directory. This causes G\\_FILE\\_MONITOR\\_EVENT\\_RENAMED, G\\_FILE\\_MONITOR\\_EVENT\\_MOVED\\_IN and G\\_FILE\\_MONITOR\\_EVENT\\_MOVED\\_OUT events to be emitted when possible. Since: 2.46.

Flags used to set what a #[`GFileMonitor`](@ref) will watch for.
"""
@cenum GFileMonitorFlags::UInt32 begin
    G_FILE_MONITOR_NONE = 0
    G_FILE_MONITOR_WATCH_MOUNTS = 1
    G_FILE_MONITOR_SEND_MOVED = 2
    G_FILE_MONITOR_WATCH_HARD_LINKS = 4
    G_FILE_MONITOR_WATCH_MOVES = 8
end

"""
    GFileType

[`GFileType`](@ref): \\_FILE\\_TYPE\\_UNKNOWN: File's type is unknown. \\_FILE\\_TYPE\\_REGULAR: File handle represents a regular file. \\_FILE\\_TYPE\\_DIRECTORY: File handle represents a directory. \\_FILE\\_TYPE\\_SYMBOLIC\\_LINK: File handle represents a symbolic link (Unix systems). \\_FILE\\_TYPE\\_SPECIAL: File is a "special" file, such as a socket, fifo, block device, or character device. \\_FILE\\_TYPE\\_SHORTCUT: File is a shortcut (Windows systems). \\_FILE\\_TYPE\\_MOUNTABLE: File is a mountable location.

Indicates the file's on-disk type.

On Windows systems a file will never have G\\_FILE\\_TYPE\\_SYMBOLIC\\_LINK type; use #[`GFileInfo`](@ref) and G\\_FILE\\_ATTRIBUTE\\_STANDARD\\_IS\\_SYMLINK to determine whether a file is a symlink or not. This is due to the fact that NTFS does not have a single filesystem object type for symbolic links - it has files that symlink to files, and directories that symlink to directories. #[`GFileType`](@ref) enumeration cannot precisely represent this important distinction, which is why all Windows symlinks will continue to be reported as G\\_FILE\\_TYPE\\_REGULAR or G\\_FILE\\_TYPE\\_DIRECTORY.
"""
@cenum GFileType::UInt32 begin
    G_FILE_TYPE_UNKNOWN = 0
    G_FILE_TYPE_REGULAR = 1
    G_FILE_TYPE_DIRECTORY = 2
    G_FILE_TYPE_SYMBOLIC_LINK = 3
    G_FILE_TYPE_SPECIAL = 4
    G_FILE_TYPE_SHORTCUT = 5
    G_FILE_TYPE_MOUNTABLE = 6
end

"""
    GFilesystemPreviewType

[`GFilesystemPreviewType`](@ref): \\_FILESYSTEM\\_PREVIEW\\_TYPE\\_IF\\_ALWAYS: Only preview files if user has explicitly requested it. \\_FILESYSTEM\\_PREVIEW\\_TYPE\\_IF\\_LOCAL: Preview files if user has requested preview of "local" files. \\_FILESYSTEM\\_PREVIEW\\_TYPE\\_NEVER: Never preview files.

Indicates a hint from the file system whether files should be previewed in a file manager. Returned as the value of the key G\\_FILE\\_ATTRIBUTE\\_FILESYSTEM\\_USE\\_PREVIEW.
"""
@cenum GFilesystemPreviewType::UInt32 begin
    G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS = 0
    G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL = 1
    G_FILESYSTEM_PREVIEW_TYPE_NEVER = 2
end

"""
    GFileMonitorEvent

[`GFileMonitorEvent`](@ref): \\_FILE\\_MONITOR\\_EVENT\\_CHANGED: a file changed. \\_FILE\\_MONITOR\\_EVENT\\_CHANGES\\_DONE\\_HINT: a hint that this was probably the last change in a set of changes. \\_FILE\\_MONITOR\\_EVENT\\_DELETED: a file was deleted. \\_FILE\\_MONITOR\\_EVENT\\_CREATED: a file was created. \\_FILE\\_MONITOR\\_EVENT\\_ATTRIBUTE\\_CHANGED: a file attribute was changed. \\_FILE\\_MONITOR\\_EVENT\\_PRE\\_UNMOUNT: the file location will soon be unmounted. \\_FILE\\_MONITOR\\_EVENT\\_UNMOUNTED: the file location was unmounted. \\_FILE\\_MONITOR\\_EVENT\\_MOVED: the file was moved -- only sent if the (deprecated) G\\_FILE\\_MONITOR\\_SEND\\_MOVED flag is set \\_FILE\\_MONITOR\\_EVENT\\_RENAMED: the file was renamed within the current directory -- only sent if the G\\_FILE\\_MONITOR\\_WATCH\\_MOVES flag is set. Since: 2.46. \\_FILE\\_MONITOR\\_EVENT\\_MOVED\\_IN: the file was moved into the monitored directory from another location -- only sent if the G\\_FILE\\_MONITOR\\_WATCH\\_MOVES flag is set. Since: 2.46. \\_FILE\\_MONITOR\\_EVENT\\_MOVED\\_OUT: the file was moved out of the monitored directory to another location -- only sent if the G\\_FILE\\_MONITOR\\_WATCH\\_MOVES flag is set. Since: 2.46

Specifies what type of event a monitor event is.
"""
@cenum GFileMonitorEvent::UInt32 begin
    G_FILE_MONITOR_EVENT_CHANGED = 0
    G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT = 1
    G_FILE_MONITOR_EVENT_DELETED = 2
    G_FILE_MONITOR_EVENT_CREATED = 3
    G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED = 4
    G_FILE_MONITOR_EVENT_PRE_UNMOUNT = 5
    G_FILE_MONITOR_EVENT_UNMOUNTED = 6
    G_FILE_MONITOR_EVENT_MOVED = 7
    G_FILE_MONITOR_EVENT_RENAMED = 8
    G_FILE_MONITOR_EVENT_MOVED_IN = 9
    G_FILE_MONITOR_EVENT_MOVED_OUT = 10
end

"""
    GIOErrorEnum

[`GIOErrorEnum`](@ref): \\_IO\\_ERROR\\_FAILED: Generic error condition for when an operation fails and no more specific #[`GIOErrorEnum`](@ref) value is defined. \\_IO\\_ERROR\\_NOT\\_FOUND: File not found. \\_IO\\_ERROR\\_EXISTS: File already exists. \\_IO\\_ERROR\\_IS\\_DIRECTORY: File is a directory. \\_IO\\_ERROR\\_NOT\\_DIRECTORY: File is not a directory. \\_IO\\_ERROR\\_NOT\\_EMPTY: File is a directory that isn't empty. \\_IO\\_ERROR\\_NOT\\_REGULAR\\_FILE: File is not a regular file. \\_IO\\_ERROR\\_NOT\\_SYMBOLIC\\_LINK: File is not a symbolic link. \\_IO\\_ERROR\\_NOT\\_MOUNTABLE\\_FILE: File cannot be mounted. \\_IO\\_ERROR\\_FILENAME\\_TOO\\_LONG: Filename is too many characters. \\_IO\\_ERROR\\_INVALID\\_FILENAME: Filename is invalid or contains invalid characters. \\_IO\\_ERROR\\_TOO\\_MANY\\_LINKS: File contains too many symbolic links. \\_IO\\_ERROR\\_NO\\_SPACE: No space left on drive. \\_IO\\_ERROR\\_INVALID\\_ARGUMENT: Invalid argument. \\_IO\\_ERROR\\_PERMISSION\\_DENIED: Permission denied. \\_IO\\_ERROR\\_NOT\\_SUPPORTED: Operation (or one of its parameters) not supported \\_IO\\_ERROR\\_NOT\\_MOUNTED: File isn't mounted. \\_IO\\_ERROR\\_ALREADY\\_MOUNTED: File is already mounted. \\_IO\\_ERROR\\_CLOSED: File was closed. \\_IO\\_ERROR\\_CANCELLED: Operation was cancelled. See #[`GCancellable`](@ref). \\_IO\\_ERROR\\_PENDING: Operations are still pending. \\_IO\\_ERROR\\_READ\\_ONLY: File is read only. \\_IO\\_ERROR\\_CANT\\_CREATE\\_BACKUP: Backup couldn't be created. \\_IO\\_ERROR\\_WRONG\\_ETAG: File's Entity Tag was incorrect. \\_IO\\_ERROR\\_TIMED\\_OUT: Operation timed out. \\_IO\\_ERROR\\_WOULD\\_RECURSE: Operation would be recursive. \\_IO\\_ERROR\\_BUSY: File is busy. \\_IO\\_ERROR\\_WOULD\\_BLOCK: Operation would block. \\_IO\\_ERROR\\_HOST\\_NOT\\_FOUND: Host couldn't be found (remote operations). \\_IO\\_ERROR\\_WOULD\\_MERGE: Operation would merge files. \\_IO\\_ERROR\\_FAILED\\_HANDLED: Operation failed and a helper program has already interacted with the user. Do not display any error dialog. \\_IO\\_ERROR\\_TOO\\_MANY\\_OPEN\\_FILES: The current process has too many files open and can't open any more. Duplicate descriptors do count toward this limit. Since 2.20 \\_IO\\_ERROR\\_NOT\\_INITIALIZED: The object has not been initialized. Since 2.22 \\_IO\\_ERROR\\_ADDRESS\\_IN\\_USE: The requested address is already in use. Since 2.22 \\_IO\\_ERROR\\_PARTIAL\\_INPUT: Need more input to finish operation. Since 2.24 \\_IO\\_ERROR\\_INVALID\\_DATA: The input data was invalid. Since 2.24 \\_IO\\_ERROR\\_DBUS\\_ERROR: A remote object generated an error that doesn't correspond to a locally registered #[`GError`](@ref) error domain. Use [`g_dbus_error_get_remote_error`](@ref)() to extract the D-Bus error name and [`g_dbus_error_strip_remote_error`](@ref)() to fix up the message so it matches what was received on the wire. Since 2.26. \\_IO\\_ERROR\\_HOST\\_UNREACHABLE: Host unreachable. Since 2.26 \\_IO\\_ERROR\\_NETWORK\\_UNREACHABLE: Network unreachable. Since 2.26 \\_IO\\_ERROR\\_CONNECTION\\_REFUSED: Connection refused. Since 2.26 \\_IO\\_ERROR\\_PROXY\\_FAILED: Connection to proxy server failed. Since 2.26 \\_IO\\_ERROR\\_PROXY\\_AUTH\\_FAILED: Proxy authentication failed. Since 2.26 \\_IO\\_ERROR\\_PROXY\\_NEED\\_AUTH: Proxy server needs authentication. Since 2.26 \\_IO\\_ERROR\\_PROXY\\_NOT\\_ALLOWED: Proxy connection is not allowed by ruleset. Since 2.26 \\_IO\\_ERROR\\_BROKEN\\_PIPE: Broken pipe. Since 2.36 \\_IO\\_ERROR\\_CONNECTION\\_CLOSED: Connection closed by peer. Note that this is the same code as G\\_IO\\_ERROR\\_BROKEN\\_PIPE; before 2.44 some "connection closed" errors returned G\\_IO\\_ERROR\\_BROKEN\\_PIPE, but others returned G\\_IO\\_ERROR\\_FAILED. Now they should all return the same value, which has this more logical name. Since 2.44. \\_IO\\_ERROR\\_NOT\\_CONNECTED: Transport endpoint is not connected. Since 2.44 \\_IO\\_ERROR\\_MESSAGE\\_TOO\\_LARGE: Message too large. Since 2.48. \\_IO\\_ERROR\\_NO\\_SUCH\\_DEVICE: No such device found. Since 2.74 \\_IO\\_ERROR\\_DESTINATION\\_UNSET: Destination address unset. Since 2.80

Error codes returned by GIO functions.

Note that this domain may be extended in future GLib releases. In general, new error codes either only apply to new APIs, or else replace G\\_IO\\_ERROR\\_FAILED in cases that were not explicitly distinguished before. You should therefore avoid writing code like |[<!-- language="C" --> if ([`g_error_matches`](@ref) (error, [`G_IO_ERROR`](@ref), G\\_IO\\_ERROR\\_FAILED)) { // Assume that this is EPRINTERONFIRE ... } ]| but should instead treat all unrecognized error codes the same as G\\_IO\\_ERROR\\_FAILED.

See also #[`GPollableReturn`](@ref) for a cheaper way of returning G\\_IO\\_ERROR\\_WOULD\\_BLOCK to callers without allocating a #[`GError`](@ref).
"""
@cenum GIOErrorEnum::UInt32 begin
    G_IO_ERROR_FAILED = 0
    G_IO_ERROR_NOT_FOUND = 1
    G_IO_ERROR_EXISTS = 2
    G_IO_ERROR_IS_DIRECTORY = 3
    G_IO_ERROR_NOT_DIRECTORY = 4
    G_IO_ERROR_NOT_EMPTY = 5
    G_IO_ERROR_NOT_REGULAR_FILE = 6
    G_IO_ERROR_NOT_SYMBOLIC_LINK = 7
    G_IO_ERROR_NOT_MOUNTABLE_FILE = 8
    G_IO_ERROR_FILENAME_TOO_LONG = 9
    G_IO_ERROR_INVALID_FILENAME = 10
    G_IO_ERROR_TOO_MANY_LINKS = 11
    G_IO_ERROR_NO_SPACE = 12
    G_IO_ERROR_INVALID_ARGUMENT = 13
    G_IO_ERROR_PERMISSION_DENIED = 14
    G_IO_ERROR_NOT_SUPPORTED = 15
    G_IO_ERROR_NOT_MOUNTED = 16
    G_IO_ERROR_ALREADY_MOUNTED = 17
    G_IO_ERROR_CLOSED = 18
    G_IO_ERROR_CANCELLED = 19
    G_IO_ERROR_PENDING = 20
    G_IO_ERROR_READ_ONLY = 21
    G_IO_ERROR_CANT_CREATE_BACKUP = 22
    G_IO_ERROR_WRONG_ETAG = 23
    G_IO_ERROR_TIMED_OUT = 24
    G_IO_ERROR_WOULD_RECURSE = 25
    G_IO_ERROR_BUSY = 26
    G_IO_ERROR_WOULD_BLOCK = 27
    G_IO_ERROR_HOST_NOT_FOUND = 28
    G_IO_ERROR_WOULD_MERGE = 29
    G_IO_ERROR_FAILED_HANDLED = 30
    G_IO_ERROR_TOO_MANY_OPEN_FILES = 31
    G_IO_ERROR_NOT_INITIALIZED = 32
    G_IO_ERROR_ADDRESS_IN_USE = 33
    G_IO_ERROR_PARTIAL_INPUT = 34
    G_IO_ERROR_INVALID_DATA = 35
    G_IO_ERROR_DBUS_ERROR = 36
    G_IO_ERROR_HOST_UNREACHABLE = 37
    G_IO_ERROR_NETWORK_UNREACHABLE = 38
    G_IO_ERROR_CONNECTION_REFUSED = 39
    G_IO_ERROR_PROXY_FAILED = 40
    G_IO_ERROR_PROXY_AUTH_FAILED = 41
    G_IO_ERROR_PROXY_NEED_AUTH = 42
    G_IO_ERROR_PROXY_NOT_ALLOWED = 43
    G_IO_ERROR_BROKEN_PIPE = 44
    G_IO_ERROR_CONNECTION_CLOSED = 44
    G_IO_ERROR_NOT_CONNECTED = 45
    G_IO_ERROR_MESSAGE_TOO_LARGE = 46
    G_IO_ERROR_NO_SUCH_DEVICE = 47
    G_IO_ERROR_DESTINATION_UNSET = 48
end

"""
    GAskPasswordFlags

[`GAskPasswordFlags`](@ref): \\_ASK\\_PASSWORD\\_NEED\\_PASSWORD: operation requires a password. \\_ASK\\_PASSWORD\\_NEED\\_USERNAME: operation requires a username. \\_ASK\\_PASSWORD\\_NEED\\_DOMAIN: operation requires a domain. \\_ASK\\_PASSWORD\\_SAVING\\_SUPPORTED: operation supports saving settings. \\_ASK\\_PASSWORD\\_ANONYMOUS\\_SUPPORTED: operation supports anonymous users. \\_ASK\\_PASSWORD\\_TCRYPT: operation takes TCRYPT parameters (Since: 2.58)

#[`GAskPasswordFlags`](@ref) are used to request specific information from the user, or to notify the user of their choices in an authentication situation.
"""
@cenum GAskPasswordFlags::UInt32 begin
    G_ASK_PASSWORD_NEED_PASSWORD = 1
    G_ASK_PASSWORD_NEED_USERNAME = 2
    G_ASK_PASSWORD_NEED_DOMAIN = 4
    G_ASK_PASSWORD_SAVING_SUPPORTED = 8
    G_ASK_PASSWORD_ANONYMOUS_SUPPORTED = 16
    G_ASK_PASSWORD_TCRYPT = 32
end

"""
    GPasswordSave

[`GPasswordSave`](@ref): \\_PASSWORD\\_SAVE\\_NEVER: never save a password. \\_PASSWORD\\_SAVE\\_FOR\\_SESSION: save a password for the session. \\_PASSWORD\\_SAVE\\_PERMANENTLY: save a password permanently.

#[`GPasswordSave`](@ref) is used to indicate the lifespan of a saved password.

#Gvfs stores passwords in the Gnome keyring when this flag allows it to, and later retrieves it again from there.
"""
@cenum GPasswordSave::UInt32 begin
    G_PASSWORD_SAVE_NEVER = 0
    G_PASSWORD_SAVE_FOR_SESSION = 1
    G_PASSWORD_SAVE_PERMANENTLY = 2
end

"""
    GMountOperationResult

[`GMountOperationResult`](@ref): \\_MOUNT\\_OPERATION\\_HANDLED: The request was fulfilled and the user specified data is now available \\_MOUNT\\_OPERATION\\_ABORTED: The user requested the mount operation to be aborted \\_MOUNT\\_OPERATION\\_UNHANDLED: The request was unhandled (i.e. not implemented)

#[`GMountOperationResult`](@ref) is returned as a result when a request for information is send by the mounting operation.
"""
@cenum GMountOperationResult::UInt32 begin
    G_MOUNT_OPERATION_HANDLED = 0
    G_MOUNT_OPERATION_ABORTED = 1
    G_MOUNT_OPERATION_UNHANDLED = 2
end

"""
    GOutputStreamSpliceFlags

[`GOutputStreamSpliceFlags`](@ref): \\_OUTPUT\\_STREAM\\_SPLICE\\_NONE: Do not close either stream. \\_OUTPUT\\_STREAM\\_SPLICE\\_CLOSE\\_SOURCE: Close the source stream after the splice. \\_OUTPUT\\_STREAM\\_SPLICE\\_CLOSE\\_TARGET: Close the target stream after the splice.

[`GOutputStreamSpliceFlags`](@ref) determine how streams should be spliced.
"""
@cenum GOutputStreamSpliceFlags::UInt32 begin
    G_OUTPUT_STREAM_SPLICE_NONE = 0
    G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE = 1
    G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET = 2
end

"""
    GIOStreamSpliceFlags

[`GIOStreamSpliceFlags`](@ref): \\_IO\\_STREAM\\_SPLICE\\_NONE: Do not close either stream. \\_IO\\_STREAM\\_SPLICE\\_CLOSE\\_STREAM1: Close the first stream after the splice. \\_IO\\_STREAM\\_SPLICE\\_CLOSE\\_STREAM2: Close the second stream after the splice. \\_IO\\_STREAM\\_SPLICE\\_WAIT\\_FOR\\_BOTH: Wait for both splice operations to finish before calling the callback.

[`GIOStreamSpliceFlags`](@ref) determine how streams should be spliced.

Since: 2.28
"""
@cenum GIOStreamSpliceFlags::UInt32 begin
    G_IO_STREAM_SPLICE_NONE = 0
    G_IO_STREAM_SPLICE_CLOSE_STREAM1 = 1
    G_IO_STREAM_SPLICE_CLOSE_STREAM2 = 2
    G_IO_STREAM_SPLICE_WAIT_FOR_BOTH = 4
end

"""
    GEmblemOrigin

[`GEmblemOrigin`](@ref): \\_EMBLEM\\_ORIGIN\\_UNKNOWN: Emblem of unknown origin \\_EMBLEM\\_ORIGIN\\_DEVICE: Emblem adds device-specific information \\_EMBLEM\\_ORIGIN\\_LIVEMETADATA: Emblem depicts live metadata, such as "readonly" \\_EMBLEM\\_ORIGIN\\_TAG: Emblem comes from a user-defined tag, e.g. set by nautilus (in the future)

[`GEmblemOrigin`](@ref) is used to add information about the origin of the emblem to #[`GEmblem`](@ref).

Since: 2.18
"""
@cenum GEmblemOrigin::UInt32 begin
    G_EMBLEM_ORIGIN_UNKNOWN = 0
    G_EMBLEM_ORIGIN_DEVICE = 1
    G_EMBLEM_ORIGIN_LIVEMETADATA = 2
    G_EMBLEM_ORIGIN_TAG = 3
end

"""
    GResolverError

[`GResolverError`](@ref): \\_RESOLVER\\_ERROR\\_NOT\\_FOUND: the requested name/address/service was not found \\_RESOLVER\\_ERROR\\_TEMPORARY\\_FAILURE: the requested information could not be looked up due to a network error or similar problem \\_RESOLVER\\_ERROR\\_INTERNAL: unknown error

An error code used with G\\_RESOLVER\\_ERROR in a #[`GError`](@ref) returned from a #[`GResolver`](@ref) routine.

Since: 2.22
"""
@cenum GResolverError::UInt32 begin
    G_RESOLVER_ERROR_NOT_FOUND = 0
    G_RESOLVER_ERROR_TEMPORARY_FAILURE = 1
    G_RESOLVER_ERROR_INTERNAL = 2
end

"""
    GResolverRecordType

[`GResolverRecordType`](@ref): \\_RESOLVER\\_RECORD\\_SRV: look up DNS SRV records for a domain \\_RESOLVER\\_RECORD\\_MX: look up DNS MX records for a domain \\_RESOLVER\\_RECORD\\_TXT: look up DNS TXT records for a name \\_RESOLVER\\_RECORD\\_SOA: look up DNS SOA records for a zone \\_RESOLVER\\_RECORD\\_NS: look up DNS NS records for a domain

The type of record that [`g_resolver_lookup_records`](@ref)() or [`g_resolver_lookup_records_async`](@ref)() should retrieve. The records are returned as lists of #[`GVariant`](@ref) tuples. Each record type has different values in the variant tuples returned.

G\\_RESOLVER\\_RECORD\\_SRV records are returned as variants with the signature `(qqqs)`, containing a [`guint16`](@ref) with the priority, a [`guint16`](@ref) with the weight, a [`guint16`](@ref) with the port, and a string of the hostname.

G\\_RESOLVER\\_RECORD\\_MX records are returned as variants with the signature `(qs)`, representing a [`guint16`](@ref) with the preference, and a string containing the mail exchanger hostname.

G\\_RESOLVER\\_RECORD\\_TXT records are returned as variants with the signature `(as)`, representing an array of the strings in the text record. Note: Most TXT records only contain a single string, but [RFC 1035](https://tools.ietf.org/html/rfc1035#section-3.3.14) does allow a record to contain multiple strings. The RFC which defines the interpretation of a specific TXT record will likely require concatenation of multiple strings if they are present, as with [RFC 7208](https://tools.ietf.org/html/rfc7208#section-3.3).

G\\_RESOLVER\\_RECORD\\_SOA records are returned as variants with the signature `(ssuuuuu)`, representing a string containing the primary name server, a string containing the administrator, the serial as a [`guint32`](@ref), the refresh interval as a [`guint32`](@ref), the retry interval as a [`guint32`](@ref), the expire timeout as a [`guint32`](@ref), and the TTL as a [`guint32`](@ref).

G\\_RESOLVER\\_RECORD\\_NS records are returned as variants with the signature `(s)`, representing a string of the hostname of the name server.

Since: 2.34
"""
@cenum GResolverRecordType::UInt32 begin
    G_RESOLVER_RECORD_SRV = 1
    G_RESOLVER_RECORD_MX = 2
    G_RESOLVER_RECORD_TXT = 3
    G_RESOLVER_RECORD_SOA = 4
    G_RESOLVER_RECORD_NS = 5
end

"""
    GResourceError

[`GResourceError`](@ref): \\_RESOURCE\\_ERROR\\_NOT\\_FOUND: no file was found at the requested path \\_RESOURCE\\_ERROR\\_INTERNAL: unknown error

An error code used with G\\_RESOURCE\\_ERROR in a #[`GError`](@ref) returned from a #[`GResource`](@ref) routine.

Since: 2.32
"""
@cenum GResourceError::UInt32 begin
    G_RESOURCE_ERROR_NOT_FOUND = 0
    G_RESOURCE_ERROR_INTERNAL = 1
end

"""
    GResourceFlags

[`GResourceFlags`](@ref): \\_RESOURCE\\_FLAGS\\_NONE: No flags set. \\_RESOURCE\\_FLAGS\\_COMPRESSED: The file is compressed.

[`GResourceFlags`](@ref) give information about a particular file inside a resource bundle.

Since: 2.32
"""
@cenum GResourceFlags::UInt32 begin
    G_RESOURCE_FLAGS_NONE = 0
    G_RESOURCE_FLAGS_COMPRESSED = 1
end

"""
    GResourceLookupFlags

[`GResourceLookupFlags`](@ref): \\_RESOURCE\\_LOOKUP\\_FLAGS\\_NONE: No flags set.

[`GResourceLookupFlags`](@ref) determine how resource path lookups are handled.

Since: 2.32
"""
@cenum GResourceLookupFlags::UInt32 begin
    G_RESOURCE_LOOKUP_FLAGS_NONE = 0
end

"""
    GSocketFamily

[`GSocketFamily`](@ref): \\_SOCKET\\_FAMILY\\_INVALID: no address family \\_SOCKET\\_FAMILY\\_IPV4: the IPv4 family \\_SOCKET\\_FAMILY\\_IPV6: the IPv6 family \\_SOCKET\\_FAMILY\\_UNIX: the UNIX domain family

The protocol family of a #[`GSocketAddress`](@ref). (These values are identical to the system defines AF\\_INET, AF\\_INET6 and AF\\_UNIX, if available.)

Since: 2.22
"""
@cenum GSocketFamily::UInt32 begin
    G_SOCKET_FAMILY_INVALID = 0
    G_SOCKET_FAMILY_UNIX = 1
    G_SOCKET_FAMILY_IPV4 = 2
    G_SOCKET_FAMILY_IPV6 = 10
end

"""
    GSocketType

[`GSocketType`](@ref): \\_SOCKET\\_TYPE\\_INVALID: Type unknown or wrong \\_SOCKET\\_TYPE\\_STREAM: Reliable connection-based byte streams (e.g. TCP). \\_SOCKET\\_TYPE\\_DATAGRAM: Connectionless, unreliable datagram passing. (e.g. UDP) \\_SOCKET\\_TYPE\\_SEQPACKET: Reliable connection-based passing of datagrams of fixed maximum length (e.g. SCTP).

Flags used when creating a #[`GSocket`](@ref). Some protocols may not implement all the socket types.

Since: 2.22
"""
@cenum GSocketType::UInt32 begin
    G_SOCKET_TYPE_INVALID = 0
    G_SOCKET_TYPE_STREAM = 1
    G_SOCKET_TYPE_DATAGRAM = 2
    G_SOCKET_TYPE_SEQPACKET = 3
end

"""
    GSocketMsgFlags

[`GSocketMsgFlags`](@ref): \\_SOCKET\\_MSG\\_NONE: No flags. \\_SOCKET\\_MSG\\_OOB: Request to send/receive out of band data. \\_SOCKET\\_MSG\\_PEEK: Read data from the socket without removing it from the queue. \\_SOCKET\\_MSG\\_DONTROUTE: Don't use a gateway to send out the packet, only send to hosts on directly connected networks.

Flags used in [`g_socket_receive_message`](@ref)() and [`g_socket_send_message`](@ref)(). The flags listed in the enum are some commonly available flags, but the values used for them are the same as on the platform, and any other flags are passed in/out as is. So to use a platform specific flag, just include the right system header and pass in the flag.

Since: 2.22
"""
@cenum GSocketMsgFlags::UInt32 begin
    G_SOCKET_MSG_NONE = 0
    G_SOCKET_MSG_OOB = 1
    G_SOCKET_MSG_PEEK = 2
    G_SOCKET_MSG_DONTROUTE = 4
end

"""
    GSocketProtocol

[`GSocketProtocol`](@ref): \\_SOCKET\\_PROTOCOL\\_UNKNOWN: The protocol type is unknown \\_SOCKET\\_PROTOCOL\\_DEFAULT: The default protocol for the family/type \\_SOCKET\\_PROTOCOL\\_TCP: TCP over IP \\_SOCKET\\_PROTOCOL\\_UDP: UDP over IP \\_SOCKET\\_PROTOCOL\\_SCTP: SCTP over IP

A protocol identifier is specified when creating a #[`GSocket`](@ref), which is a family/type specific identifier, where 0 means the default protocol for the particular family/type.

This enum contains a set of commonly available and used protocols. You can also pass any other identifiers handled by the platform in order to use protocols not listed here.

Since: 2.22
"""
@cenum GSocketProtocol::Int32 begin
    G_SOCKET_PROTOCOL_UNKNOWN = -1
    G_SOCKET_PROTOCOL_DEFAULT = 0
    G_SOCKET_PROTOCOL_TCP = 6
    G_SOCKET_PROTOCOL_UDP = 17
    G_SOCKET_PROTOCOL_SCTP = 132
end

"""
    GZlibCompressorFormat

[`GZlibCompressorFormat`](@ref): \\_ZLIB\\_COMPRESSOR\\_FORMAT\\_ZLIB: deflate compression with zlib header \\_ZLIB\\_COMPRESSOR\\_FORMAT\\_GZIP: gzip file format \\_ZLIB\\_COMPRESSOR\\_FORMAT\\_RAW: deflate compression with no header

Used to select the type of data format to use for #[`GZlibDecompressor`](@ref) and #[`GZlibCompressor`](@ref).

Since: 2.24
"""
@cenum GZlibCompressorFormat::UInt32 begin
    G_ZLIB_COMPRESSOR_FORMAT_ZLIB = 0
    G_ZLIB_COMPRESSOR_FORMAT_GZIP = 1
    G_ZLIB_COMPRESSOR_FORMAT_RAW = 2
end

"""
    GUnixSocketAddressType

[`GUnixSocketAddressType`](@ref): \\_UNIX\\_SOCKET\\_ADDRESS\\_INVALID: invalid \\_UNIX\\_SOCKET\\_ADDRESS\\_ANONYMOUS: anonymous \\_UNIX\\_SOCKET\\_ADDRESS\\_PATH: a filesystem path \\_UNIX\\_SOCKET\\_ADDRESS\\_ABSTRACT: an abstract name \\_UNIX\\_SOCKET\\_ADDRESS\\_ABSTRACT\\_PADDED: an abstract name, 0-padded to the full length of a unix socket name

The type of name used by a #[`GUnixSocketAddress`](@ref). G\\_UNIX\\_SOCKET\\_ADDRESS\\_PATH indicates a traditional unix domain socket bound to a filesystem path. G\\_UNIX\\_SOCKET\\_ADDRESS\\_ANONYMOUS indicates a socket not bound to any name (eg, a client-side socket, or a socket created with socketpair()).

For abstract sockets, there are two incompatible ways of naming them; the man pages suggest using the entire `struct sockaddr\\_un` as the name, padding the unused parts of the sun\\_path field with zeroes; this corresponds to G\\_UNIX\\_SOCKET\\_ADDRESS\\_ABSTRACT\\_PADDED. However, many programs instead just use a portion of sun\\_path, and pass an appropriate smaller length to bind() or connect(). This is G\\_UNIX\\_SOCKET\\_ADDRESS\\_ABSTRACT.

Since: 2.26
"""
@cenum GUnixSocketAddressType::UInt32 begin
    G_UNIX_SOCKET_ADDRESS_INVALID = 0
    G_UNIX_SOCKET_ADDRESS_ANONYMOUS = 1
    G_UNIX_SOCKET_ADDRESS_PATH = 2
    G_UNIX_SOCKET_ADDRESS_ABSTRACT = 3
    G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED = 4
end

"""
    GBusType

[`GBusType`](@ref): \\_BUS\\_TYPE\\_STARTER: An alias for the message bus that activated the process, if any. \\_BUS\\_TYPE\\_NONE: Not a message bus. \\_BUS\\_TYPE\\_SYSTEM: The system-wide message bus. \\_BUS\\_TYPE\\_SESSION: The login session message bus.

An enumeration for well-known message buses.

Since: 2.26
"""
@cenum GBusType::Int32 begin
    G_BUS_TYPE_STARTER = -1
    G_BUS_TYPE_NONE = 0
    G_BUS_TYPE_SYSTEM = 1
    G_BUS_TYPE_SESSION = 2
end

"""
    GBusNameOwnerFlags

[`GBusNameOwnerFlags`](@ref): \\_BUS\\_NAME\\_OWNER\\_FLAGS\\_NONE: No flags set. \\_BUS\\_NAME\\_OWNER\\_FLAGS\\_ALLOW\\_REPLACEMENT: Allow another message bus connection to claim the name. \\_BUS\\_NAME\\_OWNER\\_FLAGS\\_REPLACE: If another message bus connection owns the name and have specified G\\_BUS\\_NAME\\_OWNER\\_FLAGS\\_ALLOW\\_REPLACEMENT, then take the name from the other connection.

Flags used in [`g_bus_own_name`](@ref)().

Since: 2.26

G\\_BUS\\_NAME\\_OWNER\\_FLAGS\\_DO\\_NOT\\_QUEUE:

If another message bus connection owns the name, immediately return an error from [func.bus\\_own\\_name] rather than entering the waiting queue for that name.

Since: 2.54
"""
@cenum GBusNameOwnerFlags::UInt32 begin
    G_BUS_NAME_OWNER_FLAGS_NONE = 0
    G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT = 1
    G_BUS_NAME_OWNER_FLAGS_REPLACE = 2
    G_BUS_NAME_OWNER_FLAGS_DO_NOT_QUEUE = 4
end

"""
    GBusNameWatcherFlags

[`GBusNameWatcherFlags`](@ref): \\_BUS\\_NAME\\_WATCHER\\_FLAGS\\_NONE: No flags set. \\_BUS\\_NAME\\_WATCHER\\_FLAGS\\_AUTO\\_START: If no-one owns the name when beginning to watch the name, ask the bus to launch an owner for the name.

Flags used in [`g_bus_watch_name`](@ref)().

Since: 2.26
"""
@cenum GBusNameWatcherFlags::UInt32 begin
    G_BUS_NAME_WATCHER_FLAGS_NONE = 0
    G_BUS_NAME_WATCHER_FLAGS_AUTO_START = 1
end

"""
    GDBusProxyFlags

[`GDBusProxyFlags`](@ref): \\_DBUS\\_PROXY\\_FLAGS\\_NONE: No flags set. \\_DBUS\\_PROXY\\_FLAGS\\_DO\\_NOT\\_LOAD\\_PROPERTIES: Don't load properties. \\_DBUS\\_PROXY\\_FLAGS\\_DO\\_NOT\\_CONNECT\\_SIGNALS: Don't connect to signals on the remote object. \\_DBUS\\_PROXY\\_FLAGS\\_DO\\_NOT\\_AUTO\\_START: If the proxy is for a well-known name, do not ask the bus to launch an owner during proxy initialization or a method call. This flag is only meaningful in proxies for well-known names. \\_DBUS\\_PROXY\\_FLAGS\\_GET\\_INVALIDATED\\_PROPERTIES: If set, the property value for any \\_\\_invalidated property\\_\\_ will be (asynchronously) retrieved upon receiving the [`PropertiesChanged`](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties) D-Bus signal and the property will not cause emission of the #[`GDBusProxy`](@ref)::g-properties-changed signal. When the value is received the #[`GDBusProxy`](@ref)::g-properties-changed signal is emitted for the property along with the retrieved value. Since 2.32. \\_DBUS\\_PROXY\\_FLAGS\\_DO\\_NOT\\_AUTO\\_START\\_AT\\_CONSTRUCTION: If the proxy is for a well-known name, do not ask the bus to launch an owner during proxy initialization, but allow it to be autostarted by a method call. This flag is only meaningful in proxies for well-known names, and only if G\\_DBUS\\_PROXY\\_FLAGS\\_DO\\_NOT\\_AUTO\\_START is not also specified. \\_DBUS\\_PROXY\\_FLAGS\\_NO\\_MATCH\\_RULE: Don't actually send the AddMatch D-Bus call for this signal subscription. This gives you more control over which match rules you add (but you must add them manually). (Since: 2.72)

Flags used when constructing an instance of a #[`GDBusProxy`](@ref) derived class.

Since: 2.26
"""
@cenum GDBusProxyFlags::UInt32 begin
    G_DBUS_PROXY_FLAGS_NONE = 0
    G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES = 1
    G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS = 2
    G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START = 4
    G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES = 8
    G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION = 16
    G_DBUS_PROXY_FLAGS_NO_MATCH_RULE = 32
end

"""
    GDBusError

[`GDBusError`](@ref): \\_DBUS\\_ERROR\\_FAILED: A generic error; "something went wrong" - see the error message for more. \\_DBUS\\_ERROR\\_NO\\_MEMORY: There was not enough memory to complete an operation. \\_DBUS\\_ERROR\\_SERVICE\\_UNKNOWN: The bus doesn't know how to launch a service to supply the bus name you wanted. \\_DBUS\\_ERROR\\_NAME\\_HAS\\_NO\\_OWNER: The bus name you referenced doesn't exist (i.e. no application owns it). \\_DBUS\\_ERROR\\_NO\\_REPLY: No reply to a message expecting one, usually means a timeout occurred. \\_DBUS\\_ERROR\\_IO\\_ERROR: Something went wrong reading or writing to a socket, for example. \\_DBUS\\_ERROR\\_BAD\\_ADDRESS: A D-Bus bus address was malformed. \\_DBUS\\_ERROR\\_NOT\\_SUPPORTED: Requested operation isn't supported (like ENOSYS on UNIX). \\_DBUS\\_ERROR\\_LIMITS\\_EXCEEDED: Some limited resource is exhausted. \\_DBUS\\_ERROR\\_ACCESS\\_DENIED: Security restrictions don't allow doing what you're trying to do. \\_DBUS\\_ERROR\\_AUTH\\_FAILED: Authentication didn't work. \\_DBUS\\_ERROR\\_NO\\_SERVER: Unable to connect to server (probably caused by ECONNREFUSED on a socket). \\_DBUS\\_ERROR\\_TIMEOUT: Certain timeout errors, possibly ETIMEDOUT on a socket. Note that G\\_DBUS\\_ERROR\\_NO\\_REPLY is used for message reply timeouts. Warning: this is confusingly-named given that G\\_DBUS\\_ERROR\\_TIMED\\_OUT also exists. We can't fix it for compatibility reasons so just be careful. \\_DBUS\\_ERROR\\_NO\\_NETWORK: No network access (probably ENETUNREACH on a socket). \\_DBUS\\_ERROR\\_ADDRESS\\_IN\\_USE: Can't bind a socket since its address is in use (i.e. EADDRINUSE). \\_DBUS\\_ERROR\\_DISCONNECTED: The connection is disconnected and you're trying to use it. \\_DBUS\\_ERROR\\_INVALID\\_ARGS: Invalid arguments passed to a method call. \\_DBUS\\_ERROR\\_FILE\\_NOT\\_FOUND: Missing file. \\_DBUS\\_ERROR\\_FILE\\_EXISTS: Existing file and the operation you're using does not silently overwrite. \\_DBUS\\_ERROR\\_UNKNOWN\\_METHOD: Method name you invoked isn't known by the object you invoked it on. \\_DBUS\\_ERROR\\_UNKNOWN\\_OBJECT: Object you invoked a method on isn't known. Since 2.42 \\_DBUS\\_ERROR\\_UNKNOWN\\_INTERFACE: Interface you invoked a method on isn't known by the object. Since 2.42 \\_DBUS\\_ERROR\\_UNKNOWN\\_PROPERTY: Property you tried to access isn't known by the object. Since 2.42 \\_DBUS\\_ERROR\\_PROPERTY\\_READ\\_ONLY: Property you tried to set is read-only. Since 2.42 \\_DBUS\\_ERROR\\_TIMED\\_OUT: Certain timeout errors, e.g. while starting a service. Warning: this is confusingly-named given that G\\_DBUS\\_ERROR\\_TIMEOUT also exists. We can't fix it for compatibility reasons so just be careful. \\_DBUS\\_ERROR\\_MATCH\\_RULE\\_NOT\\_FOUND: Tried to remove or modify a match rule that didn't exist. \\_DBUS\\_ERROR\\_MATCH\\_RULE\\_INVALID: The match rule isn't syntactically valid. \\_DBUS\\_ERROR\\_SPAWN\\_EXEC\\_FAILED: While starting a new process, the exec() call failed. \\_DBUS\\_ERROR\\_SPAWN\\_FORK\\_FAILED: While starting a new process, the fork() call failed. \\_DBUS\\_ERROR\\_SPAWN\\_CHILD\\_EXITED: While starting a new process, the child exited with a status code. \\_DBUS\\_ERROR\\_SPAWN\\_CHILD\\_SIGNALED: While starting a new process, the child exited on a signal. \\_DBUS\\_ERROR\\_SPAWN\\_FAILED: While starting a new process, something went wrong. \\_DBUS\\_ERROR\\_SPAWN\\_SETUP\\_FAILED: We failed to setup the environment correctly. \\_DBUS\\_ERROR\\_SPAWN\\_CONFIG\\_INVALID: We failed to setup the config parser correctly. \\_DBUS\\_ERROR\\_SPAWN\\_SERVICE\\_INVALID: Bus name was not valid. \\_DBUS\\_ERROR\\_SPAWN\\_SERVICE\\_NOT\\_FOUND: Service file not found in system-services directory. \\_DBUS\\_ERROR\\_SPAWN\\_PERMISSIONS\\_INVALID: Permissions are incorrect on the setuid helper. \\_DBUS\\_ERROR\\_SPAWN\\_FILE\\_INVALID: Service file invalid (Name, User or Exec missing). \\_DBUS\\_ERROR\\_SPAWN\\_NO\\_MEMORY: Tried to get a UNIX process ID and it wasn't available. \\_DBUS\\_ERROR\\_UNIX\\_PROCESS\\_ID\\_UNKNOWN: Tried to get a UNIX process ID and it wasn't available. \\_DBUS\\_ERROR\\_INVALID\\_SIGNATURE: A type signature is not valid. \\_DBUS\\_ERROR\\_INVALID\\_FILE\\_CONTENT: A file contains invalid syntax or is otherwise broken. \\_DBUS\\_ERROR\\_SELINUX\\_SECURITY\\_CONTEXT\\_UNKNOWN: Asked for SELinux security context and it wasn't available. \\_DBUS\\_ERROR\\_ADT\\_AUDIT\\_DATA\\_UNKNOWN: Asked for ADT audit data and it wasn't available. \\_DBUS\\_ERROR\\_OBJECT\\_PATH\\_IN\\_USE: There's already an object with the requested object path.

Error codes for the G\\_DBUS\\_ERROR error domain.

Since: 2.26
"""
@cenum GDBusError::UInt32 begin
    G_DBUS_ERROR_FAILED = 0
    G_DBUS_ERROR_NO_MEMORY = 1
    G_DBUS_ERROR_SERVICE_UNKNOWN = 2
    G_DBUS_ERROR_NAME_HAS_NO_OWNER = 3
    G_DBUS_ERROR_NO_REPLY = 4
    G_DBUS_ERROR_IO_ERROR = 5
    G_DBUS_ERROR_BAD_ADDRESS = 6
    G_DBUS_ERROR_NOT_SUPPORTED = 7
    G_DBUS_ERROR_LIMITS_EXCEEDED = 8
    G_DBUS_ERROR_ACCESS_DENIED = 9
    G_DBUS_ERROR_AUTH_FAILED = 10
    G_DBUS_ERROR_NO_SERVER = 11
    G_DBUS_ERROR_TIMEOUT = 12
    G_DBUS_ERROR_NO_NETWORK = 13
    G_DBUS_ERROR_ADDRESS_IN_USE = 14
    G_DBUS_ERROR_DISCONNECTED = 15
    G_DBUS_ERROR_INVALID_ARGS = 16
    G_DBUS_ERROR_FILE_NOT_FOUND = 17
    G_DBUS_ERROR_FILE_EXISTS = 18
    G_DBUS_ERROR_UNKNOWN_METHOD = 19
    G_DBUS_ERROR_TIMED_OUT = 20
    G_DBUS_ERROR_MATCH_RULE_NOT_FOUND = 21
    G_DBUS_ERROR_MATCH_RULE_INVALID = 22
    G_DBUS_ERROR_SPAWN_EXEC_FAILED = 23
    G_DBUS_ERROR_SPAWN_FORK_FAILED = 24
    G_DBUS_ERROR_SPAWN_CHILD_EXITED = 25
    G_DBUS_ERROR_SPAWN_CHILD_SIGNALED = 26
    G_DBUS_ERROR_SPAWN_FAILED = 27
    G_DBUS_ERROR_SPAWN_SETUP_FAILED = 28
    G_DBUS_ERROR_SPAWN_CONFIG_INVALID = 29
    G_DBUS_ERROR_SPAWN_SERVICE_INVALID = 30
    G_DBUS_ERROR_SPAWN_SERVICE_NOT_FOUND = 31
    G_DBUS_ERROR_SPAWN_PERMISSIONS_INVALID = 32
    G_DBUS_ERROR_SPAWN_FILE_INVALID = 33
    G_DBUS_ERROR_SPAWN_NO_MEMORY = 34
    G_DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN = 35
    G_DBUS_ERROR_INVALID_SIGNATURE = 36
    G_DBUS_ERROR_INVALID_FILE_CONTENT = 37
    G_DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN = 38
    G_DBUS_ERROR_ADT_AUDIT_DATA_UNKNOWN = 39
    G_DBUS_ERROR_OBJECT_PATH_IN_USE = 40
    G_DBUS_ERROR_UNKNOWN_OBJECT = 41
    G_DBUS_ERROR_UNKNOWN_INTERFACE = 42
    G_DBUS_ERROR_UNKNOWN_PROPERTY = 43
    G_DBUS_ERROR_PROPERTY_READ_ONLY = 44
end

"""
    GDBusConnectionFlags

[`GDBusConnectionFlags`](@ref): \\_DBUS\\_CONNECTION\\_FLAGS\\_NONE: No flags set. \\_DBUS\\_CONNECTION\\_FLAGS\\_AUTHENTICATION\\_CLIENT: Perform authentication against server. \\_DBUS\\_CONNECTION\\_FLAGS\\_AUTHENTICATION\\_SERVER: Perform authentication against client. \\_DBUS\\_CONNECTION\\_FLAGS\\_AUTHENTICATION\\_ALLOW\\_ANONYMOUS: When authenticating as a server, allow the anonymous authentication method. \\_DBUS\\_CONNECTION\\_FLAGS\\_MESSAGE\\_BUS\\_CONNECTION: Pass this flag if connecting to a peer that is a message bus. This means that the Hello() method will be invoked as part of the connection setup. \\_DBUS\\_CONNECTION\\_FLAGS\\_DELAY\\_MESSAGE\\_PROCESSING: If set, processing of D-Bus messages is delayed until [`g_dbus_connection_start_message_processing`](@ref)() is called. \\_DBUS\\_CONNECTION\\_FLAGS\\_AUTHENTICATION\\_REQUIRE\\_SAME\\_USER: When authenticating as a server, require the UID of the peer to be the same as the UID of the server. (Since: 2.68) \\_DBUS\\_CONNECTION\\_FLAGS\\_CROSS\\_NAMESPACE: When authenticating, try to use protocols that work across a Linux user namespace boundary, even if this reduces interoperability with older D-Bus implementations. This currently affects client-side `EXTERNAL` authentication, for which this flag makes connections to a server in another user namespace succeed, but causes a deadlock when connecting to a GDBus server older than 2.73.3. Since: 2.74

Flags used when creating a new #[`GDBusConnection`](@ref).

Since: 2.26
"""
@cenum GDBusConnectionFlags::UInt32 begin
    G_DBUS_CONNECTION_FLAGS_NONE = 0
    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT = 1
    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER = 2
    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS = 4
    G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION = 8
    G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING = 16
    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER = 32
    G_DBUS_CONNECTION_FLAGS_CROSS_NAMESPACE = 64
end

"""
    GDBusCapabilityFlags

[`GDBusCapabilityFlags`](@ref): \\_DBUS\\_CAPABILITY\\_FLAGS\\_NONE: No flags set. \\_DBUS\\_CAPABILITY\\_FLAGS\\_UNIX\\_FD\\_PASSING: The connection supports exchanging UNIX file descriptors with the remote peer.

Capabilities negotiated with the remote peer.

Since: 2.26
"""
@cenum GDBusCapabilityFlags::UInt32 begin
    G_DBUS_CAPABILITY_FLAGS_NONE = 0
    G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING = 1
end

"""
    GDBusCallFlags

[`GDBusCallFlags`](@ref): \\_DBUS\\_CALL\\_FLAGS\\_NONE: No flags set. \\_DBUS\\_CALL\\_FLAGS\\_NO\\_AUTO\\_START: The bus must not launch an owner for the destination name in response to this method invocation. \\_DBUS\\_CALL\\_FLAGS\\_ALLOW\\_INTERACTIVE\\_AUTHORIZATION: the caller is prepared to wait for interactive authorization. Since 2.46.

Flags used in [`g_dbus_connection_call`](@ref)() and similar APIs.

Since: 2.26
"""
@cenum GDBusCallFlags::UInt32 begin
    G_DBUS_CALL_FLAGS_NONE = 0
    G_DBUS_CALL_FLAGS_NO_AUTO_START = 1
    G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION = 2
end

"""
    GDBusMessageType

[`GDBusMessageType`](@ref): \\_DBUS\\_MESSAGE\\_TYPE\\_INVALID: Message is of invalid type. \\_DBUS\\_MESSAGE\\_TYPE\\_METHOD\\_CALL: Method call. \\_DBUS\\_MESSAGE\\_TYPE\\_METHOD\\_RETURN: Method reply. \\_DBUS\\_MESSAGE\\_TYPE\\_ERROR: Error reply. \\_DBUS\\_MESSAGE\\_TYPE\\_SIGNAL: Signal emission.

Message types used in #[`GDBusMessage`](@ref).

Since: 2.26
"""
@cenum GDBusMessageType::UInt32 begin
    G_DBUS_MESSAGE_TYPE_INVALID = 0
    G_DBUS_MESSAGE_TYPE_METHOD_CALL = 1
    G_DBUS_MESSAGE_TYPE_METHOD_RETURN = 2
    G_DBUS_MESSAGE_TYPE_ERROR = 3
    G_DBUS_MESSAGE_TYPE_SIGNAL = 4
end

"""
    GDBusMessageFlags

[`GDBusMessageFlags`](@ref): \\_DBUS\\_MESSAGE\\_FLAGS\\_NONE: No flags set. \\_DBUS\\_MESSAGE\\_FLAGS\\_NO\\_REPLY\\_EXPECTED: A reply is not expected. \\_DBUS\\_MESSAGE\\_FLAGS\\_NO\\_AUTO\\_START: The bus must not launch an owner for the destination name in response to this message. \\_DBUS\\_MESSAGE\\_FLAGS\\_ALLOW\\_INTERACTIVE\\_AUTHORIZATION: If set on a method call, this flag means that the caller is prepared to wait for interactive authorization. Since 2.46.

Message flags used in #[`GDBusMessage`](@ref).

Since: 2.26
"""
@cenum GDBusMessageFlags::UInt32 begin
    G_DBUS_MESSAGE_FLAGS_NONE = 0
    G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED = 1
    G_DBUS_MESSAGE_FLAGS_NO_AUTO_START = 2
    G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION = 4
end

"""
    GDBusMessageHeaderField

[`GDBusMessageHeaderField`](@ref): \\_DBUS\\_MESSAGE\\_HEADER\\_FIELD\\_INVALID: Not a valid header field. \\_DBUS\\_MESSAGE\\_HEADER\\_FIELD\\_PATH: The object path. \\_DBUS\\_MESSAGE\\_HEADER\\_FIELD\\_INTERFACE: The interface name. \\_DBUS\\_MESSAGE\\_HEADER\\_FIELD\\_MEMBER: The method or signal name. \\_DBUS\\_MESSAGE\\_HEADER\\_FIELD\\_ERROR\\_NAME: The name of the error that occurred. \\_DBUS\\_MESSAGE\\_HEADER\\_FIELD\\_REPLY\\_SERIAL: The serial number the message is a reply to. \\_DBUS\\_MESSAGE\\_HEADER\\_FIELD\\_DESTINATION: The name the message is intended for. \\_DBUS\\_MESSAGE\\_HEADER\\_FIELD\\_SENDER: Unique name of the sender of the message (filled in by the bus). \\_DBUS\\_MESSAGE\\_HEADER\\_FIELD\\_SIGNATURE: The signature of the message body. \\_DBUS\\_MESSAGE\\_HEADER\\_FIELD\\_NUM\\_UNIX\\_FDS: The number of UNIX file descriptors that accompany the message.

Header fields used in #[`GDBusMessage`](@ref).

Since: 2.26
"""
@cenum GDBusMessageHeaderField::UInt32 begin
    G_DBUS_MESSAGE_HEADER_FIELD_INVALID = 0
    G_DBUS_MESSAGE_HEADER_FIELD_PATH = 1
    G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE = 2
    G_DBUS_MESSAGE_HEADER_FIELD_MEMBER = 3
    G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME = 4
    G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL = 5
    G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION = 6
    G_DBUS_MESSAGE_HEADER_FIELD_SENDER = 7
    G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE = 8
    G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS = 9
end

"""
    GDBusPropertyInfoFlags

[`GDBusPropertyInfoFlags`](@ref): \\_DBUS\\_PROPERTY\\_INFO\\_FLAGS\\_NONE: No flags set. \\_DBUS\\_PROPERTY\\_INFO\\_FLAGS\\_READABLE: Property is readable. \\_DBUS\\_PROPERTY\\_INFO\\_FLAGS\\_WRITABLE: Property is writable.

Flags describing the access control of a D-Bus property.

Since: 2.26
"""
@cenum GDBusPropertyInfoFlags::UInt32 begin
    G_DBUS_PROPERTY_INFO_FLAGS_NONE = 0
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE = 1
    G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE = 2
end

"""
    GDBusSubtreeFlags

[`GDBusSubtreeFlags`](@ref): \\_DBUS\\_SUBTREE\\_FLAGS\\_NONE: No flags set. \\_DBUS\\_SUBTREE\\_FLAGS\\_DISPATCH\\_TO\\_UNENUMERATED\\_NODES: Method calls to objects not in the enumerated range will still be dispatched. This is useful if you want to dynamically spawn objects in the subtree.

Flags passed to [`g_dbus_connection_register_subtree`](@ref)().

Since: 2.26
"""
@cenum GDBusSubtreeFlags::UInt32 begin
    G_DBUS_SUBTREE_FLAGS_NONE = 0
    G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES = 1
end

"""
    GDBusServerFlags

[`GDBusServerFlags`](@ref): \\_DBUS\\_SERVER\\_FLAGS\\_NONE: No flags set. \\_DBUS\\_SERVER\\_FLAGS\\_RUN\\_IN\\_THREAD: All #[`GDBusServer`](@ref)::new-connection signals will run in separated dedicated threads (see signal for details). \\_DBUS\\_SERVER\\_FLAGS\\_AUTHENTICATION\\_ALLOW\\_ANONYMOUS: Allow the anonymous authentication method. \\_DBUS\\_SERVER\\_FLAGS\\_AUTHENTICATION\\_REQUIRE\\_SAME\\_USER: Require the UID of the peer to be the same as the UID of the server when authenticating. (Since: 2.68)

Flags used when creating a #[`GDBusServer`](@ref).

Since: 2.26
"""
@cenum GDBusServerFlags::UInt32 begin
    G_DBUS_SERVER_FLAGS_NONE = 0
    G_DBUS_SERVER_FLAGS_RUN_IN_THREAD = 1
    G_DBUS_SERVER_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS = 2
    G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER = 4
end

"""
    GDBusSignalFlags

[`GDBusSignalFlags`](@ref): \\_DBUS\\_SIGNAL\\_FLAGS\\_NONE: No flags set. \\_DBUS\\_SIGNAL\\_FLAGS\\_NO\\_MATCH\\_RULE: Don't actually send the AddMatch D-Bus call for this signal subscription. This gives you more control over which match rules you add (but you must add them manually). \\_DBUS\\_SIGNAL\\_FLAGS\\_MATCH\\_ARG0\\_NAMESPACE: Match first arguments that contain a bus or interface name with the given namespace. \\_DBUS\\_SIGNAL\\_FLAGS\\_MATCH\\_ARG0\\_PATH: Match first arguments that contain an object path that is either equivalent to the given path, or one of the paths is a subpath of the other.

Flags used when subscribing to signals via [`g_dbus_connection_signal_subscribe`](@ref)().

Since: 2.26
"""
@cenum GDBusSignalFlags::UInt32 begin
    G_DBUS_SIGNAL_FLAGS_NONE = 0
    G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE = 1
    G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE = 2
    G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH = 4
end

"""
    GDBusSendMessageFlags

[`GDBusSendMessageFlags`](@ref): \\_DBUS\\_SEND\\_MESSAGE\\_FLAGS\\_NONE: No flags set. \\_DBUS\\_SEND\\_MESSAGE\\_FLAGS\\_PRESERVE\\_SERIAL: Do not automatically assign a serial number from the #[`GDBusConnection`](@ref) object when sending a message.

Flags used when sending #GDBusMessages on a #[`GDBusConnection`](@ref).

Since: 2.26
"""
@cenum GDBusSendMessageFlags::UInt32 begin
    G_DBUS_SEND_MESSAGE_FLAGS_NONE = 0
    G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL = 1
end

"""
    GCredentialsType

[`GCredentialsType`](@ref): \\_CREDENTIALS\\_TYPE\\_INVALID: Indicates an invalid native credential type. \\_CREDENTIALS\\_TYPE\\_LINUX\\_UCRED: The native credentials type is a `struct ucred`. \\_CREDENTIALS\\_TYPE\\_FREEBSD\\_CMSGCRED: The native credentials type is a `struct cmsgcred`. \\_CREDENTIALS\\_TYPE\\_OPENBSD\\_SOCKPEERCRED: The native credentials type is a `struct sockpeercred`. Added in 2.30. \\_CREDENTIALS\\_TYPE\\_SOLARIS\\_UCRED: The native credentials type is a `ucred_t`. Added in 2.40. \\_CREDENTIALS\\_TYPE\\_NETBSD\\_UNPCBID: The native credentials type is a `struct unpcbid`. Added in 2.42. \\_CREDENTIALS\\_TYPE\\_APPLE\\_XUCRED: The native credentials type is a `struct xucred`. Added in 2.66. \\_CREDENTIALS\\_TYPE\\_WIN32\\_PID: The native credentials type is a PID `DWORD`. Added in 2.72.

Enumeration describing different kinds of native credential types.

Since: 2.26
"""
@cenum GCredentialsType::UInt32 begin
    G_CREDENTIALS_TYPE_INVALID = 0
    G_CREDENTIALS_TYPE_LINUX_UCRED = 1
    G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED = 2
    G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED = 3
    G_CREDENTIALS_TYPE_SOLARIS_UCRED = 4
    G_CREDENTIALS_TYPE_NETBSD_UNPCBID = 5
    G_CREDENTIALS_TYPE_APPLE_XUCRED = 6
    G_CREDENTIALS_TYPE_WIN32_PID = 7
end

"""
    GDBusMessageByteOrder

[`GDBusMessageByteOrder`](@ref): \\_DBUS\\_MESSAGE\\_BYTE\\_ORDER\\_BIG\\_ENDIAN: The byte order is big endian. \\_DBUS\\_MESSAGE\\_BYTE\\_ORDER\\_LITTLE\\_ENDIAN: The byte order is little endian.

Enumeration used to describe the byte order of a D-Bus message.

Since: 2.26
"""
@cenum GDBusMessageByteOrder::UInt32 begin
    G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN = 66
    G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN = 108
end

"""
    GApplicationFlags

[`GApplicationFlags`](@ref): \\_APPLICATION\\_IS\\_SERVICE: Run as a service. In this mode, registration fails if the service is already running, and the application will initially wait up to 10 seconds for an initial activation message to arrive. \\_APPLICATION\\_IS\\_LAUNCHER: Don't try to become the primary instance. \\_APPLICATION\\_HANDLES\\_OPEN: This application handles opening files (in the primary instance). Note that this flag only affects the default implementation of local\\_command\\_line(), and has no effect if G\\_APPLICATION\\_HANDLES\\_COMMAND\\_LINE is given. See [`g_application_run`](@ref)() for details. \\_APPLICATION\\_HANDLES\\_COMMAND\\_LINE: This application handles command line arguments (in the primary instance). Note that this flag only affect the default implementation of local\\_command\\_line(). See [`g_application_run`](@ref)() for details. \\_APPLICATION\\_SEND\\_ENVIRONMENT: Send the environment of the launching process to the primary instance. Set this flag if your application is expected to behave differently depending on certain environment variables. For instance, an editor might be expected to use the `GIT_COMMITTER_NAME` environment variable when editing a git commit message. The environment is available to the #[`GApplication`](@ref)::command-line signal handler, via [`g_application_command_line_getenv`](@ref)(). \\_APPLICATION\\_NON\\_UNIQUE: Make no attempts to do any of the typical single-instance application negotiation, even if the application ID is given. The application neither attempts to become the owner of the application ID nor does it check if an existing owner already exists. Everything occurs in the local process. Since: 2.30. \\_APPLICATION\\_CAN\\_OVERRIDE\\_APP\\_ID: Allow users to override the application ID from the command line with `--gapplication-app-id`. Since: 2.48 \\_APPLICATION\\_ALLOW\\_REPLACEMENT: Allow another instance to take over the bus name. Since: 2.60 \\_APPLICATION\\_REPLACE: Take over from another instance. This flag is usually set by passing `--gapplication-replace` on the commandline. Since: 2.60

Flags used to define the behaviour of a #[`GApplication`](@ref).

Since: 2.28

G\\_APPLICATION\\_FLAGS\\_NONE:

Default flags.

Deprecated: 2.74: Use [flags.ApplicationFlags.DEFAULT\\_FLAGS].

G\\_APPLICATION\\_DEFAULT\\_FLAGS:

Default flags.

Since: 2.74
"""
@cenum GApplicationFlags::UInt32 begin
    G_APPLICATION_FLAGS_NONE = 0
    G_APPLICATION_DEFAULT_FLAGS = 0
    G_APPLICATION_IS_SERVICE = 1
    G_APPLICATION_IS_LAUNCHER = 2
    G_APPLICATION_HANDLES_OPEN = 4
    G_APPLICATION_HANDLES_COMMAND_LINE = 8
    G_APPLICATION_SEND_ENVIRONMENT = 16
    G_APPLICATION_NON_UNIQUE = 32
    G_APPLICATION_CAN_OVERRIDE_APP_ID = 64
    G_APPLICATION_ALLOW_REPLACEMENT = 128
    G_APPLICATION_REPLACE = 256
end

"""
    GTlsError

[`GTlsError`](@ref): \\_TLS\\_ERROR\\_UNAVAILABLE: No TLS provider is available \\_TLS\\_ERROR\\_MISC: Miscellaneous TLS error \\_TLS\\_ERROR\\_BAD\\_CERTIFICATE: The certificate presented could not be parsed or failed validation. \\_TLS\\_ERROR\\_NOT\\_TLS: The TLS handshake failed because the peer does not seem to be a TLS server. \\_TLS\\_ERROR\\_HANDSHAKE: The TLS handshake failed because the peer's certificate was not acceptable. \\_TLS\\_ERROR\\_CERTIFICATE\\_REQUIRED: The TLS handshake failed because the server requested a client-side certificate, but none was provided. See [`g_tls_connection_set_certificate`](@ref)(). \\_TLS\\_ERROR\\_EOF: The TLS connection was closed without proper notice, which may indicate an attack. See [`g_tls_connection_set_require_close_notify`](@ref)(). \\_TLS\\_ERROR\\_INAPPROPRIATE\\_FALLBACK: The TLS handshake failed because the client sent the fallback SCSV, indicating a protocol downgrade attack. Since: 2.60 \\_TLS\\_ERROR\\_BAD\\_CERTIFICATE\\_PASSWORD: The certificate failed to load because a password was incorrect. Since: 2.72

An error code used with G\\_TLS\\_ERROR in a #[`GError`](@ref) returned from a TLS-related routine.

Since: 2.28
"""
@cenum GTlsError::UInt32 begin
    G_TLS_ERROR_UNAVAILABLE = 0
    G_TLS_ERROR_MISC = 1
    G_TLS_ERROR_BAD_CERTIFICATE = 2
    G_TLS_ERROR_NOT_TLS = 3
    G_TLS_ERROR_HANDSHAKE = 4
    G_TLS_ERROR_CERTIFICATE_REQUIRED = 5
    G_TLS_ERROR_EOF = 6
    G_TLS_ERROR_INAPPROPRIATE_FALLBACK = 7
    G_TLS_ERROR_BAD_CERTIFICATE_PASSWORD = 8
end

"""
    GTlsCertificateFlags

[`GTlsCertificateFlags`](@ref): \\_TLS\\_CERTIFICATE\\_NO\\_FLAGS: No flags set. Since: 2.74 \\_TLS\\_CERTIFICATE\\_UNKNOWN\\_CA: The signing certificate authority is not known. \\_TLS\\_CERTIFICATE\\_BAD\\_IDENTITY: The certificate does not match the expected identity of the site that it was retrieved from. \\_TLS\\_CERTIFICATE\\_NOT\\_ACTIVATED: The certificate's activation time is still in the future \\_TLS\\_CERTIFICATE\\_EXPIRED: The certificate has expired \\_TLS\\_CERTIFICATE\\_REVOKED: The certificate has been revoked according to the #[`GTlsConnection`](@ref)'s certificate revocation list. \\_TLS\\_CERTIFICATE\\_INSECURE: The certificate's algorithm is considered insecure. \\_TLS\\_CERTIFICATE\\_GENERIC\\_ERROR: Some other error occurred validating the certificate \\_TLS\\_CERTIFICATE\\_VALIDATE\\_ALL: the combination of all of the above flags

A set of flags describing TLS certification validation. This can be used to describe why a particular certificate was rejected (for example, in #[`GTlsConnection`](@ref)::accept-certificate).

GLib guarantees that if certificate verification fails, at least one flag will be set, but it does not guarantee that all possible flags will be set. Accordingly, you may not safely decide to ignore any particular type of error. For example, it would be incorrect to mask G\\_TLS\\_CERTIFICATE\\_EXPIRED if you want to allow expired certificates, because this could potentially be the only error flag set even if other problems exist with the certificate.

Since: 2.28
"""
@cenum GTlsCertificateFlags::UInt32 begin
    G_TLS_CERTIFICATE_NO_FLAGS = 0
    G_TLS_CERTIFICATE_UNKNOWN_CA = 1
    G_TLS_CERTIFICATE_BAD_IDENTITY = 2
    G_TLS_CERTIFICATE_NOT_ACTIVATED = 4
    G_TLS_CERTIFICATE_EXPIRED = 8
    G_TLS_CERTIFICATE_REVOKED = 16
    G_TLS_CERTIFICATE_INSECURE = 32
    G_TLS_CERTIFICATE_GENERIC_ERROR = 64
    G_TLS_CERTIFICATE_VALIDATE_ALL = 127
end

"""
    GTlsAuthenticationMode

[`GTlsAuthenticationMode`](@ref): \\_TLS\\_AUTHENTICATION\\_NONE: client authentication not required \\_TLS\\_AUTHENTICATION\\_REQUESTED: client authentication is requested \\_TLS\\_AUTHENTICATION\\_REQUIRED: client authentication is required

The client authentication mode for a #[`GTlsServerConnection`](@ref).

Since: 2.28
"""
@cenum GTlsAuthenticationMode::UInt32 begin
    G_TLS_AUTHENTICATION_NONE = 0
    G_TLS_AUTHENTICATION_REQUESTED = 1
    G_TLS_AUTHENTICATION_REQUIRED = 2
end

"""
    GTlsChannelBindingType

[`GTlsChannelBindingType`](@ref): \\_TLS\\_CHANNEL\\_BINDING\\_TLS\\_UNIQUE: [`tls-unique`](https://tools.ietf.org/html/rfc5929#section-3) binding type \\_TLS\\_CHANNEL\\_BINDING\\_TLS\\_SERVER\\_END\\_POINT: [`tls-server-end-point`](https://tools.ietf.org/html/rfc5929#section-4) binding type \\_TLS\\_CHANNEL\\_BINDING\\_TLS\\_EXPORTER: [`tls-exporter`](https://www.rfc-editor.org/rfc/rfc9266.html) binding type. Since: 2.74

The type of TLS channel binding data to retrieve from #[`GTlsConnection`](@ref) or #[`GDtlsConnection`](@ref), as documented by RFC 5929 or RFC 9266. The [`tls-unique-for-telnet`](https://tools.ietf.org/html/rfc5929#section-5) binding type is not currently implemented.

Since: 2.66
"""
@cenum GTlsChannelBindingType::UInt32 begin
    G_TLS_CHANNEL_BINDING_TLS_UNIQUE = 0
    G_TLS_CHANNEL_BINDING_TLS_SERVER_END_POINT = 1
    G_TLS_CHANNEL_BINDING_TLS_EXPORTER = 2
end

"""
    GTlsChannelBindingError

[`GTlsChannelBindingError`](@ref): \\_TLS\\_CHANNEL\\_BINDING\\_ERROR\\_NOT\\_IMPLEMENTED: Either entire binding retrieval facility or specific binding type is not implemented in the TLS backend. \\_TLS\\_CHANNEL\\_BINDING\\_ERROR\\_INVALID\\_STATE: The handshake is not yet complete on the connection which is a strong requirement for any existing binding type. \\_TLS\\_CHANNEL\\_BINDING\\_ERROR\\_NOT\\_AVAILABLE: Handshake is complete but binding data is not available. That normally indicates the TLS implementation failed to provide the binding data. For example, some implementations do not provide a peer certificate for resumed connections. \\_TLS\\_CHANNEL\\_BINDING\\_ERROR\\_NOT\\_SUPPORTED: Binding type is not supported on the current connection. This error could be triggered when requesting `tls-server-end-point` binding data for a certificate which has no hash function or uses multiple hash functions. \\_TLS\\_CHANNEL\\_BINDING\\_ERROR\\_GENERAL\\_ERROR: Any other backend error preventing binding data retrieval.

An error code used with G\\_TLS\\_CHANNEL\\_BINDING\\_ERROR in a #[`GError`](@ref) to indicate a TLS channel binding retrieval error.

Since: 2.66
"""
@cenum GTlsChannelBindingError::UInt32 begin
    G_TLS_CHANNEL_BINDING_ERROR_NOT_IMPLEMENTED = 0
    G_TLS_CHANNEL_BINDING_ERROR_INVALID_STATE = 1
    G_TLS_CHANNEL_BINDING_ERROR_NOT_AVAILABLE = 2
    G_TLS_CHANNEL_BINDING_ERROR_NOT_SUPPORTED = 3
    G_TLS_CHANNEL_BINDING_ERROR_GENERAL_ERROR = 4
end

"""
    GTlsRehandshakeMode

[`GTlsRehandshakeMode`](@ref): \\_TLS\\_REHANDSHAKE\\_NEVER: Never allow rehandshaking \\_TLS\\_REHANDSHAKE\\_SAFELY: Allow safe rehandshaking only \\_TLS\\_REHANDSHAKE\\_UNSAFELY: Allow unsafe rehandshaking

When to allow rehandshaking. See [`g_tls_connection_set_rehandshake_mode`](@ref)().

Since: 2.28

Deprecated: 2.60. Changing the rehandshake mode is no longer required for compatibility. Also, rehandshaking has been removed from the TLS protocol in TLS 1.3.
"""
@cenum GTlsRehandshakeMode::UInt32 begin
    G_TLS_REHANDSHAKE_NEVER = 0
    G_TLS_REHANDSHAKE_SAFELY = 1
    G_TLS_REHANDSHAKE_UNSAFELY = 2
end

"""
    _GTlsPasswordFlags

[`GTlsPasswordFlags`](@ref): \\_TLS\\_PASSWORD\\_NONE: No flags \\_TLS\\_PASSWORD\\_RETRY: The password was wrong, and the user should retry. \\_TLS\\_PASSWORD\\_MANY\\_TRIES: Hint to the user that the password has been wrong many times, and the user may not have many chances left. \\_TLS\\_PASSWORD\\_FINAL\\_TRY: Hint to the user that this is the last try to get this password right. \\_TLS\\_PASSWORD\\_PKCS11\\_USER: For PKCS #11, the user PIN is required. Since: 2.70. \\_TLS\\_PASSWORD\\_PKCS11\\_SECURITY\\_OFFICER: For PKCS #11, the security officer PIN is required. Since: 2.70. \\_TLS\\_PASSWORD\\_PKCS11\\_CONTEXT\\_SPECIFIC: For PKCS #11, the context-specific PIN is required. Since: 2.70.

Various flags for the password.

Since: 2.30
"""
@cenum _GTlsPasswordFlags::UInt32 begin
    G_TLS_PASSWORD_NONE = 0
    G_TLS_PASSWORD_RETRY = 2
    G_TLS_PASSWORD_MANY_TRIES = 4
    G_TLS_PASSWORD_FINAL_TRY = 8
    G_TLS_PASSWORD_PKCS11_USER = 16
    G_TLS_PASSWORD_PKCS11_SECURITY_OFFICER = 32
    G_TLS_PASSWORD_PKCS11_CONTEXT_SPECIFIC = 64
end

"""
[`GTlsPasswordFlags`](@ref): \\_TLS\\_PASSWORD\\_NONE: No flags \\_TLS\\_PASSWORD\\_RETRY: The password was wrong, and the user should retry. \\_TLS\\_PASSWORD\\_MANY\\_TRIES: Hint to the user that the password has been wrong many times, and the user may not have many chances left. \\_TLS\\_PASSWORD\\_FINAL\\_TRY: Hint to the user that this is the last try to get this password right. \\_TLS\\_PASSWORD\\_PKCS11\\_USER: For PKCS #11, the user PIN is required. Since: 2.70. \\_TLS\\_PASSWORD\\_PKCS11\\_SECURITY\\_OFFICER: For PKCS #11, the security officer PIN is required. Since: 2.70. \\_TLS\\_PASSWORD\\_PKCS11\\_CONTEXT\\_SPECIFIC: For PKCS #11, the context-specific PIN is required. Since: 2.70.

Various flags for the password.

Since: 2.30
"""
const GTlsPasswordFlags = _GTlsPasswordFlags

"""
    GTlsInteractionResult

[`GTlsInteractionResult`](@ref): \\_TLS\\_INTERACTION\\_UNHANDLED: The interaction was unhandled (i.e. not implemented). \\_TLS\\_INTERACTION\\_HANDLED: The interaction completed, and resulting data is available. \\_TLS\\_INTERACTION\\_FAILED: The interaction has failed, or was cancelled. and the operation should be aborted.

#[`GTlsInteractionResult`](@ref) is returned by various functions in #[`GTlsInteraction`](@ref) when finishing an interaction request.

Since: 2.30
"""
@cenum GTlsInteractionResult::UInt32 begin
    G_TLS_INTERACTION_UNHANDLED = 0
    G_TLS_INTERACTION_HANDLED = 1
    G_TLS_INTERACTION_FAILED = 2
end

"""
    GDBusInterfaceSkeletonFlags

[`GDBusInterfaceSkeletonFlags`](@ref): \\_DBUS\\_INTERFACE\\_SKELETON\\_FLAGS\\_NONE: No flags set. \\_DBUS\\_INTERFACE\\_SKELETON\\_FLAGS\\_HANDLE\\_METHOD\\_INVOCATIONS\\_IN\\_THREAD: Each method invocation is handled in a thread dedicated to the invocation. This means that the method implementation can use blocking IO without blocking any other part of the process. It also means that the method implementation must use locking to access data structures used by other threads.

Flags describing the behavior of a #[`GDBusInterfaceSkeleton`](@ref) instance.

Since: 2.30
"""
@cenum GDBusInterfaceSkeletonFlags::UInt32 begin
    G_DBUS_INTERFACE_SKELETON_FLAGS_NONE = 0
    G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD = 1
end

"""
    GDBusObjectManagerClientFlags

[`GDBusObjectManagerClientFlags`](@ref): \\_DBUS\\_OBJECT\\_MANAGER\\_CLIENT\\_FLAGS\\_NONE: No flags set. \\_DBUS\\_OBJECT\\_MANAGER\\_CLIENT\\_FLAGS\\_DO\\_NOT\\_AUTO\\_START: If not set and the manager is for a well-known name, then request the bus to launch an owner for the name if no-one owns the name. This flag can only be used in managers for well-known names.

Flags used when constructing a #[`GDBusObjectManagerClient`](@ref).

Since: 2.30
"""
@cenum GDBusObjectManagerClientFlags::UInt32 begin
    G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE = 0
    G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START = 1
end

"""
    GTlsDatabaseVerifyFlags

[`GTlsDatabaseVerifyFlags`](@ref): \\_TLS\\_DATABASE\\_VERIFY\\_NONE: No verification flags

Flags for [`g_tls_database_verify_chain`](@ref)().

Since: 2.30
"""
@cenum GTlsDatabaseVerifyFlags::UInt32 begin
    G_TLS_DATABASE_VERIFY_NONE = 0
end

"""
    GTlsDatabaseLookupFlags

[`GTlsDatabaseLookupFlags`](@ref): \\_TLS\\_DATABASE\\_LOOKUP\\_NONE: No lookup flags \\_TLS\\_DATABASE\\_LOOKUP\\_KEYPAIR: Restrict lookup to certificates that have a private key.

Flags for [`g_tls_database_lookup_certificate_for_handle`](@ref)(), [`g_tls_database_lookup_certificate_issuer`](@ref)(), and [`g_tls_database_lookup_certificates_issued_by`](@ref)().

Since: 2.30
"""
@cenum GTlsDatabaseLookupFlags::UInt32 begin
    G_TLS_DATABASE_LOOKUP_NONE = 0
    G_TLS_DATABASE_LOOKUP_KEYPAIR = 1
end

"""
    GTlsCertificateRequestFlags

[`GTlsCertificateRequestFlags`](@ref): \\_TLS\\_CERTIFICATE\\_REQUEST\\_NONE: No flags

Flags for [`g_tls_interaction_request_certificate`](@ref)(), [`g_tls_interaction_request_certificate_async`](@ref)(), and [`g_tls_interaction_invoke_request_certificate`](@ref)().

Since: 2.40
"""
@cenum GTlsCertificateRequestFlags::UInt32 begin
    G_TLS_CERTIFICATE_REQUEST_NONE = 0
end

"""
    GTlsProtocolVersion

[`GTlsProtocolVersion`](@ref): \\_TLS\\_PROTOCOL\\_VERSION\\_UNKNOWN: No protocol version or unknown protocol version \\_TLS\\_PROTOCOL\\_VERSION\\_SSL\\_3\\_0: SSL 3.0, which is insecure and should not be used \\_TLS\\_PROTOCOL\\_VERSION\\_TLS\\_1\\_0: TLS 1.0, which is insecure and should not be used \\_TLS\\_PROTOCOL\\_VERSION\\_TLS\\_1\\_1: TLS 1.1, which is insecure and should not be used \\_TLS\\_PROTOCOL\\_VERSION\\_TLS\\_1\\_2: TLS 1.2, defined by [RFC 5246](https://datatracker.ietf.org/doc/html/rfc5246) \\_TLS\\_PROTOCOL\\_VERSION\\_TLS\\_1\\_3: TLS 1.3, defined by [RFC 8446](https://datatracker.ietf.org/doc/html/rfc8446) \\_TLS\\_PROTOCOL\\_VERSION\\_DTLS\\_1\\_0: DTLS 1.0, which is insecure and should not be used \\_TLS\\_PROTOCOL\\_VERSION\\_DTLS\\_1\\_2: DTLS 1.2, defined by [RFC 6347](https://datatracker.ietf.org/doc/html/rfc6347)

The TLS or DTLS protocol version used by a #[`GTlsConnection`](@ref) or #[`GDtlsConnection`](@ref). The integer values of these versions are sequential to ensure newer known protocol versions compare greater than older known versions. Any known DTLS protocol version will compare greater than any SSL or TLS protocol version. The protocol version may be G\\_TLS\\_PROTOCOL\\_VERSION\\_UNKNOWN if the TLS backend supports a newer protocol version that GLib does not yet know about. This means that it's possible for an unknown DTLS protocol version to compare less than the TLS protocol versions.

Since: 2.70
"""
@cenum GTlsProtocolVersion::UInt32 begin
    G_TLS_PROTOCOL_VERSION_UNKNOWN = 0
    G_TLS_PROTOCOL_VERSION_SSL_3_0 = 1
    G_TLS_PROTOCOL_VERSION_TLS_1_0 = 2
    G_TLS_PROTOCOL_VERSION_TLS_1_1 = 3
    G_TLS_PROTOCOL_VERSION_TLS_1_2 = 4
    G_TLS_PROTOCOL_VERSION_TLS_1_3 = 5
    G_TLS_PROTOCOL_VERSION_DTLS_1_0 = 201
    G_TLS_PROTOCOL_VERSION_DTLS_1_2 = 202
end

"""
    GIOModuleScopeFlags

[`GIOModuleScopeFlags`](@ref): \\_IO\\_MODULE\\_SCOPE\\_NONE: No module scan flags \\_IO\\_MODULE\\_SCOPE\\_BLOCK\\_DUPLICATES: When using this scope to load or scan modules, automatically block a modules which has the same base basename as previously loaded module.

Flags for use with [`g_io_module_scope_new`](@ref)().

Since: 2.30
"""
@cenum GIOModuleScopeFlags::UInt32 begin
    G_IO_MODULE_SCOPE_NONE = 0
    G_IO_MODULE_SCOPE_BLOCK_DUPLICATES = 1
end

"""
    GSocketClientEvent

[`GSocketClientEvent`](@ref): \\_SOCKET\\_CLIENT\\_RESOLVING: The client is doing a DNS lookup. \\_SOCKET\\_CLIENT\\_RESOLVED: The client has completed a DNS lookup. \\_SOCKET\\_CLIENT\\_CONNECTING: The client is connecting to a remote host (either a proxy or the destination server). \\_SOCKET\\_CLIENT\\_CONNECTED: The client has connected to a remote host. \\_SOCKET\\_CLIENT\\_PROXY\\_NEGOTIATING: The client is negotiating with a proxy to connect to the destination server. \\_SOCKET\\_CLIENT\\_PROXY\\_NEGOTIATED: The client has negotiated with the proxy server. \\_SOCKET\\_CLIENT\\_TLS\\_HANDSHAKING: The client is performing a TLS handshake. \\_SOCKET\\_CLIENT\\_TLS\\_HANDSHAKED: The client has performed a TLS handshake. \\_SOCKET\\_CLIENT\\_COMPLETE: The client is done with a particular #[`GSocketConnectable`](@ref).

Describes an event occurring on a #[`GSocketClient`](@ref). See the #[`GSocketClient`](@ref)::event signal for more details.

Additional values may be added to this type in the future.

Since: 2.32
"""
@cenum GSocketClientEvent::UInt32 begin
    G_SOCKET_CLIENT_RESOLVING = 0
    G_SOCKET_CLIENT_RESOLVED = 1
    G_SOCKET_CLIENT_CONNECTING = 2
    G_SOCKET_CLIENT_CONNECTED = 3
    G_SOCKET_CLIENT_PROXY_NEGOTIATING = 4
    G_SOCKET_CLIENT_PROXY_NEGOTIATED = 5
    G_SOCKET_CLIENT_TLS_HANDSHAKING = 6
    G_SOCKET_CLIENT_TLS_HANDSHAKED = 7
    G_SOCKET_CLIENT_COMPLETE = 8
end

"""
    GSocketListenerEvent

[`GSocketListenerEvent`](@ref): \\_SOCKET\\_LISTENER\\_BINDING: The listener is about to bind a socket. \\_SOCKET\\_LISTENER\\_BOUND: The listener has bound a socket. \\_SOCKET\\_LISTENER\\_LISTENING: The listener is about to start listening on this socket. \\_SOCKET\\_LISTENER\\_LISTENED: The listener is now listening on this socket.

Describes an event occurring on a #[`GSocketListener`](@ref). See the #[`GSocketListener`](@ref)::event signal for more details.

Additional values may be added to this type in the future.

Since: 2.46
"""
@cenum GSocketListenerEvent::UInt32 begin
    G_SOCKET_LISTENER_BINDING = 0
    G_SOCKET_LISTENER_BOUND = 1
    G_SOCKET_LISTENER_LISTENING = 2
    G_SOCKET_LISTENER_LISTENED = 3
end

"""
    GTestDBusFlags

[`GTestDBusFlags`](@ref): \\_TEST\\_DBUS\\_NONE: No flags.

Flags to define future #[`GTestDBus`](@ref) behaviour.

Since: 2.34
"""
@cenum GTestDBusFlags::UInt32 begin
    G_TEST_DBUS_NONE = 0
end

"""
    GSubprocessFlags

[`GSubprocessFlags`](@ref): \\_SUBPROCESS\\_FLAGS\\_NONE: No flags. \\_SUBPROCESS\\_FLAGS\\_STDIN\\_PIPE: create a pipe for the stdin of the spawned process that can be accessed with [`g_subprocess_get_stdin_pipe`](@ref)(). \\_SUBPROCESS\\_FLAGS\\_STDIN\\_INHERIT: stdin is inherited from the calling process. \\_SUBPROCESS\\_FLAGS\\_STDOUT\\_PIPE: create a pipe for the stdout of the spawned process that can be accessed with [`g_subprocess_get_stdout_pipe`](@ref)(). \\_SUBPROCESS\\_FLAGS\\_STDOUT\\_SILENCE: silence the stdout of the spawned process (ie: redirect to `/dev/null`). \\_SUBPROCESS\\_FLAGS\\_STDERR\\_PIPE: create a pipe for the stderr of the spawned process that can be accessed with [`g_subprocess_get_stderr_pipe`](@ref)(). \\_SUBPROCESS\\_FLAGS\\_STDERR\\_SILENCE: silence the stderr of the spawned process (ie: redirect to `/dev/null`). \\_SUBPROCESS\\_FLAGS\\_STDERR\\_MERGE: merge the stderr of the spawned process with whatever the stdout happens to be. This is a good way of directing both streams to a common log file, for example. \\_SUBPROCESS\\_FLAGS\\_INHERIT\\_FDS: spawned processes will inherit the file descriptors of their parent, unless those descriptors have been explicitly marked as close-on-exec. This flag has no effect over the "standard" file descriptors (stdin, stdout, stderr). \\_SUBPROCESS\\_FLAGS\\_SEARCH\\_PATH\\_FROM\\_ENVP: if path searching is needed when spawning the subprocess, use the `PATH` in the launcher environment. (Since: 2.72)

Flags to define the behaviour of a #[`GSubprocess`](@ref).

Note that the default for stdin is to redirect from `/dev/null`. For stdout and stderr the default are for them to inherit the corresponding descriptor from the calling process.

Note that it is a programmer error to mix 'incompatible' flags. For example, you may not request both G\\_SUBPROCESS\\_FLAGS\\_STDOUT\\_PIPE and G\\_SUBPROCESS\\_FLAGS\\_STDOUT\\_SILENCE.

Since: 2.40
"""
@cenum GSubprocessFlags::UInt32 begin
    G_SUBPROCESS_FLAGS_NONE = 0
    G_SUBPROCESS_FLAGS_STDIN_PIPE = 1
    G_SUBPROCESS_FLAGS_STDIN_INHERIT = 2
    G_SUBPROCESS_FLAGS_STDOUT_PIPE = 4
    G_SUBPROCESS_FLAGS_STDOUT_SILENCE = 8
    G_SUBPROCESS_FLAGS_STDERR_PIPE = 16
    G_SUBPROCESS_FLAGS_STDERR_SILENCE = 32
    G_SUBPROCESS_FLAGS_STDERR_MERGE = 64
    G_SUBPROCESS_FLAGS_INHERIT_FDS = 128
    G_SUBPROCESS_FLAGS_SEARCH_PATH_FROM_ENVP = 256
end

"""
    GNotificationPriority

[`GNotificationPriority`](@ref): \\_NOTIFICATION\\_PRIORITY\\_LOW: for notifications that do not require immediate attention - typically used for contextual background information, such as contact birthdays or local weather \\_NOTIFICATION\\_PRIORITY\\_NORMAL: the default priority, to be used for the majority of notifications (for example email messages, software updates, completed download/sync operations) \\_NOTIFICATION\\_PRIORITY\\_HIGH: for events that require more attention, usually because responses are time-sensitive (for example chat and SMS messages or alarms) \\_NOTIFICATION\\_PRIORITY\\_URGENT: for urgent notifications, or notifications that require a response in a short space of time (for example phone calls or emergency warnings)

Priority levels for #GNotifications.

Since: 2.42
"""
@cenum GNotificationPriority::UInt32 begin
    G_NOTIFICATION_PRIORITY_NORMAL = 0
    G_NOTIFICATION_PRIORITY_LOW = 1
    G_NOTIFICATION_PRIORITY_HIGH = 2
    G_NOTIFICATION_PRIORITY_URGENT = 3
end

"""
    GNetworkConnectivity

[`GNetworkConnectivity`](@ref): \\_NETWORK\\_CONNECTIVITY\\_LOCAL: The host is not configured with a route to the Internet; it may or may not be connected to a local network. \\_NETWORK\\_CONNECTIVITY\\_LIMITED: The host is connected to a network, but does not appear to be able to reach the full Internet, perhaps due to upstream network problems. \\_NETWORK\\_CONNECTIVITY\\_PORTAL: The host is behind a captive portal and cannot reach the full Internet. \\_NETWORK\\_CONNECTIVITY\\_FULL: The host is connected to a network, and appears to be able to reach the full Internet.

The host's network connectivity state, as reported by #[`GNetworkMonitor`](@ref).

Since: 2.44
"""
@cenum GNetworkConnectivity::UInt32 begin
    G_NETWORK_CONNECTIVITY_LOCAL = 1
    G_NETWORK_CONNECTIVITY_LIMITED = 2
    G_NETWORK_CONNECTIVITY_PORTAL = 3
    G_NETWORK_CONNECTIVITY_FULL = 4
end

"""
    GPollableReturn

[`GPollableReturn`](@ref): \\_POLLABLE\\_RETURN\\_FAILED: Generic error condition for when an operation fails. \\_POLLABLE\\_RETURN\\_OK: The operation was successfully finished. \\_POLLABLE\\_RETURN\\_WOULD\\_BLOCK: The operation would block.

Return value for various IO operations that signal errors via the return value and not necessarily via a #[`GError`](@ref).

This enum exists to be able to return errors to callers without having to allocate a #[`GError`](@ref). Allocating #GErrors can be quite expensive for regularly happening errors like G\\_IO\\_ERROR\\_WOULD\\_BLOCK.

In case of G\\_POLLABLE\\_RETURN\\_FAILED a #[`GError`](@ref) should be set for the operation to give details about the error that happened.

Since: 2.60
"""
@cenum GPollableReturn::Int32 begin
    G_POLLABLE_RETURN_FAILED = 0
    G_POLLABLE_RETURN_OK = 1
    G_POLLABLE_RETURN_WOULD_BLOCK = -27
end

"""
    GMemoryMonitorWarningLevel

[`GMemoryMonitorWarningLevel`](@ref): \\_MEMORY\\_MONITOR\\_WARNING\\_LEVEL\\_LOW: Memory on the device is low, processes should free up unneeded resources (for example, in-memory caches) so they can be used elsewhere. \\_MEMORY\\_MONITOR\\_WARNING\\_LEVEL\\_MEDIUM: Same as \\_MEMORY\\_MONITOR\\_WARNING\\_LEVEL\\_LOW but the device has even less free memory, so processes should try harder to free up unneeded resources. If your process does not need to stay running, it is a good time for it to quit. \\_MEMORY\\_MONITOR\\_WARNING\\_LEVEL\\_CRITICAL: The system will soon start terminating processes to reclaim memory, including background processes.

Memory availability warning levels.

Note that because new values might be added, it is recommended that applications check #[`GMemoryMonitorWarningLevel`](@ref) as ranges, for example: |[<!-- language="C" --> if (warning\\_level > G\\_MEMORY\\_MONITOR\\_WARNING\\_LEVEL\\_LOW) drop\\_caches (); ]|

Since: 2.64
"""
@cenum GMemoryMonitorWarningLevel::UInt32 begin
    G_MEMORY_MONITOR_WARNING_LEVEL_LOW = 50
    G_MEMORY_MONITOR_WARNING_LEVEL_MEDIUM = 100
    G_MEMORY_MONITOR_WARNING_LEVEL_CRITICAL = 255
end

const _GSettingsBackend = Cvoid

const GSettingsBackend = _GSettingsBackend

const _GFileAttributeMatcher = Cvoid

"""
[`GFileAttributeMatcher`](@ref):

Determines if a string matches a file attribute.
"""
const GFileAttributeMatcher = _GFileAttributeMatcher

"""
    _GFileAttributeInfo

[`GFileAttributeInfo`](@ref):

`: the name of the attribute.`

: the #[`GFileAttributeType`](@ref) type of the attribute. : a set of #[`GFileAttributeInfoFlags`](@ref).

Information about a specific attribute.
"""
struct _GFileAttributeInfo
    name::Cstring
    type::GFileAttributeType
    flags::GFileAttributeInfoFlags
end

"""
[`GFileAttributeInfo`](@ref):

`: the name of the attribute.`

: the #[`GFileAttributeType`](@ref) type of the attribute. : a set of #[`GFileAttributeInfoFlags`](@ref).

Information about a specific attribute.
"""
const GFileAttributeInfo = _GFileAttributeInfo

"""
    _GFileAttributeInfoList

[`GFileAttributeInfoList`](@ref): : an array of #GFileAttributeInfos. \\_infos: the number of values in the array.

Acts as a lightweight registry for possible valid file attributes. The registry stores Key-Value pair formats as #GFileAttributeInfos.
"""
struct _GFileAttributeInfoList
    infos::Ptr{GFileAttributeInfo}
    n_infos::Cint
end

"""
[`GFileAttributeInfoList`](@ref): : an array of #GFileAttributeInfos. \\_infos: the number of values in the array.

Acts as a lightweight registry for possible valid file attributes. The registry stores Key-Value pair formats as #GFileAttributeInfos.
"""
const GFileAttributeInfoList = _GFileAttributeInfoList

const _GIOExtensionPoint = Cvoid

const GIOExtensionPoint = _GIOExtensionPoint

const _GIOExtension = Cvoid

const GIOExtension = _GIOExtension

const _GIOSchedulerJob = Cvoid

"""
[`GIOSchedulerJob`](@ref):

Opaque class for defining and scheduling IO jobs.

Deprecated: 2.36: Use [struct.ThreadPool] or [method.Task.run\\_in\\_thread]
"""
const GIOSchedulerJob = _GIOSchedulerJob

const _GIOStreamAdapter = Cvoid

const GIOStreamAdapter = _GIOStreamAdapter

const _GResource = Cvoid

const GResource = _GResource

const _GSrvTarget = Cvoid

const GSrvTarget = _GSrvTarget

# typedef void ( * GAsyncReadyCallback ) ( GObject * source_object , GAsyncResult * res , gpointer data )
"""
[`GAsyncReadyCallback`](@ref): \\_object: (nullable): the object the asynchronous operation was started with. : a #[`GAsyncResult`](@ref).

\\date : user data passed to the callback.

Type definition for a function that will be called back when an asynchronous operation within GIO has been completed. #[`GAsyncReadyCallback`](@ref) callbacks from #[`GTask`](@ref) are guaranteed to be invoked in a later iteration of the thread-default main context (see [method.MainContext.push\\_thread\\_default]) where the #[`GTask`](@ref) was created. All other users of #[`GAsyncReadyCallback`](@ref) must likewise call it asynchronously in a later iteration of the main context.

The asynchronous operation is guaranteed to have held a reference to \\_object from the time when the `*\\_async()` function was called, until after this callback returns.
"""
const GAsyncReadyCallback = Ptr{Cvoid}

# typedef void ( * GFileProgressCallback ) ( goffset current_num_bytes , goffset total_num_bytes , gpointer data )
"""
[`GFileProgressCallback`](@ref): \\_num\\_bytes: the current number of bytes in the operation. \\_num\\_bytes: the total number of bytes in the operation.

\\date : user data passed to the callback.

When doing file operations that may take a while, such as moving a file or copying a file, a progress callback is used to pass how far along that operation is to the application.
"""
const GFileProgressCallback = Ptr{Cvoid}

# typedef gboolean ( * GFileReadMoreCallback ) ( const char * file_contents , goffset file_size , gpointer callback_data )
"""
[`GFileReadMoreCallback`](@ref):

`_contents: the data as currently read.`

`_size: the size of the data currently read.`

`_data: data passed to the callback.`

When loading the partial contents of a file with [`g_file_load_partial_contents_async`](@ref)(), it may become necessary to determine if any more data from the file should be loaded. A #[`GFileReadMoreCallback`](@ref) function facilitates this by returning TRUE if more data should be read, or FALSE otherwise.

Returns: TRUE if more data should be read back. FALSE otherwise.
"""
const GFileReadMoreCallback = Ptr{Cvoid}

# typedef void ( * GFileMeasureProgressCallback ) ( gboolean reporting , guint64 current_size , guint64 num_dirs , guint64 num_files , gpointer data )
"""
[`GFileMeasureProgressCallback`](@ref): : TRUE if more reports will come \\_size: the current cumulative size measurement

`_dirs: the number of directories visited so far`

`_files: the number of non-directory files encountered`

\\date : the data passed to the original request for this callback

This callback type is used by [`g_file_measure_disk_usage`](@ref)() to make periodic progress reports when measuring the amount of disk spaced used by a directory.

These calls are made on a best-effort basis and not all types of #[`GFile`](@ref) will support them. At the minimum, however, one call will always be made immediately.

In the case that there is no support,  will be set to FALSE (and the other values undefined) and no further calls will be made. Otherwise, the  will be TRUE and the other values all-zeros during the first (immediate) call. In this way, you can know which type of progress UI to show without a delay.

For [`g_file_measure_disk_usage`](@ref)() the callback is made directly. For [`g_file_measure_disk_usage_async`](@ref)() the callback is made via the default main context of the calling thread (ie: the same way that the final async result would be reported).

\\_size is in the same units as requested by the operation (see G\\_FILE\\_MEASURE\\_APPARENT\\_SIZE).

The frequency of the updates is implementation defined, but is ideally about once every 200ms.

The last progress callback may or may not be equal to the final result. Always check the async result to get the final value.

Since: 2.38
"""
const GFileMeasureProgressCallback = Ptr{Cvoid}

# typedef gboolean ( * GIOSchedulerJobFunc ) ( GIOSchedulerJob * job , GCancellable * cancellable , gpointer data )
"""
[`GIOSchedulerJobFunc`](@ref): : a #[`GIOSchedulerJob`](@ref). : optional #[`GCancellable`](@ref) object, NULL to ignore.

\\date : data passed to the callback function

I/O Job function.

Long-running jobs should periodically check the  to see if they have been cancelled.

Returns: TRUE if this function should be called again to complete the job, FALSE if the job is complete (or cancelled) Deprecated: 2.36: Use [struct.ThreadPool] or [method.Task.run\\_in\\_thread]
"""
const GIOSchedulerJobFunc = Ptr{Cvoid}

# typedef void ( * GSimpleAsyncThreadFunc ) ( GSimpleAsyncResult * res , GObject * object , GCancellable * cancellable )
"""
[`GSimpleAsyncThreadFunc`](@ref): : a #[`GSimpleAsyncResult`](@ref). : a #[`GObject`](@ref). : optional #[`GCancellable`](@ref) object, NULL to ignore.

Simple thread function that runs an asynchronous operation and checks for cancellation.
"""
const GSimpleAsyncThreadFunc = Ptr{Cvoid}

# typedef gboolean ( * GSocketSourceFunc ) ( GSocket * socket , GIOCondition condition , gpointer data )
"""
[`GSocketSourceFunc`](@ref): : the #[`GSocket`](@ref) : the current condition at the source fired.

\\date : data passed in by the user.

This is the function type of the callback used for the #[`GSource`](@ref) returned by [`g_socket_create_source`](@ref)().

Returns: it should return FALSE if the source should be removed.

Since: 2.22
"""
const GSocketSourceFunc = Ptr{Cvoid}

# typedef gboolean ( * GDatagramBasedSourceFunc ) ( GDatagramBased * datagram_based , GIOCondition condition , gpointer data )
"""
[`GDatagramBasedSourceFunc`](@ref): \\_based: the #[`GDatagramBased`](@ref) : the current condition at the source fired

\\date : data passed in by the user

This is the function type of the callback used for the #[`GSource`](@ref) returned by [`g_datagram_based_create_source`](@ref)().

Returns: G\\_SOURCE\\_REMOVE if the source should be removed, G\\_SOURCE\\_CONTINUE otherwise

Since: 2.48
"""
const GDatagramBasedSourceFunc = Ptr{Cvoid}

struct _GInputVector
    buffer::gpointer
    size::gsize
end

"""
[`GInputVector`](@ref): : Pointer to a buffer where data will be written. : the available size in .

Structure used for scatter/gather data input. You generally pass in an array of #GInputVectors and the operation will store the read data starting in the first buffer, switching to the next as needed.

Since: 2.22
"""
const GInputVector = _GInputVector

struct _GInputMessage
    address::Ptr{Ptr{GSocketAddress}}
    vectors::Ptr{GInputVector}
    num_vectors::guint
    bytes_received::gsize
    flags::gint
    control_messages::Ptr{Ptr{Ptr{GSocketControlMessage}}}
    num_control_messages::Ptr{guint}
end

"""
[`GInputMessage`](@ref): : (optional) (out) (transfer full): return location for a #[`GSocketAddress`](@ref), or NULL : (array length=num\\_vectors) (out): pointer to an array of input vectors

`_vectors: the number of input vectors pointed to by @vectors`

\\_received: (out): will be set to the number of bytes that have been received : (out): collection of #[`GSocketMsgFlags`](@ref) for the received message, outputted by the call \\_messages: (array length=num\\_control\\_messages) (optional) (out) (transfer full): return location for a caller-allocated array of #GSocketControlMessages, or NULL

`_control_messages: (out) (optional): return location for the number of`

elements in \\_messages

Structure used for scatter/gather data input when receiving multiple messages or packets in one go. You generally pass in an array of empty #GInputVectors and the operation will use all the buffers as if they were one buffer, and will set \\_received to the total number of bytes received across all #GInputVectors.

This structure closely mirrors `struct mmsghdr` and `struct msghdr` from the POSIX sockets API (see `man 2 recvmmsg`).

If  is non-NULL then it is set to the source address the message was received from, and the caller must free it afterwards.

If \\_messages is non-NULL then it is set to an array of control messages received with the message (if any), and the caller must free it afterwards.

`_control_messages is set to the number of elements in`

this array, which may be zero.

Flags relevant to this message will be returned in . For example, `MSG_EOR` or `MSG_TRUNC`.

Since: 2.48
"""
const GInputMessage = _GInputMessage

struct _GOutputVector
    buffer::gconstpointer
    size::gsize
end

"""
[`GOutputVector`](@ref): : Pointer to a buffer of data to read. : the size of .

Structure used for scatter/gather data output. You generally pass in an array of #GOutputVectors and the operation will use all the buffers as if they were one buffer.

Since: 2.22
"""
const GOutputVector = _GOutputVector

struct _GOutputMessage
    address::Ptr{GSocketAddress}
    vectors::Ptr{GOutputVector}
    num_vectors::guint
    bytes_sent::guint
    control_messages::Ptr{Ptr{GSocketControlMessage}}
    num_control_messages::guint
end

"""
[`GOutputMessage`](@ref): : (nullable): a #[`GSocketAddress`](@ref), or NULL : pointer to an array of output vectors

`_vectors: the number of output vectors pointed to by @vectors.`

\\_sent: initialize to 0. Will be set to the number of bytes that have been sent \\_messages: (array length=num\\_control\\_messages) (nullable): a pointer to an array of #GSocketControlMessages, or NULL.

`_control_messages: number of elements in @control_messages.`

Structure used for scatter/gather data output when sending multiple messages or packets in one go. You generally pass in an array of #GOutputVectors and the operation will use all the buffers as if they were one buffer.

If  is NULL then the message is sent to the default receiver (as previously set by [`g_socket_connect`](@ref)()).

Since: 2.44
"""
const GOutputMessage = _GOutputMessage

"""
    _GDBusErrorEntry

[`GDBusErrorEntry`](@ref): \\_code: an error code \\_error\\_name: the D-Bus error name to associate with \\_code

Struct used in [func.DBusError.register\\_error\\_domain].

Since: 2.26
"""
struct _GDBusErrorEntry
    error_code::gint
    dbus_error_name::Ptr{gchar}
end

"""
[`GDBusErrorEntry`](@ref): \\_code: an error code \\_error\\_name: the D-Bus error name to associate with \\_code

Struct used in [func.DBusError.register\\_error\\_domain].

Since: 2.26
"""
const GDBusErrorEntry = _GDBusErrorEntry

# typedef void ( * GDBusInterfaceMethodCallFunc ) ( GDBusConnection * connection , const gchar * sender , const gchar * object_path , const gchar * interface_name , const gchar * method_name , GVariant * parameters , GDBusMethodInvocation * invocation , gpointer user_data )
"""
[`GDBusInterfaceMethodCallFunc`](@ref): : A #[`GDBusConnection`](@ref). : (nullable): The unique bus name of the remote caller, or `NULL` if not specified by the caller, e.g. on peer-to-peer connections. \\_path: The object path that the method was invoked on.

`_name: (nullable): The D-Bus interface name the method was invoked on,`

or `NULL` if not specified by the sender.

`_name: The name of the method that was invoked.`

: A #[`GVariant`](@ref) tuple with parameters. : (transfer full): A #[`GDBusMethodInvocation`](@ref) object that must be used to return a value or error. \\_data: The \\_data #[`gpointer`](@ref) passed to [`g_dbus_connection_register_object`](@ref)().

The type of the

`_call function in #GDBusInterfaceVTable.`

`_name may be `NULL` if not specified by the sender, although its`

encouraged for the sender to set it. If unset, and the object has only one method (across all interfaces) matching

`_name, that method is invoked.`

Otherwise, behaviour is implementation defined. See the [D-Bus specification](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-types-method). It is recommended to return [error.DBusError.UNKNOWN\\_METHOD].

Since: 2.26
"""
const GDBusInterfaceMethodCallFunc = Ptr{Cvoid}

# typedef GVariant * ( * GDBusInterfaceGetPropertyFunc ) ( GDBusConnection * connection , const gchar * sender , const gchar * object_path , const gchar * interface_name , const gchar * property_name , GError * * error , gpointer user_data )
"""
[`GDBusInterfaceGetPropertyFunc`](@ref): : A #[`GDBusConnection`](@ref). : (nullable): The unique bus name of the remote caller or NULL if not specified by the caller, e.g. on peer-to-peer connections. \\_path: The object path that the method was invoked on.

`_name: The D-Bus interface name for the property.`

`_name: The name of the property to get the value of.`

: Return location for error. \\_data: The \\_data #[`gpointer`](@ref) passed to [`g_dbus_connection_register_object`](@ref)().

The type of the \\_property function in #[`GDBusInterfaceVTable`](@ref).

Returns: A #[`GVariant`](@ref) with the value for

`_name or %NULL if`

is set. If the returned #[`GVariant`](@ref) is floating, it is consumed - otherwise its reference count is decreased by one.

Since: 2.26
"""
const GDBusInterfaceGetPropertyFunc = Ptr{Cvoid}

# typedef gboolean ( * GDBusInterfaceSetPropertyFunc ) ( GDBusConnection * connection , const gchar * sender , const gchar * object_path , const gchar * interface_name , const gchar * property_name , GVariant * value , GError * * error , gpointer user_data )
"""
[`GDBusInterfaceSetPropertyFunc`](@ref): : A #[`GDBusConnection`](@ref). : (nullable): The unique bus name of the remote caller or NULL if not specified by the caller, e.g. on peer-to-peer connections. \\_path: The object path that the method was invoked on.

`_name: The D-Bus interface name for the property.`

`_name: The name of the property to get the value of.`

: The value to set the property to. : Return location for error. \\_data: The \\_data #[`gpointer`](@ref) passed to [`g_dbus_connection_register_object`](@ref)().

The type of the

Returns: TRUE if the property was set to , FALSE if  is set.

Since: 2.26

# See also
\\_property function in #[`GDBusInterfaceVTable`](@ref).
"""
const GDBusInterfaceSetPropertyFunc = Ptr{Cvoid}

"""
    _GDBusInterfaceVTable

[`GDBusInterfaceVTable`](@ref):

`_call: Function for handling incoming method calls.`

\\_property: Function for getting a property.

Virtual table for handling properties and method calls for a D-Bus interface.

Since 2.38, if you want to handle getting/setting D-Bus properties asynchronously, give NULL as your get\\_property() or set\\_property() function. The D-Bus call will be directed to your

`_call function,`

with the provided

`_name set to "org.freedesktop.DBus.Properties".`

Ownership of the #[`GDBusMethodInvocation`](@ref) object passed to the method\\_call() function is transferred to your handler; you must call one of the methods of #[`GDBusMethodInvocation`](@ref) to return a reply (possibly empty), or an error. These functions also take ownership of the passed-in invocation object, so unless the invocation object has otherwise been referenced, it will be then be freed. Calling one of these functions may be done within your method\\_call() implementation but it also can be done at a later point to handle the method asynchronously.

The usual checks on the validity of the calls is performed. For `Get` calls, an error is automatically returned if the property does not exist or the permissions do not allow access. The same checks are performed for `Set` calls, and the provided value is also checked for being the correct type.

For both `Get` and `Set` calls, the #[`GDBusMethodInvocation`](@ref) passed to the

`_call handler can be queried with`

[`g_dbus_method_invocation_get_property_info`](@ref)() to get a pointer to the #[`GDBusPropertyInfo`](@ref) of the property.

If you have readable properties specified in your interface info, you must ensure that you either provide a non-NULL \\_property() function or provide implementations of both the `Get` and `GetAll` methods on org.freedesktop.DBus.Properties interface in your

`_call`

function. Note that the required return type of the `Get` call is `(v)`, not the type of the property. `GetAll` expects a return value of type `a{sv}`.

If you have writable properties specified in your interface info, you must ensure that you either provide a non-NULL

Since: 2.26

# See also
\\_property: Function for setting a property., \\_property() function or provide an implementation of the `Set` call. If implementing the call, you must return the value of type G\\_VARIANT\\_TYPE\\_UNIT.
"""
struct _GDBusInterfaceVTable
    method_call::GDBusInterfaceMethodCallFunc
    get_property::GDBusInterfaceGetPropertyFunc
    set_property::GDBusInterfaceSetPropertyFunc
    padding::NTuple{8, gpointer}
end

"""
[`GDBusInterfaceVTable`](@ref):

`_call: Function for handling incoming method calls.`

\\_property: Function for getting a property.

Virtual table for handling properties and method calls for a D-Bus interface.

Since 2.38, if you want to handle getting/setting D-Bus properties asynchronously, give NULL as your get\\_property() or set\\_property() function. The D-Bus call will be directed to your

`_call function,`

with the provided

`_name set to "org.freedesktop.DBus.Properties".`

Ownership of the #[`GDBusMethodInvocation`](@ref) object passed to the method\\_call() function is transferred to your handler; you must call one of the methods of #[`GDBusMethodInvocation`](@ref) to return a reply (possibly empty), or an error. These functions also take ownership of the passed-in invocation object, so unless the invocation object has otherwise been referenced, it will be then be freed. Calling one of these functions may be done within your method\\_call() implementation but it also can be done at a later point to handle the method asynchronously.

The usual checks on the validity of the calls is performed. For `Get` calls, an error is automatically returned if the property does not exist or the permissions do not allow access. The same checks are performed for `Set` calls, and the provided value is also checked for being the correct type.

For both `Get` and `Set` calls, the #[`GDBusMethodInvocation`](@ref) passed to the

`_call handler can be queried with`

[`g_dbus_method_invocation_get_property_info`](@ref)() to get a pointer to the #[`GDBusPropertyInfo`](@ref) of the property.

If you have readable properties specified in your interface info, you must ensure that you either provide a non-NULL \\_property() function or provide implementations of both the `Get` and `GetAll` methods on org.freedesktop.DBus.Properties interface in your

`_call`

function. Note that the required return type of the `Get` call is `(v)`, not the type of the property. `GetAll` expects a return value of type `a{sv}`.

If you have writable properties specified in your interface info, you must ensure that you either provide a non-NULL

Since: 2.26

# See also
\\_property: Function for setting a property., \\_property() function or provide an implementation of the `Set` call. If implementing the call, you must return the value of type G\\_VARIANT\\_TYPE\\_UNIT.
"""
const GDBusInterfaceVTable = _GDBusInterfaceVTable

# typedef gchar * * ( * GDBusSubtreeEnumerateFunc ) ( GDBusConnection * connection , const gchar * sender , const gchar * object_path , gpointer user_data )
"""
[`GDBusSubtreeEnumerateFunc`](@ref): : A #[`GDBusConnection`](@ref). : The unique bus name of the remote caller. \\_path: The object path that was registered with [`g_dbus_connection_register_subtree`](@ref)(). \\_data: The \\_data #[`gpointer`](@ref) passed to [`g_dbus_connection_register_subtree`](@ref)().

The type of the  function in #[`GDBusSubtreeVTable`](@ref).

This function is called when generating introspection data and also when preparing to dispatch incoming messages in the event that the G\\_DBUS\\_SUBTREE\\_FLAGS\\_DISPATCH\\_TO\\_UNENUMERATED\\_NODES flag is not specified (ie: to verify that the object path is valid).

Hierarchies are not supported; the items that you return should not contain the `/` character.

The return value will be freed with [`g_strfreev`](@ref)().

Returns: (array zero-terminated=1) (transfer full): A newly allocated array of strings for node names that are children of \\_path.

Since: 2.26
"""
const GDBusSubtreeEnumerateFunc = Ptr{Cvoid}

# typedef GDBusInterfaceInfo * * ( * GDBusSubtreeIntrospectFunc ) ( GDBusConnection * connection , const gchar * sender , const gchar * object_path , const gchar * node , gpointer user_data )
"""
[`GDBusSubtreeIntrospectFunc`](@ref): : A #[`GDBusConnection`](@ref). : The unique bus name of the remote caller. \\_path: The object path that was registered with [`g_dbus_connection_register_subtree`](@ref)(). : A node that is a child of \\_path (relative to \\_path) or NULL for the root of the subtree. \\_data: The \\_data #[`gpointer`](@ref) passed to [`g_dbus_connection_register_subtree`](@ref)().

The type of the  function in #[`GDBusSubtreeVTable`](@ref).

Subtrees are flat. , if non-NULL, is always exactly one segment of the object path (ie: it never contains a slash).

This function should return NULL to indicate that there is no object at this node.

If this function returns non-NULL, the return value is expected to be a NULL-terminated array of pointers to #[`GDBusInterfaceInfo`](@ref) structures describing the interfaces implemented by . This array will have [`g_dbus_interface_info_unref`](@ref)() called on each item before being freed with [`g_free`](@ref)().

The difference between returning NULL and an array containing zero items is that the standard DBus interfaces will returned to the remote introspector in the empty array case, but not in the NULL case.

Returns: (array zero-terminated=1) (nullable) (transfer full): A NULL-terminated array of pointers to #[`GDBusInterfaceInfo`](@ref), or NULL.

Since: 2.26
"""
const GDBusSubtreeIntrospectFunc = Ptr{Cvoid}

# typedef const GDBusInterfaceVTable * ( * GDBusSubtreeDispatchFunc ) ( GDBusConnection * connection , const gchar * sender , const gchar * object_path , const gchar * interface_name , const gchar * node , gpointer * out_user_data , gpointer user_data )
"""
[`GDBusSubtreeDispatchFunc`](@ref): : A #[`GDBusConnection`](@ref). : The unique bus name of the remote caller. \\_path: The object path that was registered with [`g_dbus_connection_register_subtree`](@ref)().

`_name: The D-Bus interface name that the method call or property access is for.`

: A node that is a child of \\_path (relative to \\_path) or NULL for the root of the subtree. \\_user\\_data: (nullable) (not optional): Return location for user data to pass to functions in the returned #[`GDBusInterfaceVTable`](@ref). \\_data: The \\_data #[`gpointer`](@ref) passed to [`g_dbus_connection_register_subtree`](@ref)().

The type of the  function in #[`GDBusSubtreeVTable`](@ref).

Subtrees are flat. , if non-NULL, is always exactly one segment of the object path (ie: it never contains a slash).

Returns: (nullable): A #[`GDBusInterfaceVTable`](@ref) or NULL if you don't want to handle the methods.

Since: 2.26
"""
const GDBusSubtreeDispatchFunc = Ptr{Cvoid}

"""
    _GDBusSubtreeVTable

[`GDBusSubtreeVTable`](@ref): : Function for enumerating child nodes. : Function for introspecting a child node. : Function for dispatching a remote call on a child node.

Virtual table for handling subtrees registered with [`g_dbus_connection_register_subtree`](@ref)().

Since: 2.26
"""
struct _GDBusSubtreeVTable
    enumerate::GDBusSubtreeEnumerateFunc
    introspect::GDBusSubtreeIntrospectFunc
    dispatch::GDBusSubtreeDispatchFunc
    padding::NTuple{8, gpointer}
end

"""
[`GDBusSubtreeVTable`](@ref): : Function for enumerating child nodes. : Function for introspecting a child node. : Function for dispatching a remote call on a child node.

Virtual table for handling subtrees registered with [`g_dbus_connection_register_subtree`](@ref)().

Since: 2.26
"""
const GDBusSubtreeVTable = _GDBusSubtreeVTable

"""
    _GDBusAnnotationInfo

[`GDBusAnnotationInfo`](@ref): _count: The reference count or -1 if statically allocated. : The name of the annotation, e.g. "org.freedesktop.DBus.Deprecated". : The value of the annotation. : (array zero-terminated=1): A pointer to a NULL-terminated array of pointers to #[`GDBusAnnotationInfo`](@ref) structures or NULL if there are no annotations.

Information about an annotation.

Since: 2.26
"""
struct _GDBusAnnotationInfo
    ref_count::gint
    key::Ptr{gchar}
    value::Ptr{gchar}
    annotations::Ptr{Ptr{Cvoid}} # annotations::Ptr{Ptr{GDBusAnnotationInfo}}
end

function Base.getproperty(x::_GDBusAnnotationInfo, f::Symbol)
    f === :annotations && return Ptr{Ptr{GDBusAnnotationInfo}}(getfield(x, f))
    return getfield(x, f)
end

"""
[`GDBusAnnotationInfo`](@ref): _count: The reference count or -1 if statically allocated. : The name of the annotation, e.g. "org.freedesktop.DBus.Deprecated". : The value of the annotation. : (array zero-terminated=1): A pointer to a NULL-terminated array of pointers to #[`GDBusAnnotationInfo`](@ref) structures or NULL if there are no annotations.

Information about an annotation.

Since: 2.26
"""
const GDBusAnnotationInfo = _GDBusAnnotationInfo

"""
    _GDBusArgInfo

[`GDBusArgInfo`](@ref): _count: The reference count or -1 if statically allocated.

`: Name of the argument, e.g. @unix_user_id.`

: D-Bus signature of the argument (a single complete type). : (array zero-terminated=1): A pointer to a NULL-terminated array of pointers to #[`GDBusAnnotationInfo`](@ref) structures or NULL if there are no annotations.

Information about an argument for a method or a signal.

Since: 2.26
"""
struct _GDBusArgInfo
    ref_count::gint
    name::Ptr{gchar}
    signature::Ptr{gchar}
    annotations::Ptr{Ptr{GDBusAnnotationInfo}}
end

"""
[`GDBusArgInfo`](@ref): _count: The reference count or -1 if statically allocated.

`: Name of the argument, e.g. @unix_user_id.`

: D-Bus signature of the argument (a single complete type). : (array zero-terminated=1): A pointer to a NULL-terminated array of pointers to #[`GDBusAnnotationInfo`](@ref) structures or NULL if there are no annotations.

Information about an argument for a method or a signal.

Since: 2.26
"""
const GDBusArgInfo = _GDBusArgInfo

"""
    _GDBusMethodInfo

[`GDBusMethodInfo`](@ref): _count: The reference count or -1 if statically allocated.

`: The name of the D-Bus method, e.g. @RequestName.`

\\_args: (array zero-terminated=1): A pointer to a NULL-terminated array of pointers to #[`GDBusArgInfo`](@ref) structures or NULL if there are no in arguments. \\_args: (array zero-terminated=1): A pointer to a NULL-terminated array of pointers to #[`GDBusArgInfo`](@ref) structures or NULL if there are no out arguments. : (array zero-terminated=1): A pointer to a NULL-terminated array of pointers to #[`GDBusAnnotationInfo`](@ref) structures or NULL if there are no annotations.

Information about a method on a D-Bus interface.

Since: 2.26
"""
struct _GDBusMethodInfo
    ref_count::gint
    name::Ptr{gchar}
    in_args::Ptr{Ptr{GDBusArgInfo}}
    out_args::Ptr{Ptr{GDBusArgInfo}}
    annotations::Ptr{Ptr{GDBusAnnotationInfo}}
end

"""
[`GDBusMethodInfo`](@ref): _count: The reference count or -1 if statically allocated.

`: The name of the D-Bus method, e.g. @RequestName.`

\\_args: (array zero-terminated=1): A pointer to a NULL-terminated array of pointers to #[`GDBusArgInfo`](@ref) structures or NULL if there are no in arguments. \\_args: (array zero-terminated=1): A pointer to a NULL-terminated array of pointers to #[`GDBusArgInfo`](@ref) structures or NULL if there are no out arguments. : (array zero-terminated=1): A pointer to a NULL-terminated array of pointers to #[`GDBusAnnotationInfo`](@ref) structures or NULL if there are no annotations.

Information about a method on a D-Bus interface.

Since: 2.26
"""
const GDBusMethodInfo = _GDBusMethodInfo

"""
    _GDBusSignalInfo

[`GDBusSignalInfo`](@ref): _count: The reference count or -1 if statically allocated.

`: The name of the D-Bus signal, e.g. "NameOwnerChanged".`

* : (array zero-terminated=1): A pointer to a NULL-terminated array of pointers to #[`GDBusArgInfo`](@ref) structures or NULL if there are no arguments. : (array zero-terminated=1): A pointer to a NULL-terminated array of pointers to #[`GDBusAnnotationInfo`](@ref) structures or NULL if there are no annotations.

Information about a signal on a D-Bus interface.

Since: 2.26
"""
struct _GDBusSignalInfo
    ref_count::gint
    name::Ptr{gchar}
    args::Ptr{Ptr{GDBusArgInfo}}
    annotations::Ptr{Ptr{GDBusAnnotationInfo}}
end

"""
[`GDBusSignalInfo`](@ref): _count: The reference count or -1 if statically allocated.

`: The name of the D-Bus signal, e.g. "NameOwnerChanged".`

* : (array zero-terminated=1): A pointer to a NULL-terminated array of pointers to #[`GDBusArgInfo`](@ref) structures or NULL if there are no arguments. : (array zero-terminated=1): A pointer to a NULL-terminated array of pointers to #[`GDBusAnnotationInfo`](@ref) structures or NULL if there are no annotations.

Information about a signal on a D-Bus interface.

Since: 2.26
"""
const GDBusSignalInfo = _GDBusSignalInfo

"""
    _GDBusPropertyInfo

[`GDBusPropertyInfo`](@ref): _count: The reference count or -1 if statically allocated.

`: The name of the D-Bus property, e.g. "SupportedFilesystems".`

: The D-Bus signature of the property (a single complete type). : Access control flags for the property. : (array zero-terminated=1): A pointer to a NULL-terminated array of pointers to #[`GDBusAnnotationInfo`](@ref) structures or NULL if there are no annotations.

Information about a D-Bus property on a D-Bus interface.

Since: 2.26
"""
struct _GDBusPropertyInfo
    ref_count::gint
    name::Ptr{gchar}
    signature::Ptr{gchar}
    flags::GDBusPropertyInfoFlags
    annotations::Ptr{Ptr{GDBusAnnotationInfo}}
end

"""
[`GDBusPropertyInfo`](@ref): _count: The reference count or -1 if statically allocated.

`: The name of the D-Bus property, e.g. "SupportedFilesystems".`

: The D-Bus signature of the property (a single complete type). : Access control flags for the property. : (array zero-terminated=1): A pointer to a NULL-terminated array of pointers to #[`GDBusAnnotationInfo`](@ref) structures or NULL if there are no annotations.

Information about a D-Bus property on a D-Bus interface.

Since: 2.26
"""
const GDBusPropertyInfo = _GDBusPropertyInfo

"""
    _GDBusInterfaceInfo

[`GDBusInterfaceInfo`](@ref): _count: The reference count or -1 if statically allocated.

`: The name of the D-Bus interface, e.g. "org.freedesktop.DBus.Properties".`

`: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusMethodInfo structures or %NULL if there are no methods.`

: (array zero-terminated=1): A pointer to a NULL-terminated array of pointers to #[`GDBusSignalInfo`](@ref) structures or NULL if there are no signals. : (array zero-terminated=1): A pointer to a NULL-terminated array of pointers to #[`GDBusPropertyInfo`](@ref) structures or NULL if there are no properties. : (array zero-terminated=1): A pointer to a NULL-terminated array of pointers to #[`GDBusAnnotationInfo`](@ref) structures or NULL if there are no annotations.

Information about a D-Bus interface.

Since: 2.26
"""
struct _GDBusInterfaceInfo
    ref_count::gint
    name::Ptr{gchar}
    methods::Ptr{Ptr{GDBusMethodInfo}}
    signals::Ptr{Ptr{GDBusSignalInfo}}
    properties::Ptr{Ptr{GDBusPropertyInfo}}
    annotations::Ptr{Ptr{GDBusAnnotationInfo}}
end

"""
[`GDBusInterfaceInfo`](@ref): _count: The reference count or -1 if statically allocated.

`: The name of the D-Bus interface, e.g. "org.freedesktop.DBus.Properties".`

`: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusMethodInfo structures or %NULL if there are no methods.`

: (array zero-terminated=1): A pointer to a NULL-terminated array of pointers to #[`GDBusSignalInfo`](@ref) structures or NULL if there are no signals. : (array zero-terminated=1): A pointer to a NULL-terminated array of pointers to #[`GDBusPropertyInfo`](@ref) structures or NULL if there are no properties. : (array zero-terminated=1): A pointer to a NULL-terminated array of pointers to #[`GDBusAnnotationInfo`](@ref) structures or NULL if there are no annotations.

Information about a D-Bus interface.

Since: 2.26
"""
const GDBusInterfaceInfo = _GDBusInterfaceInfo

"""
    _GDBusNodeInfo

[`GDBusNodeInfo`](@ref): _count: The reference count or -1 if statically allocated. : The path of the node or NULL if omitted. Note that this may be a relative path. See the D-Bus specification for more details.

`: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusInterfaceInfo structures or %NULL if there are no interfaces.`

: (array zero-terminated=1): A pointer to a NULL-terminated array of pointers to #[`GDBusNodeInfo`](@ref) structures or NULL if there are no nodes. : (array zero-terminated=1): A pointer to a NULL-terminated array of pointers to #[`GDBusAnnotationInfo`](@ref) structures or NULL if there are no annotations.

Information about nodes in a remote object hierarchy.

Since: 2.26
"""
struct _GDBusNodeInfo
    ref_count::gint
    path::Ptr{gchar}
    interfaces::Ptr{Ptr{GDBusInterfaceInfo}}
    nodes::Ptr{Ptr{Cvoid}} # nodes::Ptr{Ptr{GDBusNodeInfo}}
    annotations::Ptr{Ptr{GDBusAnnotationInfo}}
end

function Base.getproperty(x::_GDBusNodeInfo, f::Symbol)
    f === :nodes && return Ptr{Ptr{GDBusNodeInfo}}(getfield(x, f))
    return getfield(x, f)
end

"""
[`GDBusNodeInfo`](@ref): _count: The reference count or -1 if statically allocated. : The path of the node or NULL if omitted. Note that this may be a relative path. See the D-Bus specification for more details.

`: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusInterfaceInfo structures or %NULL if there are no interfaces.`

: (array zero-terminated=1): A pointer to a NULL-terminated array of pointers to #[`GDBusNodeInfo`](@ref) structures or NULL if there are no nodes. : (array zero-terminated=1): A pointer to a NULL-terminated array of pointers to #[`GDBusAnnotationInfo`](@ref) structures or NULL if there are no annotations.

Information about nodes in a remote object hierarchy.

Since: 2.26
"""
const GDBusNodeInfo = _GDBusNodeInfo

# typedef gboolean ( * GCancellableSourceFunc ) ( GCancellable * cancellable , gpointer data )
"""
[`GCancellableSourceFunc`](@ref): : the #[`GCancellable`](@ref)

\\date : data passed in by the user.

This is the function type of the callback used for the #[`GSource`](@ref) returned by [`g_cancellable_source_new`](@ref)().

Returns: it should return FALSE if the source should be removed.

Since: 2.28
"""
const GCancellableSourceFunc = Ptr{Cvoid}

# typedef gboolean ( * GPollableSourceFunc ) ( GObject * pollable_stream , gpointer data )
"""
[`GPollableSourceFunc`](@ref): \\_stream: the #[`GPollableInputStream`](@ref) or #[`GPollableOutputStream`](@ref)

\\date : data passed in by the user.

This is the function type of the callback used for the #[`GSource`](@ref) returned by [`g_pollable_input_stream_create_source`](@ref)() and [`g_pollable_output_stream_create_source`](@ref)().

Returns: it should return FALSE if the source should be removed.

Since: 2.28
"""
const GPollableSourceFunc = Ptr{Cvoid}

# typedef GType ( * GDBusProxyTypeFunc ) ( GDBusObjectManagerClient * manager , const gchar * object_path , const gchar * interface_name , gpointer data )
"""
[`GDBusProxyTypeFunc`](@ref): : A #[`GDBusObjectManagerClient`](@ref). \\_path: The object path of the remote object.

`_name: (nullable): The interface name of the remote object or %NULL if a #GDBusObjectProxy #GType is requested.`

\\date : data passed in by the user.

Function signature for a function used to determine the #[`GType`](@ref) to use for an interface proxy (if

`_name is not %NULL) or`

object proxy (if

`_name is %NULL).`

This function is called in the thread-default main context (see [method.MainContext.push\\_thread\\_default]) that  was constructed in.

Returns: A #[`GType`](@ref) to use for the remote object. The returned type must be a #[`GDBusProxy`](@ref) or #[`GDBusObjectProxy`](@ref) -derived type.

Since: 2.30
"""
const GDBusProxyTypeFunc = Ptr{Cvoid}

"""
    g_action_get_name(action)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar * g_action_get_name (GAction *action);
```
"""
function g_action_get_name(action)
    @ccall libaravis.g_action_get_name(action::Ptr{GAction})::Ptr{gchar}
end

"""
    g_action_get_parameter_type(action)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const GVariantType * g_action_get_parameter_type (GAction *action);
```
"""
function g_action_get_parameter_type(action)
    @ccall libaravis.g_action_get_parameter_type(action::Ptr{GAction})::Ptr{GVariantType}
end

"""
    g_action_get_state_type(action)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const GVariantType * g_action_get_state_type (GAction *action);
```
"""
function g_action_get_state_type(action)
    @ccall libaravis.g_action_get_state_type(action::Ptr{GAction})::Ptr{GVariantType}
end

"""
    g_action_get_state_hint(action)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GVariant * g_action_get_state_hint (GAction *action);
```
"""
function g_action_get_state_hint(action)
    @ccall libaravis.g_action_get_state_hint(action::Ptr{GAction})::Ptr{GVariant}
end

"""
    g_action_get_enabled(action)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_action_get_enabled (GAction *action);
```
"""
function g_action_get_enabled(action)
    @ccall libaravis.g_action_get_enabled(action::Ptr{GAction})::gboolean
end

"""
    g_action_get_state(action)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GVariant * g_action_get_state (GAction *action);
```
"""
function g_action_get_state(action)
    @ccall libaravis.g_action_get_state(action::Ptr{GAction})::Ptr{GVariant}
end

"""
    g_action_change_state(action, value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_action_change_state (GAction *action, GVariant *value);
```
"""
function g_action_change_state(action, value)
    @ccall libaravis.g_action_change_state(action::Ptr{GAction}, value::Ptr{GVariant})::Cvoid
end

"""
    g_action_activate(action, parameter)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_action_activate (GAction *action, GVariant *parameter);
```
"""
function g_action_activate(action, parameter)
    @ccall libaravis.g_action_activate(action::Ptr{GAction}, parameter::Ptr{GVariant})::Cvoid
end

"""
    g_action_name_is_valid(action_name)

### Prototype
```c
GIO_AVAILABLE_IN_2_28 gboolean g_action_name_is_valid (const gchar *action_name);
```
"""
function g_action_name_is_valid(action_name)
    @ccall libaravis.g_action_name_is_valid(action_name::Ptr{gchar})::gboolean
end

"""
    g_action_parse_detailed_name(detailed_name, action_name, target_value, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_38 gboolean g_action_parse_detailed_name (const gchar *detailed_name, gchar **action_name, GVariant **target_value, GError **error);
```
"""
function g_action_parse_detailed_name(detailed_name, action_name, target_value, error)
    @ccall libaravis.g_action_parse_detailed_name(detailed_name::Ptr{gchar}, action_name::Ptr{Ptr{gchar}}, target_value::Ptr{Ptr{GVariant}}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_action_print_detailed_name(action_name, target_value)

### Prototype
```c
GIO_AVAILABLE_IN_2_38 gchar * g_action_print_detailed_name (const gchar *action_name, GVariant *target_value);
```
"""
function g_action_print_detailed_name(action_name, target_value)
    @ccall libaravis.g_action_print_detailed_name(action_name::Ptr{gchar}, target_value::Ptr{GVariant})::Ptr{gchar}
end

"""
    g_action_group_has_action(action_group, action_name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_action_group_has_action (GActionGroup *action_group, const gchar *action_name);
```
"""
function g_action_group_has_action(action_group, action_name)
    @ccall libaravis.g_action_group_has_action(action_group::Ptr{GActionGroup}, action_name::Ptr{gchar})::gboolean
end

"""
    g_action_group_list_actions(action_group)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gchar ** g_action_group_list_actions (GActionGroup *action_group);
```
"""
function g_action_group_list_actions(action_group)
    @ccall libaravis.g_action_group_list_actions(action_group::Ptr{GActionGroup})::Ptr{Ptr{gchar}}
end

"""
    g_action_group_get_action_parameter_type(action_group, action_name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const GVariantType * g_action_group_get_action_parameter_type (GActionGroup *action_group, const gchar *action_name);
```
"""
function g_action_group_get_action_parameter_type(action_group, action_name)
    @ccall libaravis.g_action_group_get_action_parameter_type(action_group::Ptr{GActionGroup}, action_name::Ptr{gchar})::Ptr{GVariantType}
end

"""
    g_action_group_get_action_state_type(action_group, action_name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const GVariantType * g_action_group_get_action_state_type (GActionGroup *action_group, const gchar *action_name);
```
"""
function g_action_group_get_action_state_type(action_group, action_name)
    @ccall libaravis.g_action_group_get_action_state_type(action_group::Ptr{GActionGroup}, action_name::Ptr{gchar})::Ptr{GVariantType}
end

"""
    g_action_group_get_action_state_hint(action_group, action_name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GVariant * g_action_group_get_action_state_hint (GActionGroup *action_group, const gchar *action_name);
```
"""
function g_action_group_get_action_state_hint(action_group, action_name)
    @ccall libaravis.g_action_group_get_action_state_hint(action_group::Ptr{GActionGroup}, action_name::Ptr{gchar})::Ptr{GVariant}
end

"""
    g_action_group_get_action_enabled(action_group, action_name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_action_group_get_action_enabled (GActionGroup *action_group, const gchar *action_name);
```
"""
function g_action_group_get_action_enabled(action_group, action_name)
    @ccall libaravis.g_action_group_get_action_enabled(action_group::Ptr{GActionGroup}, action_name::Ptr{gchar})::gboolean
end

"""
    g_action_group_get_action_state(action_group, action_name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GVariant * g_action_group_get_action_state (GActionGroup *action_group, const gchar *action_name);
```
"""
function g_action_group_get_action_state(action_group, action_name)
    @ccall libaravis.g_action_group_get_action_state(action_group::Ptr{GActionGroup}, action_name::Ptr{gchar})::Ptr{GVariant}
end

"""
    g_action_group_change_action_state(action_group, action_name, value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_action_group_change_action_state (GActionGroup *action_group, const gchar *action_name, GVariant *value);
```
"""
function g_action_group_change_action_state(action_group, action_name, value)
    @ccall libaravis.g_action_group_change_action_state(action_group::Ptr{GActionGroup}, action_name::Ptr{gchar}, value::Ptr{GVariant})::Cvoid
end

"""
    g_action_group_activate_action(action_group, action_name, parameter)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_action_group_activate_action (GActionGroup *action_group, const gchar *action_name, GVariant *parameter);
```
"""
function g_action_group_activate_action(action_group, action_name, parameter)
    @ccall libaravis.g_action_group_activate_action(action_group::Ptr{GActionGroup}, action_name::Ptr{gchar}, parameter::Ptr{GVariant})::Cvoid
end

"""
    g_action_group_action_added(action_group, action_name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_action_group_action_added (GActionGroup *action_group, const gchar *action_name);
```
"""
function g_action_group_action_added(action_group, action_name)
    @ccall libaravis.g_action_group_action_added(action_group::Ptr{GActionGroup}, action_name::Ptr{gchar})::Cvoid
end

"""
    g_action_group_action_removed(action_group, action_name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_action_group_action_removed (GActionGroup *action_group, const gchar *action_name);
```
"""
function g_action_group_action_removed(action_group, action_name)
    @ccall libaravis.g_action_group_action_removed(action_group::Ptr{GActionGroup}, action_name::Ptr{gchar})::Cvoid
end

"""
    g_action_group_action_enabled_changed(action_group, action_name, enabled)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_action_group_action_enabled_changed (GActionGroup *action_group, const gchar *action_name, gboolean enabled);
```
"""
function g_action_group_action_enabled_changed(action_group, action_name, enabled)
    @ccall libaravis.g_action_group_action_enabled_changed(action_group::Ptr{GActionGroup}, action_name::Ptr{gchar}, enabled::gboolean)::Cvoid
end

"""
    g_action_group_action_state_changed(action_group, action_name, state)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_action_group_action_state_changed (GActionGroup *action_group, const gchar *action_name, GVariant *state);
```
"""
function g_action_group_action_state_changed(action_group, action_name, state)
    @ccall libaravis.g_action_group_action_state_changed(action_group::Ptr{GActionGroup}, action_name::Ptr{gchar}, state::Ptr{GVariant})::Cvoid
end

"""
    g_action_group_query_action(action_group, action_name, enabled, parameter_type, state_type, state_hint, state)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 gboolean g_action_group_query_action (GActionGroup *action_group, const gchar *action_name, gboolean *enabled, const GVariantType **parameter_type, const GVariantType **state_type, GVariant **state_hint, GVariant **state) G_GNUC_WARN_UNUSED_RESULT;
```
"""
function g_action_group_query_action(action_group, action_name, enabled, parameter_type, state_type, state_hint, state)
    @ccall libaravis.g_action_group_query_action(action_group::Ptr{GActionGroup}, action_name::Ptr{gchar}, enabled::Ptr{gboolean}, parameter_type::Ptr{Ptr{GVariantType}}, state_type::Ptr{Ptr{GVariantType}}, state_hint::Ptr{Ptr{GVariant}}, state::Ptr{Ptr{GVariant}})::gboolean
end

"""
    g_dbus_connection_export_action_group(connection, object_path, action_group, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 guint g_dbus_connection_export_action_group (GDBusConnection *connection, const gchar *object_path, GActionGroup *action_group, GError **error);
```
"""
function g_dbus_connection_export_action_group(connection, object_path, action_group, error)
    @ccall libaravis.g_dbus_connection_export_action_group(connection::Ptr{GDBusConnection}, object_path::Ptr{gchar}, action_group::Ptr{GActionGroup}, error::Ptr{Ptr{GError}})::guint
end

"""
    g_dbus_connection_unexport_action_group(connection, export_id)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_dbus_connection_unexport_action_group (GDBusConnection *connection, guint export_id);
```
"""
function g_dbus_connection_unexport_action_group(connection, export_id)
    @ccall libaravis.g_dbus_connection_unexport_action_group(connection::Ptr{GDBusConnection}, export_id::guint)::Cvoid
end

struct _GActionEntry
    name::Ptr{gchar}
    activate::Ptr{Cvoid}
    parameter_type::Ptr{gchar}
    state::Ptr{gchar}
    change_state::Ptr{Cvoid}
    padding::NTuple{3, gsize}
end

const GActionEntry = _GActionEntry

"""
    g_action_map_lookup_action(action_map, action_name)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GAction * g_action_map_lookup_action (GActionMap *action_map, const gchar *action_name);
```
"""
function g_action_map_lookup_action(action_map, action_name)
    @ccall libaravis.g_action_map_lookup_action(action_map::Ptr{GActionMap}, action_name::Ptr{gchar})::Ptr{GAction}
end

"""
    g_action_map_add_action(action_map, action)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_action_map_add_action (GActionMap *action_map, GAction *action);
```
"""
function g_action_map_add_action(action_map, action)
    @ccall libaravis.g_action_map_add_action(action_map::Ptr{GActionMap}, action::Ptr{GAction})::Cvoid
end

"""
    g_action_map_remove_action(action_map, action_name)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_action_map_remove_action (GActionMap *action_map, const gchar *action_name);
```
"""
function g_action_map_remove_action(action_map, action_name)
    @ccall libaravis.g_action_map_remove_action(action_map::Ptr{GActionMap}, action_name::Ptr{gchar})::Cvoid
end

"""
    g_action_map_add_action_entries(action_map, entries, n_entries, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_action_map_add_action_entries (GActionMap *action_map, const GActionEntry *entries, gint n_entries, gpointer user_data);
```
"""
function g_action_map_add_action_entries(action_map, entries, n_entries, user_data)
    @ccall libaravis.g_action_map_add_action_entries(action_map::Ptr{GActionMap}, entries::Ptr{GActionEntry}, n_entries::gint, user_data::gpointer)::Cvoid
end

"""
    g_action_map_remove_action_entries(action_map, entries, n_entries)

### Prototype
```c
GIO_AVAILABLE_IN_2_78 void g_action_map_remove_action_entries (GActionMap *action_map, const GActionEntry *entries, gint n_entries);
```
"""
function g_action_map_remove_action_entries(action_map, entries, n_entries)
    @ccall libaravis.g_action_map_remove_action_entries(action_map::Ptr{GActionMap}, entries::Ptr{GActionEntry}, n_entries::gint)::Cvoid
end

"""
    g_app_info_create_from_commandline(commandline, application_name, flags, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GAppInfo * g_app_info_create_from_commandline (const char *commandline, const char *application_name, GAppInfoCreateFlags flags, GError **error);
```
"""
function g_app_info_create_from_commandline(commandline, application_name, flags, error)
    @ccall libaravis.g_app_info_create_from_commandline(commandline::Cstring, application_name::Cstring, flags::GAppInfoCreateFlags, error::Ptr{Ptr{GError}})::Ptr{GAppInfo}
end

"""
    g_app_info_dup(appinfo)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GAppInfo * g_app_info_dup (GAppInfo *appinfo);
```
"""
function g_app_info_dup(appinfo)
    @ccall libaravis.g_app_info_dup(appinfo::Ptr{GAppInfo})::Ptr{GAppInfo}
end

"""
    g_app_info_equal(appinfo1, appinfo2)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_app_info_equal (GAppInfo *appinfo1, GAppInfo *appinfo2);
```
"""
function g_app_info_equal(appinfo1, appinfo2)
    @ccall libaravis.g_app_info_equal(appinfo1::Ptr{GAppInfo}, appinfo2::Ptr{GAppInfo})::gboolean
end

"""
    g_app_info_get_id(appinfo)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const char *g_app_info_get_id (GAppInfo *appinfo);
```
"""
function g_app_info_get_id(appinfo)
    @ccall libaravis.g_app_info_get_id(appinfo::Ptr{GAppInfo})::Cstring
end

"""
    g_app_info_get_name(appinfo)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const char *g_app_info_get_name (GAppInfo *appinfo);
```
"""
function g_app_info_get_name(appinfo)
    @ccall libaravis.g_app_info_get_name(appinfo::Ptr{GAppInfo})::Cstring
end

"""
    g_app_info_get_display_name(appinfo)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const char *g_app_info_get_display_name (GAppInfo *appinfo);
```
"""
function g_app_info_get_display_name(appinfo)
    @ccall libaravis.g_app_info_get_display_name(appinfo::Ptr{GAppInfo})::Cstring
end

"""
    g_app_info_get_description(appinfo)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const char *g_app_info_get_description (GAppInfo *appinfo);
```
"""
function g_app_info_get_description(appinfo)
    @ccall libaravis.g_app_info_get_description(appinfo::Ptr{GAppInfo})::Cstring
end

"""
    g_app_info_get_executable(appinfo)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const char *g_app_info_get_executable (GAppInfo *appinfo);
```
"""
function g_app_info_get_executable(appinfo)
    @ccall libaravis.g_app_info_get_executable(appinfo::Ptr{GAppInfo})::Cstring
end

"""
    g_app_info_get_commandline(appinfo)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const char *g_app_info_get_commandline (GAppInfo *appinfo);
```
"""
function g_app_info_get_commandline(appinfo)
    @ccall libaravis.g_app_info_get_commandline(appinfo::Ptr{GAppInfo})::Cstring
end

"""
    g_app_info_get_icon(appinfo)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIcon * g_app_info_get_icon (GAppInfo *appinfo);
```
"""
function g_app_info_get_icon(appinfo)
    @ccall libaravis.g_app_info_get_icon(appinfo::Ptr{GAppInfo})::Ptr{GIcon}
end

"""
    g_app_info_launch(appinfo, files, context, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_app_info_launch (GAppInfo *appinfo, GList *files, GAppLaunchContext *context, GError **error);
```
"""
function g_app_info_launch(appinfo, files, context, error)
    @ccall libaravis.g_app_info_launch(appinfo::Ptr{GAppInfo}, files::Ptr{GList}, context::Ptr{GAppLaunchContext}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_app_info_supports_uris(appinfo)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_app_info_supports_uris (GAppInfo *appinfo);
```
"""
function g_app_info_supports_uris(appinfo)
    @ccall libaravis.g_app_info_supports_uris(appinfo::Ptr{GAppInfo})::gboolean
end

"""
    g_app_info_supports_files(appinfo)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_app_info_supports_files (GAppInfo *appinfo);
```
"""
function g_app_info_supports_files(appinfo)
    @ccall libaravis.g_app_info_supports_files(appinfo::Ptr{GAppInfo})::gboolean
end

"""
    g_app_info_launch_uris(appinfo, uris, context, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_app_info_launch_uris (GAppInfo *appinfo, GList *uris, GAppLaunchContext *context, GError **error);
```
"""
function g_app_info_launch_uris(appinfo, uris, context, error)
    @ccall libaravis.g_app_info_launch_uris(appinfo::Ptr{GAppInfo}, uris::Ptr{GList}, context::Ptr{GAppLaunchContext}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_app_info_launch_uris_async(appinfo, uris, context, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_60 void g_app_info_launch_uris_async (GAppInfo *appinfo, GList *uris, GAppLaunchContext *context, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_app_info_launch_uris_async(appinfo, uris, context, cancellable, callback, user_data)
    @ccall libaravis.g_app_info_launch_uris_async(appinfo::Ptr{GAppInfo}, uris::Ptr{GList}, context::Ptr{GAppLaunchContext}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_app_info_launch_uris_finish(appinfo, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_60 gboolean g_app_info_launch_uris_finish (GAppInfo *appinfo, GAsyncResult *result, GError **error);
```
"""
function g_app_info_launch_uris_finish(appinfo, result, error)
    @ccall libaravis.g_app_info_launch_uris_finish(appinfo::Ptr{GAppInfo}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_app_info_should_show(appinfo)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_app_info_should_show (GAppInfo *appinfo);
```
"""
function g_app_info_should_show(appinfo)
    @ccall libaravis.g_app_info_should_show(appinfo::Ptr{GAppInfo})::gboolean
end

"""
    g_app_info_set_as_default_for_type(appinfo, content_type, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_app_info_set_as_default_for_type (GAppInfo *appinfo, const char *content_type, GError **error);
```
"""
function g_app_info_set_as_default_for_type(appinfo, content_type, error)
    @ccall libaravis.g_app_info_set_as_default_for_type(appinfo::Ptr{GAppInfo}, content_type::Cstring, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_app_info_set_as_default_for_extension(appinfo, extension, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_app_info_set_as_default_for_extension (GAppInfo *appinfo, const char *extension, GError **error);
```
"""
function g_app_info_set_as_default_for_extension(appinfo, extension, error)
    @ccall libaravis.g_app_info_set_as_default_for_extension(appinfo::Ptr{GAppInfo}, extension::Cstring, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_app_info_add_supports_type(appinfo, content_type, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_app_info_add_supports_type (GAppInfo *appinfo, const char *content_type, GError **error);
```
"""
function g_app_info_add_supports_type(appinfo, content_type, error)
    @ccall libaravis.g_app_info_add_supports_type(appinfo::Ptr{GAppInfo}, content_type::Cstring, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_app_info_can_remove_supports_type(appinfo)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_app_info_can_remove_supports_type (GAppInfo *appinfo);
```
"""
function g_app_info_can_remove_supports_type(appinfo)
    @ccall libaravis.g_app_info_can_remove_supports_type(appinfo::Ptr{GAppInfo})::gboolean
end

"""
    g_app_info_remove_supports_type(appinfo, content_type, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_app_info_remove_supports_type (GAppInfo *appinfo, const char *content_type, GError **error);
```
"""
function g_app_info_remove_supports_type(appinfo, content_type, error)
    @ccall libaravis.g_app_info_remove_supports_type(appinfo::Ptr{GAppInfo}, content_type::Cstring, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_app_info_get_supported_types(appinfo)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 const char **g_app_info_get_supported_types (GAppInfo *appinfo);
```
"""
function g_app_info_get_supported_types(appinfo)
    @ccall libaravis.g_app_info_get_supported_types(appinfo::Ptr{GAppInfo})::Ptr{Cstring}
end

"""
    g_app_info_can_delete(appinfo)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_app_info_can_delete (GAppInfo *appinfo);
```
"""
function g_app_info_can_delete(appinfo)
    @ccall libaravis.g_app_info_can_delete(appinfo::Ptr{GAppInfo})::gboolean
end

"""
    g_app_info_delete(appinfo)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_app_info_delete (GAppInfo *appinfo);
```
"""
function g_app_info_delete(appinfo)
    @ccall libaravis.g_app_info_delete(appinfo::Ptr{GAppInfo})::gboolean
end

"""
    g_app_info_set_as_last_used_for_type(appinfo, content_type, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_app_info_set_as_last_used_for_type (GAppInfo *appinfo, const char *content_type, GError **error);
```
"""
function g_app_info_set_as_last_used_for_type(appinfo, content_type, error)
    @ccall libaravis.g_app_info_set_as_last_used_for_type(appinfo::Ptr{GAppInfo}, content_type::Cstring, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_app_info_get_all()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GList * g_app_info_get_all (void);
```
"""
function g_app_info_get_all()
    @ccall libaravis.g_app_info_get_all()::Ptr{GList}
end

"""
    g_app_info_get_all_for_type(content_type)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GList * g_app_info_get_all_for_type (const char *content_type);
```
"""
function g_app_info_get_all_for_type(content_type)
    @ccall libaravis.g_app_info_get_all_for_type(content_type::Cstring)::Ptr{GList}
end

"""
    g_app_info_get_recommended_for_type(content_type)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GList * g_app_info_get_recommended_for_type (const gchar *content_type);
```
"""
function g_app_info_get_recommended_for_type(content_type)
    @ccall libaravis.g_app_info_get_recommended_for_type(content_type::Ptr{gchar})::Ptr{GList}
end

"""
    g_app_info_get_fallback_for_type(content_type)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GList * g_app_info_get_fallback_for_type (const gchar *content_type);
```
"""
function g_app_info_get_fallback_for_type(content_type)
    @ccall libaravis.g_app_info_get_fallback_for_type(content_type::Ptr{gchar})::Ptr{GList}
end

"""
    g_app_info_reset_type_associations(content_type)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_app_info_reset_type_associations (const char *content_type);
```
"""
function g_app_info_reset_type_associations(content_type)
    @ccall libaravis.g_app_info_reset_type_associations(content_type::Cstring)::Cvoid
end

"""
    g_app_info_get_default_for_type(content_type, must_support_uris)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GAppInfo *g_app_info_get_default_for_type (const char *content_type, gboolean must_support_uris);
```
"""
function g_app_info_get_default_for_type(content_type, must_support_uris)
    @ccall libaravis.g_app_info_get_default_for_type(content_type::Cstring, must_support_uris::gboolean)::Ptr{GAppInfo}
end

"""
    g_app_info_get_default_for_type_async(content_type, must_support_uris, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_74 void g_app_info_get_default_for_type_async (const char *content_type, gboolean must_support_uris, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_app_info_get_default_for_type_async(content_type, must_support_uris, cancellable, callback, user_data)
    @ccall libaravis.g_app_info_get_default_for_type_async(content_type::Cstring, must_support_uris::gboolean, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_app_info_get_default_for_type_finish(result, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_74 GAppInfo *g_app_info_get_default_for_type_finish (GAsyncResult *result, GError **error);
```
"""
function g_app_info_get_default_for_type_finish(result, error)
    @ccall libaravis.g_app_info_get_default_for_type_finish(result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GAppInfo}
end

"""
    g_app_info_get_default_for_uri_scheme(uri_scheme)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GAppInfo *g_app_info_get_default_for_uri_scheme (const char *uri_scheme);
```
"""
function g_app_info_get_default_for_uri_scheme(uri_scheme)
    @ccall libaravis.g_app_info_get_default_for_uri_scheme(uri_scheme::Cstring)::Ptr{GAppInfo}
end

"""
    g_app_info_get_default_for_uri_scheme_async(uri_scheme, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_74 void g_app_info_get_default_for_uri_scheme_async (const char *uri_scheme, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_app_info_get_default_for_uri_scheme_async(uri_scheme, cancellable, callback, user_data)
    @ccall libaravis.g_app_info_get_default_for_uri_scheme_async(uri_scheme::Cstring, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_app_info_get_default_for_uri_scheme_finish(result, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_74 GAppInfo *g_app_info_get_default_for_uri_scheme_finish (GAsyncResult *result, GError **error);
```
"""
function g_app_info_get_default_for_uri_scheme_finish(result, error)
    @ccall libaravis.g_app_info_get_default_for_uri_scheme_finish(result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GAppInfo}
end

"""
    g_app_info_launch_default_for_uri(uri, context, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_app_info_launch_default_for_uri (const char *uri, GAppLaunchContext *context, GError **error);
```
"""
function g_app_info_launch_default_for_uri(uri, context, error)
    @ccall libaravis.g_app_info_launch_default_for_uri(uri::Cstring, context::Ptr{GAppLaunchContext}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_app_info_launch_default_for_uri_async(uri, context, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_50 void g_app_info_launch_default_for_uri_async (const char *uri, GAppLaunchContext *context, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_app_info_launch_default_for_uri_async(uri, context, cancellable, callback, user_data)
    @ccall libaravis.g_app_info_launch_default_for_uri_async(uri::Cstring, context::Ptr{GAppLaunchContext}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_app_info_launch_default_for_uri_finish(result, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_50 gboolean g_app_info_launch_default_for_uri_finish (GAsyncResult *result, GError **error);
```
"""
function g_app_info_launch_default_for_uri_finish(result, error)
    @ccall libaravis.g_app_info_launch_default_for_uri_finish(result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_app_launch_context_new()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GAppLaunchContext *g_app_launch_context_new (void);
```
"""
function g_app_launch_context_new()
    @ccall libaravis.g_app_launch_context_new()::Ptr{GAppLaunchContext}
end

"""
    g_app_launch_context_setenv(context, variable, value)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_app_launch_context_setenv (GAppLaunchContext *context, const char *variable, const char *value);
```
"""
function g_app_launch_context_setenv(context, variable, value)
    @ccall libaravis.g_app_launch_context_setenv(context::Ptr{GAppLaunchContext}, variable::Cstring, value::Cstring)::Cvoid
end

"""
    g_app_launch_context_unsetenv(context, variable)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_app_launch_context_unsetenv (GAppLaunchContext *context, const char *variable);
```
"""
function g_app_launch_context_unsetenv(context, variable)
    @ccall libaravis.g_app_launch_context_unsetenv(context::Ptr{GAppLaunchContext}, variable::Cstring)::Cvoid
end

"""
    g_app_launch_context_get_environment(context)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 char ** g_app_launch_context_get_environment (GAppLaunchContext *context);
```
"""
function g_app_launch_context_get_environment(context)
    @ccall libaravis.g_app_launch_context_get_environment(context::Ptr{GAppLaunchContext})::Ptr{Cstring}
end

"""
    g_app_launch_context_get_display(context, info, files)

### Prototype
```c
GIO_AVAILABLE_IN_ALL char * g_app_launch_context_get_display (GAppLaunchContext *context, GAppInfo *info, GList *files);
```
"""
function g_app_launch_context_get_display(context, info, files)
    @ccall libaravis.g_app_launch_context_get_display(context::Ptr{GAppLaunchContext}, info::Ptr{GAppInfo}, files::Ptr{GList})::Cstring
end

"""
    g_app_launch_context_get_startup_notify_id(context, info, files)

### Prototype
```c
GIO_AVAILABLE_IN_ALL char * g_app_launch_context_get_startup_notify_id (GAppLaunchContext *context, GAppInfo *info, GList *files);
```
"""
function g_app_launch_context_get_startup_notify_id(context, info, files)
    @ccall libaravis.g_app_launch_context_get_startup_notify_id(context::Ptr{GAppLaunchContext}, info::Ptr{GAppInfo}, files::Ptr{GList})::Cstring
end

"""
    g_app_launch_context_launch_failed(context, startup_notify_id)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_app_launch_context_launch_failed (GAppLaunchContext *context, const char * startup_notify_id);
```
"""
function g_app_launch_context_launch_failed(context, startup_notify_id)
    @ccall libaravis.g_app_launch_context_launch_failed(context::Ptr{GAppLaunchContext}, startup_notify_id::Cstring)::Cvoid
end

"""
    g_app_info_monitor_get()

### Prototype
```c
GIO_AVAILABLE_IN_2_40 GAppInfoMonitor * g_app_info_monitor_get (void);
```
"""
function g_app_info_monitor_get()
    @ccall libaravis.g_app_info_monitor_get()::Ptr{GAppInfoMonitor}
end

"""
    g_application_id_is_valid(application_id)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_application_id_is_valid (const gchar *application_id);
```
"""
function g_application_id_is_valid(application_id)
    @ccall libaravis.g_application_id_is_valid(application_id::Ptr{gchar})::gboolean
end

"""
    g_application_new(application_id, flags)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GApplication * g_application_new (const gchar *application_id, GApplicationFlags flags);
```
"""
function g_application_new(application_id, flags)
    @ccall libaravis.g_application_new(application_id::Ptr{gchar}, flags::GApplicationFlags)::Ptr{GApplication}
end

"""
    g_application_get_application_id(application)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar * g_application_get_application_id (GApplication *application);
```
"""
function g_application_get_application_id(application)
    @ccall libaravis.g_application_get_application_id(application::Ptr{GApplication})::Ptr{gchar}
end

"""
    g_application_set_application_id(application, application_id)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_application_set_application_id (GApplication *application, const gchar *application_id);
```
"""
function g_application_set_application_id(application, application_id)
    @ccall libaravis.g_application_set_application_id(application::Ptr{GApplication}, application_id::Ptr{gchar})::Cvoid
end

"""
    g_application_get_version(application)

### Prototype
```c
GIO_AVAILABLE_IN_2_80 const gchar * g_application_get_version (GApplication *application);
```
"""
function g_application_get_version(application)
    @ccall libaravis.g_application_get_version(application::Ptr{GApplication})::Ptr{gchar}
end

"""
    g_application_set_version(application, version)

### Prototype
```c
GIO_AVAILABLE_IN_2_80 void g_application_set_version (GApplication *application, const gchar *version);
```
"""
function g_application_set_version(application, version)
    @ccall libaravis.g_application_set_version(application::Ptr{GApplication}, version::Ptr{gchar})::Cvoid
end

"""
    g_application_get_dbus_connection(application)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 GDBusConnection * g_application_get_dbus_connection (GApplication *application);
```
"""
function g_application_get_dbus_connection(application)
    @ccall libaravis.g_application_get_dbus_connection(application::Ptr{GApplication})::Ptr{GDBusConnection}
end

"""
    g_application_get_dbus_object_path(application)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 const gchar * g_application_get_dbus_object_path (GApplication *application);
```
"""
function g_application_get_dbus_object_path(application)
    @ccall libaravis.g_application_get_dbus_object_path(application::Ptr{GApplication})::Ptr{gchar}
end

"""
    g_application_get_inactivity_timeout(application)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint g_application_get_inactivity_timeout (GApplication *application);
```
"""
function g_application_get_inactivity_timeout(application)
    @ccall libaravis.g_application_get_inactivity_timeout(application::Ptr{GApplication})::guint
end

"""
    g_application_set_inactivity_timeout(application, inactivity_timeout)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_application_set_inactivity_timeout (GApplication *application, guint inactivity_timeout);
```
"""
function g_application_set_inactivity_timeout(application, inactivity_timeout)
    @ccall libaravis.g_application_set_inactivity_timeout(application::Ptr{GApplication}, inactivity_timeout::guint)::Cvoid
end

"""
    g_application_get_flags(application)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GApplicationFlags g_application_get_flags (GApplication *application);
```
"""
function g_application_get_flags(application)
    @ccall libaravis.g_application_get_flags(application::Ptr{GApplication})::GApplicationFlags
end

"""
    g_application_set_flags(application, flags)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_application_set_flags (GApplication *application, GApplicationFlags flags);
```
"""
function g_application_set_flags(application, flags)
    @ccall libaravis.g_application_set_flags(application::Ptr{GApplication}, flags::GApplicationFlags)::Cvoid
end

"""
    g_application_get_resource_base_path(application)

### Prototype
```c
GIO_AVAILABLE_IN_2_42 const gchar * g_application_get_resource_base_path (GApplication *application);
```
"""
function g_application_get_resource_base_path(application)
    @ccall libaravis.g_application_get_resource_base_path(application::Ptr{GApplication})::Ptr{gchar}
end

"""
    g_application_set_resource_base_path(application, resource_path)

### Prototype
```c
GIO_AVAILABLE_IN_2_42 void g_application_set_resource_base_path (GApplication *application, const gchar *resource_path);
```
"""
function g_application_set_resource_base_path(application, resource_path)
    @ccall libaravis.g_application_set_resource_base_path(application::Ptr{GApplication}, resource_path::Ptr{gchar})::Cvoid
end

"""
    g_application_set_action_group(application, action_group)

### Prototype
```c
GIO_DEPRECATED void g_application_set_action_group (GApplication *application, GActionGroup *action_group);
```
"""
function g_application_set_action_group(application, action_group)
    @ccall libaravis.g_application_set_action_group(application::Ptr{GApplication}, action_group::Ptr{GActionGroup})::Cvoid
end

"""
    g_application_add_main_option_entries(application, entries)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_application_add_main_option_entries (GApplication *application, const GOptionEntry *entries);
```
"""
function g_application_add_main_option_entries(application, entries)
    @ccall libaravis.g_application_add_main_option_entries(application::Ptr{GApplication}, entries::Ptr{GOptionEntry})::Cvoid
end

"""
    g_application_add_main_option(application, long_name, short_name, flags, arg, description, arg_description)

### Prototype
```c
GIO_AVAILABLE_IN_2_42 void g_application_add_main_option (GApplication *application, const char *long_name, char short_name, GOptionFlags flags, GOptionArg arg, const char *description, const char *arg_description);
```
"""
function g_application_add_main_option(application, long_name, short_name, flags, arg, description, arg_description)
    @ccall libaravis.g_application_add_main_option(application::Ptr{GApplication}, long_name::Cstring, short_name::Cchar, flags::GOptionFlags, arg::GOptionArg, description::Cstring, arg_description::Cstring)::Cvoid
end

"""
    g_application_add_option_group(application, group)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_application_add_option_group (GApplication *application, GOptionGroup *group);
```
"""
function g_application_add_option_group(application, group)
    @ccall libaravis.g_application_add_option_group(application::Ptr{GApplication}, group::Ptr{GOptionGroup})::Cvoid
end

"""
    g_application_set_option_context_parameter_string(application, parameter_string)

### Prototype
```c
GIO_AVAILABLE_IN_2_56 void g_application_set_option_context_parameter_string (GApplication *application, const gchar *parameter_string);
```
"""
function g_application_set_option_context_parameter_string(application, parameter_string)
    @ccall libaravis.g_application_set_option_context_parameter_string(application::Ptr{GApplication}, parameter_string::Ptr{gchar})::Cvoid
end

"""
    g_application_set_option_context_summary(application, summary)

### Prototype
```c
GIO_AVAILABLE_IN_2_56 void g_application_set_option_context_summary (GApplication *application, const gchar *summary);
```
"""
function g_application_set_option_context_summary(application, summary)
    @ccall libaravis.g_application_set_option_context_summary(application::Ptr{GApplication}, summary::Ptr{gchar})::Cvoid
end

"""
    g_application_set_option_context_description(application, description)

### Prototype
```c
GIO_AVAILABLE_IN_2_56 void g_application_set_option_context_description (GApplication *application, const gchar *description);
```
"""
function g_application_set_option_context_description(application, description)
    @ccall libaravis.g_application_set_option_context_description(application::Ptr{GApplication}, description::Ptr{gchar})::Cvoid
end

"""
    g_application_get_is_registered(application)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_application_get_is_registered (GApplication *application);
```
"""
function g_application_get_is_registered(application)
    @ccall libaravis.g_application_get_is_registered(application::Ptr{GApplication})::gboolean
end

"""
    g_application_get_is_remote(application)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_application_get_is_remote (GApplication *application);
```
"""
function g_application_get_is_remote(application)
    @ccall libaravis.g_application_get_is_remote(application::Ptr{GApplication})::gboolean
end

"""
    g_application_register(application, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_application_register (GApplication *application, GCancellable *cancellable, GError **error);
```
"""
function g_application_register(application, cancellable, error)
    @ccall libaravis.g_application_register(application::Ptr{GApplication}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_application_hold(application)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_application_hold (GApplication *application);
```
"""
function g_application_hold(application)
    @ccall libaravis.g_application_hold(application::Ptr{GApplication})::Cvoid
end

"""
    g_application_release(application)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_application_release (GApplication *application);
```
"""
function g_application_release(application)
    @ccall libaravis.g_application_release(application::Ptr{GApplication})::Cvoid
end

"""
    g_application_activate(application)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_application_activate (GApplication *application);
```
"""
function g_application_activate(application)
    @ccall libaravis.g_application_activate(application::Ptr{GApplication})::Cvoid
end

"""
    g_application_open(application, files, n_files, hint)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_application_open (GApplication *application, GFile **files, gint n_files, const gchar *hint);
```
"""
function g_application_open(application, files, n_files, hint)
    @ccall libaravis.g_application_open(application::Ptr{GApplication}, files::Ptr{Ptr{GFile}}, n_files::gint, hint::Ptr{gchar})::Cvoid
end

"""
    g_application_run(application, argc, argv)

### Prototype
```c
GIO_AVAILABLE_IN_ALL int g_application_run (GApplication *application, int argc, char **argv);
```
"""
function g_application_run(application, argc, argv)
    @ccall libaravis.g_application_run(application::Ptr{GApplication}, argc::Cint, argv::Ptr{Cstring})::Cint
end

"""
    g_application_quit(application)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_application_quit (GApplication *application);
```
"""
function g_application_quit(application)
    @ccall libaravis.g_application_quit(application::Ptr{GApplication})::Cvoid
end

"""
    g_application_get_default()

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GApplication * g_application_get_default (void);
```
"""
function g_application_get_default()
    @ccall libaravis.g_application_get_default()::Ptr{GApplication}
end

"""
    g_application_set_default(application)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_application_set_default (GApplication *application);
```
"""
function g_application_set_default(application)
    @ccall libaravis.g_application_set_default(application::Ptr{GApplication})::Cvoid
end

"""
    g_application_mark_busy(application)

### Prototype
```c
GIO_AVAILABLE_IN_2_38 void g_application_mark_busy (GApplication *application);
```
"""
function g_application_mark_busy(application)
    @ccall libaravis.g_application_mark_busy(application::Ptr{GApplication})::Cvoid
end

"""
    g_application_unmark_busy(application)

### Prototype
```c
GIO_AVAILABLE_IN_2_38 void g_application_unmark_busy (GApplication *application);
```
"""
function g_application_unmark_busy(application)
    @ccall libaravis.g_application_unmark_busy(application::Ptr{GApplication})::Cvoid
end

"""
    g_application_get_is_busy(application)

### Prototype
```c
GIO_AVAILABLE_IN_2_44 gboolean g_application_get_is_busy (GApplication *application);
```
"""
function g_application_get_is_busy(application)
    @ccall libaravis.g_application_get_is_busy(application::Ptr{GApplication})::gboolean
end

"""
    g_application_send_notification(application, id, notification)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_application_send_notification (GApplication *application, const gchar *id, GNotification *notification);
```
"""
function g_application_send_notification(application, id, notification)
    @ccall libaravis.g_application_send_notification(application::Ptr{GApplication}, id::Ptr{gchar}, notification::Ptr{GNotification})::Cvoid
end

"""
    g_application_withdraw_notification(application, id)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_application_withdraw_notification (GApplication *application, const gchar *id);
```
"""
function g_application_withdraw_notification(application, id)
    @ccall libaravis.g_application_withdraw_notification(application::Ptr{GApplication}, id::Ptr{gchar})::Cvoid
end

"""
    g_application_bind_busy_property(application, object, property)

### Prototype
```c
GIO_AVAILABLE_IN_2_44 void g_application_bind_busy_property (GApplication *application, gpointer object, const gchar *property);
```
"""
function g_application_bind_busy_property(application, object, property)
    @ccall libaravis.g_application_bind_busy_property(application::Ptr{GApplication}, object::gpointer, property::Ptr{gchar})::Cvoid
end

"""
    g_application_unbind_busy_property(application, object, property)

### Prototype
```c
GIO_AVAILABLE_IN_2_44 void g_application_unbind_busy_property (GApplication *application, gpointer object, const gchar *property);
```
"""
function g_application_unbind_busy_property(application, object, property)
    @ccall libaravis.g_application_unbind_busy_property(application::Ptr{GApplication}, object::gpointer, property::Ptr{gchar})::Cvoid
end

"""
    g_application_command_line_get_arguments(cmdline, argc)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gchar ** g_application_command_line_get_arguments (GApplicationCommandLine *cmdline, int *argc);
```
"""
function g_application_command_line_get_arguments(cmdline, argc)
    @ccall libaravis.g_application_command_line_get_arguments(cmdline::Ptr{GApplicationCommandLine}, argc::Ptr{Cint})::Ptr{Ptr{gchar}}
end

"""
    g_application_command_line_get_options_dict(cmdline)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 GVariantDict * g_application_command_line_get_options_dict (GApplicationCommandLine *cmdline);
```
"""
function g_application_command_line_get_options_dict(cmdline)
    @ccall libaravis.g_application_command_line_get_options_dict(cmdline::Ptr{GApplicationCommandLine})::Ptr{GVariantDict}
end

"""
    g_application_command_line_get_stdin(cmdline)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 GInputStream * g_application_command_line_get_stdin (GApplicationCommandLine *cmdline);
```
"""
function g_application_command_line_get_stdin(cmdline)
    @ccall libaravis.g_application_command_line_get_stdin(cmdline::Ptr{GApplicationCommandLine})::Ptr{GInputStream}
end

"""
    g_application_command_line_get_environ(cmdline)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar * const * g_application_command_line_get_environ (GApplicationCommandLine *cmdline);
```
"""
function g_application_command_line_get_environ(cmdline)
    @ccall libaravis.g_application_command_line_get_environ(cmdline::Ptr{GApplicationCommandLine})::Ptr{Ptr{gchar}}
end

"""
    g_application_command_line_getenv(cmdline, name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar * g_application_command_line_getenv (GApplicationCommandLine *cmdline, const gchar *name);
```
"""
function g_application_command_line_getenv(cmdline, name)
    @ccall libaravis.g_application_command_line_getenv(cmdline::Ptr{GApplicationCommandLine}, name::Ptr{gchar})::Ptr{gchar}
end

"""
    g_application_command_line_get_cwd(cmdline)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar * g_application_command_line_get_cwd (GApplicationCommandLine *cmdline);
```
"""
function g_application_command_line_get_cwd(cmdline)
    @ccall libaravis.g_application_command_line_get_cwd(cmdline::Ptr{GApplicationCommandLine})::Ptr{gchar}
end

"""
    g_application_command_line_get_is_remote(cmdline)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_application_command_line_get_is_remote (GApplicationCommandLine *cmdline);
```
"""
function g_application_command_line_get_is_remote(cmdline)
    @ccall libaravis.g_application_command_line_get_is_remote(cmdline::Ptr{GApplicationCommandLine})::gboolean
end

"""
    g_application_command_line_print_literal(cmdline, message)

### Prototype
```c
GIO_AVAILABLE_IN_2_80 void g_application_command_line_print_literal (GApplicationCommandLine *cmdline, const gchar *message);
```
"""
function g_application_command_line_print_literal(cmdline, message)
    @ccall libaravis.g_application_command_line_print_literal(cmdline::Ptr{GApplicationCommandLine}, message::Ptr{gchar})::Cvoid
end

"""
    g_application_command_line_printerr_literal(cmdline, message)

### Prototype
```c
GIO_AVAILABLE_IN_2_80 void g_application_command_line_printerr_literal (GApplicationCommandLine *cmdline, const gchar *message);
```
"""
function g_application_command_line_printerr_literal(cmdline, message)
    @ccall libaravis.g_application_command_line_printerr_literal(cmdline::Ptr{GApplicationCommandLine}, message::Ptr{gchar})::Cvoid
end

"""
    g_application_command_line_get_exit_status(cmdline)

### Prototype
```c
GIO_AVAILABLE_IN_ALL int g_application_command_line_get_exit_status (GApplicationCommandLine *cmdline);
```
"""
function g_application_command_line_get_exit_status(cmdline)
    @ccall libaravis.g_application_command_line_get_exit_status(cmdline::Ptr{GApplicationCommandLine})::Cint
end

"""
    g_application_command_line_set_exit_status(cmdline, exit_status)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_application_command_line_set_exit_status (GApplicationCommandLine *cmdline, int exit_status);
```
"""
function g_application_command_line_set_exit_status(cmdline, exit_status)
    @ccall libaravis.g_application_command_line_set_exit_status(cmdline::Ptr{GApplicationCommandLine}, exit_status::Cint)::Cvoid
end

"""
    g_application_command_line_get_platform_data(cmdline)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GVariant * g_application_command_line_get_platform_data (GApplicationCommandLine *cmdline);
```
"""
function g_application_command_line_get_platform_data(cmdline)
    @ccall libaravis.g_application_command_line_get_platform_data(cmdline::Ptr{GApplicationCommandLine})::Ptr{GVariant}
end

"""
    g_application_command_line_create_file_for_arg(cmdline, arg)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 GFile * g_application_command_line_create_file_for_arg (GApplicationCommandLine *cmdline, const gchar *arg);
```
"""
function g_application_command_line_create_file_for_arg(cmdline, arg)
    @ccall libaravis.g_application_command_line_create_file_for_arg(cmdline::Ptr{GApplicationCommandLine}, arg::Ptr{gchar})::Ptr{GFile}
end

"""
    g_application_command_line_done(cmdline)

### Prototype
```c
GIO_AVAILABLE_IN_2_80 void g_application_command_line_done (GApplicationCommandLine *cmdline);
```
"""
function g_application_command_line_done(cmdline)
    @ccall libaravis.g_application_command_line_done(cmdline::Ptr{GApplicationCommandLine})::Cvoid
end

"""
    g_initable_init(initable, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_initable_init (GInitable *initable, GCancellable *cancellable, GError **error);
```
"""
function g_initable_init(initable, cancellable, error)
    @ccall libaravis.g_initable_init(initable::Ptr{GInitable}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_initable_newv(object_type, n_parameters, parameters, cancellable, error)

### Prototype
```c
GIO_DEPRECATED_IN_2_54_FOR(g_object_new_with_properties and g_initable_init) gpointer g_initable_newv (GType object_type, guint n_parameters, GParameter *parameters, GCancellable *cancellable, GError **error);
```
"""
function g_initable_newv(object_type, n_parameters, parameters, cancellable, error)
    @ccall libaravis.g_initable_newv(object_type::GType, n_parameters::guint, parameters::Ptr{GParameter}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gpointer
end

"""
    g_async_initable_init_async(initable, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_async_initable_init_async (GAsyncInitable *initable, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_async_initable_init_async(initable, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_async_initable_init_async(initable::Ptr{GAsyncInitable}, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_async_initable_init_finish(initable, res, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_async_initable_init_finish (GAsyncInitable *initable, GAsyncResult *res, GError **error);
```
"""
function g_async_initable_init_finish(initable, res, error)
    @ccall libaravis.g_async_initable_init_finish(initable::Ptr{GAsyncInitable}, res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_async_initable_newv_async(object_type, n_parameters, parameters, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_DEPRECATED_IN_2_54_FOR(g_object_new_with_properties and g_async_initable_init_async) void g_async_initable_newv_async (GType object_type, guint n_parameters, GParameter *parameters, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_async_initable_newv_async(object_type, n_parameters, parameters, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_async_initable_newv_async(object_type::GType, n_parameters::guint, parameters::Ptr{GParameter}, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_async_initable_new_finish(initable, res, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GObject *g_async_initable_new_finish (GAsyncInitable *initable, GAsyncResult *res, GError **error);
```
"""
function g_async_initable_new_finish(initable, res, error)
    @ccall libaravis.g_async_initable_new_finish(initable::Ptr{GAsyncInitable}, res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GObject}
end

"""
    g_async_result_get_user_data(res)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gpointer g_async_result_get_user_data (GAsyncResult *res);
```
"""
function g_async_result_get_user_data(res)
    @ccall libaravis.g_async_result_get_user_data(res::Ptr{GAsyncResult})::gpointer
end

"""
    g_async_result_get_source_object(res)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GObject *g_async_result_get_source_object (GAsyncResult *res);
```
"""
function g_async_result_get_source_object(res)
    @ccall libaravis.g_async_result_get_source_object(res::Ptr{GAsyncResult})::Ptr{GObject}
end

"""
    g_async_result_legacy_propagate_error(res, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 gboolean g_async_result_legacy_propagate_error (GAsyncResult *res, GError **error);
```
"""
function g_async_result_legacy_propagate_error(res, error)
    @ccall libaravis.g_async_result_legacy_propagate_error(res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_async_result_is_tagged(res, source_tag)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 gboolean g_async_result_is_tagged (GAsyncResult *res, gpointer source_tag);
```
"""
function g_async_result_is_tagged(res, source_tag)
    @ccall libaravis.g_async_result_is_tagged(res::Ptr{GAsyncResult}, source_tag::gpointer)::gboolean
end

"""
    g_input_stream_read(stream, buffer, count, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gssize g_input_stream_read (GInputStream *stream, void *buffer, gsize count, GCancellable *cancellable, GError **error);
```
"""
function g_input_stream_read(stream, buffer, count, cancellable, error)
    @ccall libaravis.g_input_stream_read(stream::Ptr{GInputStream}, buffer::Ptr{Cvoid}, count::gsize, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gssize
end

"""
    g_input_stream_read_all(stream, buffer, count, bytes_read, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_input_stream_read_all (GInputStream *stream, void *buffer, gsize count, gsize *bytes_read, GCancellable *cancellable, GError **error);
```
"""
function g_input_stream_read_all(stream, buffer, count, bytes_read, cancellable, error)
    @ccall libaravis.g_input_stream_read_all(stream::Ptr{GInputStream}, buffer::Ptr{Cvoid}, count::gsize, bytes_read::Ptr{gsize}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_input_stream_read_bytes(stream, count, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 GBytes *g_input_stream_read_bytes (GInputStream *stream, gsize count, GCancellable *cancellable, GError **error);
```
"""
function g_input_stream_read_bytes(stream, count, cancellable, error)
    @ccall libaravis.g_input_stream_read_bytes(stream::Ptr{GInputStream}, count::gsize, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GBytes}
end

"""
    g_input_stream_skip(stream, count, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gssize g_input_stream_skip (GInputStream *stream, gsize count, GCancellable *cancellable, GError **error);
```
"""
function g_input_stream_skip(stream, count, cancellable, error)
    @ccall libaravis.g_input_stream_skip(stream::Ptr{GInputStream}, count::gsize, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gssize
end

"""
    g_input_stream_close(stream, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_input_stream_close (GInputStream *stream, GCancellable *cancellable, GError **error);
```
"""
function g_input_stream_close(stream, cancellable, error)
    @ccall libaravis.g_input_stream_close(stream::Ptr{GInputStream}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_input_stream_read_async(stream, buffer, count, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_input_stream_read_async (GInputStream *stream, void *buffer, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_input_stream_read_async(stream, buffer, count, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_input_stream_read_async(stream::Ptr{GInputStream}, buffer::Ptr{Cvoid}, count::gsize, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_input_stream_read_finish(stream, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gssize g_input_stream_read_finish (GInputStream *stream, GAsyncResult *result, GError **error);
```
"""
function g_input_stream_read_finish(stream, result, error)
    @ccall libaravis.g_input_stream_read_finish(stream::Ptr{GInputStream}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gssize
end

"""
    g_input_stream_read_all_async(stream, buffer, count, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_44 void g_input_stream_read_all_async (GInputStream *stream, void *buffer, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_input_stream_read_all_async(stream, buffer, count, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_input_stream_read_all_async(stream::Ptr{GInputStream}, buffer::Ptr{Cvoid}, count::gsize, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_input_stream_read_all_finish(stream, result, bytes_read, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_44 gboolean g_input_stream_read_all_finish (GInputStream *stream, GAsyncResult *result, gsize *bytes_read, GError **error);
```
"""
function g_input_stream_read_all_finish(stream, result, bytes_read, error)
    @ccall libaravis.g_input_stream_read_all_finish(stream::Ptr{GInputStream}, result::Ptr{GAsyncResult}, bytes_read::Ptr{gsize}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_input_stream_read_bytes_async(stream, count, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 void g_input_stream_read_bytes_async (GInputStream *stream, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_input_stream_read_bytes_async(stream, count, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_input_stream_read_bytes_async(stream::Ptr{GInputStream}, count::gsize, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_input_stream_read_bytes_finish(stream, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 GBytes *g_input_stream_read_bytes_finish (GInputStream *stream, GAsyncResult *result, GError **error);
```
"""
function g_input_stream_read_bytes_finish(stream, result, error)
    @ccall libaravis.g_input_stream_read_bytes_finish(stream::Ptr{GInputStream}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GBytes}
end

"""
    g_input_stream_skip_async(stream, count, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_input_stream_skip_async (GInputStream *stream, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_input_stream_skip_async(stream, count, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_input_stream_skip_async(stream::Ptr{GInputStream}, count::gsize, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_input_stream_skip_finish(stream, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gssize g_input_stream_skip_finish (GInputStream *stream, GAsyncResult *result, GError **error);
```
"""
function g_input_stream_skip_finish(stream, result, error)
    @ccall libaravis.g_input_stream_skip_finish(stream::Ptr{GInputStream}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gssize
end

"""
    g_input_stream_close_async(stream, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_input_stream_close_async (GInputStream *stream, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_input_stream_close_async(stream, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_input_stream_close_async(stream::Ptr{GInputStream}, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_input_stream_close_finish(stream, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_input_stream_close_finish (GInputStream *stream, GAsyncResult *result, GError **error);
```
"""
function g_input_stream_close_finish(stream, result, error)
    @ccall libaravis.g_input_stream_close_finish(stream::Ptr{GInputStream}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_input_stream_is_closed(stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_input_stream_is_closed (GInputStream *stream);
```
"""
function g_input_stream_is_closed(stream)
    @ccall libaravis.g_input_stream_is_closed(stream::Ptr{GInputStream})::gboolean
end

"""
    g_input_stream_has_pending(stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_input_stream_has_pending (GInputStream *stream);
```
"""
function g_input_stream_has_pending(stream)
    @ccall libaravis.g_input_stream_has_pending(stream::Ptr{GInputStream})::gboolean
end

"""
    g_input_stream_set_pending(stream, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_input_stream_set_pending (GInputStream *stream, GError **error);
```
"""
function g_input_stream_set_pending(stream, error)
    @ccall libaravis.g_input_stream_set_pending(stream::Ptr{GInputStream}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_input_stream_clear_pending(stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_input_stream_clear_pending (GInputStream *stream);
```
"""
function g_input_stream_clear_pending(stream)
    @ccall libaravis.g_input_stream_clear_pending(stream::Ptr{GInputStream})::Cvoid
end

"""
    g_filter_input_stream_get_base_stream(stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GInputStream * g_filter_input_stream_get_base_stream (GFilterInputStream *stream);
```
"""
function g_filter_input_stream_get_base_stream(stream)
    @ccall libaravis.g_filter_input_stream_get_base_stream(stream::Ptr{GFilterInputStream})::Ptr{GInputStream}
end

"""
    g_filter_input_stream_get_close_base_stream(stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_filter_input_stream_get_close_base_stream (GFilterInputStream *stream);
```
"""
function g_filter_input_stream_get_close_base_stream(stream)
    @ccall libaravis.g_filter_input_stream_get_close_base_stream(stream::Ptr{GFilterInputStream})::gboolean
end

"""
    g_filter_input_stream_set_close_base_stream(stream, close_base)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_filter_input_stream_set_close_base_stream (GFilterInputStream *stream, gboolean close_base);
```
"""
function g_filter_input_stream_set_close_base_stream(stream, close_base)
    @ccall libaravis.g_filter_input_stream_set_close_base_stream(stream::Ptr{GFilterInputStream}, close_base::gboolean)::Cvoid
end

"""
    g_buffered_input_stream_new(base_stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GInputStream* g_buffered_input_stream_new (GInputStream *base_stream);
```
"""
function g_buffered_input_stream_new(base_stream)
    @ccall libaravis.g_buffered_input_stream_new(base_stream::Ptr{GInputStream})::Ptr{GInputStream}
end

"""
    g_buffered_input_stream_new_sized(base_stream, size)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GInputStream* g_buffered_input_stream_new_sized (GInputStream *base_stream, gsize size);
```
"""
function g_buffered_input_stream_new_sized(base_stream, size)
    @ccall libaravis.g_buffered_input_stream_new_sized(base_stream::Ptr{GInputStream}, size::gsize)::Ptr{GInputStream}
end

"""
    g_buffered_input_stream_get_buffer_size(stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gsize g_buffered_input_stream_get_buffer_size (GBufferedInputStream *stream);
```
"""
function g_buffered_input_stream_get_buffer_size(stream)
    @ccall libaravis.g_buffered_input_stream_get_buffer_size(stream::Ptr{GBufferedInputStream})::gsize
end

"""
    g_buffered_input_stream_set_buffer_size(stream, size)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_buffered_input_stream_set_buffer_size (GBufferedInputStream *stream, gsize size);
```
"""
function g_buffered_input_stream_set_buffer_size(stream, size)
    @ccall libaravis.g_buffered_input_stream_set_buffer_size(stream::Ptr{GBufferedInputStream}, size::gsize)::Cvoid
end

"""
    g_buffered_input_stream_get_available(stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gsize g_buffered_input_stream_get_available (GBufferedInputStream *stream);
```
"""
function g_buffered_input_stream_get_available(stream)
    @ccall libaravis.g_buffered_input_stream_get_available(stream::Ptr{GBufferedInputStream})::gsize
end

"""
    g_buffered_input_stream_peek(stream, buffer, offset, count)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gsize g_buffered_input_stream_peek (GBufferedInputStream *stream, void *buffer, gsize offset, gsize count);
```
"""
function g_buffered_input_stream_peek(stream, buffer, offset, count)
    @ccall libaravis.g_buffered_input_stream_peek(stream::Ptr{GBufferedInputStream}, buffer::Ptr{Cvoid}, offset::gsize, count::gsize)::gsize
end

"""
    g_buffered_input_stream_peek_buffer(stream, count)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const void* g_buffered_input_stream_peek_buffer (GBufferedInputStream *stream, gsize *count);
```
"""
function g_buffered_input_stream_peek_buffer(stream, count)
    @ccall libaravis.g_buffered_input_stream_peek_buffer(stream::Ptr{GBufferedInputStream}, count::Ptr{gsize})::Ptr{Cvoid}
end

"""
    g_buffered_input_stream_fill(stream, count, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gssize g_buffered_input_stream_fill (GBufferedInputStream *stream, gssize count, GCancellable *cancellable, GError **error);
```
"""
function g_buffered_input_stream_fill(stream, count, cancellable, error)
    @ccall libaravis.g_buffered_input_stream_fill(stream::Ptr{GBufferedInputStream}, count::gssize, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gssize
end

"""
    g_buffered_input_stream_fill_async(stream, count, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_buffered_input_stream_fill_async (GBufferedInputStream *stream, gssize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_buffered_input_stream_fill_async(stream, count, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_buffered_input_stream_fill_async(stream::Ptr{GBufferedInputStream}, count::gssize, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_buffered_input_stream_fill_finish(stream, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gssize g_buffered_input_stream_fill_finish (GBufferedInputStream *stream, GAsyncResult *result, GError **error);
```
"""
function g_buffered_input_stream_fill_finish(stream, result, error)
    @ccall libaravis.g_buffered_input_stream_fill_finish(stream::Ptr{GBufferedInputStream}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gssize
end

"""
    g_buffered_input_stream_read_byte(stream, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL int g_buffered_input_stream_read_byte (GBufferedInputStream *stream, GCancellable *cancellable, GError **error);
```
"""
function g_buffered_input_stream_read_byte(stream, cancellable, error)
    @ccall libaravis.g_buffered_input_stream_read_byte(stream::Ptr{GBufferedInputStream}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Cint
end

"""
    g_output_stream_write(stream, buffer, count, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gssize g_output_stream_write (GOutputStream *stream, const void *buffer, gsize count, GCancellable *cancellable, GError **error);
```
"""
function g_output_stream_write(stream, buffer, count, cancellable, error)
    @ccall libaravis.g_output_stream_write(stream::Ptr{GOutputStream}, buffer::Ptr{Cvoid}, count::gsize, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gssize
end

"""
    g_output_stream_write_all(stream, buffer, count, bytes_written, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_output_stream_write_all (GOutputStream *stream, const void *buffer, gsize count, gsize *bytes_written, GCancellable *cancellable, GError **error);
```
"""
function g_output_stream_write_all(stream, buffer, count, bytes_written, cancellable, error)
    @ccall libaravis.g_output_stream_write_all(stream::Ptr{GOutputStream}, buffer::Ptr{Cvoid}, count::gsize, bytes_written::Ptr{gsize}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_output_stream_writev(stream, vectors, n_vectors, bytes_written, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_60 gboolean g_output_stream_writev (GOutputStream *stream, const GOutputVector *vectors, gsize n_vectors, gsize *bytes_written, GCancellable *cancellable, GError **error);
```
"""
function g_output_stream_writev(stream, vectors, n_vectors, bytes_written, cancellable, error)
    @ccall libaravis.g_output_stream_writev(stream::Ptr{GOutputStream}, vectors::Ptr{GOutputVector}, n_vectors::gsize, bytes_written::Ptr{gsize}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_output_stream_writev_all(stream, vectors, n_vectors, bytes_written, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_60 gboolean g_output_stream_writev_all (GOutputStream *stream, GOutputVector *vectors, gsize n_vectors, gsize *bytes_written, GCancellable *cancellable, GError **error);
```
"""
function g_output_stream_writev_all(stream, vectors, n_vectors, bytes_written, cancellable, error)
    @ccall libaravis.g_output_stream_writev_all(stream::Ptr{GOutputStream}, vectors::Ptr{GOutputVector}, n_vectors::gsize, bytes_written::Ptr{gsize}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_output_stream_write_bytes(stream, bytes, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 gssize g_output_stream_write_bytes (GOutputStream *stream, GBytes *bytes, GCancellable *cancellable, GError **error);
```
"""
function g_output_stream_write_bytes(stream, bytes, cancellable, error)
    @ccall libaravis.g_output_stream_write_bytes(stream::Ptr{GOutputStream}, bytes::Ptr{GBytes}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gssize
end

"""
    g_output_stream_splice(stream, source, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gssize g_output_stream_splice (GOutputStream *stream, GInputStream *source, GOutputStreamSpliceFlags flags, GCancellable *cancellable, GError **error);
```
"""
function g_output_stream_splice(stream, source, flags, cancellable, error)
    @ccall libaravis.g_output_stream_splice(stream::Ptr{GOutputStream}, source::Ptr{GInputStream}, flags::GOutputStreamSpliceFlags, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gssize
end

"""
    g_output_stream_flush(stream, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_output_stream_flush (GOutputStream *stream, GCancellable *cancellable, GError **error);
```
"""
function g_output_stream_flush(stream, cancellable, error)
    @ccall libaravis.g_output_stream_flush(stream::Ptr{GOutputStream}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_output_stream_close(stream, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_output_stream_close (GOutputStream *stream, GCancellable *cancellable, GError **error);
```
"""
function g_output_stream_close(stream, cancellable, error)
    @ccall libaravis.g_output_stream_close(stream::Ptr{GOutputStream}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_output_stream_write_async(stream, buffer, count, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_output_stream_write_async (GOutputStream *stream, const void *buffer, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_output_stream_write_async(stream, buffer, count, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_output_stream_write_async(stream::Ptr{GOutputStream}, buffer::Ptr{Cvoid}, count::gsize, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_output_stream_write_finish(stream, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gssize g_output_stream_write_finish (GOutputStream *stream, GAsyncResult *result, GError **error);
```
"""
function g_output_stream_write_finish(stream, result, error)
    @ccall libaravis.g_output_stream_write_finish(stream::Ptr{GOutputStream}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gssize
end

"""
    g_output_stream_write_all_async(stream, buffer, count, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_44 void g_output_stream_write_all_async (GOutputStream *stream, const void *buffer, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_output_stream_write_all_async(stream, buffer, count, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_output_stream_write_all_async(stream::Ptr{GOutputStream}, buffer::Ptr{Cvoid}, count::gsize, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_output_stream_write_all_finish(stream, result, bytes_written, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_44 gboolean g_output_stream_write_all_finish (GOutputStream *stream, GAsyncResult *result, gsize *bytes_written, GError **error);
```
"""
function g_output_stream_write_all_finish(stream, result, bytes_written, error)
    @ccall libaravis.g_output_stream_write_all_finish(stream::Ptr{GOutputStream}, result::Ptr{GAsyncResult}, bytes_written::Ptr{gsize}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_output_stream_writev_async(stream, vectors, n_vectors, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_60 void g_output_stream_writev_async (GOutputStream *stream, const GOutputVector *vectors, gsize n_vectors, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_output_stream_writev_async(stream, vectors, n_vectors, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_output_stream_writev_async(stream::Ptr{GOutputStream}, vectors::Ptr{GOutputVector}, n_vectors::gsize, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_output_stream_writev_finish(stream, result, bytes_written, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_60 gboolean g_output_stream_writev_finish (GOutputStream *stream, GAsyncResult *result, gsize *bytes_written, GError **error);
```
"""
function g_output_stream_writev_finish(stream, result, bytes_written, error)
    @ccall libaravis.g_output_stream_writev_finish(stream::Ptr{GOutputStream}, result::Ptr{GAsyncResult}, bytes_written::Ptr{gsize}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_output_stream_writev_all_async(stream, vectors, n_vectors, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_60 void g_output_stream_writev_all_async (GOutputStream *stream, GOutputVector *vectors, gsize n_vectors, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_output_stream_writev_all_async(stream, vectors, n_vectors, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_output_stream_writev_all_async(stream::Ptr{GOutputStream}, vectors::Ptr{GOutputVector}, n_vectors::gsize, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_output_stream_writev_all_finish(stream, result, bytes_written, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_60 gboolean g_output_stream_writev_all_finish (GOutputStream *stream, GAsyncResult *result, gsize *bytes_written, GError **error);
```
"""
function g_output_stream_writev_all_finish(stream, result, bytes_written, error)
    @ccall libaravis.g_output_stream_writev_all_finish(stream::Ptr{GOutputStream}, result::Ptr{GAsyncResult}, bytes_written::Ptr{gsize}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_output_stream_write_bytes_async(stream, bytes, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 void g_output_stream_write_bytes_async (GOutputStream *stream, GBytes *bytes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_output_stream_write_bytes_async(stream, bytes, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_output_stream_write_bytes_async(stream::Ptr{GOutputStream}, bytes::Ptr{GBytes}, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_output_stream_write_bytes_finish(stream, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 gssize g_output_stream_write_bytes_finish (GOutputStream *stream, GAsyncResult *result, GError **error);
```
"""
function g_output_stream_write_bytes_finish(stream, result, error)
    @ccall libaravis.g_output_stream_write_bytes_finish(stream::Ptr{GOutputStream}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gssize
end

"""
    g_output_stream_splice_async(stream, source, flags, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_output_stream_splice_async (GOutputStream *stream, GInputStream *source, GOutputStreamSpliceFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_output_stream_splice_async(stream, source, flags, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_output_stream_splice_async(stream::Ptr{GOutputStream}, source::Ptr{GInputStream}, flags::GOutputStreamSpliceFlags, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_output_stream_splice_finish(stream, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gssize g_output_stream_splice_finish (GOutputStream *stream, GAsyncResult *result, GError **error);
```
"""
function g_output_stream_splice_finish(stream, result, error)
    @ccall libaravis.g_output_stream_splice_finish(stream::Ptr{GOutputStream}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gssize
end

"""
    g_output_stream_flush_async(stream, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_output_stream_flush_async (GOutputStream *stream, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_output_stream_flush_async(stream, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_output_stream_flush_async(stream::Ptr{GOutputStream}, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_output_stream_flush_finish(stream, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_output_stream_flush_finish (GOutputStream *stream, GAsyncResult *result, GError **error);
```
"""
function g_output_stream_flush_finish(stream, result, error)
    @ccall libaravis.g_output_stream_flush_finish(stream::Ptr{GOutputStream}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_output_stream_close_async(stream, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_output_stream_close_async (GOutputStream *stream, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_output_stream_close_async(stream, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_output_stream_close_async(stream::Ptr{GOutputStream}, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_output_stream_close_finish(stream, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_output_stream_close_finish (GOutputStream *stream, GAsyncResult *result, GError **error);
```
"""
function g_output_stream_close_finish(stream, result, error)
    @ccall libaravis.g_output_stream_close_finish(stream::Ptr{GOutputStream}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_output_stream_is_closed(stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_output_stream_is_closed (GOutputStream *stream);
```
"""
function g_output_stream_is_closed(stream)
    @ccall libaravis.g_output_stream_is_closed(stream::Ptr{GOutputStream})::gboolean
end

"""
    g_output_stream_is_closing(stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_output_stream_is_closing (GOutputStream *stream);
```
"""
function g_output_stream_is_closing(stream)
    @ccall libaravis.g_output_stream_is_closing(stream::Ptr{GOutputStream})::gboolean
end

"""
    g_output_stream_has_pending(stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_output_stream_has_pending (GOutputStream *stream);
```
"""
function g_output_stream_has_pending(stream)
    @ccall libaravis.g_output_stream_has_pending(stream::Ptr{GOutputStream})::gboolean
end

"""
    g_output_stream_set_pending(stream, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_output_stream_set_pending (GOutputStream *stream, GError **error);
```
"""
function g_output_stream_set_pending(stream, error)
    @ccall libaravis.g_output_stream_set_pending(stream::Ptr{GOutputStream}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_output_stream_clear_pending(stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_output_stream_clear_pending (GOutputStream *stream);
```
"""
function g_output_stream_clear_pending(stream)
    @ccall libaravis.g_output_stream_clear_pending(stream::Ptr{GOutputStream})::Cvoid
end

"""
    g_filter_output_stream_get_base_stream(stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GOutputStream * g_filter_output_stream_get_base_stream (GFilterOutputStream *stream);
```
"""
function g_filter_output_stream_get_base_stream(stream)
    @ccall libaravis.g_filter_output_stream_get_base_stream(stream::Ptr{GFilterOutputStream})::Ptr{GOutputStream}
end

"""
    g_filter_output_stream_get_close_base_stream(stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_filter_output_stream_get_close_base_stream (GFilterOutputStream *stream);
```
"""
function g_filter_output_stream_get_close_base_stream(stream)
    @ccall libaravis.g_filter_output_stream_get_close_base_stream(stream::Ptr{GFilterOutputStream})::gboolean
end

"""
    g_filter_output_stream_set_close_base_stream(stream, close_base)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_filter_output_stream_set_close_base_stream (GFilterOutputStream *stream, gboolean close_base);
```
"""
function g_filter_output_stream_set_close_base_stream(stream, close_base)
    @ccall libaravis.g_filter_output_stream_set_close_base_stream(stream::Ptr{GFilterOutputStream}, close_base::gboolean)::Cvoid
end

"""
    g_buffered_output_stream_new(base_stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GOutputStream* g_buffered_output_stream_new (GOutputStream *base_stream);
```
"""
function g_buffered_output_stream_new(base_stream)
    @ccall libaravis.g_buffered_output_stream_new(base_stream::Ptr{GOutputStream})::Ptr{GOutputStream}
end

"""
    g_buffered_output_stream_new_sized(base_stream, size)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GOutputStream* g_buffered_output_stream_new_sized (GOutputStream *base_stream, gsize size);
```
"""
function g_buffered_output_stream_new_sized(base_stream, size)
    @ccall libaravis.g_buffered_output_stream_new_sized(base_stream::Ptr{GOutputStream}, size::gsize)::Ptr{GOutputStream}
end

"""
    g_buffered_output_stream_get_buffer_size(stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gsize g_buffered_output_stream_get_buffer_size (GBufferedOutputStream *stream);
```
"""
function g_buffered_output_stream_get_buffer_size(stream)
    @ccall libaravis.g_buffered_output_stream_get_buffer_size(stream::Ptr{GBufferedOutputStream})::gsize
end

"""
    g_buffered_output_stream_set_buffer_size(stream, size)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_buffered_output_stream_set_buffer_size (GBufferedOutputStream *stream, gsize size);
```
"""
function g_buffered_output_stream_set_buffer_size(stream, size)
    @ccall libaravis.g_buffered_output_stream_set_buffer_size(stream::Ptr{GBufferedOutputStream}, size::gsize)::Cvoid
end

"""
    g_buffered_output_stream_get_auto_grow(stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_buffered_output_stream_get_auto_grow (GBufferedOutputStream *stream);
```
"""
function g_buffered_output_stream_get_auto_grow(stream)
    @ccall libaravis.g_buffered_output_stream_get_auto_grow(stream::Ptr{GBufferedOutputStream})::gboolean
end

"""
    g_buffered_output_stream_set_auto_grow(stream, auto_grow)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_buffered_output_stream_set_auto_grow (GBufferedOutputStream *stream, gboolean auto_grow);
```
"""
function g_buffered_output_stream_set_auto_grow(stream, auto_grow)
    @ccall libaravis.g_buffered_output_stream_set_auto_grow(stream::Ptr{GBufferedOutputStream}, auto_grow::gboolean)::Cvoid
end

"""
    g_bytes_icon_new(bytes)

### Prototype
```c
GIO_AVAILABLE_IN_2_38 GIcon * g_bytes_icon_new (GBytes *bytes);
```
"""
function g_bytes_icon_new(bytes)
    @ccall libaravis.g_bytes_icon_new(bytes::Ptr{GBytes})::Ptr{GIcon}
end

"""
    g_bytes_icon_get_bytes(icon)

### Prototype
```c
GIO_AVAILABLE_IN_2_38 GBytes * g_bytes_icon_get_bytes (GBytesIcon *icon);
```
"""
function g_bytes_icon_get_bytes(icon)
    @ccall libaravis.g_bytes_icon_get_bytes(icon::Ptr{GBytesIcon})::Ptr{GBytes}
end

"""
    g_cancellable_new()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GCancellable *g_cancellable_new (void);
```
"""
function g_cancellable_new()
    @ccall libaravis.g_cancellable_new()::Ptr{GCancellable}
end

"""
    g_cancellable_is_cancelled(cancellable)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_cancellable_is_cancelled (GCancellable *cancellable);
```
"""
function g_cancellable_is_cancelled(cancellable)
    @ccall libaravis.g_cancellable_is_cancelled(cancellable::Ptr{GCancellable})::gboolean
end

"""
    g_cancellable_set_error_if_cancelled(cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_cancellable_set_error_if_cancelled (GCancellable *cancellable, GError **error);
```
"""
function g_cancellable_set_error_if_cancelled(cancellable, error)
    @ccall libaravis.g_cancellable_set_error_if_cancelled(cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_cancellable_get_fd(cancellable)

### Prototype
```c
GIO_AVAILABLE_IN_ALL int g_cancellable_get_fd (GCancellable *cancellable);
```
"""
function g_cancellable_get_fd(cancellable)
    @ccall libaravis.g_cancellable_get_fd(cancellable::Ptr{GCancellable})::Cint
end

"""
    g_cancellable_make_pollfd(cancellable, pollfd)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_cancellable_make_pollfd (GCancellable *cancellable, GPollFD *pollfd);
```
"""
function g_cancellable_make_pollfd(cancellable, pollfd)
    @ccall libaravis.g_cancellable_make_pollfd(cancellable::Ptr{GCancellable}, pollfd::Ptr{GPollFD})::gboolean
end

"""
    g_cancellable_release_fd(cancellable)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_cancellable_release_fd (GCancellable *cancellable);
```
"""
function g_cancellable_release_fd(cancellable)
    @ccall libaravis.g_cancellable_release_fd(cancellable::Ptr{GCancellable})::Cvoid
end

"""
    g_cancellable_source_new(cancellable)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSource * g_cancellable_source_new (GCancellable *cancellable);
```
"""
function g_cancellable_source_new(cancellable)
    @ccall libaravis.g_cancellable_source_new(cancellable::Ptr{GCancellable})::Ptr{GSource}
end

"""
    g_cancellable_get_current()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GCancellable *g_cancellable_get_current (void);
```
"""
function g_cancellable_get_current()
    @ccall libaravis.g_cancellable_get_current()::Ptr{GCancellable}
end

"""
    g_cancellable_push_current(cancellable)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_cancellable_push_current (GCancellable *cancellable);
```
"""
function g_cancellable_push_current(cancellable)
    @ccall libaravis.g_cancellable_push_current(cancellable::Ptr{GCancellable})::Cvoid
end

"""
    g_cancellable_pop_current(cancellable)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_cancellable_pop_current (GCancellable *cancellable);
```
"""
function g_cancellable_pop_current(cancellable)
    @ccall libaravis.g_cancellable_pop_current(cancellable::Ptr{GCancellable})::Cvoid
end

"""
    g_cancellable_reset(cancellable)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_cancellable_reset (GCancellable *cancellable);
```
"""
function g_cancellable_reset(cancellable)
    @ccall libaravis.g_cancellable_reset(cancellable::Ptr{GCancellable})::Cvoid
end

"""
    g_cancellable_connect(cancellable, callback, data, data_destroy_func)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gulong g_cancellable_connect (GCancellable *cancellable, GCallback callback, gpointer data, GDestroyNotify data_destroy_func);
```
"""
function g_cancellable_connect(cancellable, callback, data, data_destroy_func)
    @ccall libaravis.g_cancellable_connect(cancellable::Ptr{GCancellable}, callback::GCallback, data::gpointer, data_destroy_func::GDestroyNotify)::gulong
end

"""
    g_cancellable_disconnect(cancellable, handler_id)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_cancellable_disconnect (GCancellable *cancellable, gulong handler_id);
```
"""
function g_cancellable_disconnect(cancellable, handler_id)
    @ccall libaravis.g_cancellable_disconnect(cancellable::Ptr{GCancellable}, handler_id::gulong)::Cvoid
end

"""
    g_cancellable_cancel(cancellable)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_cancellable_cancel (GCancellable *cancellable);
```
"""
function g_cancellable_cancel(cancellable)
    @ccall libaravis.g_cancellable_cancel(cancellable::Ptr{GCancellable})::Cvoid
end

"""
    g_converter_convert(converter, inbuf, inbuf_size, outbuf, outbuf_size, flags, bytes_read, bytes_written, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GConverterResult g_converter_convert (GConverter *converter, const void *inbuf, gsize inbuf_size, void *outbuf, gsize outbuf_size, GConverterFlags flags, gsize *bytes_read, gsize *bytes_written, GError **error);
```
"""
function g_converter_convert(converter, inbuf, inbuf_size, outbuf, outbuf_size, flags, bytes_read, bytes_written, error)
    @ccall libaravis.g_converter_convert(converter::Ptr{GConverter}, inbuf::Ptr{Cvoid}, inbuf_size::gsize, outbuf::Ptr{Cvoid}, outbuf_size::gsize, flags::GConverterFlags, bytes_read::Ptr{gsize}, bytes_written::Ptr{gsize}, error::Ptr{Ptr{GError}})::GConverterResult
end

"""
    g_converter_reset(converter)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_converter_reset (GConverter *converter);
```
"""
function g_converter_reset(converter)
    @ccall libaravis.g_converter_reset(converter::Ptr{GConverter})::Cvoid
end

"""
    g_converter_convert_bytes(converter, bytes, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_82 GBytes * g_converter_convert_bytes (GConverter *converter, GBytes *bytes, GError **error);
```
"""
function g_converter_convert_bytes(converter, bytes, error)
    @ccall libaravis.g_converter_convert_bytes(converter::Ptr{GConverter}, bytes::Ptr{GBytes}, error::Ptr{Ptr{GError}})::Ptr{GBytes}
end

"""
    g_charset_converter_new(to_charset, from_charset, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GCharsetConverter *g_charset_converter_new (const gchar *to_charset, const gchar *from_charset, GError **error);
```
"""
function g_charset_converter_new(to_charset, from_charset, error)
    @ccall libaravis.g_charset_converter_new(to_charset::Ptr{gchar}, from_charset::Ptr{gchar}, error::Ptr{Ptr{GError}})::Ptr{GCharsetConverter}
end

"""
    g_charset_converter_set_use_fallback(converter, use_fallback)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_charset_converter_set_use_fallback (GCharsetConverter *converter, gboolean use_fallback);
```
"""
function g_charset_converter_set_use_fallback(converter, use_fallback)
    @ccall libaravis.g_charset_converter_set_use_fallback(converter::Ptr{GCharsetConverter}, use_fallback::gboolean)::Cvoid
end

"""
    g_charset_converter_get_use_fallback(converter)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_charset_converter_get_use_fallback (GCharsetConverter *converter);
```
"""
function g_charset_converter_get_use_fallback(converter)
    @ccall libaravis.g_charset_converter_get_use_fallback(converter::Ptr{GCharsetConverter})::gboolean
end

"""
    g_charset_converter_get_num_fallbacks(converter)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint g_charset_converter_get_num_fallbacks (GCharsetConverter *converter);
```
"""
function g_charset_converter_get_num_fallbacks(converter)
    @ccall libaravis.g_charset_converter_get_num_fallbacks(converter::Ptr{GCharsetConverter})::guint
end

"""
    g_content_type_equals(type1, type2)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_content_type_equals (const gchar *type1, const gchar *type2);
```
"""
function g_content_type_equals(type1, type2)
    @ccall libaravis.g_content_type_equals(type1::Ptr{gchar}, type2::Ptr{gchar})::gboolean
end

"""
    g_content_type_is_a(type, supertype)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_content_type_is_a (const gchar *type, const gchar *supertype);
```
"""
function g_content_type_is_a(type, supertype)
    @ccall libaravis.g_content_type_is_a(type::Ptr{gchar}, supertype::Ptr{gchar})::gboolean
end

"""
    g_content_type_is_mime_type(type, mime_type)

### Prototype
```c
GIO_AVAILABLE_IN_2_52 gboolean g_content_type_is_mime_type (const gchar *type, const gchar *mime_type);
```
"""
function g_content_type_is_mime_type(type, mime_type)
    @ccall libaravis.g_content_type_is_mime_type(type::Ptr{gchar}, mime_type::Ptr{gchar})::gboolean
end

"""
    g_content_type_is_unknown(type)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_content_type_is_unknown (const gchar *type);
```
"""
function g_content_type_is_unknown(type)
    @ccall libaravis.g_content_type_is_unknown(type::Ptr{gchar})::gboolean
end

"""
    g_content_type_get_description(type)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gchar * g_content_type_get_description (const gchar *type);
```
"""
function g_content_type_get_description(type)
    @ccall libaravis.g_content_type_get_description(type::Ptr{gchar})::Ptr{gchar}
end

"""
    g_content_type_get_mime_type(type)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gchar * g_content_type_get_mime_type (const gchar *type);
```
"""
function g_content_type_get_mime_type(type)
    @ccall libaravis.g_content_type_get_mime_type(type::Ptr{gchar})::Ptr{gchar}
end

"""
    g_content_type_get_icon(type)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIcon * g_content_type_get_icon (const gchar *type);
```
"""
function g_content_type_get_icon(type)
    @ccall libaravis.g_content_type_get_icon(type::Ptr{gchar})::Ptr{GIcon}
end

"""
    g_content_type_get_symbolic_icon(type)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 GIcon * g_content_type_get_symbolic_icon (const gchar *type);
```
"""
function g_content_type_get_symbolic_icon(type)
    @ccall libaravis.g_content_type_get_symbolic_icon(type::Ptr{gchar})::Ptr{GIcon}
end

"""
    g_content_type_get_generic_icon_name(type)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 gchar * g_content_type_get_generic_icon_name (const gchar *type);
```
"""
function g_content_type_get_generic_icon_name(type)
    @ccall libaravis.g_content_type_get_generic_icon_name(type::Ptr{gchar})::Ptr{gchar}
end

"""
    g_content_type_can_be_executable(type)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_content_type_can_be_executable (const gchar *type);
```
"""
function g_content_type_can_be_executable(type)
    @ccall libaravis.g_content_type_can_be_executable(type::Ptr{gchar})::gboolean
end

"""
    g_content_type_from_mime_type(mime_type)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gchar * g_content_type_from_mime_type (const gchar *mime_type);
```
"""
function g_content_type_from_mime_type(mime_type)
    @ccall libaravis.g_content_type_from_mime_type(mime_type::Ptr{gchar})::Ptr{gchar}
end

"""
    g_content_type_guess(filename, data, data_size, result_uncertain)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gchar * g_content_type_guess (const gchar *filename, const guchar *data, gsize data_size, gboolean *result_uncertain);
```
"""
function g_content_type_guess(filename, data, data_size, result_uncertain)
    @ccall libaravis.g_content_type_guess(filename::Ptr{gchar}, data::Ptr{guchar}, data_size::gsize, result_uncertain::Ptr{gboolean})::Ptr{gchar}
end

"""
    g_content_type_guess_for_tree(root)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gchar ** g_content_type_guess_for_tree (GFile *root);
```
"""
function g_content_type_guess_for_tree(root)
    @ccall libaravis.g_content_type_guess_for_tree(root::Ptr{GFile})::Ptr{Ptr{gchar}}
end

"""
    g_content_types_get_registered()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GList * g_content_types_get_registered (void);
```
"""
function g_content_types_get_registered()
    @ccall libaravis.g_content_types_get_registered()::Ptr{GList}
end

"""
    g_content_type_get_mime_dirs()

### Prototype
```c
GIO_AVAILABLE_IN_2_60 const gchar * const *g_content_type_get_mime_dirs (void);
```
"""
function g_content_type_get_mime_dirs()
    @ccall libaravis.g_content_type_get_mime_dirs()::Ptr{Ptr{gchar}}
end

"""
    g_content_type_set_mime_dirs(dirs)

### Prototype
```c
GIO_AVAILABLE_IN_2_60 void g_content_type_set_mime_dirs (const gchar * const *dirs);
```
"""
function g_content_type_set_mime_dirs(dirs)
    @ccall libaravis.g_content_type_set_mime_dirs(dirs::Ptr{Ptr{gchar}})::Cvoid
end

"""
    g_converter_input_stream_new(base_stream, converter)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GInputStream *g_converter_input_stream_new (GInputStream *base_stream, GConverter *converter);
```
"""
function g_converter_input_stream_new(base_stream, converter)
    @ccall libaravis.g_converter_input_stream_new(base_stream::Ptr{GInputStream}, converter::Ptr{GConverter})::Ptr{GInputStream}
end

"""
    g_converter_input_stream_get_converter(converter_stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GConverter *g_converter_input_stream_get_converter (GConverterInputStream *converter_stream);
```
"""
function g_converter_input_stream_get_converter(converter_stream)
    @ccall libaravis.g_converter_input_stream_get_converter(converter_stream::Ptr{GConverterInputStream})::Ptr{GConverter}
end

"""
    g_converter_output_stream_new(base_stream, converter)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GOutputStream *g_converter_output_stream_new (GOutputStream *base_stream, GConverter *converter);
```
"""
function g_converter_output_stream_new(base_stream, converter)
    @ccall libaravis.g_converter_output_stream_new(base_stream::Ptr{GOutputStream}, converter::Ptr{GConverter})::Ptr{GOutputStream}
end

"""
    g_converter_output_stream_get_converter(converter_stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GConverter *g_converter_output_stream_get_converter (GConverterOutputStream *converter_stream);
```
"""
function g_converter_output_stream_get_converter(converter_stream)
    @ccall libaravis.g_converter_output_stream_get_converter(converter_stream::Ptr{GConverterOutputStream})::Ptr{GConverter}
end

"""
    g_credentials_new()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GCredentials *g_credentials_new (void);
```
"""
function g_credentials_new()
    @ccall libaravis.g_credentials_new()::Ptr{GCredentials}
end

"""
    g_credentials_to_string(credentials)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gchar *g_credentials_to_string (GCredentials *credentials);
```
"""
function g_credentials_to_string(credentials)
    @ccall libaravis.g_credentials_to_string(credentials::Ptr{GCredentials})::Ptr{gchar}
end

"""
    g_credentials_get_native(credentials, native_type)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gpointer g_credentials_get_native (GCredentials *credentials, GCredentialsType native_type);
```
"""
function g_credentials_get_native(credentials, native_type)
    @ccall libaravis.g_credentials_get_native(credentials::Ptr{GCredentials}, native_type::GCredentialsType)::gpointer
end

"""
    g_credentials_set_native(credentials, native_type, native)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_credentials_set_native (GCredentials *credentials, GCredentialsType native_type, gpointer native);
```
"""
function g_credentials_set_native(credentials, native_type, native)
    @ccall libaravis.g_credentials_set_native(credentials::Ptr{GCredentials}, native_type::GCredentialsType, native::gpointer)::Cvoid
end

"""
    g_credentials_is_same_user(credentials, other_credentials, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_credentials_is_same_user (GCredentials *credentials, GCredentials *other_credentials, GError **error);
```
"""
function g_credentials_is_same_user(credentials, other_credentials, error)
    @ccall libaravis.g_credentials_is_same_user(credentials::Ptr{GCredentials}, other_credentials::Ptr{GCredentials}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_credentials_get_unix_pid(credentials, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 pid_t g_credentials_get_unix_pid (GCredentials *credentials, GError **error);
```
"""
function g_credentials_get_unix_pid(credentials, error)
    @ccall libaravis.g_credentials_get_unix_pid(credentials::Ptr{GCredentials}, error::Ptr{Ptr{GError}})::pid_t
end

"""
    g_credentials_get_unix_user(credentials, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL uid_t g_credentials_get_unix_user (GCredentials *credentials, GError **error);
```
"""
function g_credentials_get_unix_user(credentials, error)
    @ccall libaravis.g_credentials_get_unix_user(credentials::Ptr{GCredentials}, error::Ptr{Ptr{GError}})::uid_t
end

"""
    g_credentials_set_unix_user(credentials, uid, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_credentials_set_unix_user (GCredentials *credentials, uid_t uid, GError **error);
```
"""
function g_credentials_set_unix_user(credentials, uid, error)
    @ccall libaravis.g_credentials_set_unix_user(credentials::Ptr{GCredentials}, uid::uid_t, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_datagram_based_receive_messages(datagram_based, messages, num_messages, flags, timeout, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 gint g_datagram_based_receive_messages (GDatagramBased *datagram_based, GInputMessage *messages, guint num_messages, gint flags, gint64 timeout, GCancellable *cancellable, GError **error);
```
"""
function g_datagram_based_receive_messages(datagram_based, messages, num_messages, flags, timeout, cancellable, error)
    @ccall libaravis.g_datagram_based_receive_messages(datagram_based::Ptr{GDatagramBased}, messages::Ptr{GInputMessage}, num_messages::guint, flags::gint, timeout::gint64, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gint
end

"""
    g_datagram_based_send_messages(datagram_based, messages, num_messages, flags, timeout, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 gint g_datagram_based_send_messages (GDatagramBased *datagram_based, GOutputMessage *messages, guint num_messages, gint flags, gint64 timeout, GCancellable *cancellable, GError **error);
```
"""
function g_datagram_based_send_messages(datagram_based, messages, num_messages, flags, timeout, cancellable, error)
    @ccall libaravis.g_datagram_based_send_messages(datagram_based::Ptr{GDatagramBased}, messages::Ptr{GOutputMessage}, num_messages::guint, flags::gint, timeout::gint64, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gint
end

"""
    g_datagram_based_create_source(datagram_based, condition, cancellable)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 GSource * g_datagram_based_create_source (GDatagramBased *datagram_based, GIOCondition condition, GCancellable *cancellable);
```
"""
function g_datagram_based_create_source(datagram_based, condition, cancellable)
    @ccall libaravis.g_datagram_based_create_source(datagram_based::Ptr{GDatagramBased}, condition::GIOCondition, cancellable::Ptr{GCancellable})::Ptr{GSource}
end

"""
    g_datagram_based_condition_check(datagram_based, condition)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 GIOCondition g_datagram_based_condition_check (GDatagramBased *datagram_based, GIOCondition condition);
```
"""
function g_datagram_based_condition_check(datagram_based, condition)
    @ccall libaravis.g_datagram_based_condition_check(datagram_based::Ptr{GDatagramBased}, condition::GIOCondition)::GIOCondition
end

"""
    g_datagram_based_condition_wait(datagram_based, condition, timeout, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 gboolean g_datagram_based_condition_wait (GDatagramBased *datagram_based, GIOCondition condition, gint64 timeout, GCancellable *cancellable, GError **error);
```
"""
function g_datagram_based_condition_wait(datagram_based, condition, timeout, cancellable, error)
    @ccall libaravis.g_datagram_based_condition_wait(datagram_based::Ptr{GDatagramBased}, condition::GIOCondition, timeout::gint64, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_data_input_stream_new(base_stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDataInputStream * g_data_input_stream_new (GInputStream *base_stream);
```
"""
function g_data_input_stream_new(base_stream)
    @ccall libaravis.g_data_input_stream_new(base_stream::Ptr{GInputStream})::Ptr{GDataInputStream}
end

"""
    g_data_input_stream_set_byte_order(stream, order)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_data_input_stream_set_byte_order (GDataInputStream *stream, GDataStreamByteOrder order);
```
"""
function g_data_input_stream_set_byte_order(stream, order)
    @ccall libaravis.g_data_input_stream_set_byte_order(stream::Ptr{GDataInputStream}, order::GDataStreamByteOrder)::Cvoid
end

"""
    g_data_input_stream_get_byte_order(stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDataStreamByteOrder g_data_input_stream_get_byte_order (GDataInputStream *stream);
```
"""
function g_data_input_stream_get_byte_order(stream)
    @ccall libaravis.g_data_input_stream_get_byte_order(stream::Ptr{GDataInputStream})::GDataStreamByteOrder
end

"""
    g_data_input_stream_set_newline_type(stream, type)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_data_input_stream_set_newline_type (GDataInputStream *stream, GDataStreamNewlineType type);
```
"""
function g_data_input_stream_set_newline_type(stream, type)
    @ccall libaravis.g_data_input_stream_set_newline_type(stream::Ptr{GDataInputStream}, type::GDataStreamNewlineType)::Cvoid
end

"""
    g_data_input_stream_get_newline_type(stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDataStreamNewlineType g_data_input_stream_get_newline_type (GDataInputStream *stream);
```
"""
function g_data_input_stream_get_newline_type(stream)
    @ccall libaravis.g_data_input_stream_get_newline_type(stream::Ptr{GDataInputStream})::GDataStreamNewlineType
end

"""
    g_data_input_stream_read_byte(stream, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guchar g_data_input_stream_read_byte (GDataInputStream *stream, GCancellable *cancellable, GError **error);
```
"""
function g_data_input_stream_read_byte(stream, cancellable, error)
    @ccall libaravis.g_data_input_stream_read_byte(stream::Ptr{GDataInputStream}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::guchar
end

"""
    g_data_input_stream_read_int16(stream, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gint16 g_data_input_stream_read_int16 (GDataInputStream *stream, GCancellable *cancellable, GError **error);
```
"""
function g_data_input_stream_read_int16(stream, cancellable, error)
    @ccall libaravis.g_data_input_stream_read_int16(stream::Ptr{GDataInputStream}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gint16
end

"""
    g_data_input_stream_read_uint16(stream, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint16 g_data_input_stream_read_uint16 (GDataInputStream *stream, GCancellable *cancellable, GError **error);
```
"""
function g_data_input_stream_read_uint16(stream, cancellable, error)
    @ccall libaravis.g_data_input_stream_read_uint16(stream::Ptr{GDataInputStream}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::guint16
end

"""
    g_data_input_stream_read_int32(stream, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gint32 g_data_input_stream_read_int32 (GDataInputStream *stream, GCancellable *cancellable, GError **error);
```
"""
function g_data_input_stream_read_int32(stream, cancellable, error)
    @ccall libaravis.g_data_input_stream_read_int32(stream::Ptr{GDataInputStream}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gint32
end

"""
    g_data_input_stream_read_uint32(stream, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint32 g_data_input_stream_read_uint32 (GDataInputStream *stream, GCancellable *cancellable, GError **error);
```
"""
function g_data_input_stream_read_uint32(stream, cancellable, error)
    @ccall libaravis.g_data_input_stream_read_uint32(stream::Ptr{GDataInputStream}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::guint32
end

"""
    g_data_input_stream_read_int64(stream, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gint64 g_data_input_stream_read_int64 (GDataInputStream *stream, GCancellable *cancellable, GError **error);
```
"""
function g_data_input_stream_read_int64(stream, cancellable, error)
    @ccall libaravis.g_data_input_stream_read_int64(stream::Ptr{GDataInputStream}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gint64
end

"""
    g_data_input_stream_read_uint64(stream, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint64 g_data_input_stream_read_uint64 (GDataInputStream *stream, GCancellable *cancellable, GError **error);
```
"""
function g_data_input_stream_read_uint64(stream, cancellable, error)
    @ccall libaravis.g_data_input_stream_read_uint64(stream::Ptr{GDataInputStream}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::guint64
end

"""
    g_data_input_stream_read_line(stream, length, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL char * g_data_input_stream_read_line (GDataInputStream *stream, gsize *length, GCancellable *cancellable, GError **error);
```
"""
function g_data_input_stream_read_line(stream, length, cancellable, error)
    @ccall libaravis.g_data_input_stream_read_line(stream::Ptr{GDataInputStream}, length::Ptr{gsize}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Cstring
end

"""
    g_data_input_stream_read_line_utf8(stream, length, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_30 char * g_data_input_stream_read_line_utf8 (GDataInputStream *stream, gsize *length, GCancellable *cancellable, GError **error);
```
"""
function g_data_input_stream_read_line_utf8(stream, length, cancellable, error)
    @ccall libaravis.g_data_input_stream_read_line_utf8(stream::Ptr{GDataInputStream}, length::Ptr{gsize}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Cstring
end

"""
    g_data_input_stream_read_line_async(stream, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_data_input_stream_read_line_async (GDataInputStream *stream, gint io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_data_input_stream_read_line_async(stream, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_data_input_stream_read_line_async(stream::Ptr{GDataInputStream}, io_priority::gint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_data_input_stream_read_line_finish(stream, result, length, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL char * g_data_input_stream_read_line_finish (GDataInputStream *stream, GAsyncResult *result, gsize *length, GError **error);
```
"""
function g_data_input_stream_read_line_finish(stream, result, length, error)
    @ccall libaravis.g_data_input_stream_read_line_finish(stream::Ptr{GDataInputStream}, result::Ptr{GAsyncResult}, length::Ptr{gsize}, error::Ptr{Ptr{GError}})::Cstring
end

"""
    g_data_input_stream_read_line_finish_utf8(stream, result, length, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_30 char * g_data_input_stream_read_line_finish_utf8(GDataInputStream *stream, GAsyncResult *result, gsize *length, GError **error);
```
"""
function g_data_input_stream_read_line_finish_utf8(stream, result, length, error)
    @ccall libaravis.g_data_input_stream_read_line_finish_utf8(stream::Ptr{GDataInputStream}, result::Ptr{GAsyncResult}, length::Ptr{gsize}, error::Ptr{Ptr{GError}})::Cstring
end

"""
    g_data_input_stream_read_until(stream, stop_chars, length, cancellable, error)

### Prototype
```c
GIO_DEPRECATED_IN_2_56_FOR (g_data_input_stream_read_upto) char * g_data_input_stream_read_until (GDataInputStream *stream, const gchar *stop_chars, gsize *length, GCancellable *cancellable, GError **error);
```
"""
function g_data_input_stream_read_until(stream, stop_chars, length, cancellable, error)
    @ccall libaravis.g_data_input_stream_read_until(stream::Ptr{GDataInputStream}, stop_chars::Ptr{gchar}, length::Ptr{gsize}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Cstring
end

"""
    g_data_input_stream_read_until_async(stream, stop_chars, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_DEPRECATED_IN_2_56_FOR (g_data_input_stream_read_upto_async) void g_data_input_stream_read_until_async (GDataInputStream *stream, const gchar *stop_chars, gint io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_data_input_stream_read_until_async(stream, stop_chars, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_data_input_stream_read_until_async(stream::Ptr{GDataInputStream}, stop_chars::Ptr{gchar}, io_priority::gint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_data_input_stream_read_until_finish(stream, result, length, error)

### Prototype
```c
GIO_DEPRECATED_IN_2_56_FOR (g_data_input_stream_read_upto_finish) char * g_data_input_stream_read_until_finish (GDataInputStream *stream, GAsyncResult *result, gsize *length, GError **error);
```
"""
function g_data_input_stream_read_until_finish(stream, result, length, error)
    @ccall libaravis.g_data_input_stream_read_until_finish(stream::Ptr{GDataInputStream}, result::Ptr{GAsyncResult}, length::Ptr{gsize}, error::Ptr{Ptr{GError}})::Cstring
end

"""
    g_data_input_stream_read_upto(stream, stop_chars, stop_chars_len, length, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL char * g_data_input_stream_read_upto (GDataInputStream *stream, const gchar *stop_chars, gssize stop_chars_len, gsize *length, GCancellable *cancellable, GError **error);
```
"""
function g_data_input_stream_read_upto(stream, stop_chars, stop_chars_len, length, cancellable, error)
    @ccall libaravis.g_data_input_stream_read_upto(stream::Ptr{GDataInputStream}, stop_chars::Ptr{gchar}, stop_chars_len::gssize, length::Ptr{gsize}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Cstring
end

"""
    g_data_input_stream_read_upto_async(stream, stop_chars, stop_chars_len, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_data_input_stream_read_upto_async (GDataInputStream *stream, const gchar *stop_chars, gssize stop_chars_len, gint io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_data_input_stream_read_upto_async(stream, stop_chars, stop_chars_len, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_data_input_stream_read_upto_async(stream::Ptr{GDataInputStream}, stop_chars::Ptr{gchar}, stop_chars_len::gssize, io_priority::gint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_data_input_stream_read_upto_finish(stream, result, length, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL char * g_data_input_stream_read_upto_finish (GDataInputStream *stream, GAsyncResult *result, gsize *length, GError **error);
```
"""
function g_data_input_stream_read_upto_finish(stream, result, length, error)
    @ccall libaravis.g_data_input_stream_read_upto_finish(stream::Ptr{GDataInputStream}, result::Ptr{GAsyncResult}, length::Ptr{gsize}, error::Ptr{Ptr{GError}})::Cstring
end

"""
    g_data_output_stream_new(base_stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDataOutputStream * g_data_output_stream_new (GOutputStream *base_stream);
```
"""
function g_data_output_stream_new(base_stream)
    @ccall libaravis.g_data_output_stream_new(base_stream::Ptr{GOutputStream})::Ptr{GDataOutputStream}
end

"""
    g_data_output_stream_set_byte_order(stream, order)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_data_output_stream_set_byte_order (GDataOutputStream *stream, GDataStreamByteOrder order);
```
"""
function g_data_output_stream_set_byte_order(stream, order)
    @ccall libaravis.g_data_output_stream_set_byte_order(stream::Ptr{GDataOutputStream}, order::GDataStreamByteOrder)::Cvoid
end

"""
    g_data_output_stream_get_byte_order(stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDataStreamByteOrder g_data_output_stream_get_byte_order (GDataOutputStream *stream);
```
"""
function g_data_output_stream_get_byte_order(stream)
    @ccall libaravis.g_data_output_stream_get_byte_order(stream::Ptr{GDataOutputStream})::GDataStreamByteOrder
end

"""
    g_data_output_stream_put_byte(stream, data, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_data_output_stream_put_byte (GDataOutputStream *stream, guchar data, GCancellable *cancellable, GError **error);
```
"""
function g_data_output_stream_put_byte(stream, data, cancellable, error)
    @ccall libaravis.g_data_output_stream_put_byte(stream::Ptr{GDataOutputStream}, data::guchar, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_data_output_stream_put_int16(stream, data, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_data_output_stream_put_int16 (GDataOutputStream *stream, gint16 data, GCancellable *cancellable, GError **error);
```
"""
function g_data_output_stream_put_int16(stream, data, cancellable, error)
    @ccall libaravis.g_data_output_stream_put_int16(stream::Ptr{GDataOutputStream}, data::gint16, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_data_output_stream_put_uint16(stream, data, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_data_output_stream_put_uint16 (GDataOutputStream *stream, guint16 data, GCancellable *cancellable, GError **error);
```
"""
function g_data_output_stream_put_uint16(stream, data, cancellable, error)
    @ccall libaravis.g_data_output_stream_put_uint16(stream::Ptr{GDataOutputStream}, data::guint16, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_data_output_stream_put_int32(stream, data, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_data_output_stream_put_int32 (GDataOutputStream *stream, gint32 data, GCancellable *cancellable, GError **error);
```
"""
function g_data_output_stream_put_int32(stream, data, cancellable, error)
    @ccall libaravis.g_data_output_stream_put_int32(stream::Ptr{GDataOutputStream}, data::gint32, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_data_output_stream_put_uint32(stream, data, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_data_output_stream_put_uint32 (GDataOutputStream *stream, guint32 data, GCancellable *cancellable, GError **error);
```
"""
function g_data_output_stream_put_uint32(stream, data, cancellable, error)
    @ccall libaravis.g_data_output_stream_put_uint32(stream::Ptr{GDataOutputStream}, data::guint32, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_data_output_stream_put_int64(stream, data, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_data_output_stream_put_int64 (GDataOutputStream *stream, gint64 data, GCancellable *cancellable, GError **error);
```
"""
function g_data_output_stream_put_int64(stream, data, cancellable, error)
    @ccall libaravis.g_data_output_stream_put_int64(stream::Ptr{GDataOutputStream}, data::gint64, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_data_output_stream_put_uint64(stream, data, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_data_output_stream_put_uint64 (GDataOutputStream *stream, guint64 data, GCancellable *cancellable, GError **error);
```
"""
function g_data_output_stream_put_uint64(stream, data, cancellable, error)
    @ccall libaravis.g_data_output_stream_put_uint64(stream::Ptr{GDataOutputStream}, data::guint64, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_data_output_stream_put_string(stream, str, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_data_output_stream_put_string (GDataOutputStream *stream, const char *str, GCancellable *cancellable, GError **error);
```
"""
function g_data_output_stream_put_string(stream, str, cancellable, error)
    @ccall libaravis.g_data_output_stream_put_string(stream::Ptr{GDataOutputStream}, str::Cstring, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_dbus_action_group_get(connection, bus_name, object_path)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GDBusActionGroup * g_dbus_action_group_get (GDBusConnection *connection, const gchar *bus_name, const gchar *object_path);
```
"""
function g_dbus_action_group_get(connection, bus_name, object_path)
    @ccall libaravis.g_dbus_action_group_get(connection::Ptr{GDBusConnection}, bus_name::Ptr{gchar}, object_path::Ptr{gchar})::Ptr{GDBusActionGroup}
end

"""
    g_dbus_address_escape_value(string)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 gchar *g_dbus_address_escape_value (const gchar *string);
```
"""
function g_dbus_address_escape_value(string)
    @ccall libaravis.g_dbus_address_escape_value(string::Ptr{gchar})::Ptr{gchar}
end

"""
    g_dbus_is_address(string)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_dbus_is_address (const gchar *string);
```
"""
function g_dbus_is_address(string)
    @ccall libaravis.g_dbus_is_address(string::Ptr{gchar})::gboolean
end

"""
    g_dbus_is_supported_address(string, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_dbus_is_supported_address (const gchar *string, GError **error);
```
"""
function g_dbus_is_supported_address(string, error)
    @ccall libaravis.g_dbus_is_supported_address(string::Ptr{gchar}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_dbus_address_get_stream(address, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_address_get_stream (const gchar *address, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_dbus_address_get_stream(address, cancellable, callback, user_data)
    @ccall libaravis.g_dbus_address_get_stream(address::Ptr{gchar}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_dbus_address_get_stream_finish(res, out_guid, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIOStream *g_dbus_address_get_stream_finish (GAsyncResult *res, gchar **out_guid, GError **error);
```
"""
function g_dbus_address_get_stream_finish(res, out_guid, error)
    @ccall libaravis.g_dbus_address_get_stream_finish(res::Ptr{GAsyncResult}, out_guid::Ptr{Ptr{gchar}}, error::Ptr{Ptr{GError}})::Ptr{GIOStream}
end

"""
    g_dbus_address_get_stream_sync(address, out_guid, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIOStream *g_dbus_address_get_stream_sync (const gchar *address, gchar **out_guid, GCancellable *cancellable, GError **error);
```
"""
function g_dbus_address_get_stream_sync(address, out_guid, cancellable, error)
    @ccall libaravis.g_dbus_address_get_stream_sync(address::Ptr{gchar}, out_guid::Ptr{Ptr{gchar}}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GIOStream}
end

"""
    g_dbus_address_get_for_bus_sync(bus_type, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gchar *g_dbus_address_get_for_bus_sync (GBusType bus_type, GCancellable *cancellable, GError **error);
```
"""
function g_dbus_address_get_for_bus_sync(bus_type, cancellable, error)
    @ccall libaravis.g_dbus_address_get_for_bus_sync(bus_type::GBusType, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_dbus_auth_observer_new()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusAuthObserver *g_dbus_auth_observer_new (void);
```
"""
function g_dbus_auth_observer_new()
    @ccall libaravis.g_dbus_auth_observer_new()::Ptr{GDBusAuthObserver}
end

"""
    g_dbus_auth_observer_authorize_authenticated_peer(observer, stream, credentials)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_dbus_auth_observer_authorize_authenticated_peer (GDBusAuthObserver *observer, GIOStream *stream, GCredentials *credentials);
```
"""
function g_dbus_auth_observer_authorize_authenticated_peer(observer, stream, credentials)
    @ccall libaravis.g_dbus_auth_observer_authorize_authenticated_peer(observer::Ptr{GDBusAuthObserver}, stream::Ptr{GIOStream}, credentials::Ptr{GCredentials})::gboolean
end

"""
    g_dbus_auth_observer_allow_mechanism(observer, mechanism)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 gboolean g_dbus_auth_observer_allow_mechanism (GDBusAuthObserver *observer, const gchar *mechanism);
```
"""
function g_dbus_auth_observer_allow_mechanism(observer, mechanism)
    @ccall libaravis.g_dbus_auth_observer_allow_mechanism(observer::Ptr{GDBusAuthObserver}, mechanism::Ptr{gchar})::gboolean
end

"""
    g_bus_get(bus_type, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_bus_get (GBusType bus_type, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_bus_get(bus_type, cancellable, callback, user_data)
    @ccall libaravis.g_bus_get(bus_type::GBusType, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_bus_get_finish(res, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusConnection *g_bus_get_finish (GAsyncResult *res, GError **error);
```
"""
function g_bus_get_finish(res, error)
    @ccall libaravis.g_bus_get_finish(res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GDBusConnection}
end

"""
    g_bus_get_sync(bus_type, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusConnection *g_bus_get_sync (GBusType bus_type, GCancellable *cancellable, GError **error);
```
"""
function g_bus_get_sync(bus_type, cancellable, error)
    @ccall libaravis.g_bus_get_sync(bus_type::GBusType, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GDBusConnection}
end

"""
    g_dbus_connection_new(stream, guid, flags, observer, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_connection_new (GIOStream *stream, const gchar *guid, GDBusConnectionFlags flags, GDBusAuthObserver *observer, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_dbus_connection_new(stream, guid, flags, observer, cancellable, callback, user_data)
    @ccall libaravis.g_dbus_connection_new(stream::Ptr{GIOStream}, guid::Ptr{gchar}, flags::GDBusConnectionFlags, observer::Ptr{GDBusAuthObserver}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_dbus_connection_new_finish(res, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusConnection *g_dbus_connection_new_finish (GAsyncResult *res, GError **error);
```
"""
function g_dbus_connection_new_finish(res, error)
    @ccall libaravis.g_dbus_connection_new_finish(res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GDBusConnection}
end

"""
    g_dbus_connection_new_sync(stream, guid, flags, observer, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusConnection *g_dbus_connection_new_sync (GIOStream *stream, const gchar *guid, GDBusConnectionFlags flags, GDBusAuthObserver *observer, GCancellable *cancellable, GError **error);
```
"""
function g_dbus_connection_new_sync(stream, guid, flags, observer, cancellable, error)
    @ccall libaravis.g_dbus_connection_new_sync(stream::Ptr{GIOStream}, guid::Ptr{gchar}, flags::GDBusConnectionFlags, observer::Ptr{GDBusAuthObserver}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GDBusConnection}
end

"""
    g_dbus_connection_new_for_address(address, flags, observer, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_connection_new_for_address (const gchar *address, GDBusConnectionFlags flags, GDBusAuthObserver *observer, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_dbus_connection_new_for_address(address, flags, observer, cancellable, callback, user_data)
    @ccall libaravis.g_dbus_connection_new_for_address(address::Ptr{gchar}, flags::GDBusConnectionFlags, observer::Ptr{GDBusAuthObserver}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_dbus_connection_new_for_address_finish(res, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusConnection *g_dbus_connection_new_for_address_finish (GAsyncResult *res, GError **error);
```
"""
function g_dbus_connection_new_for_address_finish(res, error)
    @ccall libaravis.g_dbus_connection_new_for_address_finish(res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GDBusConnection}
end

"""
    g_dbus_connection_new_for_address_sync(address, flags, observer, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusConnection *g_dbus_connection_new_for_address_sync (const gchar *address, GDBusConnectionFlags flags, GDBusAuthObserver *observer, GCancellable *cancellable, GError **error);
```
"""
function g_dbus_connection_new_for_address_sync(address, flags, observer, cancellable, error)
    @ccall libaravis.g_dbus_connection_new_for_address_sync(address::Ptr{gchar}, flags::GDBusConnectionFlags, observer::Ptr{GDBusAuthObserver}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GDBusConnection}
end

"""
    g_dbus_connection_start_message_processing(connection)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_connection_start_message_processing (GDBusConnection *connection);
```
"""
function g_dbus_connection_start_message_processing(connection)
    @ccall libaravis.g_dbus_connection_start_message_processing(connection::Ptr{GDBusConnection})::Cvoid
end

"""
    g_dbus_connection_is_closed(connection)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_dbus_connection_is_closed (GDBusConnection *connection);
```
"""
function g_dbus_connection_is_closed(connection)
    @ccall libaravis.g_dbus_connection_is_closed(connection::Ptr{GDBusConnection})::gboolean
end

"""
    g_dbus_connection_get_stream(connection)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIOStream *g_dbus_connection_get_stream (GDBusConnection *connection);
```
"""
function g_dbus_connection_get_stream(connection)
    @ccall libaravis.g_dbus_connection_get_stream(connection::Ptr{GDBusConnection})::Ptr{GIOStream}
end

"""
    g_dbus_connection_get_guid(connection)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_dbus_connection_get_guid (GDBusConnection *connection);
```
"""
function g_dbus_connection_get_guid(connection)
    @ccall libaravis.g_dbus_connection_get_guid(connection::Ptr{GDBusConnection})::Ptr{gchar}
end

"""
    g_dbus_connection_get_unique_name(connection)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_dbus_connection_get_unique_name (GDBusConnection *connection);
```
"""
function g_dbus_connection_get_unique_name(connection)
    @ccall libaravis.g_dbus_connection_get_unique_name(connection::Ptr{GDBusConnection})::Ptr{gchar}
end

"""
    g_dbus_connection_get_peer_credentials(connection)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GCredentials *g_dbus_connection_get_peer_credentials (GDBusConnection *connection);
```
"""
function g_dbus_connection_get_peer_credentials(connection)
    @ccall libaravis.g_dbus_connection_get_peer_credentials(connection::Ptr{GDBusConnection})::Ptr{GCredentials}
end

"""
    g_dbus_connection_get_last_serial(connection)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 guint32 g_dbus_connection_get_last_serial (GDBusConnection *connection);
```
"""
function g_dbus_connection_get_last_serial(connection)
    @ccall libaravis.g_dbus_connection_get_last_serial(connection::Ptr{GDBusConnection})::guint32
end

"""
    g_dbus_connection_get_exit_on_close(connection)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_dbus_connection_get_exit_on_close (GDBusConnection *connection);
```
"""
function g_dbus_connection_get_exit_on_close(connection)
    @ccall libaravis.g_dbus_connection_get_exit_on_close(connection::Ptr{GDBusConnection})::gboolean
end

"""
    g_dbus_connection_set_exit_on_close(connection, exit_on_close)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_connection_set_exit_on_close (GDBusConnection *connection, gboolean exit_on_close);
```
"""
function g_dbus_connection_set_exit_on_close(connection, exit_on_close)
    @ccall libaravis.g_dbus_connection_set_exit_on_close(connection::Ptr{GDBusConnection}, exit_on_close::gboolean)::Cvoid
end

"""
    g_dbus_connection_get_capabilities(connection)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusCapabilityFlags g_dbus_connection_get_capabilities (GDBusConnection *connection);
```
"""
function g_dbus_connection_get_capabilities(connection)
    @ccall libaravis.g_dbus_connection_get_capabilities(connection::Ptr{GDBusConnection})::GDBusCapabilityFlags
end

"""
    g_dbus_connection_get_flags(connection)

### Prototype
```c
GIO_AVAILABLE_IN_2_60 GDBusConnectionFlags g_dbus_connection_get_flags (GDBusConnection *connection);
```
"""
function g_dbus_connection_get_flags(connection)
    @ccall libaravis.g_dbus_connection_get_flags(connection::Ptr{GDBusConnection})::GDBusConnectionFlags
end

"""
    g_dbus_connection_close(connection, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_connection_close (GDBusConnection *connection, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_dbus_connection_close(connection, cancellable, callback, user_data)
    @ccall libaravis.g_dbus_connection_close(connection::Ptr{GDBusConnection}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_dbus_connection_close_finish(connection, res, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_dbus_connection_close_finish (GDBusConnection *connection, GAsyncResult *res, GError **error);
```
"""
function g_dbus_connection_close_finish(connection, res, error)
    @ccall libaravis.g_dbus_connection_close_finish(connection::Ptr{GDBusConnection}, res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_dbus_connection_close_sync(connection, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_dbus_connection_close_sync (GDBusConnection *connection, GCancellable *cancellable, GError **error);
```
"""
function g_dbus_connection_close_sync(connection, cancellable, error)
    @ccall libaravis.g_dbus_connection_close_sync(connection::Ptr{GDBusConnection}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_dbus_connection_flush(connection, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_connection_flush (GDBusConnection *connection, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_dbus_connection_flush(connection, cancellable, callback, user_data)
    @ccall libaravis.g_dbus_connection_flush(connection::Ptr{GDBusConnection}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_dbus_connection_flush_finish(connection, res, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_dbus_connection_flush_finish (GDBusConnection *connection, GAsyncResult *res, GError **error);
```
"""
function g_dbus_connection_flush_finish(connection, res, error)
    @ccall libaravis.g_dbus_connection_flush_finish(connection::Ptr{GDBusConnection}, res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_dbus_connection_flush_sync(connection, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_dbus_connection_flush_sync (GDBusConnection *connection, GCancellable *cancellable, GError **error);
```
"""
function g_dbus_connection_flush_sync(connection, cancellable, error)
    @ccall libaravis.g_dbus_connection_flush_sync(connection::Ptr{GDBusConnection}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_dbus_connection_send_message(connection, message, flags, out_serial, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_dbus_connection_send_message (GDBusConnection *connection, GDBusMessage *message, GDBusSendMessageFlags flags, volatile guint32 *out_serial, GError **error);
```
"""
function g_dbus_connection_send_message(connection, message, flags, out_serial, error)
    @ccall libaravis.g_dbus_connection_send_message(connection::Ptr{GDBusConnection}, message::Ptr{GDBusMessage}, flags::GDBusSendMessageFlags, out_serial::Ptr{guint32}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_dbus_connection_send_message_with_reply(connection, message, flags, timeout_msec, out_serial, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_connection_send_message_with_reply (GDBusConnection *connection, GDBusMessage *message, GDBusSendMessageFlags flags, gint timeout_msec, volatile guint32 *out_serial, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_dbus_connection_send_message_with_reply(connection, message, flags, timeout_msec, out_serial, cancellable, callback, user_data)
    @ccall libaravis.g_dbus_connection_send_message_with_reply(connection::Ptr{GDBusConnection}, message::Ptr{GDBusMessage}, flags::GDBusSendMessageFlags, timeout_msec::gint, out_serial::Ptr{guint32}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_dbus_connection_send_message_with_reply_finish(connection, res, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusMessage *g_dbus_connection_send_message_with_reply_finish (GDBusConnection *connection, GAsyncResult *res, GError **error);
```
"""
function g_dbus_connection_send_message_with_reply_finish(connection, res, error)
    @ccall libaravis.g_dbus_connection_send_message_with_reply_finish(connection::Ptr{GDBusConnection}, res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GDBusMessage}
end

"""
    g_dbus_connection_send_message_with_reply_sync(connection, message, flags, timeout_msec, out_serial, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusMessage *g_dbus_connection_send_message_with_reply_sync (GDBusConnection *connection, GDBusMessage *message, GDBusSendMessageFlags flags, gint timeout_msec, volatile guint32 *out_serial, GCancellable *cancellable, GError **error);
```
"""
function g_dbus_connection_send_message_with_reply_sync(connection, message, flags, timeout_msec, out_serial, cancellable, error)
    @ccall libaravis.g_dbus_connection_send_message_with_reply_sync(connection::Ptr{GDBusConnection}, message::Ptr{GDBusMessage}, flags::GDBusSendMessageFlags, timeout_msec::gint, out_serial::Ptr{guint32}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GDBusMessage}
end

"""
    g_dbus_connection_emit_signal(connection, destination_bus_name, object_path, interface_name, signal_name, parameters, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_dbus_connection_emit_signal (GDBusConnection *connection, const gchar *destination_bus_name, const gchar *object_path, const gchar *interface_name, const gchar *signal_name, GVariant *parameters, GError **error);
```
"""
function g_dbus_connection_emit_signal(connection, destination_bus_name, object_path, interface_name, signal_name, parameters, error)
    @ccall libaravis.g_dbus_connection_emit_signal(connection::Ptr{GDBusConnection}, destination_bus_name::Ptr{gchar}, object_path::Ptr{gchar}, interface_name::Ptr{gchar}, signal_name::Ptr{gchar}, parameters::Ptr{GVariant}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_dbus_connection_call(connection, bus_name, object_path, interface_name, method_name, parameters, reply_type, flags, timeout_msec, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_connection_call (GDBusConnection *connection, const gchar *bus_name, const gchar *object_path, const gchar *interface_name, const gchar *method_name, GVariant *parameters, const GVariantType *reply_type, GDBusCallFlags flags, gint timeout_msec, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_dbus_connection_call(connection, bus_name, object_path, interface_name, method_name, parameters, reply_type, flags, timeout_msec, cancellable, callback, user_data)
    @ccall libaravis.g_dbus_connection_call(connection::Ptr{GDBusConnection}, bus_name::Ptr{gchar}, object_path::Ptr{gchar}, interface_name::Ptr{gchar}, method_name::Ptr{gchar}, parameters::Ptr{GVariant}, reply_type::Ptr{GVariantType}, flags::GDBusCallFlags, timeout_msec::gint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_dbus_connection_call_finish(connection, res, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GVariant *g_dbus_connection_call_finish (GDBusConnection *connection, GAsyncResult *res, GError **error);
```
"""
function g_dbus_connection_call_finish(connection, res, error)
    @ccall libaravis.g_dbus_connection_call_finish(connection::Ptr{GDBusConnection}, res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GVariant}
end

"""
    g_dbus_connection_call_sync(connection, bus_name, object_path, interface_name, method_name, parameters, reply_type, flags, timeout_msec, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GVariant *g_dbus_connection_call_sync (GDBusConnection *connection, const gchar *bus_name, const gchar *object_path, const gchar *interface_name, const gchar *method_name, GVariant *parameters, const GVariantType *reply_type, GDBusCallFlags flags, gint timeout_msec, GCancellable *cancellable, GError **error);
```
"""
function g_dbus_connection_call_sync(connection, bus_name, object_path, interface_name, method_name, parameters, reply_type, flags, timeout_msec, cancellable, error)
    @ccall libaravis.g_dbus_connection_call_sync(connection::Ptr{GDBusConnection}, bus_name::Ptr{gchar}, object_path::Ptr{gchar}, interface_name::Ptr{gchar}, method_name::Ptr{gchar}, parameters::Ptr{GVariant}, reply_type::Ptr{GVariantType}, flags::GDBusCallFlags, timeout_msec::gint, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GVariant}
end

"""
    g_dbus_connection_call_with_unix_fd_list(connection, bus_name, object_path, interface_name, method_name, parameters, reply_type, flags, timeout_msec, fd_list, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_30 void g_dbus_connection_call_with_unix_fd_list (GDBusConnection *connection, const gchar *bus_name, const gchar *object_path, const gchar *interface_name, const gchar *method_name, GVariant *parameters, const GVariantType *reply_type, GDBusCallFlags flags, gint timeout_msec, GUnixFDList *fd_list, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_dbus_connection_call_with_unix_fd_list(connection, bus_name, object_path, interface_name, method_name, parameters, reply_type, flags, timeout_msec, fd_list, cancellable, callback, user_data)
    @ccall libaravis.g_dbus_connection_call_with_unix_fd_list(connection::Ptr{GDBusConnection}, bus_name::Ptr{gchar}, object_path::Ptr{gchar}, interface_name::Ptr{gchar}, method_name::Ptr{gchar}, parameters::Ptr{GVariant}, reply_type::Ptr{GVariantType}, flags::GDBusCallFlags, timeout_msec::gint, fd_list::Ptr{GUnixFDList}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_dbus_connection_call_with_unix_fd_list_finish(connection, out_fd_list, res, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_30 GVariant *g_dbus_connection_call_with_unix_fd_list_finish (GDBusConnection *connection, GUnixFDList **out_fd_list, GAsyncResult *res, GError **error);
```
"""
function g_dbus_connection_call_with_unix_fd_list_finish(connection, out_fd_list, res, error)
    @ccall libaravis.g_dbus_connection_call_with_unix_fd_list_finish(connection::Ptr{GDBusConnection}, out_fd_list::Ptr{Ptr{GUnixFDList}}, res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GVariant}
end

"""
    g_dbus_connection_call_with_unix_fd_list_sync(connection, bus_name, object_path, interface_name, method_name, parameters, reply_type, flags, timeout_msec, fd_list, out_fd_list, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_30 GVariant *g_dbus_connection_call_with_unix_fd_list_sync (GDBusConnection *connection, const gchar *bus_name, const gchar *object_path, const gchar *interface_name, const gchar *method_name, GVariant *parameters, const GVariantType *reply_type, GDBusCallFlags flags, gint timeout_msec, GUnixFDList *fd_list, GUnixFDList **out_fd_list, GCancellable *cancellable, GError **error);
```
"""
function g_dbus_connection_call_with_unix_fd_list_sync(connection, bus_name, object_path, interface_name, method_name, parameters, reply_type, flags, timeout_msec, fd_list, out_fd_list, cancellable, error)
    @ccall libaravis.g_dbus_connection_call_with_unix_fd_list_sync(connection::Ptr{GDBusConnection}, bus_name::Ptr{gchar}, object_path::Ptr{gchar}, interface_name::Ptr{gchar}, method_name::Ptr{gchar}, parameters::Ptr{GVariant}, reply_type::Ptr{GVariantType}, flags::GDBusCallFlags, timeout_msec::gint, fd_list::Ptr{GUnixFDList}, out_fd_list::Ptr{Ptr{GUnixFDList}}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GVariant}
end

"""
    g_dbus_connection_register_object(connection, object_path, interface_info, vtable, user_data, user_data_free_func, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint g_dbus_connection_register_object (GDBusConnection *connection, const gchar *object_path, GDBusInterfaceInfo *interface_info, const GDBusInterfaceVTable *vtable, gpointer user_data, GDestroyNotify user_data_free_func, GError **error);
```
"""
function g_dbus_connection_register_object(connection, object_path, interface_info, vtable, user_data, user_data_free_func, error)
    @ccall libaravis.g_dbus_connection_register_object(connection::Ptr{GDBusConnection}, object_path::Ptr{gchar}, interface_info::Ptr{GDBusInterfaceInfo}, vtable::Ptr{GDBusInterfaceVTable}, user_data::gpointer, user_data_free_func::GDestroyNotify, error::Ptr{Ptr{GError}})::guint
end

"""
    g_dbus_connection_register_object_with_closures(connection, object_path, interface_info, method_call_closure, get_property_closure, set_property_closure, error)

### Prototype
```c
GIO_DEPRECATED_IN_2_84_FOR(g_dbus_connection_register_object_with_closures2) guint g_dbus_connection_register_object_with_closures (GDBusConnection *connection, const gchar *object_path, GDBusInterfaceInfo *interface_info, GClosure *method_call_closure, GClosure *get_property_closure, GClosure *set_property_closure, GError **error);
```
"""
function g_dbus_connection_register_object_with_closures(connection, object_path, interface_info, method_call_closure, get_property_closure, set_property_closure, error)
    @ccall libaravis.g_dbus_connection_register_object_with_closures(connection::Ptr{GDBusConnection}, object_path::Ptr{gchar}, interface_info::Ptr{GDBusInterfaceInfo}, method_call_closure::Ptr{GClosure}, get_property_closure::Ptr{GClosure}, set_property_closure::Ptr{GClosure}, error::Ptr{Ptr{GError}})::guint
end

"""
    g_dbus_connection_register_object_with_closures2(connection, object_path, interface_info, method_call_closure, get_property_closure, set_property_closure, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_84 guint g_dbus_connection_register_object_with_closures2 (GDBusConnection *connection, const gchar *object_path, GDBusInterfaceInfo *interface_info, GClosure *method_call_closure, GClosure *get_property_closure, GClosure *set_property_closure, GError **error);
```
"""
function g_dbus_connection_register_object_with_closures2(connection, object_path, interface_info, method_call_closure, get_property_closure, set_property_closure, error)
    @ccall libaravis.g_dbus_connection_register_object_with_closures2(connection::Ptr{GDBusConnection}, object_path::Ptr{gchar}, interface_info::Ptr{GDBusInterfaceInfo}, method_call_closure::Ptr{GClosure}, get_property_closure::Ptr{GClosure}, set_property_closure::Ptr{GClosure}, error::Ptr{Ptr{GError}})::guint
end

"""
    g_dbus_connection_unregister_object(connection, registration_id)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_dbus_connection_unregister_object (GDBusConnection *connection, guint registration_id);
```
"""
function g_dbus_connection_unregister_object(connection, registration_id)
    @ccall libaravis.g_dbus_connection_unregister_object(connection::Ptr{GDBusConnection}, registration_id::guint)::gboolean
end

"""
    g_dbus_connection_register_subtree(connection, object_path, vtable, flags, user_data, user_data_free_func, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint g_dbus_connection_register_subtree (GDBusConnection *connection, const gchar *object_path, const GDBusSubtreeVTable *vtable, GDBusSubtreeFlags flags, gpointer user_data, GDestroyNotify user_data_free_func, GError **error);
```
"""
function g_dbus_connection_register_subtree(connection, object_path, vtable, flags, user_data, user_data_free_func, error)
    @ccall libaravis.g_dbus_connection_register_subtree(connection::Ptr{GDBusConnection}, object_path::Ptr{gchar}, vtable::Ptr{GDBusSubtreeVTable}, flags::GDBusSubtreeFlags, user_data::gpointer, user_data_free_func::GDestroyNotify, error::Ptr{Ptr{GError}})::guint
end

"""
    g_dbus_connection_unregister_subtree(connection, registration_id)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_dbus_connection_unregister_subtree (GDBusConnection *connection, guint registration_id);
```
"""
function g_dbus_connection_unregister_subtree(connection, registration_id)
    @ccall libaravis.g_dbus_connection_unregister_subtree(connection::Ptr{GDBusConnection}, registration_id::guint)::gboolean
end

# typedef void ( * GDBusSignalCallback ) ( GDBusConnection * connection , const gchar * sender_name , const gchar * object_path , const gchar * interface_name , const gchar * signal_name , GVariant * parameters , gpointer user_data )
"""
[`GDBusSignalCallback`](@ref): : A #[`GDBusConnection`](@ref). \\_name: (nullable): The unique bus name of the sender of the signal, or NULL on a peer-to-peer D-Bus connection. \\_path: The object path that the signal was emitted on.

`_name: The name of the interface.`

\\_name: The name of the signal. : A #[`GVariant`](@ref) tuple with parameters for the signal. \\_data: User data passed when subscribing to the signal.

Signature for callback function used in [`g_dbus_connection_signal_subscribe`](@ref)().

Since: 2.26
"""
const GDBusSignalCallback = Ptr{Cvoid}

"""
    g_dbus_connection_signal_subscribe(connection, sender, interface_name, member, object_path, arg0, flags, callback, user_data, user_data_free_func)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint g_dbus_connection_signal_subscribe (GDBusConnection *connection, const gchar *sender, const gchar *interface_name, const gchar *member, const gchar *object_path, const gchar *arg0, GDBusSignalFlags flags, GDBusSignalCallback callback, gpointer user_data, GDestroyNotify user_data_free_func);
```
"""
function g_dbus_connection_signal_subscribe(connection, sender, interface_name, member, object_path, arg0, flags, callback, user_data, user_data_free_func)
    @ccall libaravis.g_dbus_connection_signal_subscribe(connection::Ptr{GDBusConnection}, sender::Ptr{gchar}, interface_name::Ptr{gchar}, member::Ptr{gchar}, object_path::Ptr{gchar}, arg0::Ptr{gchar}, flags::GDBusSignalFlags, callback::GDBusSignalCallback, user_data::gpointer, user_data_free_func::GDestroyNotify)::guint
end

"""
    g_dbus_connection_signal_unsubscribe(connection, subscription_id)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_connection_signal_unsubscribe (GDBusConnection *connection, guint subscription_id);
```
"""
function g_dbus_connection_signal_unsubscribe(connection, subscription_id)
    @ccall libaravis.g_dbus_connection_signal_unsubscribe(connection::Ptr{GDBusConnection}, subscription_id::guint)::Cvoid
end

"""
    g_clear_dbus_signal_subscription(subscription_id_pointer, connection)

[`g_clear_dbus_signal_subscription`](@ref): (skip) \\_id\\_pointer: (not optional) (inout): A pointer to either a subscription ID obtained from [method.DBusConnection.signal\\_subscribe], or zero. : The connection from which the subscription ID was obtained. This pointer may be `NULL` or invalid, if the subscription ID is zero.

If \\_id\\_pointer points to a nonzero subscription ID, unsubscribe from that D-Bus signal subscription as if via [method.DBusConnection.signal\\_unsubscribe].

Also set the value pointed to by \\_id\\_pointer to zero, which signifies its no longer a valid subscription ID.

This convenience function for C code helps to ensure that each signal subscription is unsubscribed exactly once, similar to [func.clear\\_object] and [func.clear\\_signal\\_handler].

Since: 2.84

### Prototype
```c
static inline void g_clear_dbus_signal_subscription (guint *subscription_id_pointer, GDBusConnection *connection);
```
"""
function g_clear_dbus_signal_subscription(subscription_id_pointer, connection)
    @ccall libaravis.g_clear_dbus_signal_subscription(subscription_id_pointer::Ptr{guint}, connection::Ptr{GDBusConnection})::Cvoid
end

# typedef GDBusMessage * ( * GDBusMessageFilterFunction ) ( GDBusConnection * connection , GDBusMessage * message , gboolean incoming , gpointer user_data )
"""
[`GDBusMessageFilterFunction`](@ref): : (transfer none): A #[`GDBusConnection`](@ref). : (transfer full): A locked #[`GDBusMessage`](@ref) that the filter function takes ownership of. : TRUE if it is a message received from the other peer, FALSE if it is a message to be sent to the other peer. \\_data: User data passed when adding the filter.

Signature for function used in [`g_dbus_connection_add_filter`](@ref)().

A filter function is passed a #[`GDBusMessage`](@ref) and expected to return a #[`GDBusMessage`](@ref) too. Passive filter functions that don't modify the message can simply return the  object: |[ static [`GDBusMessage`](@ref) * passive\\_filter ([`GDBusConnection`](@ref) *connection [`GDBusMessage`](@ref) *message, [`gboolean`](@ref) incoming, [`gpointer`](@ref) user\\_data) { // inspect  return message; } ]| Filter functions that wants to drop a message can simply return NULL: |[ static [`GDBusMessage`](@ref) * drop\\_filter ([`GDBusConnection`](@ref) *connection [`GDBusMessage`](@ref) *message, [`gboolean`](@ref) incoming, [`gpointer`](@ref) user\\_data) { if (should\\_drop\\_message) { [`g_object_unref`](@ref) (message); message = NULL; } return message; } ]| Finally, a filter function may modify a message by copying it: |[ static [`GDBusMessage`](@ref) * modifying\\_filter ([`GDBusConnection`](@ref) *connection [`GDBusMessage`](@ref) *message, [`gboolean`](@ref) incoming, [`gpointer`](@ref) user\\_data) { [`GDBusMessage`](@ref) *copy; [`GError`](@ref) *error;

error = NULL; copy = [`g_dbus_message_copy`](@ref) (message, &error); // handle  being set [`g_object_unref`](@ref) (message);

// modify

return copy; } ]| If the returned #[`GDBusMessage`](@ref) is different from  and cannot be sent on  (it could use features, such as file descriptors, not compatible with ), then a warning is logged to standard error. Applications can check this ahead of time using [`g_dbus_message_to_blob`](@ref)() passing a #[`GDBusCapabilityFlags`](@ref) value obtained from .

Returns: (transfer full) (nullable): A #[`GDBusMessage`](@ref) that will be freed with [`g_object_unref`](@ref)() or NULL to drop the message. Passive filter functions can simply return the passed  object.

Since: 2.26
"""
const GDBusMessageFilterFunction = Ptr{Cvoid}

"""
    g_dbus_connection_add_filter(connection, filter_function, user_data, user_data_free_func)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint g_dbus_connection_add_filter (GDBusConnection *connection, GDBusMessageFilterFunction filter_function, gpointer user_data, GDestroyNotify user_data_free_func);
```
"""
function g_dbus_connection_add_filter(connection, filter_function, user_data, user_data_free_func)
    @ccall libaravis.g_dbus_connection_add_filter(connection::Ptr{GDBusConnection}, filter_function::GDBusMessageFilterFunction, user_data::gpointer, user_data_free_func::GDestroyNotify)::guint
end

"""
    g_dbus_connection_remove_filter(connection, filter_id)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_connection_remove_filter (GDBusConnection *connection, guint filter_id);
```
"""
function g_dbus_connection_remove_filter(connection, filter_id)
    @ccall libaravis.g_dbus_connection_remove_filter(connection::Ptr{GDBusConnection}, filter_id::guint)::Cvoid
end

"""
    g_dbus_error_is_remote_error(error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_dbus_error_is_remote_error (const GError *error);
```
"""
function g_dbus_error_is_remote_error(error)
    @ccall libaravis.g_dbus_error_is_remote_error(error::Ptr{GError})::gboolean
end

"""
    g_dbus_error_get_remote_error(error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gchar *g_dbus_error_get_remote_error (const GError *error);
```
"""
function g_dbus_error_get_remote_error(error)
    @ccall libaravis.g_dbus_error_get_remote_error(error::Ptr{GError})::Ptr{gchar}
end

"""
    g_dbus_error_strip_remote_error(error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_dbus_error_strip_remote_error (GError *error);
```
"""
function g_dbus_error_strip_remote_error(error)
    @ccall libaravis.g_dbus_error_strip_remote_error(error::Ptr{GError})::gboolean
end

"""
    g_dbus_error_register_error(error_domain, error_code, dbus_error_name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_dbus_error_register_error (GQuark error_domain, gint error_code, const gchar *dbus_error_name);
```
"""
function g_dbus_error_register_error(error_domain, error_code, dbus_error_name)
    @ccall libaravis.g_dbus_error_register_error(error_domain::GQuark, error_code::gint, dbus_error_name::Ptr{gchar})::gboolean
end

"""
    g_dbus_error_unregister_error(error_domain, error_code, dbus_error_name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_dbus_error_unregister_error (GQuark error_domain, gint error_code, const gchar *dbus_error_name);
```
"""
function g_dbus_error_unregister_error(error_domain, error_code, dbus_error_name)
    @ccall libaravis.g_dbus_error_unregister_error(error_domain::GQuark, error_code::gint, dbus_error_name::Ptr{gchar})::gboolean
end

"""
    g_dbus_error_register_error_domain(error_domain_quark_name, quark_volatile, entries, num_entries)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_error_register_error_domain (const gchar *error_domain_quark_name, volatile gsize *quark_volatile, const GDBusErrorEntry *entries, guint num_entries);
```
"""
function g_dbus_error_register_error_domain(error_domain_quark_name, quark_volatile, entries, num_entries)
    @ccall libaravis.g_dbus_error_register_error_domain(error_domain_quark_name::Ptr{gchar}, quark_volatile::Ptr{gsize}, entries::Ptr{GDBusErrorEntry}, num_entries::guint)::Cvoid
end

"""
    g_dbus_error_new_for_dbus_error(dbus_error_name, dbus_error_message)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GError *g_dbus_error_new_for_dbus_error (const gchar *dbus_error_name, const gchar *dbus_error_message);
```
"""
function g_dbus_error_new_for_dbus_error(dbus_error_name, dbus_error_message)
    @ccall libaravis.g_dbus_error_new_for_dbus_error(dbus_error_name::Ptr{gchar}, dbus_error_message::Ptr{gchar})::Ptr{GError}
end

"""
    g_dbus_error_encode_gerror(error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gchar *g_dbus_error_encode_gerror (const GError *error);
```
"""
function g_dbus_error_encode_gerror(error)
    @ccall libaravis.g_dbus_error_encode_gerror(error::Ptr{GError})::Ptr{gchar}
end

"""
    g_dbus_interface_get_info(interface_)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusInterfaceInfo *g_dbus_interface_get_info (GDBusInterface *interface_);
```
"""
function g_dbus_interface_get_info(interface_)
    @ccall libaravis.g_dbus_interface_get_info(interface_::Ptr{GDBusInterface})::Ptr{GDBusInterfaceInfo}
end

"""
    g_dbus_interface_get_object(interface_)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusObject *g_dbus_interface_get_object (GDBusInterface *interface_);
```
"""
function g_dbus_interface_get_object(interface_)
    @ccall libaravis.g_dbus_interface_get_object(interface_::Ptr{GDBusInterface})::Ptr{GDBusObject}
end

"""
    g_dbus_interface_set_object(interface_, object)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_interface_set_object (GDBusInterface *interface_, GDBusObject *object);
```
"""
function g_dbus_interface_set_object(interface_, object)
    @ccall libaravis.g_dbus_interface_set_object(interface_::Ptr{GDBusInterface}, object::Ptr{GDBusObject})::Cvoid
end

"""
    g_dbus_interface_dup_object(interface_)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GDBusObject *g_dbus_interface_dup_object (GDBusInterface *interface_);
```
"""
function g_dbus_interface_dup_object(interface_)
    @ccall libaravis.g_dbus_interface_dup_object(interface_::Ptr{GDBusInterface})::Ptr{GDBusObject}
end

"""
    g_dbus_interface_skeleton_get_flags(interface_)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusInterfaceSkeletonFlags g_dbus_interface_skeleton_get_flags (GDBusInterfaceSkeleton *interface_);
```
"""
function g_dbus_interface_skeleton_get_flags(interface_)
    @ccall libaravis.g_dbus_interface_skeleton_get_flags(interface_::Ptr{GDBusInterfaceSkeleton})::GDBusInterfaceSkeletonFlags
end

"""
    g_dbus_interface_skeleton_set_flags(interface_, flags)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_interface_skeleton_set_flags (GDBusInterfaceSkeleton *interface_, GDBusInterfaceSkeletonFlags flags);
```
"""
function g_dbus_interface_skeleton_set_flags(interface_, flags)
    @ccall libaravis.g_dbus_interface_skeleton_set_flags(interface_::Ptr{GDBusInterfaceSkeleton}, flags::GDBusInterfaceSkeletonFlags)::Cvoid
end

"""
    g_dbus_interface_skeleton_get_info(interface_)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusInterfaceInfo *g_dbus_interface_skeleton_get_info (GDBusInterfaceSkeleton *interface_);
```
"""
function g_dbus_interface_skeleton_get_info(interface_)
    @ccall libaravis.g_dbus_interface_skeleton_get_info(interface_::Ptr{GDBusInterfaceSkeleton})::Ptr{GDBusInterfaceInfo}
end

"""
    g_dbus_interface_skeleton_get_vtable(interface_)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusInterfaceVTable *g_dbus_interface_skeleton_get_vtable (GDBusInterfaceSkeleton *interface_);
```
"""
function g_dbus_interface_skeleton_get_vtable(interface_)
    @ccall libaravis.g_dbus_interface_skeleton_get_vtable(interface_::Ptr{GDBusInterfaceSkeleton})::Ptr{GDBusInterfaceVTable}
end

"""
    g_dbus_interface_skeleton_get_properties(interface_)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GVariant *g_dbus_interface_skeleton_get_properties (GDBusInterfaceSkeleton *interface_);
```
"""
function g_dbus_interface_skeleton_get_properties(interface_)
    @ccall libaravis.g_dbus_interface_skeleton_get_properties(interface_::Ptr{GDBusInterfaceSkeleton})::Ptr{GVariant}
end

"""
    g_dbus_interface_skeleton_flush(interface_)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_interface_skeleton_flush (GDBusInterfaceSkeleton *interface_);
```
"""
function g_dbus_interface_skeleton_flush(interface_)
    @ccall libaravis.g_dbus_interface_skeleton_flush(interface_::Ptr{GDBusInterfaceSkeleton})::Cvoid
end

"""
    g_dbus_interface_skeleton_export(interface_, connection, object_path, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_dbus_interface_skeleton_export (GDBusInterfaceSkeleton *interface_, GDBusConnection *connection, const gchar *object_path, GError **error);
```
"""
function g_dbus_interface_skeleton_export(interface_, connection, object_path, error)
    @ccall libaravis.g_dbus_interface_skeleton_export(interface_::Ptr{GDBusInterfaceSkeleton}, connection::Ptr{GDBusConnection}, object_path::Ptr{gchar}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_dbus_interface_skeleton_unexport(interface_)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_interface_skeleton_unexport (GDBusInterfaceSkeleton *interface_);
```
"""
function g_dbus_interface_skeleton_unexport(interface_)
    @ccall libaravis.g_dbus_interface_skeleton_unexport(interface_::Ptr{GDBusInterfaceSkeleton})::Cvoid
end

"""
    g_dbus_interface_skeleton_unexport_from_connection(interface_, connection)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_interface_skeleton_unexport_from_connection (GDBusInterfaceSkeleton *interface_, GDBusConnection *connection);
```
"""
function g_dbus_interface_skeleton_unexport_from_connection(interface_, connection)
    @ccall libaravis.g_dbus_interface_skeleton_unexport_from_connection(interface_::Ptr{GDBusInterfaceSkeleton}, connection::Ptr{GDBusConnection})::Cvoid
end

"""
    g_dbus_interface_skeleton_get_connection(interface_)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusConnection *g_dbus_interface_skeleton_get_connection (GDBusInterfaceSkeleton *interface_);
```
"""
function g_dbus_interface_skeleton_get_connection(interface_)
    @ccall libaravis.g_dbus_interface_skeleton_get_connection(interface_::Ptr{GDBusInterfaceSkeleton})::Ptr{GDBusConnection}
end

"""
    g_dbus_interface_skeleton_get_connections(interface_)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GList *g_dbus_interface_skeleton_get_connections (GDBusInterfaceSkeleton *interface_);
```
"""
function g_dbus_interface_skeleton_get_connections(interface_)
    @ccall libaravis.g_dbus_interface_skeleton_get_connections(interface_::Ptr{GDBusInterfaceSkeleton})::Ptr{GList}
end

"""
    g_dbus_interface_skeleton_has_connection(interface_, connection)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_dbus_interface_skeleton_has_connection (GDBusInterfaceSkeleton *interface_, GDBusConnection *connection);
```
"""
function g_dbus_interface_skeleton_has_connection(interface_, connection)
    @ccall libaravis.g_dbus_interface_skeleton_has_connection(interface_::Ptr{GDBusInterfaceSkeleton}, connection::Ptr{GDBusConnection})::gboolean
end

"""
    g_dbus_interface_skeleton_get_object_path(interface_)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_dbus_interface_skeleton_get_object_path (GDBusInterfaceSkeleton *interface_);
```
"""
function g_dbus_interface_skeleton_get_object_path(interface_)
    @ccall libaravis.g_dbus_interface_skeleton_get_object_path(interface_::Ptr{GDBusInterfaceSkeleton})::Ptr{gchar}
end

"""
    g_dbus_annotation_info_lookup(annotations, name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_dbus_annotation_info_lookup (GDBusAnnotationInfo **annotations, const gchar *name);
```
"""
function g_dbus_annotation_info_lookup(annotations, name)
    @ccall libaravis.g_dbus_annotation_info_lookup(annotations::Ptr{Ptr{GDBusAnnotationInfo}}, name::Ptr{gchar})::Ptr{gchar}
end

"""
    g_dbus_interface_info_lookup_method(info, name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusMethodInfo *g_dbus_interface_info_lookup_method (GDBusInterfaceInfo *info, const gchar *name);
```
"""
function g_dbus_interface_info_lookup_method(info, name)
    @ccall libaravis.g_dbus_interface_info_lookup_method(info::Ptr{GDBusInterfaceInfo}, name::Ptr{gchar})::Ptr{GDBusMethodInfo}
end

"""
    g_dbus_interface_info_lookup_signal(info, name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusSignalInfo *g_dbus_interface_info_lookup_signal (GDBusInterfaceInfo *info, const gchar *name);
```
"""
function g_dbus_interface_info_lookup_signal(info, name)
    @ccall libaravis.g_dbus_interface_info_lookup_signal(info::Ptr{GDBusInterfaceInfo}, name::Ptr{gchar})::Ptr{GDBusSignalInfo}
end

"""
    g_dbus_interface_info_lookup_property(info, name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusPropertyInfo *g_dbus_interface_info_lookup_property (GDBusInterfaceInfo *info, const gchar *name);
```
"""
function g_dbus_interface_info_lookup_property(info, name)
    @ccall libaravis.g_dbus_interface_info_lookup_property(info::Ptr{GDBusInterfaceInfo}, name::Ptr{gchar})::Ptr{GDBusPropertyInfo}
end

"""
    g_dbus_interface_info_cache_build(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_interface_info_cache_build (GDBusInterfaceInfo *info);
```
"""
function g_dbus_interface_info_cache_build(info)
    @ccall libaravis.g_dbus_interface_info_cache_build(info::Ptr{GDBusInterfaceInfo})::Cvoid
end

"""
    g_dbus_interface_info_cache_release(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_interface_info_cache_release (GDBusInterfaceInfo *info);
```
"""
function g_dbus_interface_info_cache_release(info)
    @ccall libaravis.g_dbus_interface_info_cache_release(info::Ptr{GDBusInterfaceInfo})::Cvoid
end

"""
    g_dbus_interface_info_generate_xml(info, indent, string_builder)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_interface_info_generate_xml (GDBusInterfaceInfo *info, guint indent, GString *string_builder);
```
"""
function g_dbus_interface_info_generate_xml(info, indent, string_builder)
    @ccall libaravis.g_dbus_interface_info_generate_xml(info::Ptr{GDBusInterfaceInfo}, indent::guint, string_builder::Ptr{GString})::Cvoid
end

"""
    g_dbus_node_info_new_for_xml(xml_data, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusNodeInfo *g_dbus_node_info_new_for_xml (const gchar *xml_data, GError **error);
```
"""
function g_dbus_node_info_new_for_xml(xml_data, error)
    @ccall libaravis.g_dbus_node_info_new_for_xml(xml_data::Ptr{gchar}, error::Ptr{Ptr{GError}})::Ptr{GDBusNodeInfo}
end

"""
    g_dbus_node_info_lookup_interface(info, name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusInterfaceInfo *g_dbus_node_info_lookup_interface (GDBusNodeInfo *info, const gchar *name);
```
"""
function g_dbus_node_info_lookup_interface(info, name)
    @ccall libaravis.g_dbus_node_info_lookup_interface(info::Ptr{GDBusNodeInfo}, name::Ptr{gchar})::Ptr{GDBusInterfaceInfo}
end

"""
    g_dbus_node_info_generate_xml(info, indent, string_builder)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_node_info_generate_xml (GDBusNodeInfo *info, guint indent, GString *string_builder);
```
"""
function g_dbus_node_info_generate_xml(info, indent, string_builder)
    @ccall libaravis.g_dbus_node_info_generate_xml(info::Ptr{GDBusNodeInfo}, indent::guint, string_builder::Ptr{GString})::Cvoid
end

"""
    g_dbus_node_info_ref(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusNodeInfo *g_dbus_node_info_ref (GDBusNodeInfo *info);
```
"""
function g_dbus_node_info_ref(info)
    @ccall libaravis.g_dbus_node_info_ref(info::Ptr{GDBusNodeInfo})::Ptr{GDBusNodeInfo}
end

"""
    g_dbus_interface_info_ref(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusInterfaceInfo *g_dbus_interface_info_ref (GDBusInterfaceInfo *info);
```
"""
function g_dbus_interface_info_ref(info)
    @ccall libaravis.g_dbus_interface_info_ref(info::Ptr{GDBusInterfaceInfo})::Ptr{GDBusInterfaceInfo}
end

"""
    g_dbus_method_info_ref(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusMethodInfo *g_dbus_method_info_ref (GDBusMethodInfo *info);
```
"""
function g_dbus_method_info_ref(info)
    @ccall libaravis.g_dbus_method_info_ref(info::Ptr{GDBusMethodInfo})::Ptr{GDBusMethodInfo}
end

"""
    g_dbus_signal_info_ref(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusSignalInfo *g_dbus_signal_info_ref (GDBusSignalInfo *info);
```
"""
function g_dbus_signal_info_ref(info)
    @ccall libaravis.g_dbus_signal_info_ref(info::Ptr{GDBusSignalInfo})::Ptr{GDBusSignalInfo}
end

"""
    g_dbus_property_info_ref(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusPropertyInfo *g_dbus_property_info_ref (GDBusPropertyInfo *info);
```
"""
function g_dbus_property_info_ref(info)
    @ccall libaravis.g_dbus_property_info_ref(info::Ptr{GDBusPropertyInfo})::Ptr{GDBusPropertyInfo}
end

"""
    g_dbus_arg_info_ref(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusArgInfo *g_dbus_arg_info_ref (GDBusArgInfo *info);
```
"""
function g_dbus_arg_info_ref(info)
    @ccall libaravis.g_dbus_arg_info_ref(info::Ptr{GDBusArgInfo})::Ptr{GDBusArgInfo}
end

"""
    g_dbus_annotation_info_ref(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusAnnotationInfo *g_dbus_annotation_info_ref (GDBusAnnotationInfo *info);
```
"""
function g_dbus_annotation_info_ref(info)
    @ccall libaravis.g_dbus_annotation_info_ref(info::Ptr{GDBusAnnotationInfo})::Ptr{GDBusAnnotationInfo}
end

"""
    g_dbus_node_info_unref(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_node_info_unref (GDBusNodeInfo *info);
```
"""
function g_dbus_node_info_unref(info)
    @ccall libaravis.g_dbus_node_info_unref(info::Ptr{GDBusNodeInfo})::Cvoid
end

"""
    g_dbus_interface_info_unref(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_interface_info_unref (GDBusInterfaceInfo *info);
```
"""
function g_dbus_interface_info_unref(info)
    @ccall libaravis.g_dbus_interface_info_unref(info::Ptr{GDBusInterfaceInfo})::Cvoid
end

"""
    g_dbus_method_info_unref(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_method_info_unref (GDBusMethodInfo *info);
```
"""
function g_dbus_method_info_unref(info)
    @ccall libaravis.g_dbus_method_info_unref(info::Ptr{GDBusMethodInfo})::Cvoid
end

"""
    g_dbus_signal_info_unref(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_signal_info_unref (GDBusSignalInfo *info);
```
"""
function g_dbus_signal_info_unref(info)
    @ccall libaravis.g_dbus_signal_info_unref(info::Ptr{GDBusSignalInfo})::Cvoid
end

"""
    g_dbus_property_info_unref(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_property_info_unref (GDBusPropertyInfo *info);
```
"""
function g_dbus_property_info_unref(info)
    @ccall libaravis.g_dbus_property_info_unref(info::Ptr{GDBusPropertyInfo})::Cvoid
end

"""
    g_dbus_arg_info_unref(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_arg_info_unref (GDBusArgInfo *info);
```
"""
function g_dbus_arg_info_unref(info)
    @ccall libaravis.g_dbus_arg_info_unref(info::Ptr{GDBusArgInfo})::Cvoid
end

"""
    g_dbus_annotation_info_unref(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_annotation_info_unref (GDBusAnnotationInfo *info);
```
"""
function g_dbus_annotation_info_unref(info)
    @ccall libaravis.g_dbus_annotation_info_unref(info::Ptr{GDBusAnnotationInfo})::Cvoid
end

"""
    g_dbus_menu_model_get(connection, bus_name, object_path)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusMenuModel * g_dbus_menu_model_get (GDBusConnection *connection, const gchar *bus_name, const gchar *object_path);
```
"""
function g_dbus_menu_model_get(connection, bus_name, object_path)
    @ccall libaravis.g_dbus_menu_model_get(connection::Ptr{GDBusConnection}, bus_name::Ptr{gchar}, object_path::Ptr{gchar})::Ptr{GDBusMenuModel}
end

"""
    g_dbus_message_new()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusMessage *g_dbus_message_new (void);
```
"""
function g_dbus_message_new()
    @ccall libaravis.g_dbus_message_new()::Ptr{GDBusMessage}
end

"""
    g_dbus_message_new_signal(path, interface_, signal)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusMessage *g_dbus_message_new_signal (const gchar *path, const gchar *interface_, const gchar *signal);
```
"""
function g_dbus_message_new_signal(path, interface_, signal)
    @ccall libaravis.g_dbus_message_new_signal(path::Ptr{gchar}, interface_::Ptr{gchar}, signal::Ptr{gchar})::Ptr{GDBusMessage}
end

"""
    g_dbus_message_new_method_call(name, path, interface_, method)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusMessage *g_dbus_message_new_method_call (const gchar *name, const gchar *path, const gchar *interface_, const gchar *method);
```
"""
function g_dbus_message_new_method_call(name, path, interface_, method)
    @ccall libaravis.g_dbus_message_new_method_call(name::Ptr{gchar}, path::Ptr{gchar}, interface_::Ptr{gchar}, method::Ptr{gchar})::Ptr{GDBusMessage}
end

"""
    g_dbus_message_new_method_reply(method_call_message)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusMessage *g_dbus_message_new_method_reply (GDBusMessage *method_call_message);
```
"""
function g_dbus_message_new_method_reply(method_call_message)
    @ccall libaravis.g_dbus_message_new_method_reply(method_call_message::Ptr{GDBusMessage})::Ptr{GDBusMessage}
end

"""
    g_dbus_message_new_method_error_literal(method_call_message, error_name, error_message)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusMessage *g_dbus_message_new_method_error_literal (GDBusMessage *method_call_message, const gchar *error_name, const gchar *error_message);
```
"""
function g_dbus_message_new_method_error_literal(method_call_message, error_name, error_message)
    @ccall libaravis.g_dbus_message_new_method_error_literal(method_call_message::Ptr{GDBusMessage}, error_name::Ptr{gchar}, error_message::Ptr{gchar})::Ptr{GDBusMessage}
end

"""
    g_dbus_message_print(message, indent)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gchar *g_dbus_message_print (GDBusMessage *message, guint indent);
```
"""
function g_dbus_message_print(message, indent)
    @ccall libaravis.g_dbus_message_print(message::Ptr{GDBusMessage}, indent::guint)::Ptr{gchar}
end

"""
    g_dbus_message_get_locked(message)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_dbus_message_get_locked (GDBusMessage *message);
```
"""
function g_dbus_message_get_locked(message)
    @ccall libaravis.g_dbus_message_get_locked(message::Ptr{GDBusMessage})::gboolean
end

"""
    g_dbus_message_lock(message)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_message_lock (GDBusMessage *message);
```
"""
function g_dbus_message_lock(message)
    @ccall libaravis.g_dbus_message_lock(message::Ptr{GDBusMessage})::Cvoid
end

"""
    g_dbus_message_copy(message, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusMessage *g_dbus_message_copy (GDBusMessage *message, GError **error);
```
"""
function g_dbus_message_copy(message, error)
    @ccall libaravis.g_dbus_message_copy(message::Ptr{GDBusMessage}, error::Ptr{Ptr{GError}})::Ptr{GDBusMessage}
end

"""
    g_dbus_message_get_byte_order(message)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusMessageByteOrder g_dbus_message_get_byte_order (GDBusMessage *message);
```
"""
function g_dbus_message_get_byte_order(message)
    @ccall libaravis.g_dbus_message_get_byte_order(message::Ptr{GDBusMessage})::GDBusMessageByteOrder
end

"""
    g_dbus_message_set_byte_order(message, byte_order)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_message_set_byte_order (GDBusMessage *message, GDBusMessageByteOrder byte_order);
```
"""
function g_dbus_message_set_byte_order(message, byte_order)
    @ccall libaravis.g_dbus_message_set_byte_order(message::Ptr{GDBusMessage}, byte_order::GDBusMessageByteOrder)::Cvoid
end

"""
    g_dbus_message_get_message_type(message)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusMessageType g_dbus_message_get_message_type (GDBusMessage *message);
```
"""
function g_dbus_message_get_message_type(message)
    @ccall libaravis.g_dbus_message_get_message_type(message::Ptr{GDBusMessage})::GDBusMessageType
end

"""
    g_dbus_message_set_message_type(message, type)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_message_set_message_type (GDBusMessage *message, GDBusMessageType type);
```
"""
function g_dbus_message_set_message_type(message, type)
    @ccall libaravis.g_dbus_message_set_message_type(message::Ptr{GDBusMessage}, type::GDBusMessageType)::Cvoid
end

"""
    g_dbus_message_get_flags(message)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusMessageFlags g_dbus_message_get_flags (GDBusMessage *message);
```
"""
function g_dbus_message_get_flags(message)
    @ccall libaravis.g_dbus_message_get_flags(message::Ptr{GDBusMessage})::GDBusMessageFlags
end

"""
    g_dbus_message_set_flags(message, flags)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_message_set_flags (GDBusMessage *message, GDBusMessageFlags flags);
```
"""
function g_dbus_message_set_flags(message, flags)
    @ccall libaravis.g_dbus_message_set_flags(message::Ptr{GDBusMessage}, flags::GDBusMessageFlags)::Cvoid
end

"""
    g_dbus_message_get_serial(message)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint32 g_dbus_message_get_serial (GDBusMessage *message);
```
"""
function g_dbus_message_get_serial(message)
    @ccall libaravis.g_dbus_message_get_serial(message::Ptr{GDBusMessage})::guint32
end

"""
    g_dbus_message_set_serial(message, serial)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_message_set_serial (GDBusMessage *message, guint32 serial);
```
"""
function g_dbus_message_set_serial(message, serial)
    @ccall libaravis.g_dbus_message_set_serial(message::Ptr{GDBusMessage}, serial::guint32)::Cvoid
end

"""
    g_dbus_message_get_header(message, header_field)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GVariant *g_dbus_message_get_header (GDBusMessage *message, GDBusMessageHeaderField header_field);
```
"""
function g_dbus_message_get_header(message, header_field)
    @ccall libaravis.g_dbus_message_get_header(message::Ptr{GDBusMessage}, header_field::GDBusMessageHeaderField)::Ptr{GVariant}
end

"""
    g_dbus_message_set_header(message, header_field, value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_message_set_header (GDBusMessage *message, GDBusMessageHeaderField header_field, GVariant *value);
```
"""
function g_dbus_message_set_header(message, header_field, value)
    @ccall libaravis.g_dbus_message_set_header(message::Ptr{GDBusMessage}, header_field::GDBusMessageHeaderField, value::Ptr{GVariant})::Cvoid
end

"""
    g_dbus_message_get_header_fields(message)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guchar *g_dbus_message_get_header_fields (GDBusMessage *message);
```
"""
function g_dbus_message_get_header_fields(message)
    @ccall libaravis.g_dbus_message_get_header_fields(message::Ptr{GDBusMessage})::Ptr{guchar}
end

"""
    g_dbus_message_get_body(message)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GVariant *g_dbus_message_get_body (GDBusMessage *message);
```
"""
function g_dbus_message_get_body(message)
    @ccall libaravis.g_dbus_message_get_body(message::Ptr{GDBusMessage})::Ptr{GVariant}
end

"""
    g_dbus_message_set_body(message, body)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_message_set_body (GDBusMessage *message, GVariant *body);
```
"""
function g_dbus_message_set_body(message, body)
    @ccall libaravis.g_dbus_message_set_body(message::Ptr{GDBusMessage}, body::Ptr{GVariant})::Cvoid
end

"""
    g_dbus_message_get_unix_fd_list(message)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GUnixFDList *g_dbus_message_get_unix_fd_list (GDBusMessage *message);
```
"""
function g_dbus_message_get_unix_fd_list(message)
    @ccall libaravis.g_dbus_message_get_unix_fd_list(message::Ptr{GDBusMessage})::Ptr{GUnixFDList}
end

"""
    g_dbus_message_set_unix_fd_list(message, fd_list)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_message_set_unix_fd_list (GDBusMessage *message, GUnixFDList *fd_list);
```
"""
function g_dbus_message_set_unix_fd_list(message, fd_list)
    @ccall libaravis.g_dbus_message_set_unix_fd_list(message::Ptr{GDBusMessage}, fd_list::Ptr{GUnixFDList})::Cvoid
end

"""
    g_dbus_message_get_reply_serial(message)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint32 g_dbus_message_get_reply_serial (GDBusMessage *message);
```
"""
function g_dbus_message_get_reply_serial(message)
    @ccall libaravis.g_dbus_message_get_reply_serial(message::Ptr{GDBusMessage})::guint32
end

"""
    g_dbus_message_set_reply_serial(message, value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_message_set_reply_serial (GDBusMessage *message, guint32 value);
```
"""
function g_dbus_message_set_reply_serial(message, value)
    @ccall libaravis.g_dbus_message_set_reply_serial(message::Ptr{GDBusMessage}, value::guint32)::Cvoid
end

"""
    g_dbus_message_get_interface(message)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_dbus_message_get_interface (GDBusMessage *message);
```
"""
function g_dbus_message_get_interface(message)
    @ccall libaravis.g_dbus_message_get_interface(message::Ptr{GDBusMessage})::Ptr{gchar}
end

"""
    g_dbus_message_set_interface(message, value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_message_set_interface (GDBusMessage *message, const gchar *value);
```
"""
function g_dbus_message_set_interface(message, value)
    @ccall libaravis.g_dbus_message_set_interface(message::Ptr{GDBusMessage}, value::Ptr{gchar})::Cvoid
end

"""
    g_dbus_message_get_member(message)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_dbus_message_get_member (GDBusMessage *message);
```
"""
function g_dbus_message_get_member(message)
    @ccall libaravis.g_dbus_message_get_member(message::Ptr{GDBusMessage})::Ptr{gchar}
end

"""
    g_dbus_message_set_member(message, value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_message_set_member (GDBusMessage *message, const gchar *value);
```
"""
function g_dbus_message_set_member(message, value)
    @ccall libaravis.g_dbus_message_set_member(message::Ptr{GDBusMessage}, value::Ptr{gchar})::Cvoid
end

"""
    g_dbus_message_get_path(message)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_dbus_message_get_path (GDBusMessage *message);
```
"""
function g_dbus_message_get_path(message)
    @ccall libaravis.g_dbus_message_get_path(message::Ptr{GDBusMessage})::Ptr{gchar}
end

"""
    g_dbus_message_set_path(message, value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_message_set_path (GDBusMessage *message, const gchar *value);
```
"""
function g_dbus_message_set_path(message, value)
    @ccall libaravis.g_dbus_message_set_path(message::Ptr{GDBusMessage}, value::Ptr{gchar})::Cvoid
end

"""
    g_dbus_message_get_sender(message)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_dbus_message_get_sender (GDBusMessage *message);
```
"""
function g_dbus_message_get_sender(message)
    @ccall libaravis.g_dbus_message_get_sender(message::Ptr{GDBusMessage})::Ptr{gchar}
end

"""
    g_dbus_message_set_sender(message, value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_message_set_sender (GDBusMessage *message, const gchar *value);
```
"""
function g_dbus_message_set_sender(message, value)
    @ccall libaravis.g_dbus_message_set_sender(message::Ptr{GDBusMessage}, value::Ptr{gchar})::Cvoid
end

"""
    g_dbus_message_get_destination(message)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_dbus_message_get_destination (GDBusMessage *message);
```
"""
function g_dbus_message_get_destination(message)
    @ccall libaravis.g_dbus_message_get_destination(message::Ptr{GDBusMessage})::Ptr{gchar}
end

"""
    g_dbus_message_set_destination(message, value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_message_set_destination (GDBusMessage *message, const gchar *value);
```
"""
function g_dbus_message_set_destination(message, value)
    @ccall libaravis.g_dbus_message_set_destination(message::Ptr{GDBusMessage}, value::Ptr{gchar})::Cvoid
end

"""
    g_dbus_message_get_error_name(message)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_dbus_message_get_error_name (GDBusMessage *message);
```
"""
function g_dbus_message_get_error_name(message)
    @ccall libaravis.g_dbus_message_get_error_name(message::Ptr{GDBusMessage})::Ptr{gchar}
end

"""
    g_dbus_message_set_error_name(message, value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_message_set_error_name (GDBusMessage *message, const gchar *value);
```
"""
function g_dbus_message_set_error_name(message, value)
    @ccall libaravis.g_dbus_message_set_error_name(message::Ptr{GDBusMessage}, value::Ptr{gchar})::Cvoid
end

"""
    g_dbus_message_get_signature(message)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_dbus_message_get_signature (GDBusMessage *message);
```
"""
function g_dbus_message_get_signature(message)
    @ccall libaravis.g_dbus_message_get_signature(message::Ptr{GDBusMessage})::Ptr{gchar}
end

"""
    g_dbus_message_set_signature(message, value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_message_set_signature (GDBusMessage *message, const gchar *value);
```
"""
function g_dbus_message_set_signature(message, value)
    @ccall libaravis.g_dbus_message_set_signature(message::Ptr{GDBusMessage}, value::Ptr{gchar})::Cvoid
end

"""
    g_dbus_message_get_num_unix_fds(message)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint32 g_dbus_message_get_num_unix_fds (GDBusMessage *message);
```
"""
function g_dbus_message_get_num_unix_fds(message)
    @ccall libaravis.g_dbus_message_get_num_unix_fds(message::Ptr{GDBusMessage})::guint32
end

"""
    g_dbus_message_set_num_unix_fds(message, value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_message_set_num_unix_fds (GDBusMessage *message, guint32 value);
```
"""
function g_dbus_message_set_num_unix_fds(message, value)
    @ccall libaravis.g_dbus_message_set_num_unix_fds(message::Ptr{GDBusMessage}, value::guint32)::Cvoid
end

"""
    g_dbus_message_get_arg0(message)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_dbus_message_get_arg0 (GDBusMessage *message);
```
"""
function g_dbus_message_get_arg0(message)
    @ccall libaravis.g_dbus_message_get_arg0(message::Ptr{GDBusMessage})::Ptr{gchar}
end

"""
    g_dbus_message_get_arg0_path(message)

### Prototype
```c
GIO_AVAILABLE_IN_2_80 const gchar *g_dbus_message_get_arg0_path (GDBusMessage *message);
```
"""
function g_dbus_message_get_arg0_path(message)
    @ccall libaravis.g_dbus_message_get_arg0_path(message::Ptr{GDBusMessage})::Ptr{gchar}
end

"""
    g_dbus_message_new_from_blob(blob, blob_len, capabilities, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusMessage *g_dbus_message_new_from_blob (guchar *blob, gsize blob_len, GDBusCapabilityFlags capabilities, GError **error);
```
"""
function g_dbus_message_new_from_blob(blob, blob_len, capabilities, error)
    @ccall libaravis.g_dbus_message_new_from_blob(blob::Ptr{guchar}, blob_len::gsize, capabilities::GDBusCapabilityFlags, error::Ptr{Ptr{GError}})::Ptr{GDBusMessage}
end

"""
    g_dbus_message_bytes_needed(blob, blob_len, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gssize g_dbus_message_bytes_needed (guchar *blob, gsize blob_len, GError **error);
```
"""
function g_dbus_message_bytes_needed(blob, blob_len, error)
    @ccall libaravis.g_dbus_message_bytes_needed(blob::Ptr{guchar}, blob_len::gsize, error::Ptr{Ptr{GError}})::gssize
end

"""
    g_dbus_message_to_blob(message, out_size, capabilities, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guchar *g_dbus_message_to_blob (GDBusMessage *message, gsize *out_size, GDBusCapabilityFlags capabilities, GError **error);
```
"""
function g_dbus_message_to_blob(message, out_size, capabilities, error)
    @ccall libaravis.g_dbus_message_to_blob(message::Ptr{GDBusMessage}, out_size::Ptr{gsize}, capabilities::GDBusCapabilityFlags, error::Ptr{Ptr{GError}})::Ptr{guchar}
end

"""
    g_dbus_message_to_gerror(message, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_dbus_message_to_gerror (GDBusMessage *message, GError **error);
```
"""
function g_dbus_message_to_gerror(message, error)
    @ccall libaravis.g_dbus_message_to_gerror(message::Ptr{GDBusMessage}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_dbus_method_invocation_get_sender(invocation)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_dbus_method_invocation_get_sender (GDBusMethodInvocation *invocation);
```
"""
function g_dbus_method_invocation_get_sender(invocation)
    @ccall libaravis.g_dbus_method_invocation_get_sender(invocation::Ptr{GDBusMethodInvocation})::Ptr{gchar}
end

"""
    g_dbus_method_invocation_get_object_path(invocation)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_dbus_method_invocation_get_object_path (GDBusMethodInvocation *invocation);
```
"""
function g_dbus_method_invocation_get_object_path(invocation)
    @ccall libaravis.g_dbus_method_invocation_get_object_path(invocation::Ptr{GDBusMethodInvocation})::Ptr{gchar}
end

"""
    g_dbus_method_invocation_get_interface_name(invocation)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_dbus_method_invocation_get_interface_name (GDBusMethodInvocation *invocation);
```
"""
function g_dbus_method_invocation_get_interface_name(invocation)
    @ccall libaravis.g_dbus_method_invocation_get_interface_name(invocation::Ptr{GDBusMethodInvocation})::Ptr{gchar}
end

"""
    g_dbus_method_invocation_get_method_name(invocation)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_dbus_method_invocation_get_method_name (GDBusMethodInvocation *invocation);
```
"""
function g_dbus_method_invocation_get_method_name(invocation)
    @ccall libaravis.g_dbus_method_invocation_get_method_name(invocation::Ptr{GDBusMethodInvocation})::Ptr{gchar}
end

"""
    g_dbus_method_invocation_get_method_info(invocation)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const GDBusMethodInfo *g_dbus_method_invocation_get_method_info (GDBusMethodInvocation *invocation);
```
"""
function g_dbus_method_invocation_get_method_info(invocation)
    @ccall libaravis.g_dbus_method_invocation_get_method_info(invocation::Ptr{GDBusMethodInvocation})::Ptr{GDBusMethodInfo}
end

"""
    g_dbus_method_invocation_get_property_info(invocation)

### Prototype
```c
GIO_AVAILABLE_IN_2_38 const GDBusPropertyInfo *g_dbus_method_invocation_get_property_info (GDBusMethodInvocation *invocation);
```
"""
function g_dbus_method_invocation_get_property_info(invocation)
    @ccall libaravis.g_dbus_method_invocation_get_property_info(invocation::Ptr{GDBusMethodInvocation})::Ptr{GDBusPropertyInfo}
end

"""
    g_dbus_method_invocation_get_connection(invocation)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusConnection *g_dbus_method_invocation_get_connection (GDBusMethodInvocation *invocation);
```
"""
function g_dbus_method_invocation_get_connection(invocation)
    @ccall libaravis.g_dbus_method_invocation_get_connection(invocation::Ptr{GDBusMethodInvocation})::Ptr{GDBusConnection}
end

"""
    g_dbus_method_invocation_get_message(invocation)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusMessage *g_dbus_method_invocation_get_message (GDBusMethodInvocation *invocation);
```
"""
function g_dbus_method_invocation_get_message(invocation)
    @ccall libaravis.g_dbus_method_invocation_get_message(invocation::Ptr{GDBusMethodInvocation})::Ptr{GDBusMessage}
end

"""
    g_dbus_method_invocation_get_parameters(invocation)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GVariant *g_dbus_method_invocation_get_parameters (GDBusMethodInvocation *invocation);
```
"""
function g_dbus_method_invocation_get_parameters(invocation)
    @ccall libaravis.g_dbus_method_invocation_get_parameters(invocation::Ptr{GDBusMethodInvocation})::Ptr{GVariant}
end

"""
    g_dbus_method_invocation_get_user_data(invocation)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gpointer g_dbus_method_invocation_get_user_data (GDBusMethodInvocation *invocation);
```
"""
function g_dbus_method_invocation_get_user_data(invocation)
    @ccall libaravis.g_dbus_method_invocation_get_user_data(invocation::Ptr{GDBusMethodInvocation})::gpointer
end

"""
    g_dbus_method_invocation_return_value(invocation, parameters)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_method_invocation_return_value (GDBusMethodInvocation *invocation, GVariant *parameters);
```
"""
function g_dbus_method_invocation_return_value(invocation, parameters)
    @ccall libaravis.g_dbus_method_invocation_return_value(invocation::Ptr{GDBusMethodInvocation}, parameters::Ptr{GVariant})::Cvoid
end

"""
    g_dbus_method_invocation_return_value_with_unix_fd_list(invocation, parameters, fd_list)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_method_invocation_return_value_with_unix_fd_list (GDBusMethodInvocation *invocation, GVariant *parameters, GUnixFDList *fd_list);
```
"""
function g_dbus_method_invocation_return_value_with_unix_fd_list(invocation, parameters, fd_list)
    @ccall libaravis.g_dbus_method_invocation_return_value_with_unix_fd_list(invocation::Ptr{GDBusMethodInvocation}, parameters::Ptr{GVariant}, fd_list::Ptr{GUnixFDList})::Cvoid
end

"""
    g_dbus_method_invocation_return_error_literal(invocation, domain, code, message)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_method_invocation_return_error_literal (GDBusMethodInvocation *invocation, GQuark domain, gint code, const gchar *message);
```
"""
function g_dbus_method_invocation_return_error_literal(invocation, domain, code, message)
    @ccall libaravis.g_dbus_method_invocation_return_error_literal(invocation::Ptr{GDBusMethodInvocation}, domain::GQuark, code::gint, message::Ptr{gchar})::Cvoid
end

"""
    g_dbus_method_invocation_return_gerror(invocation, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_method_invocation_return_gerror (GDBusMethodInvocation *invocation, const GError *error);
```
"""
function g_dbus_method_invocation_return_gerror(invocation, error)
    @ccall libaravis.g_dbus_method_invocation_return_gerror(invocation::Ptr{GDBusMethodInvocation}, error::Ptr{GError})::Cvoid
end

"""
    g_dbus_method_invocation_take_error(invocation, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_method_invocation_take_error (GDBusMethodInvocation *invocation, GError *error);
```
"""
function g_dbus_method_invocation_take_error(invocation, error)
    @ccall libaravis.g_dbus_method_invocation_take_error(invocation::Ptr{GDBusMethodInvocation}, error::Ptr{GError})::Cvoid
end

"""
    g_dbus_method_invocation_return_dbus_error(invocation, error_name, error_message)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_method_invocation_return_dbus_error (GDBusMethodInvocation *invocation, const gchar *error_name, const gchar *error_message);
```
"""
function g_dbus_method_invocation_return_dbus_error(invocation, error_name, error_message)
    @ccall libaravis.g_dbus_method_invocation_return_dbus_error(invocation::Ptr{GDBusMethodInvocation}, error_name::Ptr{gchar}, error_message::Ptr{gchar})::Cvoid
end

# typedef void ( * GBusAcquiredCallback ) ( GDBusConnection * connection , const gchar * name , gpointer user_data )
"""
[`GBusAcquiredCallback`](@ref): : the connection to a message bus

`: the name that is requested to be owned`

\\_data: user data passed to [func.bus\\_own\\_name]

Invoked when a connection to a message bus has been obtained.

Since: 2.26
"""
const GBusAcquiredCallback = Ptr{Cvoid}

# typedef void ( * GBusNameAcquiredCallback ) ( GDBusConnection * connection , const gchar * name , gpointer user_data )
"""
[`GBusNameAcquiredCallback`](@ref): : the connection on which to acquired the name

`: the name being owned`

\\_data: user data passed to [func.bus\\_own\\_name] or [func.bus\\_own\\_name\\_on\\_connection]

Invoked when the name is acquired.

Since: 2.26
"""
const GBusNameAcquiredCallback = Ptr{Cvoid}

# typedef void ( * GBusNameLostCallback ) ( GDBusConnection * connection , const gchar * name , gpointer user_data )
"""
[`GBusNameLostCallback`](@ref): : the connect on which to acquire the name or `NULL` if the connection was disconnected

`: the name being owned`

\\_data: user data passed to [func.bus\\_own\\_name] or [func.bus\\_own\\_name\\_on\\_connection]

Invoked when the name is lost or  has been closed.

Since: 2.26
"""
const GBusNameLostCallback = Ptr{Cvoid}

"""
    g_bus_own_name(bus_type, name, flags, bus_acquired_handler, name_acquired_handler, name_lost_handler, user_data, user_data_free_func)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint g_bus_own_name (GBusType bus_type, const gchar *name, GBusNameOwnerFlags flags, GBusAcquiredCallback bus_acquired_handler, GBusNameAcquiredCallback name_acquired_handler, GBusNameLostCallback name_lost_handler, gpointer user_data, GDestroyNotify user_data_free_func);
```
"""
function g_bus_own_name(bus_type, name, flags, bus_acquired_handler, name_acquired_handler, name_lost_handler, user_data, user_data_free_func)
    @ccall libaravis.g_bus_own_name(bus_type::GBusType, name::Ptr{gchar}, flags::GBusNameOwnerFlags, bus_acquired_handler::GBusAcquiredCallback, name_acquired_handler::GBusNameAcquiredCallback, name_lost_handler::GBusNameLostCallback, user_data::gpointer, user_data_free_func::GDestroyNotify)::guint
end

"""
    g_bus_own_name_on_connection(connection, name, flags, name_acquired_handler, name_lost_handler, user_data, user_data_free_func)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint g_bus_own_name_on_connection (GDBusConnection *connection, const gchar *name, GBusNameOwnerFlags flags, GBusNameAcquiredCallback name_acquired_handler, GBusNameLostCallback name_lost_handler, gpointer user_data, GDestroyNotify user_data_free_func);
```
"""
function g_bus_own_name_on_connection(connection, name, flags, name_acquired_handler, name_lost_handler, user_data, user_data_free_func)
    @ccall libaravis.g_bus_own_name_on_connection(connection::Ptr{GDBusConnection}, name::Ptr{gchar}, flags::GBusNameOwnerFlags, name_acquired_handler::GBusNameAcquiredCallback, name_lost_handler::GBusNameLostCallback, user_data::gpointer, user_data_free_func::GDestroyNotify)::guint
end

"""
    g_bus_own_name_with_closures(bus_type, name, flags, bus_acquired_closure, name_acquired_closure, name_lost_closure)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint g_bus_own_name_with_closures (GBusType bus_type, const gchar *name, GBusNameOwnerFlags flags, GClosure *bus_acquired_closure, GClosure *name_acquired_closure, GClosure *name_lost_closure);
```
"""
function g_bus_own_name_with_closures(bus_type, name, flags, bus_acquired_closure, name_acquired_closure, name_lost_closure)
    @ccall libaravis.g_bus_own_name_with_closures(bus_type::GBusType, name::Ptr{gchar}, flags::GBusNameOwnerFlags, bus_acquired_closure::Ptr{GClosure}, name_acquired_closure::Ptr{GClosure}, name_lost_closure::Ptr{GClosure})::guint
end

"""
    g_bus_own_name_on_connection_with_closures(connection, name, flags, name_acquired_closure, name_lost_closure)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint g_bus_own_name_on_connection_with_closures ( GDBusConnection *connection, const gchar *name, GBusNameOwnerFlags flags, GClosure *name_acquired_closure, GClosure *name_lost_closure);
```
"""
function g_bus_own_name_on_connection_with_closures(connection, name, flags, name_acquired_closure, name_lost_closure)
    @ccall libaravis.g_bus_own_name_on_connection_with_closures(connection::Ptr{GDBusConnection}, name::Ptr{gchar}, flags::GBusNameOwnerFlags, name_acquired_closure::Ptr{GClosure}, name_lost_closure::Ptr{GClosure})::guint
end

"""
    g_bus_unown_name(owner_id)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_bus_unown_name (guint owner_id);
```
"""
function g_bus_unown_name(owner_id)
    @ccall libaravis.g_bus_unown_name(owner_id::guint)::Cvoid
end

# typedef void ( * GBusNameAppearedCallback ) ( GDBusConnection * connection , const gchar * name , const gchar * name_owner , gpointer user_data )
"""
[`GBusNameAppearedCallback`](@ref): : The #[`GDBusConnection`](@ref) the name is being watched on.

`: The name being watched.`

`_owner: Unique name of the owner of the name being watched.`

\\_data: User data passed to [`g_bus_watch_name`](@ref)().

Invoked when the name being watched is known to have to have an owner.

Since: 2.26
"""
const GBusNameAppearedCallback = Ptr{Cvoid}

# typedef void ( * GBusNameVanishedCallback ) ( GDBusConnection * connection , const gchar * name , gpointer user_data )
"""
[`GBusNameVanishedCallback`](@ref): : The #[`GDBusConnection`](@ref) the name is being watched on, or NULL.

`: The name being watched.`

\\_data: User data passed to [`g_bus_watch_name`](@ref)().

Invoked when the name being watched is known not to have to have an owner.

This is also invoked when the #[`GDBusConnection`](@ref) on which the watch was established has been closed. In that case,  will be NULL.

Since: 2.26
"""
const GBusNameVanishedCallback = Ptr{Cvoid}

"""
    g_bus_watch_name(bus_type, name, flags, name_appeared_handler, name_vanished_handler, user_data, user_data_free_func)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint g_bus_watch_name (GBusType bus_type, const gchar *name, GBusNameWatcherFlags flags, GBusNameAppearedCallback name_appeared_handler, GBusNameVanishedCallback name_vanished_handler, gpointer user_data, GDestroyNotify user_data_free_func);
```
"""
function g_bus_watch_name(bus_type, name, flags, name_appeared_handler, name_vanished_handler, user_data, user_data_free_func)
    @ccall libaravis.g_bus_watch_name(bus_type::GBusType, name::Ptr{gchar}, flags::GBusNameWatcherFlags, name_appeared_handler::GBusNameAppearedCallback, name_vanished_handler::GBusNameVanishedCallback, user_data::gpointer, user_data_free_func::GDestroyNotify)::guint
end

"""
    g_bus_watch_name_on_connection(connection, name, flags, name_appeared_handler, name_vanished_handler, user_data, user_data_free_func)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint g_bus_watch_name_on_connection (GDBusConnection *connection, const gchar *name, GBusNameWatcherFlags flags, GBusNameAppearedCallback name_appeared_handler, GBusNameVanishedCallback name_vanished_handler, gpointer user_data, GDestroyNotify user_data_free_func);
```
"""
function g_bus_watch_name_on_connection(connection, name, flags, name_appeared_handler, name_vanished_handler, user_data, user_data_free_func)
    @ccall libaravis.g_bus_watch_name_on_connection(connection::Ptr{GDBusConnection}, name::Ptr{gchar}, flags::GBusNameWatcherFlags, name_appeared_handler::GBusNameAppearedCallback, name_vanished_handler::GBusNameVanishedCallback, user_data::gpointer, user_data_free_func::GDestroyNotify)::guint
end

"""
    g_bus_watch_name_with_closures(bus_type, name, flags, name_appeared_closure, name_vanished_closure)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint g_bus_watch_name_with_closures (GBusType bus_type, const gchar *name, GBusNameWatcherFlags flags, GClosure *name_appeared_closure, GClosure *name_vanished_closure);
```
"""
function g_bus_watch_name_with_closures(bus_type, name, flags, name_appeared_closure, name_vanished_closure)
    @ccall libaravis.g_bus_watch_name_with_closures(bus_type::GBusType, name::Ptr{gchar}, flags::GBusNameWatcherFlags, name_appeared_closure::Ptr{GClosure}, name_vanished_closure::Ptr{GClosure})::guint
end

"""
    g_bus_watch_name_on_connection_with_closures(connection, name, flags, name_appeared_closure, name_vanished_closure)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint g_bus_watch_name_on_connection_with_closures ( GDBusConnection *connection, const gchar *name, GBusNameWatcherFlags flags, GClosure *name_appeared_closure, GClosure *name_vanished_closure);
```
"""
function g_bus_watch_name_on_connection_with_closures(connection, name, flags, name_appeared_closure, name_vanished_closure)
    @ccall libaravis.g_bus_watch_name_on_connection_with_closures(connection::Ptr{GDBusConnection}, name::Ptr{gchar}, flags::GBusNameWatcherFlags, name_appeared_closure::Ptr{GClosure}, name_vanished_closure::Ptr{GClosure})::guint
end

"""
    g_bus_unwatch_name(watcher_id)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_bus_unwatch_name (guint watcher_id);
```
"""
function g_bus_unwatch_name(watcher_id)
    @ccall libaravis.g_bus_unwatch_name(watcher_id::guint)::Cvoid
end

"""
    g_dbus_object_get_object_path(object)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_dbus_object_get_object_path (GDBusObject *object);
```
"""
function g_dbus_object_get_object_path(object)
    @ccall libaravis.g_dbus_object_get_object_path(object::Ptr{GDBusObject})::Ptr{gchar}
end

"""
    g_dbus_object_get_interfaces(object)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GList *g_dbus_object_get_interfaces (GDBusObject *object);
```
"""
function g_dbus_object_get_interfaces(object)
    @ccall libaravis.g_dbus_object_get_interfaces(object::Ptr{GDBusObject})::Ptr{GList}
end

"""
    g_dbus_object_get_interface(object, interface_name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusInterface *g_dbus_object_get_interface (GDBusObject *object, const gchar *interface_name);
```
"""
function g_dbus_object_get_interface(object, interface_name)
    @ccall libaravis.g_dbus_object_get_interface(object::Ptr{GDBusObject}, interface_name::Ptr{gchar})::Ptr{GDBusInterface}
end

"""
    g_dbus_object_manager_get_object_path(manager)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_dbus_object_manager_get_object_path (GDBusObjectManager *manager);
```
"""
function g_dbus_object_manager_get_object_path(manager)
    @ccall libaravis.g_dbus_object_manager_get_object_path(manager::Ptr{GDBusObjectManager})::Ptr{gchar}
end

"""
    g_dbus_object_manager_get_objects(manager)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GList *g_dbus_object_manager_get_objects (GDBusObjectManager *manager);
```
"""
function g_dbus_object_manager_get_objects(manager)
    @ccall libaravis.g_dbus_object_manager_get_objects(manager::Ptr{GDBusObjectManager})::Ptr{GList}
end

"""
    g_dbus_object_manager_get_object(manager, object_path)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusObject *g_dbus_object_manager_get_object (GDBusObjectManager *manager, const gchar *object_path);
```
"""
function g_dbus_object_manager_get_object(manager, object_path)
    @ccall libaravis.g_dbus_object_manager_get_object(manager::Ptr{GDBusObjectManager}, object_path::Ptr{gchar})::Ptr{GDBusObject}
end

"""
    g_dbus_object_manager_get_interface(manager, object_path, interface_name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusInterface *g_dbus_object_manager_get_interface (GDBusObjectManager *manager, const gchar *object_path, const gchar *interface_name);
```
"""
function g_dbus_object_manager_get_interface(manager, object_path, interface_name)
    @ccall libaravis.g_dbus_object_manager_get_interface(manager::Ptr{GDBusObjectManager}, object_path::Ptr{gchar}, interface_name::Ptr{gchar})::Ptr{GDBusInterface}
end

"""
    g_dbus_object_manager_client_new(connection, flags, name, object_path, get_proxy_type_func, get_proxy_type_user_data, get_proxy_type_destroy_notify, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_object_manager_client_new (GDBusConnection *connection, GDBusObjectManagerClientFlags flags, const gchar *name, const gchar *object_path, GDBusProxyTypeFunc get_proxy_type_func, gpointer get_proxy_type_user_data, GDestroyNotify get_proxy_type_destroy_notify, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_dbus_object_manager_client_new(connection, flags, name, object_path, get_proxy_type_func, get_proxy_type_user_data, get_proxy_type_destroy_notify, cancellable, callback, user_data)
    @ccall libaravis.g_dbus_object_manager_client_new(connection::Ptr{GDBusConnection}, flags::GDBusObjectManagerClientFlags, name::Ptr{gchar}, object_path::Ptr{gchar}, get_proxy_type_func::GDBusProxyTypeFunc, get_proxy_type_user_data::gpointer, get_proxy_type_destroy_notify::GDestroyNotify, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_dbus_object_manager_client_new_finish(res, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusObjectManager *g_dbus_object_manager_client_new_finish (GAsyncResult *res, GError **error);
```
"""
function g_dbus_object_manager_client_new_finish(res, error)
    @ccall libaravis.g_dbus_object_manager_client_new_finish(res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GDBusObjectManager}
end

"""
    g_dbus_object_manager_client_new_sync(connection, flags, name, object_path, get_proxy_type_func, get_proxy_type_user_data, get_proxy_type_destroy_notify, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusObjectManager *g_dbus_object_manager_client_new_sync (GDBusConnection *connection, GDBusObjectManagerClientFlags flags, const gchar *name, const gchar *object_path, GDBusProxyTypeFunc get_proxy_type_func, gpointer get_proxy_type_user_data, GDestroyNotify get_proxy_type_destroy_notify, GCancellable *cancellable, GError **error);
```
"""
function g_dbus_object_manager_client_new_sync(connection, flags, name, object_path, get_proxy_type_func, get_proxy_type_user_data, get_proxy_type_destroy_notify, cancellable, error)
    @ccall libaravis.g_dbus_object_manager_client_new_sync(connection::Ptr{GDBusConnection}, flags::GDBusObjectManagerClientFlags, name::Ptr{gchar}, object_path::Ptr{gchar}, get_proxy_type_func::GDBusProxyTypeFunc, get_proxy_type_user_data::gpointer, get_proxy_type_destroy_notify::GDestroyNotify, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GDBusObjectManager}
end

"""
    g_dbus_object_manager_client_new_for_bus(bus_type, flags, name, object_path, get_proxy_type_func, get_proxy_type_user_data, get_proxy_type_destroy_notify, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_object_manager_client_new_for_bus (GBusType bus_type, GDBusObjectManagerClientFlags flags, const gchar *name, const gchar *object_path, GDBusProxyTypeFunc get_proxy_type_func, gpointer get_proxy_type_user_data, GDestroyNotify get_proxy_type_destroy_notify, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_dbus_object_manager_client_new_for_bus(bus_type, flags, name, object_path, get_proxy_type_func, get_proxy_type_user_data, get_proxy_type_destroy_notify, cancellable, callback, user_data)
    @ccall libaravis.g_dbus_object_manager_client_new_for_bus(bus_type::GBusType, flags::GDBusObjectManagerClientFlags, name::Ptr{gchar}, object_path::Ptr{gchar}, get_proxy_type_func::GDBusProxyTypeFunc, get_proxy_type_user_data::gpointer, get_proxy_type_destroy_notify::GDestroyNotify, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_dbus_object_manager_client_new_for_bus_finish(res, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusObjectManager *g_dbus_object_manager_client_new_for_bus_finish (GAsyncResult *res, GError **error);
```
"""
function g_dbus_object_manager_client_new_for_bus_finish(res, error)
    @ccall libaravis.g_dbus_object_manager_client_new_for_bus_finish(res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GDBusObjectManager}
end

"""
    g_dbus_object_manager_client_new_for_bus_sync(bus_type, flags, name, object_path, get_proxy_type_func, get_proxy_type_user_data, get_proxy_type_destroy_notify, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusObjectManager *g_dbus_object_manager_client_new_for_bus_sync (GBusType bus_type, GDBusObjectManagerClientFlags flags, const gchar *name, const gchar *object_path, GDBusProxyTypeFunc get_proxy_type_func, gpointer get_proxy_type_user_data, GDestroyNotify get_proxy_type_destroy_notify, GCancellable *cancellable, GError **error);
```
"""
function g_dbus_object_manager_client_new_for_bus_sync(bus_type, flags, name, object_path, get_proxy_type_func, get_proxy_type_user_data, get_proxy_type_destroy_notify, cancellable, error)
    @ccall libaravis.g_dbus_object_manager_client_new_for_bus_sync(bus_type::GBusType, flags::GDBusObjectManagerClientFlags, name::Ptr{gchar}, object_path::Ptr{gchar}, get_proxy_type_func::GDBusProxyTypeFunc, get_proxy_type_user_data::gpointer, get_proxy_type_destroy_notify::GDestroyNotify, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GDBusObjectManager}
end

"""
    g_dbus_object_manager_client_get_connection(manager)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusConnection *g_dbus_object_manager_client_get_connection (GDBusObjectManagerClient *manager);
```
"""
function g_dbus_object_manager_client_get_connection(manager)
    @ccall libaravis.g_dbus_object_manager_client_get_connection(manager::Ptr{GDBusObjectManagerClient})::Ptr{GDBusConnection}
end

"""
    g_dbus_object_manager_client_get_flags(manager)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusObjectManagerClientFlags g_dbus_object_manager_client_get_flags (GDBusObjectManagerClient *manager);
```
"""
function g_dbus_object_manager_client_get_flags(manager)
    @ccall libaravis.g_dbus_object_manager_client_get_flags(manager::Ptr{GDBusObjectManagerClient})::GDBusObjectManagerClientFlags
end

"""
    g_dbus_object_manager_client_get_name(manager)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_dbus_object_manager_client_get_name (GDBusObjectManagerClient *manager);
```
"""
function g_dbus_object_manager_client_get_name(manager)
    @ccall libaravis.g_dbus_object_manager_client_get_name(manager::Ptr{GDBusObjectManagerClient})::Ptr{gchar}
end

"""
    g_dbus_object_manager_client_get_name_owner(manager)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gchar *g_dbus_object_manager_client_get_name_owner (GDBusObjectManagerClient *manager);
```
"""
function g_dbus_object_manager_client_get_name_owner(manager)
    @ccall libaravis.g_dbus_object_manager_client_get_name_owner(manager::Ptr{GDBusObjectManagerClient})::Ptr{gchar}
end

"""
    g_dbus_object_manager_server_new(object_path)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusObjectManagerServer *g_dbus_object_manager_server_new (const gchar *object_path);
```
"""
function g_dbus_object_manager_server_new(object_path)
    @ccall libaravis.g_dbus_object_manager_server_new(object_path::Ptr{gchar})::Ptr{GDBusObjectManagerServer}
end

"""
    g_dbus_object_manager_server_get_connection(manager)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusConnection *g_dbus_object_manager_server_get_connection (GDBusObjectManagerServer *manager);
```
"""
function g_dbus_object_manager_server_get_connection(manager)
    @ccall libaravis.g_dbus_object_manager_server_get_connection(manager::Ptr{GDBusObjectManagerServer})::Ptr{GDBusConnection}
end

"""
    g_dbus_object_manager_server_set_connection(manager, connection)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_object_manager_server_set_connection (GDBusObjectManagerServer *manager, GDBusConnection *connection);
```
"""
function g_dbus_object_manager_server_set_connection(manager, connection)
    @ccall libaravis.g_dbus_object_manager_server_set_connection(manager::Ptr{GDBusObjectManagerServer}, connection::Ptr{GDBusConnection})::Cvoid
end

"""
    g_dbus_object_manager_server_export(manager, object)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_object_manager_server_export (GDBusObjectManagerServer *manager, GDBusObjectSkeleton *object);
```
"""
function g_dbus_object_manager_server_export(manager, object)
    @ccall libaravis.g_dbus_object_manager_server_export(manager::Ptr{GDBusObjectManagerServer}, object::Ptr{GDBusObjectSkeleton})::Cvoid
end

"""
    g_dbus_object_manager_server_export_uniquely(manager, object)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_object_manager_server_export_uniquely (GDBusObjectManagerServer *manager, GDBusObjectSkeleton *object);
```
"""
function g_dbus_object_manager_server_export_uniquely(manager, object)
    @ccall libaravis.g_dbus_object_manager_server_export_uniquely(manager::Ptr{GDBusObjectManagerServer}, object::Ptr{GDBusObjectSkeleton})::Cvoid
end

"""
    g_dbus_object_manager_server_is_exported(manager, object)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_dbus_object_manager_server_is_exported (GDBusObjectManagerServer *manager, GDBusObjectSkeleton *object);
```
"""
function g_dbus_object_manager_server_is_exported(manager, object)
    @ccall libaravis.g_dbus_object_manager_server_is_exported(manager::Ptr{GDBusObjectManagerServer}, object::Ptr{GDBusObjectSkeleton})::gboolean
end

"""
    g_dbus_object_manager_server_unexport(manager, object_path)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_dbus_object_manager_server_unexport (GDBusObjectManagerServer *manager, const gchar *object_path);
```
"""
function g_dbus_object_manager_server_unexport(manager, object_path)
    @ccall libaravis.g_dbus_object_manager_server_unexport(manager::Ptr{GDBusObjectManagerServer}, object_path::Ptr{gchar})::gboolean
end

"""
    g_dbus_object_proxy_new(connection, object_path)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusObjectProxy *g_dbus_object_proxy_new (GDBusConnection *connection, const gchar *object_path);
```
"""
function g_dbus_object_proxy_new(connection, object_path)
    @ccall libaravis.g_dbus_object_proxy_new(connection::Ptr{GDBusConnection}, object_path::Ptr{gchar})::Ptr{GDBusObjectProxy}
end

"""
    g_dbus_object_proxy_get_connection(proxy)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusConnection *g_dbus_object_proxy_get_connection (GDBusObjectProxy *proxy);
```
"""
function g_dbus_object_proxy_get_connection(proxy)
    @ccall libaravis.g_dbus_object_proxy_get_connection(proxy::Ptr{GDBusObjectProxy})::Ptr{GDBusConnection}
end

"""
    g_dbus_object_skeleton_new(object_path)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusObjectSkeleton *g_dbus_object_skeleton_new (const gchar *object_path);
```
"""
function g_dbus_object_skeleton_new(object_path)
    @ccall libaravis.g_dbus_object_skeleton_new(object_path::Ptr{gchar})::Ptr{GDBusObjectSkeleton}
end

"""
    g_dbus_object_skeleton_flush(object)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_object_skeleton_flush (GDBusObjectSkeleton *object);
```
"""
function g_dbus_object_skeleton_flush(object)
    @ccall libaravis.g_dbus_object_skeleton_flush(object::Ptr{GDBusObjectSkeleton})::Cvoid
end

"""
    g_dbus_object_skeleton_add_interface(object, interface_)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_object_skeleton_add_interface (GDBusObjectSkeleton *object, GDBusInterfaceSkeleton *interface_);
```
"""
function g_dbus_object_skeleton_add_interface(object, interface_)
    @ccall libaravis.g_dbus_object_skeleton_add_interface(object::Ptr{GDBusObjectSkeleton}, interface_::Ptr{GDBusInterfaceSkeleton})::Cvoid
end

"""
    g_dbus_object_skeleton_remove_interface(object, interface_)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_object_skeleton_remove_interface (GDBusObjectSkeleton *object, GDBusInterfaceSkeleton *interface_);
```
"""
function g_dbus_object_skeleton_remove_interface(object, interface_)
    @ccall libaravis.g_dbus_object_skeleton_remove_interface(object::Ptr{GDBusObjectSkeleton}, interface_::Ptr{GDBusInterfaceSkeleton})::Cvoid
end

"""
    g_dbus_object_skeleton_remove_interface_by_name(object, interface_name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_object_skeleton_remove_interface_by_name (GDBusObjectSkeleton *object, const gchar *interface_name);
```
"""
function g_dbus_object_skeleton_remove_interface_by_name(object, interface_name)
    @ccall libaravis.g_dbus_object_skeleton_remove_interface_by_name(object::Ptr{GDBusObjectSkeleton}, interface_name::Ptr{gchar})::Cvoid
end

"""
    g_dbus_object_skeleton_set_object_path(object, object_path)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_object_skeleton_set_object_path (GDBusObjectSkeleton *object, const gchar *object_path);
```
"""
function g_dbus_object_skeleton_set_object_path(object, object_path)
    @ccall libaravis.g_dbus_object_skeleton_set_object_path(object::Ptr{GDBusObjectSkeleton}, object_path::Ptr{gchar})::Cvoid
end

"""
    g_dbus_proxy_new(connection, flags, info, name, object_path, interface_name, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_proxy_new (GDBusConnection *connection, GDBusProxyFlags flags, GDBusInterfaceInfo *info, const gchar *name, const gchar *object_path, const gchar *interface_name, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_dbus_proxy_new(connection, flags, info, name, object_path, interface_name, cancellable, callback, user_data)
    @ccall libaravis.g_dbus_proxy_new(connection::Ptr{GDBusConnection}, flags::GDBusProxyFlags, info::Ptr{GDBusInterfaceInfo}, name::Ptr{gchar}, object_path::Ptr{gchar}, interface_name::Ptr{gchar}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_dbus_proxy_new_finish(res, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusProxy *g_dbus_proxy_new_finish (GAsyncResult *res, GError **error);
```
"""
function g_dbus_proxy_new_finish(res, error)
    @ccall libaravis.g_dbus_proxy_new_finish(res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GDBusProxy}
end

"""
    g_dbus_proxy_new_sync(connection, flags, info, name, object_path, interface_name, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusProxy *g_dbus_proxy_new_sync (GDBusConnection *connection, GDBusProxyFlags flags, GDBusInterfaceInfo *info, const gchar *name, const gchar *object_path, const gchar *interface_name, GCancellable *cancellable, GError **error);
```
"""
function g_dbus_proxy_new_sync(connection, flags, info, name, object_path, interface_name, cancellable, error)
    @ccall libaravis.g_dbus_proxy_new_sync(connection::Ptr{GDBusConnection}, flags::GDBusProxyFlags, info::Ptr{GDBusInterfaceInfo}, name::Ptr{gchar}, object_path::Ptr{gchar}, interface_name::Ptr{gchar}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GDBusProxy}
end

"""
    g_dbus_proxy_new_for_bus(bus_type, flags, info, name, object_path, interface_name, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_proxy_new_for_bus (GBusType bus_type, GDBusProxyFlags flags, GDBusInterfaceInfo *info, const gchar *name, const gchar *object_path, const gchar *interface_name, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_dbus_proxy_new_for_bus(bus_type, flags, info, name, object_path, interface_name, cancellable, callback, user_data)
    @ccall libaravis.g_dbus_proxy_new_for_bus(bus_type::GBusType, flags::GDBusProxyFlags, info::Ptr{GDBusInterfaceInfo}, name::Ptr{gchar}, object_path::Ptr{gchar}, interface_name::Ptr{gchar}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_dbus_proxy_new_for_bus_finish(res, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusProxy *g_dbus_proxy_new_for_bus_finish (GAsyncResult *res, GError **error);
```
"""
function g_dbus_proxy_new_for_bus_finish(res, error)
    @ccall libaravis.g_dbus_proxy_new_for_bus_finish(res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GDBusProxy}
end

"""
    g_dbus_proxy_new_for_bus_sync(bus_type, flags, info, name, object_path, interface_name, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusProxy *g_dbus_proxy_new_for_bus_sync (GBusType bus_type, GDBusProxyFlags flags, GDBusInterfaceInfo *info, const gchar *name, const gchar *object_path, const gchar *interface_name, GCancellable *cancellable, GError **error);
```
"""
function g_dbus_proxy_new_for_bus_sync(bus_type, flags, info, name, object_path, interface_name, cancellable, error)
    @ccall libaravis.g_dbus_proxy_new_for_bus_sync(bus_type::GBusType, flags::GDBusProxyFlags, info::Ptr{GDBusInterfaceInfo}, name::Ptr{gchar}, object_path::Ptr{gchar}, interface_name::Ptr{gchar}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GDBusProxy}
end

"""
    g_dbus_proxy_get_connection(proxy)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusConnection *g_dbus_proxy_get_connection (GDBusProxy *proxy);
```
"""
function g_dbus_proxy_get_connection(proxy)
    @ccall libaravis.g_dbus_proxy_get_connection(proxy::Ptr{GDBusProxy})::Ptr{GDBusConnection}
end

"""
    g_dbus_proxy_get_flags(proxy)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusProxyFlags g_dbus_proxy_get_flags (GDBusProxy *proxy);
```
"""
function g_dbus_proxy_get_flags(proxy)
    @ccall libaravis.g_dbus_proxy_get_flags(proxy::Ptr{GDBusProxy})::GDBusProxyFlags
end

"""
    g_dbus_proxy_get_name(proxy)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_dbus_proxy_get_name (GDBusProxy *proxy);
```
"""
function g_dbus_proxy_get_name(proxy)
    @ccall libaravis.g_dbus_proxy_get_name(proxy::Ptr{GDBusProxy})::Ptr{gchar}
end

"""
    g_dbus_proxy_get_name_owner(proxy)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gchar *g_dbus_proxy_get_name_owner (GDBusProxy *proxy);
```
"""
function g_dbus_proxy_get_name_owner(proxy)
    @ccall libaravis.g_dbus_proxy_get_name_owner(proxy::Ptr{GDBusProxy})::Ptr{gchar}
end

"""
    g_dbus_proxy_get_object_path(proxy)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_dbus_proxy_get_object_path (GDBusProxy *proxy);
```
"""
function g_dbus_proxy_get_object_path(proxy)
    @ccall libaravis.g_dbus_proxy_get_object_path(proxy::Ptr{GDBusProxy})::Ptr{gchar}
end

"""
    g_dbus_proxy_get_interface_name(proxy)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_dbus_proxy_get_interface_name (GDBusProxy *proxy);
```
"""
function g_dbus_proxy_get_interface_name(proxy)
    @ccall libaravis.g_dbus_proxy_get_interface_name(proxy::Ptr{GDBusProxy})::Ptr{gchar}
end

"""
    g_dbus_proxy_get_default_timeout(proxy)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gint g_dbus_proxy_get_default_timeout (GDBusProxy *proxy);
```
"""
function g_dbus_proxy_get_default_timeout(proxy)
    @ccall libaravis.g_dbus_proxy_get_default_timeout(proxy::Ptr{GDBusProxy})::gint
end

"""
    g_dbus_proxy_set_default_timeout(proxy, timeout_msec)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_proxy_set_default_timeout (GDBusProxy *proxy, gint timeout_msec);
```
"""
function g_dbus_proxy_set_default_timeout(proxy, timeout_msec)
    @ccall libaravis.g_dbus_proxy_set_default_timeout(proxy::Ptr{GDBusProxy}, timeout_msec::gint)::Cvoid
end

"""
    g_dbus_proxy_get_interface_info(proxy)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusInterfaceInfo *g_dbus_proxy_get_interface_info (GDBusProxy *proxy);
```
"""
function g_dbus_proxy_get_interface_info(proxy)
    @ccall libaravis.g_dbus_proxy_get_interface_info(proxy::Ptr{GDBusProxy})::Ptr{GDBusInterfaceInfo}
end

"""
    g_dbus_proxy_set_interface_info(proxy, info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_proxy_set_interface_info (GDBusProxy *proxy, GDBusInterfaceInfo *info);
```
"""
function g_dbus_proxy_set_interface_info(proxy, info)
    @ccall libaravis.g_dbus_proxy_set_interface_info(proxy::Ptr{GDBusProxy}, info::Ptr{GDBusInterfaceInfo})::Cvoid
end

"""
    g_dbus_proxy_get_cached_property(proxy, property_name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GVariant *g_dbus_proxy_get_cached_property (GDBusProxy *proxy, const gchar *property_name);
```
"""
function g_dbus_proxy_get_cached_property(proxy, property_name)
    @ccall libaravis.g_dbus_proxy_get_cached_property(proxy::Ptr{GDBusProxy}, property_name::Ptr{gchar})::Ptr{GVariant}
end

"""
    g_dbus_proxy_set_cached_property(proxy, property_name, value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_proxy_set_cached_property (GDBusProxy *proxy, const gchar *property_name, GVariant *value);
```
"""
function g_dbus_proxy_set_cached_property(proxy, property_name, value)
    @ccall libaravis.g_dbus_proxy_set_cached_property(proxy::Ptr{GDBusProxy}, property_name::Ptr{gchar}, value::Ptr{GVariant})::Cvoid
end

"""
    g_dbus_proxy_get_cached_property_names(proxy)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gchar **g_dbus_proxy_get_cached_property_names (GDBusProxy *proxy);
```
"""
function g_dbus_proxy_get_cached_property_names(proxy)
    @ccall libaravis.g_dbus_proxy_get_cached_property_names(proxy::Ptr{GDBusProxy})::Ptr{Ptr{gchar}}
end

"""
    g_dbus_proxy_call(proxy, method_name, parameters, flags, timeout_msec, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_proxy_call (GDBusProxy *proxy, const gchar *method_name, GVariant *parameters, GDBusCallFlags flags, gint timeout_msec, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_dbus_proxy_call(proxy, method_name, parameters, flags, timeout_msec, cancellable, callback, user_data)
    @ccall libaravis.g_dbus_proxy_call(proxy::Ptr{GDBusProxy}, method_name::Ptr{gchar}, parameters::Ptr{GVariant}, flags::GDBusCallFlags, timeout_msec::gint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_dbus_proxy_call_finish(proxy, res, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GVariant *g_dbus_proxy_call_finish (GDBusProxy *proxy, GAsyncResult *res, GError **error);
```
"""
function g_dbus_proxy_call_finish(proxy, res, error)
    @ccall libaravis.g_dbus_proxy_call_finish(proxy::Ptr{GDBusProxy}, res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GVariant}
end

"""
    g_dbus_proxy_call_sync(proxy, method_name, parameters, flags, timeout_msec, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GVariant *g_dbus_proxy_call_sync (GDBusProxy *proxy, const gchar *method_name, GVariant *parameters, GDBusCallFlags flags, gint timeout_msec, GCancellable *cancellable, GError **error);
```
"""
function g_dbus_proxy_call_sync(proxy, method_name, parameters, flags, timeout_msec, cancellable, error)
    @ccall libaravis.g_dbus_proxy_call_sync(proxy::Ptr{GDBusProxy}, method_name::Ptr{gchar}, parameters::Ptr{GVariant}, flags::GDBusCallFlags, timeout_msec::gint, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GVariant}
end

"""
    g_dbus_proxy_call_with_unix_fd_list(proxy, method_name, parameters, flags, timeout_msec, fd_list, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_proxy_call_with_unix_fd_list (GDBusProxy *proxy, const gchar *method_name, GVariant *parameters, GDBusCallFlags flags, gint timeout_msec, GUnixFDList *fd_list, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_dbus_proxy_call_with_unix_fd_list(proxy, method_name, parameters, flags, timeout_msec, fd_list, cancellable, callback, user_data)
    @ccall libaravis.g_dbus_proxy_call_with_unix_fd_list(proxy::Ptr{GDBusProxy}, method_name::Ptr{gchar}, parameters::Ptr{GVariant}, flags::GDBusCallFlags, timeout_msec::gint, fd_list::Ptr{GUnixFDList}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_dbus_proxy_call_with_unix_fd_list_finish(proxy, out_fd_list, res, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GVariant *g_dbus_proxy_call_with_unix_fd_list_finish (GDBusProxy *proxy, GUnixFDList **out_fd_list, GAsyncResult *res, GError **error);
```
"""
function g_dbus_proxy_call_with_unix_fd_list_finish(proxy, out_fd_list, res, error)
    @ccall libaravis.g_dbus_proxy_call_with_unix_fd_list_finish(proxy::Ptr{GDBusProxy}, out_fd_list::Ptr{Ptr{GUnixFDList}}, res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GVariant}
end

"""
    g_dbus_proxy_call_with_unix_fd_list_sync(proxy, method_name, parameters, flags, timeout_msec, fd_list, out_fd_list, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GVariant *g_dbus_proxy_call_with_unix_fd_list_sync (GDBusProxy *proxy, const gchar *method_name, GVariant *parameters, GDBusCallFlags flags, gint timeout_msec, GUnixFDList *fd_list, GUnixFDList **out_fd_list, GCancellable *cancellable, GError **error);
```
"""
function g_dbus_proxy_call_with_unix_fd_list_sync(proxy, method_name, parameters, flags, timeout_msec, fd_list, out_fd_list, cancellable, error)
    @ccall libaravis.g_dbus_proxy_call_with_unix_fd_list_sync(proxy::Ptr{GDBusProxy}, method_name::Ptr{gchar}, parameters::Ptr{GVariant}, flags::GDBusCallFlags, timeout_msec::gint, fd_list::Ptr{GUnixFDList}, out_fd_list::Ptr{Ptr{GUnixFDList}}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GVariant}
end

"""
    g_dbus_server_new_sync(address, flags, guid, observer, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusServer *g_dbus_server_new_sync (const gchar *address, GDBusServerFlags flags, const gchar *guid, GDBusAuthObserver *observer, GCancellable *cancellable, GError **error);
```
"""
function g_dbus_server_new_sync(address, flags, guid, observer, cancellable, error)
    @ccall libaravis.g_dbus_server_new_sync(address::Ptr{gchar}, flags::GDBusServerFlags, guid::Ptr{gchar}, observer::Ptr{GDBusAuthObserver}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GDBusServer}
end

"""
    g_dbus_server_get_client_address(server)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_dbus_server_get_client_address (GDBusServer *server);
```
"""
function g_dbus_server_get_client_address(server)
    @ccall libaravis.g_dbus_server_get_client_address(server::Ptr{GDBusServer})::Ptr{gchar}
end

"""
    g_dbus_server_get_guid(server)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_dbus_server_get_guid (GDBusServer *server);
```
"""
function g_dbus_server_get_guid(server)
    @ccall libaravis.g_dbus_server_get_guid(server::Ptr{GDBusServer})::Ptr{gchar}
end

"""
    g_dbus_server_get_flags(server)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDBusServerFlags g_dbus_server_get_flags (GDBusServer *server);
```
"""
function g_dbus_server_get_flags(server)
    @ccall libaravis.g_dbus_server_get_flags(server::Ptr{GDBusServer})::GDBusServerFlags
end

"""
    g_dbus_server_start(server)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_server_start (GDBusServer *server);
```
"""
function g_dbus_server_start(server)
    @ccall libaravis.g_dbus_server_start(server::Ptr{GDBusServer})::Cvoid
end

"""
    g_dbus_server_stop(server)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_server_stop (GDBusServer *server);
```
"""
function g_dbus_server_stop(server)
    @ccall libaravis.g_dbus_server_stop(server::Ptr{GDBusServer})::Cvoid
end

"""
    g_dbus_server_is_active(server)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_dbus_server_is_active (GDBusServer *server);
```
"""
function g_dbus_server_is_active(server)
    @ccall libaravis.g_dbus_server_is_active(server::Ptr{GDBusServer})::gboolean
end

"""
    g_dbus_is_guid(string)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_dbus_is_guid (const gchar *string);
```
"""
function g_dbus_is_guid(string)
    @ccall libaravis.g_dbus_is_guid(string::Ptr{gchar})::gboolean
end

"""
    g_dbus_generate_guid()

### Prototype
```c
GIO_AVAILABLE_IN_ALL gchar *g_dbus_generate_guid (void);
```
"""
function g_dbus_generate_guid()
    @ccall libaravis.g_dbus_generate_guid()::Ptr{gchar}
end

"""
    g_dbus_is_name(string)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_dbus_is_name (const gchar *string);
```
"""
function g_dbus_is_name(string)
    @ccall libaravis.g_dbus_is_name(string::Ptr{gchar})::gboolean
end

"""
    g_dbus_is_unique_name(string)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_dbus_is_unique_name (const gchar *string);
```
"""
function g_dbus_is_unique_name(string)
    @ccall libaravis.g_dbus_is_unique_name(string::Ptr{gchar})::gboolean
end

"""
    g_dbus_is_member_name(string)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_dbus_is_member_name (const gchar *string);
```
"""
function g_dbus_is_member_name(string)
    @ccall libaravis.g_dbus_is_member_name(string::Ptr{gchar})::gboolean
end

"""
    g_dbus_is_interface_name(string)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_dbus_is_interface_name (const gchar *string);
```
"""
function g_dbus_is_interface_name(string)
    @ccall libaravis.g_dbus_is_interface_name(string::Ptr{gchar})::gboolean
end

"""
    g_dbus_is_error_name(string)

### Prototype
```c
GIO_AVAILABLE_IN_2_70 gboolean g_dbus_is_error_name (const gchar *string);
```
"""
function g_dbus_is_error_name(string)
    @ccall libaravis.g_dbus_is_error_name(string::Ptr{gchar})::gboolean
end

"""
    g_dbus_gvariant_to_gvalue(value, out_gvalue)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_dbus_gvariant_to_gvalue (GVariant *value, GValue *out_gvalue);
```
"""
function g_dbus_gvariant_to_gvalue(value, out_gvalue)
    @ccall libaravis.g_dbus_gvariant_to_gvalue(value::Ptr{GVariant}, out_gvalue::Ptr{GValue})::Cvoid
end

"""
    g_dbus_gvalue_to_gvariant(gvalue, type)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GVariant *g_dbus_gvalue_to_gvariant (const GValue *gvalue, const GVariantType *type);
```
"""
function g_dbus_gvalue_to_gvariant(gvalue, type)
    @ccall libaravis.g_dbus_gvalue_to_gvariant(gvalue::Ptr{GValue}, type::Ptr{GVariantType})::Ptr{GVariant}
end

"""
    g_dbus_escape_object_path_bytestring(bytes)

### Prototype
```c
GIO_AVAILABLE_IN_2_68 gchar *g_dbus_escape_object_path_bytestring (const guint8 *bytes);
```
"""
function g_dbus_escape_object_path_bytestring(bytes)
    @ccall libaravis.g_dbus_escape_object_path_bytestring(bytes::Ptr{guint8})::Ptr{gchar}
end

"""
    g_dbus_escape_object_path(s)

### Prototype
```c
GIO_AVAILABLE_IN_2_68 gchar *g_dbus_escape_object_path (const gchar *s);
```
"""
function g_dbus_escape_object_path(s)
    @ccall libaravis.g_dbus_escape_object_path(s::Ptr{gchar})::Ptr{gchar}
end

"""
    g_dbus_unescape_object_path(s)

### Prototype
```c
GIO_AVAILABLE_IN_2_68 guint8 *g_dbus_unescape_object_path (const gchar *s);
```
"""
function g_dbus_unescape_object_path(s)
    @ccall libaravis.g_dbus_unescape_object_path(s::Ptr{gchar})::Ptr{guint8}
end

const GDebugController_autoptr = Ptr{GDebugController}

const GDebugController_listautoptr = Ptr{GList}

const GDebugController_slistautoptr = Ptr{GSList}

const GDebugController_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GDebugController(_ptr)

### Prototype
```c
G_DECLARE_INTERFACE(GDebugController, g_debug_controller, g, debug_controller, GObject);
```
"""
function glib_autoptr_clear_GDebugController(_ptr)
    @ccall libaravis.glib_autoptr_clear_GDebugController(_ptr::Ptr{GDebugController})::Cvoid
end

"""
    glib_autoptr_cleanup_GDebugController(_ptr)

### Prototype
```c
G_DECLARE_INTERFACE(GDebugController, g_debug_controller, g, debug_controller, GObject);
```
"""
function glib_autoptr_cleanup_GDebugController(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GDebugController(_ptr::Ptr{Ptr{GDebugController}})::Cvoid
end

"""
    glib_autoptr_destroy_GDebugController(_ptr)

### Prototype
```c
G_DECLARE_INTERFACE(GDebugController, g_debug_controller, g, debug_controller, GObject);
```
"""
function glib_autoptr_destroy_GDebugController(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GDebugController(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GDebugController(_l)

### Prototype
```c
G_DECLARE_INTERFACE(GDebugController, g_debug_controller, g, debug_controller, GObject);
```
"""
function glib_listautoptr_cleanup_GDebugController(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GDebugController(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GDebugController(_l)

### Prototype
```c
G_DECLARE_INTERFACE(GDebugController, g_debug_controller, g, debug_controller, GObject);
```
"""
function glib_slistautoptr_cleanup_GDebugController(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GDebugController(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GDebugController(_q)

### Prototype
```c
G_DECLARE_INTERFACE(GDebugController, g_debug_controller, g, debug_controller, GObject);
```
"""
function glib_queueautoptr_cleanup_GDebugController(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GDebugController(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    g_debug_controller(ptr)

### Prototype
```c
G_DECLARE_INTERFACE(GDebugController, g_debug_controller, g, debug_controller, GObject);
```
"""
function g_debug_controller(ptr)
    @ccall libaravis.g_debug_controller(ptr::gpointer)::Ptr{GDebugController}
end

"""
    g_IS_debug_controller(ptr)

### Prototype
```c
G_DECLARE_INTERFACE(GDebugController, g_debug_controller, g, debug_controller, GObject);
```
"""
function g_IS_debug_controller(ptr)
    @ccall libaravis.g_IS_debug_controller(ptr::gpointer)::gboolean
end

"""
    g_debug_controller_GET_IFACE(ptr)

### Prototype
```c
G_DECLARE_INTERFACE(GDebugController, g_debug_controller, g, debug_controller, GObject);
```
"""
function g_debug_controller_GET_IFACE(ptr)
    @ccall libaravis.g_debug_controller_GET_IFACE(ptr::gpointer)::Ptr{GDebugControllerInterface}
end

"""
    g_debug_controller_get_debug_enabled(self)

### Prototype
```c
GIO_AVAILABLE_IN_2_72 gboolean g_debug_controller_get_debug_enabled (GDebugController *self);
```
"""
function g_debug_controller_get_debug_enabled(self)
    @ccall libaravis.g_debug_controller_get_debug_enabled(self::Ptr{GDebugController})::gboolean
end

"""
    g_debug_controller_set_debug_enabled(self, debug_enabled)

### Prototype
```c
GIO_AVAILABLE_IN_2_72 void g_debug_controller_set_debug_enabled (GDebugController *self, gboolean debug_enabled);
```
"""
function g_debug_controller_set_debug_enabled(self, debug_enabled)
    @ccall libaravis.g_debug_controller_set_debug_enabled(self::Ptr{GDebugController}, debug_enabled::gboolean)::Cvoid
end

struct _GDebugControllerDBus
    parent_instance::GObject
end

const GDebugControllerDBus = _GDebugControllerDBus

"""
    _GDebugControllerDBusClass

[`GDebugControllerDBusClass`](@ref): \\_class: The parent class. : Default handler for the #[`GDebugControllerDBus`](@ref)::authorize signal.

The virtual function table for #[`GDebugControllerDBus`](@ref).

Since: 2.72
"""
struct _GDebugControllerDBusClass
    parent_class::GObjectClass
    authorize::Ptr{Cvoid}
    padding::NTuple{12, gpointer}
end

"""
[`GDebugControllerDBusClass`](@ref): \\_class: The parent class. : Default handler for the #[`GDebugControllerDBus`](@ref)::authorize signal.

The virtual function table for #[`GDebugControllerDBus`](@ref).

Since: 2.72
"""
const GDebugControllerDBusClass = _GDebugControllerDBusClass

const GDebugControllerDBus_autoptr = Ptr{GDebugControllerDBus}

const GDebugControllerDBus_listautoptr = Ptr{GList}

const GDebugControllerDBus_slistautoptr = Ptr{GSList}

const GDebugControllerDBus_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GDebugControllerDBus(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (GDebugControllerDBus, g_debug_controller_dbus, G, DEBUG_CONTROLLER_DBUS, GObject);
```
"""
function glib_autoptr_clear_GDebugControllerDBus(_ptr)
    @ccall libaravis.glib_autoptr_clear_GDebugControllerDBus(_ptr::Ptr{GDebugControllerDBus})::Cvoid
end

"""
    glib_autoptr_cleanup_GDebugControllerDBus(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (GDebugControllerDBus, g_debug_controller_dbus, G, DEBUG_CONTROLLER_DBUS, GObject);
```
"""
function glib_autoptr_cleanup_GDebugControllerDBus(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GDebugControllerDBus(_ptr::Ptr{Ptr{GDebugControllerDBus}})::Cvoid
end

"""
    glib_autoptr_destroy_GDebugControllerDBus(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (GDebugControllerDBus, g_debug_controller_dbus, G, DEBUG_CONTROLLER_DBUS, GObject);
```
"""
function glib_autoptr_destroy_GDebugControllerDBus(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GDebugControllerDBus(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GDebugControllerDBus(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (GDebugControllerDBus, g_debug_controller_dbus, G, DEBUG_CONTROLLER_DBUS, GObject);
```
"""
function glib_listautoptr_cleanup_GDebugControllerDBus(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GDebugControllerDBus(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GDebugControllerDBus(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (GDebugControllerDBus, g_debug_controller_dbus, G, DEBUG_CONTROLLER_DBUS, GObject);
```
"""
function glib_slistautoptr_cleanup_GDebugControllerDBus(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GDebugControllerDBus(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GDebugControllerDBus(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (GDebugControllerDBus, g_debug_controller_dbus, G, DEBUG_CONTROLLER_DBUS, GObject);
```
"""
function glib_queueautoptr_cleanup_GDebugControllerDBus(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GDebugControllerDBus(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GDebugControllerDBusClass_autoptr = Ptr{GDebugControllerDBusClass}

const GDebugControllerDBusClass_listautoptr = Ptr{GList}

const GDebugControllerDBusClass_slistautoptr = Ptr{GSList}

const GDebugControllerDBusClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GDebugControllerDBusClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (GDebugControllerDBus, g_debug_controller_dbus, G, DEBUG_CONTROLLER_DBUS, GObject);
```
"""
function glib_autoptr_clear_GDebugControllerDBusClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_GDebugControllerDBusClass(_ptr::Ptr{GDebugControllerDBusClass})::Cvoid
end

"""
    glib_autoptr_cleanup_GDebugControllerDBusClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (GDebugControllerDBus, g_debug_controller_dbus, G, DEBUG_CONTROLLER_DBUS, GObject);
```
"""
function glib_autoptr_cleanup_GDebugControllerDBusClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GDebugControllerDBusClass(_ptr::Ptr{Ptr{GDebugControllerDBusClass}})::Cvoid
end

"""
    glib_autoptr_destroy_GDebugControllerDBusClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (GDebugControllerDBus, g_debug_controller_dbus, G, DEBUG_CONTROLLER_DBUS, GObject);
```
"""
function glib_autoptr_destroy_GDebugControllerDBusClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GDebugControllerDBusClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GDebugControllerDBusClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (GDebugControllerDBus, g_debug_controller_dbus, G, DEBUG_CONTROLLER_DBUS, GObject);
```
"""
function glib_listautoptr_cleanup_GDebugControllerDBusClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GDebugControllerDBusClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GDebugControllerDBusClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (GDebugControllerDBus, g_debug_controller_dbus, G, DEBUG_CONTROLLER_DBUS, GObject);
```
"""
function glib_slistautoptr_cleanup_GDebugControllerDBusClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GDebugControllerDBusClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GDebugControllerDBusClass(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (GDebugControllerDBus, g_debug_controller_dbus, G, DEBUG_CONTROLLER_DBUS, GObject);
```
"""
function glib_queueautoptr_cleanup_GDebugControllerDBusClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GDebugControllerDBusClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    G_DEBUG_CONTROLLER_DBUS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (GDebugControllerDBus, g_debug_controller_dbus, G, DEBUG_CONTROLLER_DBUS, GObject);
```
"""
function G_DEBUG_CONTROLLER_DBUS(ptr)
    @ccall libaravis.G_DEBUG_CONTROLLER_DBUS(ptr::gpointer)::Ptr{GDebugControllerDBus}
end

"""
    G_DEBUG_CONTROLLER_DBUS_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (GDebugControllerDBus, g_debug_controller_dbus, G, DEBUG_CONTROLLER_DBUS, GObject);
```
"""
function G_DEBUG_CONTROLLER_DBUS_CLASS(ptr)
    @ccall libaravis.G_DEBUG_CONTROLLER_DBUS_CLASS(ptr::gpointer)::Ptr{GDebugControllerDBusClass}
end

"""
    G_IS_DEBUG_CONTROLLER_DBUS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (GDebugControllerDBus, g_debug_controller_dbus, G, DEBUG_CONTROLLER_DBUS, GObject);
```
"""
function G_IS_DEBUG_CONTROLLER_DBUS(ptr)
    @ccall libaravis.G_IS_DEBUG_CONTROLLER_DBUS(ptr::gpointer)::gboolean
end

"""
    G_IS_DEBUG_CONTROLLER_DBUS_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (GDebugControllerDBus, g_debug_controller_dbus, G, DEBUG_CONTROLLER_DBUS, GObject);
```
"""
function G_IS_DEBUG_CONTROLLER_DBUS_CLASS(ptr)
    @ccall libaravis.G_IS_DEBUG_CONTROLLER_DBUS_CLASS(ptr::gpointer)::gboolean
end

"""
    G_DEBUG_CONTROLLER_DBUS_GET_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (GDebugControllerDBus, g_debug_controller_dbus, G, DEBUG_CONTROLLER_DBUS, GObject);
```
"""
function G_DEBUG_CONTROLLER_DBUS_GET_CLASS(ptr)
    @ccall libaravis.G_DEBUG_CONTROLLER_DBUS_GET_CLASS(ptr::gpointer)::Ptr{GDebugControllerDBusClass}
end

"""
    g_debug_controller_dbus_new(connection, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_72 GDebugControllerDBus *g_debug_controller_dbus_new (GDBusConnection *connection, GCancellable *cancellable, GError **error);
```
"""
function g_debug_controller_dbus_new(connection, cancellable, error)
    @ccall libaravis.g_debug_controller_dbus_new(connection::Ptr{GDBusConnection}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GDebugControllerDBus}
end

"""
    g_debug_controller_dbus_stop(self)

### Prototype
```c
GIO_AVAILABLE_IN_2_72 void g_debug_controller_dbus_stop (GDebugControllerDBus *self);
```
"""
function g_debug_controller_dbus_stop(self)
    @ccall libaravis.g_debug_controller_dbus_stop(self::Ptr{GDebugControllerDBus})::Cvoid
end

"""
    g_drive_get_name(drive)

### Prototype
```c
GIO_AVAILABLE_IN_ALL char * g_drive_get_name (GDrive *drive);
```
"""
function g_drive_get_name(drive)
    @ccall libaravis.g_drive_get_name(drive::Ptr{GDrive})::Cstring
end

"""
    g_drive_get_icon(drive)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIcon * g_drive_get_icon (GDrive *drive);
```
"""
function g_drive_get_icon(drive)
    @ccall libaravis.g_drive_get_icon(drive::Ptr{GDrive})::Ptr{GIcon}
end

"""
    g_drive_get_symbolic_icon(drive)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIcon * g_drive_get_symbolic_icon (GDrive *drive);
```
"""
function g_drive_get_symbolic_icon(drive)
    @ccall libaravis.g_drive_get_symbolic_icon(drive::Ptr{GDrive})::Ptr{GIcon}
end

"""
    g_drive_has_volumes(drive)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_drive_has_volumes (GDrive *drive);
```
"""
function g_drive_has_volumes(drive)
    @ccall libaravis.g_drive_has_volumes(drive::Ptr{GDrive})::gboolean
end

"""
    g_drive_get_volumes(drive)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GList * g_drive_get_volumes (GDrive *drive);
```
"""
function g_drive_get_volumes(drive)
    @ccall libaravis.g_drive_get_volumes(drive::Ptr{GDrive})::Ptr{GList}
end

"""
    g_drive_is_removable(drive)

### Prototype
```c
GIO_AVAILABLE_IN_2_50 gboolean g_drive_is_removable (GDrive *drive);
```
"""
function g_drive_is_removable(drive)
    @ccall libaravis.g_drive_is_removable(drive::Ptr{GDrive})::gboolean
end

"""
    g_drive_is_media_removable(drive)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_drive_is_media_removable (GDrive *drive);
```
"""
function g_drive_is_media_removable(drive)
    @ccall libaravis.g_drive_is_media_removable(drive::Ptr{GDrive})::gboolean
end

"""
    g_drive_has_media(drive)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_drive_has_media (GDrive *drive);
```
"""
function g_drive_has_media(drive)
    @ccall libaravis.g_drive_has_media(drive::Ptr{GDrive})::gboolean
end

"""
    g_drive_is_media_check_automatic(drive)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_drive_is_media_check_automatic (GDrive *drive);
```
"""
function g_drive_is_media_check_automatic(drive)
    @ccall libaravis.g_drive_is_media_check_automatic(drive::Ptr{GDrive})::gboolean
end

"""
    g_drive_can_poll_for_media(drive)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_drive_can_poll_for_media (GDrive *drive);
```
"""
function g_drive_can_poll_for_media(drive)
    @ccall libaravis.g_drive_can_poll_for_media(drive::Ptr{GDrive})::gboolean
end

"""
    g_drive_can_eject(drive)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_drive_can_eject (GDrive *drive);
```
"""
function g_drive_can_eject(drive)
    @ccall libaravis.g_drive_can_eject(drive::Ptr{GDrive})::gboolean
end

"""
    g_drive_eject(drive, flags, cancellable, callback, user_data)

### Prototype
```c
GIO_DEPRECATED_FOR(g_drive_eject_with_operation) void g_drive_eject (GDrive *drive, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_drive_eject(drive, flags, cancellable, callback, user_data)
    @ccall libaravis.g_drive_eject(drive::Ptr{GDrive}, flags::GMountUnmountFlags, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_drive_eject_finish(drive, result, error)

### Prototype
```c
GIO_DEPRECATED_FOR(g_drive_eject_with_operation_finish) gboolean g_drive_eject_finish (GDrive *drive, GAsyncResult *result, GError **error);
```
"""
function g_drive_eject_finish(drive, result, error)
    @ccall libaravis.g_drive_eject_finish(drive::Ptr{GDrive}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_drive_poll_for_media(drive, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_drive_poll_for_media (GDrive *drive, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_drive_poll_for_media(drive, cancellable, callback, user_data)
    @ccall libaravis.g_drive_poll_for_media(drive::Ptr{GDrive}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_drive_poll_for_media_finish(drive, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_drive_poll_for_media_finish (GDrive *drive, GAsyncResult *result, GError **error);
```
"""
function g_drive_poll_for_media_finish(drive, result, error)
    @ccall libaravis.g_drive_poll_for_media_finish(drive::Ptr{GDrive}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_drive_get_identifier(drive, kind)

### Prototype
```c
GIO_AVAILABLE_IN_ALL char * g_drive_get_identifier (GDrive *drive, const char *kind);
```
"""
function g_drive_get_identifier(drive, kind)
    @ccall libaravis.g_drive_get_identifier(drive::Ptr{GDrive}, kind::Cstring)::Cstring
end

"""
    g_drive_enumerate_identifiers(drive)

### Prototype
```c
GIO_AVAILABLE_IN_ALL char ** g_drive_enumerate_identifiers (GDrive *drive);
```
"""
function g_drive_enumerate_identifiers(drive)
    @ccall libaravis.g_drive_enumerate_identifiers(drive::Ptr{GDrive})::Ptr{Cstring}
end

"""
    g_drive_get_start_stop_type(drive)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDriveStartStopType g_drive_get_start_stop_type (GDrive *drive);
```
"""
function g_drive_get_start_stop_type(drive)
    @ccall libaravis.g_drive_get_start_stop_type(drive::Ptr{GDrive})::GDriveStartStopType
end

"""
    g_drive_can_start(drive)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_drive_can_start (GDrive *drive);
```
"""
function g_drive_can_start(drive)
    @ccall libaravis.g_drive_can_start(drive::Ptr{GDrive})::gboolean
end

"""
    g_drive_can_start_degraded(drive)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_drive_can_start_degraded (GDrive *drive);
```
"""
function g_drive_can_start_degraded(drive)
    @ccall libaravis.g_drive_can_start_degraded(drive::Ptr{GDrive})::gboolean
end

"""
    g_drive_start(drive, flags, mount_operation, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_drive_start (GDrive *drive, GDriveStartFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_drive_start(drive, flags, mount_operation, cancellable, callback, user_data)
    @ccall libaravis.g_drive_start(drive::Ptr{GDrive}, flags::GDriveStartFlags, mount_operation::Ptr{GMountOperation}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_drive_start_finish(drive, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_drive_start_finish (GDrive *drive, GAsyncResult *result, GError **error);
```
"""
function g_drive_start_finish(drive, result, error)
    @ccall libaravis.g_drive_start_finish(drive::Ptr{GDrive}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_drive_can_stop(drive)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_drive_can_stop (GDrive *drive);
```
"""
function g_drive_can_stop(drive)
    @ccall libaravis.g_drive_can_stop(drive::Ptr{GDrive})::gboolean
end

"""
    g_drive_stop(drive, flags, mount_operation, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_drive_stop (GDrive *drive, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_drive_stop(drive, flags, mount_operation, cancellable, callback, user_data)
    @ccall libaravis.g_drive_stop(drive::Ptr{GDrive}, flags::GMountUnmountFlags, mount_operation::Ptr{GMountOperation}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_drive_stop_finish(drive, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_drive_stop_finish (GDrive *drive, GAsyncResult *result, GError **error);
```
"""
function g_drive_stop_finish(drive, result, error)
    @ccall libaravis.g_drive_stop_finish(drive::Ptr{GDrive}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_drive_eject_with_operation(drive, flags, mount_operation, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_drive_eject_with_operation (GDrive *drive, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_drive_eject_with_operation(drive, flags, mount_operation, cancellable, callback, user_data)
    @ccall libaravis.g_drive_eject_with_operation(drive::Ptr{GDrive}, flags::GMountUnmountFlags, mount_operation::Ptr{GMountOperation}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_drive_eject_with_operation_finish(drive, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_drive_eject_with_operation_finish (GDrive *drive, GAsyncResult *result, GError **error);
```
"""
function g_drive_eject_with_operation_finish(drive, result, error)
    @ccall libaravis.g_drive_eject_with_operation_finish(drive::Ptr{GDrive}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_drive_get_sort_key(drive)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 const gchar *g_drive_get_sort_key (GDrive *drive);
```
"""
function g_drive_get_sort_key(drive)
    @ccall libaravis.g_drive_get_sort_key(drive::Ptr{GDrive})::Ptr{gchar}
end

"""
    g_dtls_connection_set_database(conn, database)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 void g_dtls_connection_set_database (GDtlsConnection *conn, GTlsDatabase *database);
```
"""
function g_dtls_connection_set_database(conn, database)
    @ccall libaravis.g_dtls_connection_set_database(conn::Ptr{GDtlsConnection}, database::Ptr{GTlsDatabase})::Cvoid
end

"""
    g_dtls_connection_get_database(conn)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 GTlsDatabase *g_dtls_connection_get_database (GDtlsConnection *conn);
```
"""
function g_dtls_connection_get_database(conn)
    @ccall libaravis.g_dtls_connection_get_database(conn::Ptr{GDtlsConnection})::Ptr{GTlsDatabase}
end

"""
    g_dtls_connection_set_certificate(conn, certificate)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 void g_dtls_connection_set_certificate (GDtlsConnection *conn, GTlsCertificate *certificate);
```
"""
function g_dtls_connection_set_certificate(conn, certificate)
    @ccall libaravis.g_dtls_connection_set_certificate(conn::Ptr{GDtlsConnection}, certificate::Ptr{GTlsCertificate})::Cvoid
end

"""
    g_dtls_connection_get_certificate(conn)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 GTlsCertificate *g_dtls_connection_get_certificate (GDtlsConnection *conn);
```
"""
function g_dtls_connection_get_certificate(conn)
    @ccall libaravis.g_dtls_connection_get_certificate(conn::Ptr{GDtlsConnection})::Ptr{GTlsCertificate}
end

"""
    g_dtls_connection_set_interaction(conn, interaction)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 void g_dtls_connection_set_interaction (GDtlsConnection *conn, GTlsInteraction *interaction);
```
"""
function g_dtls_connection_set_interaction(conn, interaction)
    @ccall libaravis.g_dtls_connection_set_interaction(conn::Ptr{GDtlsConnection}, interaction::Ptr{GTlsInteraction})::Cvoid
end

"""
    g_dtls_connection_get_interaction(conn)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 GTlsInteraction *g_dtls_connection_get_interaction (GDtlsConnection *conn);
```
"""
function g_dtls_connection_get_interaction(conn)
    @ccall libaravis.g_dtls_connection_get_interaction(conn::Ptr{GDtlsConnection})::Ptr{GTlsInteraction}
end

"""
    g_dtls_connection_get_peer_certificate(conn)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 GTlsCertificate *g_dtls_connection_get_peer_certificate (GDtlsConnection *conn);
```
"""
function g_dtls_connection_get_peer_certificate(conn)
    @ccall libaravis.g_dtls_connection_get_peer_certificate(conn::Ptr{GDtlsConnection})::Ptr{GTlsCertificate}
end

"""
    g_dtls_connection_get_peer_certificate_errors(conn)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 GTlsCertificateFlags g_dtls_connection_get_peer_certificate_errors (GDtlsConnection *conn);
```
"""
function g_dtls_connection_get_peer_certificate_errors(conn)
    @ccall libaravis.g_dtls_connection_get_peer_certificate_errors(conn::Ptr{GDtlsConnection})::GTlsCertificateFlags
end

"""
    g_dtls_connection_set_require_close_notify(conn, require_close_notify)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 void g_dtls_connection_set_require_close_notify (GDtlsConnection *conn, gboolean require_close_notify);
```
"""
function g_dtls_connection_set_require_close_notify(conn, require_close_notify)
    @ccall libaravis.g_dtls_connection_set_require_close_notify(conn::Ptr{GDtlsConnection}, require_close_notify::gboolean)::Cvoid
end

"""
    g_dtls_connection_get_require_close_notify(conn)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 gboolean g_dtls_connection_get_require_close_notify (GDtlsConnection *conn);
```
"""
function g_dtls_connection_get_require_close_notify(conn)
    @ccall libaravis.g_dtls_connection_get_require_close_notify(conn::Ptr{GDtlsConnection})::gboolean
end

"""
    g_dtls_connection_set_rehandshake_mode(conn, mode)

### Prototype
```c
GIO_DEPRECATED_IN_2_60 void g_dtls_connection_set_rehandshake_mode (GDtlsConnection *conn, GTlsRehandshakeMode mode);
```
"""
function g_dtls_connection_set_rehandshake_mode(conn, mode)
    @ccall libaravis.g_dtls_connection_set_rehandshake_mode(conn::Ptr{GDtlsConnection}, mode::GTlsRehandshakeMode)::Cvoid
end

"""
    g_dtls_connection_get_rehandshake_mode(conn)

### Prototype
```c
GIO_DEPRECATED_IN_2_60 GTlsRehandshakeMode g_dtls_connection_get_rehandshake_mode (GDtlsConnection *conn);
```
"""
function g_dtls_connection_get_rehandshake_mode(conn)
    @ccall libaravis.g_dtls_connection_get_rehandshake_mode(conn::Ptr{GDtlsConnection})::GTlsRehandshakeMode
end

"""
    g_dtls_connection_handshake(conn, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 gboolean g_dtls_connection_handshake (GDtlsConnection *conn, GCancellable *cancellable, GError **error);
```
"""
function g_dtls_connection_handshake(conn, cancellable, error)
    @ccall libaravis.g_dtls_connection_handshake(conn::Ptr{GDtlsConnection}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_dtls_connection_handshake_async(conn, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 void g_dtls_connection_handshake_async (GDtlsConnection *conn, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_dtls_connection_handshake_async(conn, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_dtls_connection_handshake_async(conn::Ptr{GDtlsConnection}, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_dtls_connection_handshake_finish(conn, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 gboolean g_dtls_connection_handshake_finish (GDtlsConnection *conn, GAsyncResult *result, GError **error);
```
"""
function g_dtls_connection_handshake_finish(conn, result, error)
    @ccall libaravis.g_dtls_connection_handshake_finish(conn::Ptr{GDtlsConnection}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_dtls_connection_shutdown(conn, shutdown_read, shutdown_write, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 gboolean g_dtls_connection_shutdown (GDtlsConnection *conn, gboolean shutdown_read, gboolean shutdown_write, GCancellable *cancellable, GError **error);
```
"""
function g_dtls_connection_shutdown(conn, shutdown_read, shutdown_write, cancellable, error)
    @ccall libaravis.g_dtls_connection_shutdown(conn::Ptr{GDtlsConnection}, shutdown_read::gboolean, shutdown_write::gboolean, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_dtls_connection_shutdown_async(conn, shutdown_read, shutdown_write, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 void g_dtls_connection_shutdown_async (GDtlsConnection *conn, gboolean shutdown_read, gboolean shutdown_write, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_dtls_connection_shutdown_async(conn, shutdown_read, shutdown_write, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_dtls_connection_shutdown_async(conn::Ptr{GDtlsConnection}, shutdown_read::gboolean, shutdown_write::gboolean, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_dtls_connection_shutdown_finish(conn, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 gboolean g_dtls_connection_shutdown_finish (GDtlsConnection *conn, GAsyncResult *result, GError **error);
```
"""
function g_dtls_connection_shutdown_finish(conn, result, error)
    @ccall libaravis.g_dtls_connection_shutdown_finish(conn::Ptr{GDtlsConnection}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_dtls_connection_close(conn, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 gboolean g_dtls_connection_close (GDtlsConnection *conn, GCancellable *cancellable, GError **error);
```
"""
function g_dtls_connection_close(conn, cancellable, error)
    @ccall libaravis.g_dtls_connection_close(conn::Ptr{GDtlsConnection}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_dtls_connection_close_async(conn, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 void g_dtls_connection_close_async (GDtlsConnection *conn, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_dtls_connection_close_async(conn, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_dtls_connection_close_async(conn::Ptr{GDtlsConnection}, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_dtls_connection_close_finish(conn, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 gboolean g_dtls_connection_close_finish (GDtlsConnection *conn, GAsyncResult *result, GError **error);
```
"""
function g_dtls_connection_close_finish(conn, result, error)
    @ccall libaravis.g_dtls_connection_close_finish(conn::Ptr{GDtlsConnection}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_dtls_connection_emit_accept_certificate(conn, peer_cert, errors)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 gboolean g_dtls_connection_emit_accept_certificate (GDtlsConnection *conn, GTlsCertificate *peer_cert, GTlsCertificateFlags errors);
```
"""
function g_dtls_connection_emit_accept_certificate(conn, peer_cert, errors)
    @ccall libaravis.g_dtls_connection_emit_accept_certificate(conn::Ptr{GDtlsConnection}, peer_cert::Ptr{GTlsCertificate}, errors::GTlsCertificateFlags)::gboolean
end

"""
    g_dtls_connection_set_advertised_protocols(conn, protocols)

### Prototype
```c
GIO_AVAILABLE_IN_2_60 void g_dtls_connection_set_advertised_protocols (GDtlsConnection *conn, const gchar * const *protocols);
```
"""
function g_dtls_connection_set_advertised_protocols(conn, protocols)
    @ccall libaravis.g_dtls_connection_set_advertised_protocols(conn::Ptr{GDtlsConnection}, protocols::Ptr{Ptr{gchar}})::Cvoid
end

"""
    g_dtls_connection_get_negotiated_protocol(conn)

### Prototype
```c
GIO_AVAILABLE_IN_2_60 const gchar * g_dtls_connection_get_negotiated_protocol (GDtlsConnection *conn);
```
"""
function g_dtls_connection_get_negotiated_protocol(conn)
    @ccall libaravis.g_dtls_connection_get_negotiated_protocol(conn::Ptr{GDtlsConnection})::Ptr{gchar}
end

"""
    g_dtls_connection_get_channel_binding_data(conn, type, data, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_66 gboolean g_dtls_connection_get_channel_binding_data (GDtlsConnection *conn, GTlsChannelBindingType type, GByteArray *data, GError **error);
```
"""
function g_dtls_connection_get_channel_binding_data(conn, type, data, error)
    @ccall libaravis.g_dtls_connection_get_channel_binding_data(conn::Ptr{GDtlsConnection}, type::GTlsChannelBindingType, data::Ptr{GByteArray}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_dtls_connection_get_protocol_version(conn)

### Prototype
```c
GIO_AVAILABLE_IN_2_70 GTlsProtocolVersion g_dtls_connection_get_protocol_version (GDtlsConnection *conn);
```
"""
function g_dtls_connection_get_protocol_version(conn)
    @ccall libaravis.g_dtls_connection_get_protocol_version(conn::Ptr{GDtlsConnection})::GTlsProtocolVersion
end

"""
    g_dtls_connection_get_ciphersuite_name(conn)

### Prototype
```c
GIO_AVAILABLE_IN_2_70 gchar * g_dtls_connection_get_ciphersuite_name (GDtlsConnection *conn);
```
"""
function g_dtls_connection_get_ciphersuite_name(conn)
    @ccall libaravis.g_dtls_connection_get_ciphersuite_name(conn::Ptr{GDtlsConnection})::Ptr{gchar}
end

"""
    g_dtls_client_connection_new(base_socket, server_identity, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 GDatagramBased *g_dtls_client_connection_new (GDatagramBased *base_socket, GSocketConnectable *server_identity, GError **error);
```
"""
function g_dtls_client_connection_new(base_socket, server_identity, error)
    @ccall libaravis.g_dtls_client_connection_new(base_socket::Ptr{GDatagramBased}, server_identity::Ptr{GSocketConnectable}, error::Ptr{Ptr{GError}})::Ptr{GDatagramBased}
end

"""
    g_dtls_client_connection_get_validation_flags(conn)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 GTlsCertificateFlags g_dtls_client_connection_get_validation_flags (GDtlsClientConnection *conn);
```
"""
function g_dtls_client_connection_get_validation_flags(conn)
    @ccall libaravis.g_dtls_client_connection_get_validation_flags(conn::Ptr{GDtlsClientConnection})::GTlsCertificateFlags
end

"""
    g_dtls_client_connection_set_validation_flags(conn, flags)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 void g_dtls_client_connection_set_validation_flags (GDtlsClientConnection *conn, GTlsCertificateFlags flags);
```
"""
function g_dtls_client_connection_set_validation_flags(conn, flags)
    @ccall libaravis.g_dtls_client_connection_set_validation_flags(conn::Ptr{GDtlsClientConnection}, flags::GTlsCertificateFlags)::Cvoid
end

"""
    g_dtls_client_connection_get_server_identity(conn)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 GSocketConnectable *g_dtls_client_connection_get_server_identity (GDtlsClientConnection *conn);
```
"""
function g_dtls_client_connection_get_server_identity(conn)
    @ccall libaravis.g_dtls_client_connection_get_server_identity(conn::Ptr{GDtlsClientConnection})::Ptr{GSocketConnectable}
end

"""
    g_dtls_client_connection_set_server_identity(conn, identity)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 void g_dtls_client_connection_set_server_identity (GDtlsClientConnection *conn, GSocketConnectable *identity);
```
"""
function g_dtls_client_connection_set_server_identity(conn, identity)
    @ccall libaravis.g_dtls_client_connection_set_server_identity(conn::Ptr{GDtlsClientConnection}, identity::Ptr{GSocketConnectable})::Cvoid
end

"""
    g_dtls_client_connection_get_accepted_cas(conn)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 GList * g_dtls_client_connection_get_accepted_cas (GDtlsClientConnection *conn);
```
"""
function g_dtls_client_connection_get_accepted_cas(conn)
    @ccall libaravis.g_dtls_client_connection_get_accepted_cas(conn::Ptr{GDtlsClientConnection})::Ptr{GList}
end

"""
    g_dtls_server_connection_new(base_socket, certificate, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 GDatagramBased *g_dtls_server_connection_new (GDatagramBased *base_socket, GTlsCertificate *certificate, GError **error);
```
"""
function g_dtls_server_connection_new(base_socket, certificate, error)
    @ccall libaravis.g_dtls_server_connection_new(base_socket::Ptr{GDatagramBased}, certificate::Ptr{GTlsCertificate}, error::Ptr{Ptr{GError}})::Ptr{GDatagramBased}
end

"""
    g_icon_hash(icon)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint g_icon_hash (gconstpointer icon);
```
"""
function g_icon_hash(icon)
    @ccall libaravis.g_icon_hash(icon::gconstpointer)::guint
end

"""
    g_icon_equal(icon1, icon2)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_icon_equal (GIcon *icon1, GIcon *icon2);
```
"""
function g_icon_equal(icon1, icon2)
    @ccall libaravis.g_icon_equal(icon1::Ptr{GIcon}, icon2::Ptr{GIcon})::gboolean
end

"""
    g_icon_to_string(icon)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gchar *g_icon_to_string (GIcon *icon);
```
"""
function g_icon_to_string(icon)
    @ccall libaravis.g_icon_to_string(icon::Ptr{GIcon})::Ptr{gchar}
end

"""
    g_icon_new_for_string(str, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIcon *g_icon_new_for_string (const gchar *str, GError **error);
```
"""
function g_icon_new_for_string(str, error)
    @ccall libaravis.g_icon_new_for_string(str::Ptr{gchar}, error::Ptr{Ptr{GError}})::Ptr{GIcon}
end

"""
    g_icon_serialize(icon)

### Prototype
```c
GIO_AVAILABLE_IN_2_38 GVariant * g_icon_serialize (GIcon *icon);
```
"""
function g_icon_serialize(icon)
    @ccall libaravis.g_icon_serialize(icon::Ptr{GIcon})::Ptr{GVariant}
end

"""
    g_icon_deserialize(value)

### Prototype
```c
GIO_AVAILABLE_IN_2_38 GIcon * g_icon_deserialize (GVariant *value);
```
"""
function g_icon_deserialize(value)
    @ccall libaravis.g_icon_deserialize(value::Ptr{GVariant})::Ptr{GIcon}
end

"""
    g_emblem_new(icon)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GEmblem *g_emblem_new (GIcon *icon);
```
"""
function g_emblem_new(icon)
    @ccall libaravis.g_emblem_new(icon::Ptr{GIcon})::Ptr{GEmblem}
end

"""
    g_emblem_new_with_origin(icon, origin)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GEmblem *g_emblem_new_with_origin (GIcon *icon, GEmblemOrigin origin);
```
"""
function g_emblem_new_with_origin(icon, origin)
    @ccall libaravis.g_emblem_new_with_origin(icon::Ptr{GIcon}, origin::GEmblemOrigin)::Ptr{GEmblem}
end

"""
    g_emblem_get_icon(emblem)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIcon *g_emblem_get_icon (GEmblem *emblem);
```
"""
function g_emblem_get_icon(emblem)
    @ccall libaravis.g_emblem_get_icon(emblem::Ptr{GEmblem})::Ptr{GIcon}
end

"""
    g_emblem_get_origin(emblem)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GEmblemOrigin g_emblem_get_origin (GEmblem *emblem);
```
"""
function g_emblem_get_origin(emblem)
    @ccall libaravis.g_emblem_get_origin(emblem::Ptr{GEmblem})::GEmblemOrigin
end

"""
    g_emblemed_icon_new(icon, emblem)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIcon *g_emblemed_icon_new (GIcon *icon, GEmblem *emblem);
```
"""
function g_emblemed_icon_new(icon, emblem)
    @ccall libaravis.g_emblemed_icon_new(icon::Ptr{GIcon}, emblem::Ptr{GEmblem})::Ptr{GIcon}
end

"""
    g_emblemed_icon_get_icon(emblemed)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIcon *g_emblemed_icon_get_icon (GEmblemedIcon *emblemed);
```
"""
function g_emblemed_icon_get_icon(emblemed)
    @ccall libaravis.g_emblemed_icon_get_icon(emblemed::Ptr{GEmblemedIcon})::Ptr{GIcon}
end

"""
    g_emblemed_icon_get_emblems(emblemed)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GList *g_emblemed_icon_get_emblems (GEmblemedIcon *emblemed);
```
"""
function g_emblemed_icon_get_emblems(emblemed)
    @ccall libaravis.g_emblemed_icon_get_emblems(emblemed::Ptr{GEmblemedIcon})::Ptr{GList}
end

"""
    g_emblemed_icon_add_emblem(emblemed, emblem)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_emblemed_icon_add_emblem (GEmblemedIcon *emblemed, GEmblem *emblem);
```
"""
function g_emblemed_icon_add_emblem(emblemed, emblem)
    @ccall libaravis.g_emblemed_icon_add_emblem(emblemed::Ptr{GEmblemedIcon}, emblem::Ptr{GEmblem})::Cvoid
end

"""
    g_emblemed_icon_clear_emblems(emblemed)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_emblemed_icon_clear_emblems (GEmblemedIcon *emblemed);
```
"""
function g_emblemed_icon_clear_emblems(emblemed)
    @ccall libaravis.g_emblemed_icon_clear_emblems(emblemed::Ptr{GEmblemedIcon})::Cvoid
end

"""
    g_file_new_for_path(path)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFile * g_file_new_for_path (const char *path);
```
"""
function g_file_new_for_path(path)
    @ccall libaravis.g_file_new_for_path(path::Cstring)::Ptr{GFile}
end

"""
    g_file_new_for_uri(uri)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFile * g_file_new_for_uri (const char *uri);
```
"""
function g_file_new_for_uri(uri)
    @ccall libaravis.g_file_new_for_uri(uri::Cstring)::Ptr{GFile}
end

"""
    g_file_new_for_commandline_arg(arg)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFile * g_file_new_for_commandline_arg (const char *arg);
```
"""
function g_file_new_for_commandline_arg(arg)
    @ccall libaravis.g_file_new_for_commandline_arg(arg::Cstring)::Ptr{GFile}
end

"""
    g_file_new_for_commandline_arg_and_cwd(arg, cwd)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 GFile * g_file_new_for_commandline_arg_and_cwd (const gchar *arg, const gchar *cwd);
```
"""
function g_file_new_for_commandline_arg_and_cwd(arg, cwd)
    @ccall libaravis.g_file_new_for_commandline_arg_and_cwd(arg::Ptr{gchar}, cwd::Ptr{gchar})::Ptr{GFile}
end

"""
    g_file_new_tmp(tmpl, iostream, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GFile * g_file_new_tmp (const char *tmpl, GFileIOStream **iostream, GError **error);
```
"""
function g_file_new_tmp(tmpl, iostream, error)
    @ccall libaravis.g_file_new_tmp(tmpl::Cstring, iostream::Ptr{Ptr{GFileIOStream}}, error::Ptr{Ptr{GError}})::Ptr{GFile}
end

"""
    g_file_new_tmp_async(tmpl, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_74 void g_file_new_tmp_async (const char *tmpl, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_new_tmp_async(tmpl, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_file_new_tmp_async(tmpl::Cstring, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_new_tmp_finish(result, iostream, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_74 GFile * g_file_new_tmp_finish (GAsyncResult *result, GFileIOStream **iostream, GError **error);
```
"""
function g_file_new_tmp_finish(result, iostream, error)
    @ccall libaravis.g_file_new_tmp_finish(result::Ptr{GAsyncResult}, iostream::Ptr{Ptr{GFileIOStream}}, error::Ptr{Ptr{GError}})::Ptr{GFile}
end

"""
    g_file_new_tmp_dir_async(tmpl, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_74 void g_file_new_tmp_dir_async (const char *tmpl, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_new_tmp_dir_async(tmpl, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_file_new_tmp_dir_async(tmpl::Cstring, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_new_tmp_dir_finish(result, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_74 GFile * g_file_new_tmp_dir_finish (GAsyncResult *result, GError **error);
```
"""
function g_file_new_tmp_dir_finish(result, error)
    @ccall libaravis.g_file_new_tmp_dir_finish(result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GFile}
end

"""
    g_file_parse_name(parse_name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFile * g_file_parse_name (const char *parse_name);
```
"""
function g_file_parse_name(parse_name)
    @ccall libaravis.g_file_parse_name(parse_name::Cstring)::Ptr{GFile}
end

"""
    g_file_new_build_filenamev(args)

### Prototype
```c
GIO_AVAILABLE_IN_2_78 GFile * g_file_new_build_filenamev (const gchar * const *args);
```
"""
function g_file_new_build_filenamev(args)
    @ccall libaravis.g_file_new_build_filenamev(args::Ptr{Ptr{gchar}})::Ptr{GFile}
end

"""
    g_file_dup(file)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFile * g_file_dup (GFile *file);
```
"""
function g_file_dup(file)
    @ccall libaravis.g_file_dup(file::Ptr{GFile})::Ptr{GFile}
end

"""
    g_file_hash(file)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint g_file_hash (gconstpointer file);
```
"""
function g_file_hash(file)
    @ccall libaravis.g_file_hash(file::gconstpointer)::guint
end

"""
    g_file_equal(file1, file2)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_equal (GFile *file1, GFile *file2);
```
"""
function g_file_equal(file1, file2)
    @ccall libaravis.g_file_equal(file1::Ptr{GFile}, file2::Ptr{GFile})::gboolean
end

"""
    g_file_get_basename(file)

### Prototype
```c
GIO_AVAILABLE_IN_ALL char * g_file_get_basename (GFile *file);
```
"""
function g_file_get_basename(file)
    @ccall libaravis.g_file_get_basename(file::Ptr{GFile})::Cstring
end

"""
    g_file_get_path(file)

### Prototype
```c
GIO_AVAILABLE_IN_ALL char * g_file_get_path (GFile *file);
```
"""
function g_file_get_path(file)
    @ccall libaravis.g_file_get_path(file::Ptr{GFile})::Cstring
end

"""
    g_file_peek_path(file)

### Prototype
```c
GIO_AVAILABLE_IN_2_56 const char * g_file_peek_path (GFile *file);
```
"""
function g_file_peek_path(file)
    @ccall libaravis.g_file_peek_path(file::Ptr{GFile})::Cstring
end

"""
    g_file_get_uri(file)

### Prototype
```c
GIO_AVAILABLE_IN_ALL char * g_file_get_uri (GFile *file);
```
"""
function g_file_get_uri(file)
    @ccall libaravis.g_file_get_uri(file::Ptr{GFile})::Cstring
end

"""
    g_file_get_parse_name(file)

### Prototype
```c
GIO_AVAILABLE_IN_ALL char * g_file_get_parse_name (GFile *file);
```
"""
function g_file_get_parse_name(file)
    @ccall libaravis.g_file_get_parse_name(file::Ptr{GFile})::Cstring
end

"""
    g_file_get_parent(file)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFile * g_file_get_parent (GFile *file);
```
"""
function g_file_get_parent(file)
    @ccall libaravis.g_file_get_parent(file::Ptr{GFile})::Ptr{GFile}
end

"""
    g_file_has_parent(file, parent)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_has_parent (GFile *file, GFile *parent);
```
"""
function g_file_has_parent(file, parent)
    @ccall libaravis.g_file_has_parent(file::Ptr{GFile}, parent::Ptr{GFile})::gboolean
end

"""
    g_file_get_child(file, name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFile * g_file_get_child (GFile *file, const char *name);
```
"""
function g_file_get_child(file, name)
    @ccall libaravis.g_file_get_child(file::Ptr{GFile}, name::Cstring)::Ptr{GFile}
end

"""
    g_file_get_child_for_display_name(file, display_name, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFile * g_file_get_child_for_display_name (GFile *file, const char *display_name, GError **error);
```
"""
function g_file_get_child_for_display_name(file, display_name, error)
    @ccall libaravis.g_file_get_child_for_display_name(file::Ptr{GFile}, display_name::Cstring, error::Ptr{Ptr{GError}})::Ptr{GFile}
end

"""
    g_file_has_prefix(file, prefix)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_has_prefix (GFile *file, GFile *prefix);
```
"""
function g_file_has_prefix(file, prefix)
    @ccall libaravis.g_file_has_prefix(file::Ptr{GFile}, prefix::Ptr{GFile})::gboolean
end

"""
    g_file_get_relative_path(parent, descendant)

### Prototype
```c
GIO_AVAILABLE_IN_ALL char * g_file_get_relative_path (GFile *parent, GFile *descendant);
```
"""
function g_file_get_relative_path(parent, descendant)
    @ccall libaravis.g_file_get_relative_path(parent::Ptr{GFile}, descendant::Ptr{GFile})::Cstring
end

"""
    g_file_resolve_relative_path(file, relative_path)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFile * g_file_resolve_relative_path (GFile *file, const char *relative_path);
```
"""
function g_file_resolve_relative_path(file, relative_path)
    @ccall libaravis.g_file_resolve_relative_path(file::Ptr{GFile}, relative_path::Cstring)::Ptr{GFile}
end

"""
    g_file_is_native(file)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_is_native (GFile *file);
```
"""
function g_file_is_native(file)
    @ccall libaravis.g_file_is_native(file::Ptr{GFile})::gboolean
end

"""
    g_file_has_uri_scheme(file, uri_scheme)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_has_uri_scheme (GFile *file, const char *uri_scheme);
```
"""
function g_file_has_uri_scheme(file, uri_scheme)
    @ccall libaravis.g_file_has_uri_scheme(file::Ptr{GFile}, uri_scheme::Cstring)::gboolean
end

"""
    g_file_get_uri_scheme(file)

### Prototype
```c
GIO_AVAILABLE_IN_ALL char * g_file_get_uri_scheme (GFile *file);
```
"""
function g_file_get_uri_scheme(file)
    @ccall libaravis.g_file_get_uri_scheme(file::Ptr{GFile})::Cstring
end

"""
    g_file_read(file, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileInputStream * g_file_read (GFile *file, GCancellable *cancellable, GError **error);
```
"""
function g_file_read(file, cancellable, error)
    @ccall libaravis.g_file_read(file::Ptr{GFile}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GFileInputStream}
end

"""
    g_file_read_async(file, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_read_async (GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_read_async(file, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_file_read_async(file::Ptr{GFile}, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_read_finish(file, res, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileInputStream * g_file_read_finish (GFile *file, GAsyncResult *res, GError **error);
```
"""
function g_file_read_finish(file, res, error)
    @ccall libaravis.g_file_read_finish(file::Ptr{GFile}, res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GFileInputStream}
end

"""
    g_file_append_to(file, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileOutputStream * g_file_append_to (GFile *file, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
```
"""
function g_file_append_to(file, flags, cancellable, error)
    @ccall libaravis.g_file_append_to(file::Ptr{GFile}, flags::GFileCreateFlags, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GFileOutputStream}
end

"""
    g_file_create(file, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileOutputStream * g_file_create (GFile *file, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
```
"""
function g_file_create(file, flags, cancellable, error)
    @ccall libaravis.g_file_create(file::Ptr{GFile}, flags::GFileCreateFlags, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GFileOutputStream}
end

"""
    g_file_replace(file, etag, make_backup, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileOutputStream * g_file_replace (GFile *file, const char *etag, gboolean make_backup, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
```
"""
function g_file_replace(file, etag, make_backup, flags, cancellable, error)
    @ccall libaravis.g_file_replace(file::Ptr{GFile}, etag::Cstring, make_backup::gboolean, flags::GFileCreateFlags, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GFileOutputStream}
end

"""
    g_file_append_to_async(file, flags, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_append_to_async (GFile *file, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_append_to_async(file, flags, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_file_append_to_async(file::Ptr{GFile}, flags::GFileCreateFlags, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_append_to_finish(file, res, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileOutputStream * g_file_append_to_finish (GFile *file, GAsyncResult *res, GError **error);
```
"""
function g_file_append_to_finish(file, res, error)
    @ccall libaravis.g_file_append_to_finish(file::Ptr{GFile}, res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GFileOutputStream}
end

"""
    g_file_create_async(file, flags, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_create_async (GFile *file, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_create_async(file, flags, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_file_create_async(file::Ptr{GFile}, flags::GFileCreateFlags, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_create_finish(file, res, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileOutputStream * g_file_create_finish (GFile *file, GAsyncResult *res, GError **error);
```
"""
function g_file_create_finish(file, res, error)
    @ccall libaravis.g_file_create_finish(file::Ptr{GFile}, res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GFileOutputStream}
end

"""
    g_file_replace_async(file, etag, make_backup, flags, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_replace_async (GFile *file, const char *etag, gboolean make_backup, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_replace_async(file, etag, make_backup, flags, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_file_replace_async(file::Ptr{GFile}, etag::Cstring, make_backup::gboolean, flags::GFileCreateFlags, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_replace_finish(file, res, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileOutputStream * g_file_replace_finish (GFile *file, GAsyncResult *res, GError **error);
```
"""
function g_file_replace_finish(file, res, error)
    @ccall libaravis.g_file_replace_finish(file::Ptr{GFile}, res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GFileOutputStream}
end

"""
    g_file_open_readwrite(file, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileIOStream * g_file_open_readwrite (GFile *file, GCancellable *cancellable, GError **error);
```
"""
function g_file_open_readwrite(file, cancellable, error)
    @ccall libaravis.g_file_open_readwrite(file::Ptr{GFile}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GFileIOStream}
end

"""
    g_file_open_readwrite_async(file, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_open_readwrite_async (GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_open_readwrite_async(file, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_file_open_readwrite_async(file::Ptr{GFile}, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_open_readwrite_finish(file, res, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileIOStream * g_file_open_readwrite_finish (GFile *file, GAsyncResult *res, GError **error);
```
"""
function g_file_open_readwrite_finish(file, res, error)
    @ccall libaravis.g_file_open_readwrite_finish(file::Ptr{GFile}, res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GFileIOStream}
end

"""
    g_file_create_readwrite(file, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileIOStream * g_file_create_readwrite (GFile *file, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
```
"""
function g_file_create_readwrite(file, flags, cancellable, error)
    @ccall libaravis.g_file_create_readwrite(file::Ptr{GFile}, flags::GFileCreateFlags, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GFileIOStream}
end

"""
    g_file_create_readwrite_async(file, flags, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_create_readwrite_async (GFile *file, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_create_readwrite_async(file, flags, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_file_create_readwrite_async(file::Ptr{GFile}, flags::GFileCreateFlags, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_create_readwrite_finish(file, res, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileIOStream * g_file_create_readwrite_finish (GFile *file, GAsyncResult *res, GError **error);
```
"""
function g_file_create_readwrite_finish(file, res, error)
    @ccall libaravis.g_file_create_readwrite_finish(file::Ptr{GFile}, res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GFileIOStream}
end

"""
    g_file_replace_readwrite(file, etag, make_backup, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileIOStream * g_file_replace_readwrite (GFile *file, const char *etag, gboolean make_backup, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
```
"""
function g_file_replace_readwrite(file, etag, make_backup, flags, cancellable, error)
    @ccall libaravis.g_file_replace_readwrite(file::Ptr{GFile}, etag::Cstring, make_backup::gboolean, flags::GFileCreateFlags, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GFileIOStream}
end

"""
    g_file_replace_readwrite_async(file, etag, make_backup, flags, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_replace_readwrite_async (GFile *file, const char *etag, gboolean make_backup, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_replace_readwrite_async(file, etag, make_backup, flags, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_file_replace_readwrite_async(file::Ptr{GFile}, etag::Cstring, make_backup::gboolean, flags::GFileCreateFlags, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_replace_readwrite_finish(file, res, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileIOStream * g_file_replace_readwrite_finish (GFile *file, GAsyncResult *res, GError **error);
```
"""
function g_file_replace_readwrite_finish(file, res, error)
    @ccall libaravis.g_file_replace_readwrite_finish(file::Ptr{GFile}, res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GFileIOStream}
end

"""
    g_file_query_exists(file, cancellable)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_query_exists (GFile *file, GCancellable *cancellable);
```
"""
function g_file_query_exists(file, cancellable)
    @ccall libaravis.g_file_query_exists(file::Ptr{GFile}, cancellable::Ptr{GCancellable})::gboolean
end

"""
    g_file_query_file_type(file, flags, cancellable)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileType g_file_query_file_type (GFile *file, GFileQueryInfoFlags flags, GCancellable *cancellable);
```
"""
function g_file_query_file_type(file, flags, cancellable)
    @ccall libaravis.g_file_query_file_type(file::Ptr{GFile}, flags::GFileQueryInfoFlags, cancellable::Ptr{GCancellable})::GFileType
end

"""
    g_file_query_info(file, attributes, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileInfo * g_file_query_info (GFile *file, const char *attributes, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
```
"""
function g_file_query_info(file, attributes, flags, cancellable, error)
    @ccall libaravis.g_file_query_info(file::Ptr{GFile}, attributes::Cstring, flags::GFileQueryInfoFlags, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GFileInfo}
end

"""
    g_file_query_info_async(file, attributes, flags, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_query_info_async (GFile *file, const char *attributes, GFileQueryInfoFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_query_info_async(file, attributes, flags, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_file_query_info_async(file::Ptr{GFile}, attributes::Cstring, flags::GFileQueryInfoFlags, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_query_info_finish(file, res, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileInfo * g_file_query_info_finish (GFile *file, GAsyncResult *res, GError **error);
```
"""
function g_file_query_info_finish(file, res, error)
    @ccall libaravis.g_file_query_info_finish(file::Ptr{GFile}, res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GFileInfo}
end

"""
    g_file_query_filesystem_info(file, attributes, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileInfo * g_file_query_filesystem_info (GFile *file, const char *attributes, GCancellable *cancellable, GError **error);
```
"""
function g_file_query_filesystem_info(file, attributes, cancellable, error)
    @ccall libaravis.g_file_query_filesystem_info(file::Ptr{GFile}, attributes::Cstring, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GFileInfo}
end

"""
    g_file_query_filesystem_info_async(file, attributes, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_query_filesystem_info_async (GFile *file, const char *attributes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_query_filesystem_info_async(file, attributes, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_file_query_filesystem_info_async(file::Ptr{GFile}, attributes::Cstring, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_query_filesystem_info_finish(file, res, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileInfo * g_file_query_filesystem_info_finish (GFile *file, GAsyncResult *res, GError **error);
```
"""
function g_file_query_filesystem_info_finish(file, res, error)
    @ccall libaravis.g_file_query_filesystem_info_finish(file::Ptr{GFile}, res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GFileInfo}
end

"""
    g_file_find_enclosing_mount(file, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GMount * g_file_find_enclosing_mount (GFile *file, GCancellable *cancellable, GError **error);
```
"""
function g_file_find_enclosing_mount(file, cancellable, error)
    @ccall libaravis.g_file_find_enclosing_mount(file::Ptr{GFile}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GMount}
end

"""
    g_file_find_enclosing_mount_async(file, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_find_enclosing_mount_async (GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_find_enclosing_mount_async(file, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_file_find_enclosing_mount_async(file::Ptr{GFile}, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_find_enclosing_mount_finish(file, res, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GMount * g_file_find_enclosing_mount_finish (GFile *file, GAsyncResult *res, GError **error);
```
"""
function g_file_find_enclosing_mount_finish(file, res, error)
    @ccall libaravis.g_file_find_enclosing_mount_finish(file::Ptr{GFile}, res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GMount}
end

"""
    g_file_enumerate_children(file, attributes, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileEnumerator * g_file_enumerate_children (GFile *file, const char *attributes, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
```
"""
function g_file_enumerate_children(file, attributes, flags, cancellable, error)
    @ccall libaravis.g_file_enumerate_children(file::Ptr{GFile}, attributes::Cstring, flags::GFileQueryInfoFlags, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GFileEnumerator}
end

"""
    g_file_enumerate_children_async(file, attributes, flags, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_enumerate_children_async (GFile *file, const char *attributes, GFileQueryInfoFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_enumerate_children_async(file, attributes, flags, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_file_enumerate_children_async(file::Ptr{GFile}, attributes::Cstring, flags::GFileQueryInfoFlags, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_enumerate_children_finish(file, res, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileEnumerator * g_file_enumerate_children_finish (GFile *file, GAsyncResult *res, GError **error);
```
"""
function g_file_enumerate_children_finish(file, res, error)
    @ccall libaravis.g_file_enumerate_children_finish(file::Ptr{GFile}, res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GFileEnumerator}
end

"""
    g_file_set_display_name(file, display_name, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFile * g_file_set_display_name (GFile *file, const char *display_name, GCancellable *cancellable, GError **error);
```
"""
function g_file_set_display_name(file, display_name, cancellable, error)
    @ccall libaravis.g_file_set_display_name(file::Ptr{GFile}, display_name::Cstring, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GFile}
end

"""
    g_file_set_display_name_async(file, display_name, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_set_display_name_async (GFile *file, const char *display_name, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_set_display_name_async(file, display_name, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_file_set_display_name_async(file::Ptr{GFile}, display_name::Cstring, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_set_display_name_finish(file, res, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFile * g_file_set_display_name_finish (GFile *file, GAsyncResult *res, GError **error);
```
"""
function g_file_set_display_name_finish(file, res, error)
    @ccall libaravis.g_file_set_display_name_finish(file::Ptr{GFile}, res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GFile}
end

"""
    g_file_delete(file, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_delete (GFile *file, GCancellable *cancellable, GError **error);
```
"""
function g_file_delete(file, cancellable, error)
    @ccall libaravis.g_file_delete(file::Ptr{GFile}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_delete_async(file, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 void g_file_delete_async (GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_delete_async(file, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_file_delete_async(file::Ptr{GFile}, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_delete_finish(file, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 gboolean g_file_delete_finish (GFile *file, GAsyncResult *result, GError **error);
```
"""
function g_file_delete_finish(file, result, error)
    @ccall libaravis.g_file_delete_finish(file::Ptr{GFile}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_trash(file, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_trash (GFile *file, GCancellable *cancellable, GError **error);
```
"""
function g_file_trash(file, cancellable, error)
    @ccall libaravis.g_file_trash(file::Ptr{GFile}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_trash_async(file, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_38 void g_file_trash_async (GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_trash_async(file, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_file_trash_async(file::Ptr{GFile}, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_trash_finish(file, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_38 gboolean g_file_trash_finish (GFile *file, GAsyncResult *result, GError **error);
```
"""
function g_file_trash_finish(file, result, error)
    @ccall libaravis.g_file_trash_finish(file::Ptr{GFile}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_copy(source, destination, flags, cancellable, progress_callback, progress_callback_data, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_copy (GFile *source, GFile *destination, GFileCopyFlags flags, GCancellable *cancellable, GFileProgressCallback progress_callback, gpointer progress_callback_data, GError **error);
```
"""
function g_file_copy(source, destination, flags, cancellable, progress_callback, progress_callback_data, error)
    @ccall libaravis.g_file_copy(source::Ptr{GFile}, destination::Ptr{GFile}, flags::GFileCopyFlags, cancellable::Ptr{GCancellable}, progress_callback::GFileProgressCallback, progress_callback_data::gpointer, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_copy_async(source, destination, flags, io_priority, cancellable, progress_callback, progress_callback_data, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_copy_async (GFile *source, GFile *destination, GFileCopyFlags flags, int io_priority, GCancellable *cancellable, GFileProgressCallback progress_callback, gpointer progress_callback_data, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_copy_async(source, destination, flags, io_priority, cancellable, progress_callback, progress_callback_data, callback, user_data)
    @ccall libaravis.g_file_copy_async(source::Ptr{GFile}, destination::Ptr{GFile}, flags::GFileCopyFlags, io_priority::Cint, cancellable::Ptr{GCancellable}, progress_callback::GFileProgressCallback, progress_callback_data::gpointer, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_copy_async_with_closures(source, destination, flags, io_priority, cancellable, progress_callback_closure, ready_callback_closure)

### Prototype
```c
GIO_AVAILABLE_IN_2_82 void g_file_copy_async_with_closures (GFile *source, GFile *destination, GFileCopyFlags flags, int io_priority, GCancellable *cancellable, GClosure *progress_callback_closure, GClosure *ready_callback_closure);
```
"""
function g_file_copy_async_with_closures(source, destination, flags, io_priority, cancellable, progress_callback_closure, ready_callback_closure)
    @ccall libaravis.g_file_copy_async_with_closures(source::Ptr{GFile}, destination::Ptr{GFile}, flags::GFileCopyFlags, io_priority::Cint, cancellable::Ptr{GCancellable}, progress_callback_closure::Ptr{GClosure}, ready_callback_closure::Ptr{GClosure})::Cvoid
end

"""
    g_file_copy_finish(file, res, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_copy_finish (GFile *file, GAsyncResult *res, GError **error);
```
"""
function g_file_copy_finish(file, res, error)
    @ccall libaravis.g_file_copy_finish(file::Ptr{GFile}, res::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_move(source, destination, flags, cancellable, progress_callback, progress_callback_data, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_move (GFile *source, GFile *destination, GFileCopyFlags flags, GCancellable *cancellable, GFileProgressCallback progress_callback, gpointer progress_callback_data, GError **error);
```
"""
function g_file_move(source, destination, flags, cancellable, progress_callback, progress_callback_data, error)
    @ccall libaravis.g_file_move(source::Ptr{GFile}, destination::Ptr{GFile}, flags::GFileCopyFlags, cancellable::Ptr{GCancellable}, progress_callback::GFileProgressCallback, progress_callback_data::gpointer, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_move_async(source, destination, flags, io_priority, cancellable, progress_callback, progress_callback_data, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_72 void g_file_move_async (GFile *source, GFile *destination, GFileCopyFlags flags, int io_priority, GCancellable *cancellable, GFileProgressCallback progress_callback, gpointer progress_callback_data, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_move_async(source, destination, flags, io_priority, cancellable, progress_callback, progress_callback_data, callback, user_data)
    @ccall libaravis.g_file_move_async(source::Ptr{GFile}, destination::Ptr{GFile}, flags::GFileCopyFlags, io_priority::Cint, cancellable::Ptr{GCancellable}, progress_callback::GFileProgressCallback, progress_callback_data::gpointer, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_move_async_with_closures(source, destination, flags, io_priority, cancellable, progress_callback_closure, ready_callback_closure)

### Prototype
```c
GIO_AVAILABLE_IN_2_82 void g_file_move_async_with_closures (GFile *source, GFile *destination, GFileCopyFlags flags, int io_priority, GCancellable *cancellable, GClosure *progress_callback_closure, GClosure *ready_callback_closure);
```
"""
function g_file_move_async_with_closures(source, destination, flags, io_priority, cancellable, progress_callback_closure, ready_callback_closure)
    @ccall libaravis.g_file_move_async_with_closures(source::Ptr{GFile}, destination::Ptr{GFile}, flags::GFileCopyFlags, io_priority::Cint, cancellable::Ptr{GCancellable}, progress_callback_closure::Ptr{GClosure}, ready_callback_closure::Ptr{GClosure})::Cvoid
end

"""
    g_file_move_finish(file, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_72 gboolean g_file_move_finish (GFile *file, GAsyncResult *result, GError **error);
```
"""
function g_file_move_finish(file, result, error)
    @ccall libaravis.g_file_move_finish(file::Ptr{GFile}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_make_directory(file, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_make_directory (GFile *file, GCancellable *cancellable, GError **error);
```
"""
function g_file_make_directory(file, cancellable, error)
    @ccall libaravis.g_file_make_directory(file::Ptr{GFile}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_make_directory_async(file, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_38 void g_file_make_directory_async (GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_make_directory_async(file, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_file_make_directory_async(file::Ptr{GFile}, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_make_directory_finish(file, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_38 gboolean g_file_make_directory_finish (GFile *file, GAsyncResult *result, GError **error);
```
"""
function g_file_make_directory_finish(file, result, error)
    @ccall libaravis.g_file_make_directory_finish(file::Ptr{GFile}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_make_directory_with_parents(file, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_make_directory_with_parents (GFile *file, GCancellable *cancellable, GError **error);
```
"""
function g_file_make_directory_with_parents(file, cancellable, error)
    @ccall libaravis.g_file_make_directory_with_parents(file::Ptr{GFile}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_make_symbolic_link(file, symlink_value, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_make_symbolic_link (GFile *file, const char *symlink_value, GCancellable *cancellable, GError **error);
```
"""
function g_file_make_symbolic_link(file, symlink_value, cancellable, error)
    @ccall libaravis.g_file_make_symbolic_link(file::Ptr{GFile}, symlink_value::Cstring, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_make_symbolic_link_async(file, symlink_value, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_74 void g_file_make_symbolic_link_async (GFile *file, const char *symlink_value, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_make_symbolic_link_async(file, symlink_value, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_file_make_symbolic_link_async(file::Ptr{GFile}, symlink_value::Cstring, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_make_symbolic_link_finish(file, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_74 gboolean g_file_make_symbolic_link_finish (GFile *file, GAsyncResult *result, GError **error);
```
"""
function g_file_make_symbolic_link_finish(file, result, error)
    @ccall libaravis.g_file_make_symbolic_link_finish(file::Ptr{GFile}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_query_settable_attributes(file, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileAttributeInfoList *g_file_query_settable_attributes (GFile *file, GCancellable *cancellable, GError **error);
```
"""
function g_file_query_settable_attributes(file, cancellable, error)
    @ccall libaravis.g_file_query_settable_attributes(file::Ptr{GFile}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GFileAttributeInfoList}
end

"""
    g_file_query_writable_namespaces(file, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileAttributeInfoList *g_file_query_writable_namespaces (GFile *file, GCancellable *cancellable, GError **error);
```
"""
function g_file_query_writable_namespaces(file, cancellable, error)
    @ccall libaravis.g_file_query_writable_namespaces(file::Ptr{GFile}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GFileAttributeInfoList}
end

"""
    g_file_set_attribute(file, attribute, type, value_p, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_set_attribute (GFile *file, const char *attribute, GFileAttributeType type, gpointer value_p, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
```
"""
function g_file_set_attribute(file, attribute, type, value_p, flags, cancellable, error)
    @ccall libaravis.g_file_set_attribute(file::Ptr{GFile}, attribute::Cstring, type::GFileAttributeType, value_p::gpointer, flags::GFileQueryInfoFlags, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_set_attributes_from_info(file, info, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_set_attributes_from_info (GFile *file, GFileInfo *info, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
```
"""
function g_file_set_attributes_from_info(file, info, flags, cancellable, error)
    @ccall libaravis.g_file_set_attributes_from_info(file::Ptr{GFile}, info::Ptr{GFileInfo}, flags::GFileQueryInfoFlags, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_set_attributes_async(file, info, flags, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_set_attributes_async (GFile *file, GFileInfo *info, GFileQueryInfoFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_set_attributes_async(file, info, flags, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_file_set_attributes_async(file::Ptr{GFile}, info::Ptr{GFileInfo}, flags::GFileQueryInfoFlags, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_set_attributes_finish(file, result, info, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_set_attributes_finish (GFile *file, GAsyncResult *result, GFileInfo **info, GError **error);
```
"""
function g_file_set_attributes_finish(file, result, info, error)
    @ccall libaravis.g_file_set_attributes_finish(file::Ptr{GFile}, result::Ptr{GAsyncResult}, info::Ptr{Ptr{GFileInfo}}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_set_attribute_string(file, attribute, value, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_set_attribute_string (GFile *file, const char *attribute, const char *value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
```
"""
function g_file_set_attribute_string(file, attribute, value, flags, cancellable, error)
    @ccall libaravis.g_file_set_attribute_string(file::Ptr{GFile}, attribute::Cstring, value::Cstring, flags::GFileQueryInfoFlags, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_set_attribute_byte_string(file, attribute, value, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_set_attribute_byte_string (GFile *file, const char *attribute, const char *value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
```
"""
function g_file_set_attribute_byte_string(file, attribute, value, flags, cancellable, error)
    @ccall libaravis.g_file_set_attribute_byte_string(file::Ptr{GFile}, attribute::Cstring, value::Cstring, flags::GFileQueryInfoFlags, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_set_attribute_uint32(file, attribute, value, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_set_attribute_uint32 (GFile *file, const char *attribute, guint32 value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
```
"""
function g_file_set_attribute_uint32(file, attribute, value, flags, cancellable, error)
    @ccall libaravis.g_file_set_attribute_uint32(file::Ptr{GFile}, attribute::Cstring, value::guint32, flags::GFileQueryInfoFlags, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_set_attribute_int32(file, attribute, value, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_set_attribute_int32 (GFile *file, const char *attribute, gint32 value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
```
"""
function g_file_set_attribute_int32(file, attribute, value, flags, cancellable, error)
    @ccall libaravis.g_file_set_attribute_int32(file::Ptr{GFile}, attribute::Cstring, value::gint32, flags::GFileQueryInfoFlags, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_set_attribute_uint64(file, attribute, value, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_set_attribute_uint64 (GFile *file, const char *attribute, guint64 value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
```
"""
function g_file_set_attribute_uint64(file, attribute, value, flags, cancellable, error)
    @ccall libaravis.g_file_set_attribute_uint64(file::Ptr{GFile}, attribute::Cstring, value::guint64, flags::GFileQueryInfoFlags, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_set_attribute_int64(file, attribute, value, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_set_attribute_int64 (GFile *file, const char *attribute, gint64 value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
```
"""
function g_file_set_attribute_int64(file, attribute, value, flags, cancellable, error)
    @ccall libaravis.g_file_set_attribute_int64(file::Ptr{GFile}, attribute::Cstring, value::gint64, flags::GFileQueryInfoFlags, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_mount_enclosing_volume(location, flags, mount_operation, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_mount_enclosing_volume (GFile *location, GMountMountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_mount_enclosing_volume(location, flags, mount_operation, cancellable, callback, user_data)
    @ccall libaravis.g_file_mount_enclosing_volume(location::Ptr{GFile}, flags::GMountMountFlags, mount_operation::Ptr{GMountOperation}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_mount_enclosing_volume_finish(location, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_mount_enclosing_volume_finish (GFile *location, GAsyncResult *result, GError **error);
```
"""
function g_file_mount_enclosing_volume_finish(location, result, error)
    @ccall libaravis.g_file_mount_enclosing_volume_finish(location::Ptr{GFile}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_mount_mountable(file, flags, mount_operation, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_mount_mountable (GFile *file, GMountMountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_mount_mountable(file, flags, mount_operation, cancellable, callback, user_data)
    @ccall libaravis.g_file_mount_mountable(file::Ptr{GFile}, flags::GMountMountFlags, mount_operation::Ptr{GMountOperation}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_mount_mountable_finish(file, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFile * g_file_mount_mountable_finish (GFile *file, GAsyncResult *result, GError **error);
```
"""
function g_file_mount_mountable_finish(file, result, error)
    @ccall libaravis.g_file_mount_mountable_finish(file::Ptr{GFile}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GFile}
end

"""
    g_file_unmount_mountable(file, flags, cancellable, callback, user_data)

### Prototype
```c
GIO_DEPRECATED_FOR(g_file_unmount_mountable_with_operation) void g_file_unmount_mountable (GFile *file, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_unmount_mountable(file, flags, cancellable, callback, user_data)
    @ccall libaravis.g_file_unmount_mountable(file::Ptr{GFile}, flags::GMountUnmountFlags, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_unmount_mountable_finish(file, result, error)

### Prototype
```c
GIO_DEPRECATED_FOR(g_file_unmount_mountable_with_operation_finish) gboolean g_file_unmount_mountable_finish (GFile *file, GAsyncResult *result, GError **error);
```
"""
function g_file_unmount_mountable_finish(file, result, error)
    @ccall libaravis.g_file_unmount_mountable_finish(file::Ptr{GFile}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_unmount_mountable_with_operation(file, flags, mount_operation, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_unmount_mountable_with_operation (GFile *file, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_unmount_mountable_with_operation(file, flags, mount_operation, cancellable, callback, user_data)
    @ccall libaravis.g_file_unmount_mountable_with_operation(file::Ptr{GFile}, flags::GMountUnmountFlags, mount_operation::Ptr{GMountOperation}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_unmount_mountable_with_operation_finish(file, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_unmount_mountable_with_operation_finish (GFile *file, GAsyncResult *result, GError **error);
```
"""
function g_file_unmount_mountable_with_operation_finish(file, result, error)
    @ccall libaravis.g_file_unmount_mountable_with_operation_finish(file::Ptr{GFile}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_eject_mountable(file, flags, cancellable, callback, user_data)

### Prototype
```c
GIO_DEPRECATED_FOR(g_file_eject_mountable_with_operation) void g_file_eject_mountable (GFile *file, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_eject_mountable(file, flags, cancellable, callback, user_data)
    @ccall libaravis.g_file_eject_mountable(file::Ptr{GFile}, flags::GMountUnmountFlags, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_eject_mountable_finish(file, result, error)

### Prototype
```c
GIO_DEPRECATED_FOR(g_file_eject_mountable_with_operation_finish) gboolean g_file_eject_mountable_finish (GFile *file, GAsyncResult *result, GError **error);
```
"""
function g_file_eject_mountable_finish(file, result, error)
    @ccall libaravis.g_file_eject_mountable_finish(file::Ptr{GFile}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_eject_mountable_with_operation(file, flags, mount_operation, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_eject_mountable_with_operation (GFile *file, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_eject_mountable_with_operation(file, flags, mount_operation, cancellable, callback, user_data)
    @ccall libaravis.g_file_eject_mountable_with_operation(file::Ptr{GFile}, flags::GMountUnmountFlags, mount_operation::Ptr{GMountOperation}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_eject_mountable_with_operation_finish(file, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_eject_mountable_with_operation_finish (GFile *file, GAsyncResult *result, GError **error);
```
"""
function g_file_eject_mountable_with_operation_finish(file, result, error)
    @ccall libaravis.g_file_eject_mountable_with_operation_finish(file::Ptr{GFile}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_build_attribute_list_for_copy(file, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_68 char * g_file_build_attribute_list_for_copy (GFile *file, GFileCopyFlags flags, GCancellable *cancellable, GError **error);
```
"""
function g_file_build_attribute_list_for_copy(file, flags, cancellable, error)
    @ccall libaravis.g_file_build_attribute_list_for_copy(file::Ptr{GFile}, flags::GFileCopyFlags, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Cstring
end

"""
    g_file_copy_attributes(source, destination, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_copy_attributes (GFile *source, GFile *destination, GFileCopyFlags flags, GCancellable *cancellable, GError **error);
```
"""
function g_file_copy_attributes(source, destination, flags, cancellable, error)
    @ccall libaravis.g_file_copy_attributes(source::Ptr{GFile}, destination::Ptr{GFile}, flags::GFileCopyFlags, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_monitor_directory(file, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileMonitor* g_file_monitor_directory (GFile *file, GFileMonitorFlags flags, GCancellable *cancellable, GError **error);
```
"""
function g_file_monitor_directory(file, flags, cancellable, error)
    @ccall libaravis.g_file_monitor_directory(file::Ptr{GFile}, flags::GFileMonitorFlags, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GFileMonitor}
end

"""
    g_file_monitor_file(file, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileMonitor* g_file_monitor_file (GFile *file, GFileMonitorFlags flags, GCancellable *cancellable, GError **error);
```
"""
function g_file_monitor_file(file, flags, cancellable, error)
    @ccall libaravis.g_file_monitor_file(file::Ptr{GFile}, flags::GFileMonitorFlags, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GFileMonitor}
end

"""
    g_file_monitor(file, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileMonitor* g_file_monitor (GFile *file, GFileMonitorFlags flags, GCancellable *cancellable, GError **error);
```
"""
function g_file_monitor(file, flags, cancellable, error)
    @ccall libaravis.g_file_monitor(file::Ptr{GFile}, flags::GFileMonitorFlags, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GFileMonitor}
end

"""
    g_file_measure_disk_usage(file, flags, cancellable, progress_callback, progress_data, disk_usage, num_dirs, num_files, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_38 gboolean g_file_measure_disk_usage (GFile *file, GFileMeasureFlags flags, GCancellable *cancellable, GFileMeasureProgressCallback progress_callback, gpointer progress_data, guint64 *disk_usage, guint64 *num_dirs, guint64 *num_files, GError **error);
```
"""
function g_file_measure_disk_usage(file, flags, cancellable, progress_callback, progress_data, disk_usage, num_dirs, num_files, error)
    @ccall libaravis.g_file_measure_disk_usage(file::Ptr{GFile}, flags::GFileMeasureFlags, cancellable::Ptr{GCancellable}, progress_callback::GFileMeasureProgressCallback, progress_data::gpointer, disk_usage::Ptr{guint64}, num_dirs::Ptr{guint64}, num_files::Ptr{guint64}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_measure_disk_usage_async(file, flags, io_priority, cancellable, progress_callback, progress_data, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_38 void g_file_measure_disk_usage_async (GFile *file, GFileMeasureFlags flags, gint io_priority, GCancellable *cancellable, GFileMeasureProgressCallback progress_callback, gpointer progress_data, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_measure_disk_usage_async(file, flags, io_priority, cancellable, progress_callback, progress_data, callback, user_data)
    @ccall libaravis.g_file_measure_disk_usage_async(file::Ptr{GFile}, flags::GFileMeasureFlags, io_priority::gint, cancellable::Ptr{GCancellable}, progress_callback::GFileMeasureProgressCallback, progress_data::gpointer, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_measure_disk_usage_finish(file, result, disk_usage, num_dirs, num_files, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_38 gboolean g_file_measure_disk_usage_finish (GFile *file, GAsyncResult *result, guint64 *disk_usage, guint64 *num_dirs, guint64 *num_files, GError **error);
```
"""
function g_file_measure_disk_usage_finish(file, result, disk_usage, num_dirs, num_files, error)
    @ccall libaravis.g_file_measure_disk_usage_finish(file::Ptr{GFile}, result::Ptr{GAsyncResult}, disk_usage::Ptr{guint64}, num_dirs::Ptr{guint64}, num_files::Ptr{guint64}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_start_mountable(file, flags, start_operation, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_start_mountable (GFile *file, GDriveStartFlags flags, GMountOperation *start_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_start_mountable(file, flags, start_operation, cancellable, callback, user_data)
    @ccall libaravis.g_file_start_mountable(file::Ptr{GFile}, flags::GDriveStartFlags, start_operation::Ptr{GMountOperation}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_start_mountable_finish(file, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_start_mountable_finish (GFile *file, GAsyncResult *result, GError **error);
```
"""
function g_file_start_mountable_finish(file, result, error)
    @ccall libaravis.g_file_start_mountable_finish(file::Ptr{GFile}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_stop_mountable(file, flags, mount_operation, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_stop_mountable (GFile *file, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_stop_mountable(file, flags, mount_operation, cancellable, callback, user_data)
    @ccall libaravis.g_file_stop_mountable(file::Ptr{GFile}, flags::GMountUnmountFlags, mount_operation::Ptr{GMountOperation}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_stop_mountable_finish(file, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_stop_mountable_finish (GFile *file, GAsyncResult *result, GError **error);
```
"""
function g_file_stop_mountable_finish(file, result, error)
    @ccall libaravis.g_file_stop_mountable_finish(file::Ptr{GFile}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_poll_mountable(file, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_poll_mountable (GFile *file, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_poll_mountable(file, cancellable, callback, user_data)
    @ccall libaravis.g_file_poll_mountable(file::Ptr{GFile}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_poll_mountable_finish(file, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_poll_mountable_finish (GFile *file, GAsyncResult *result, GError **error);
```
"""
function g_file_poll_mountable_finish(file, result, error)
    @ccall libaravis.g_file_poll_mountable_finish(file::Ptr{GFile}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_query_default_handler(file, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GAppInfo *g_file_query_default_handler (GFile *file, GCancellable *cancellable, GError **error);
```
"""
function g_file_query_default_handler(file, cancellable, error)
    @ccall libaravis.g_file_query_default_handler(file::Ptr{GFile}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GAppInfo}
end

"""
    g_file_query_default_handler_async(file, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_60 void g_file_query_default_handler_async (GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_query_default_handler_async(file, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_file_query_default_handler_async(file::Ptr{GFile}, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_query_default_handler_finish(file, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_60 GAppInfo *g_file_query_default_handler_finish (GFile *file, GAsyncResult *result, GError **error);
```
"""
function g_file_query_default_handler_finish(file, result, error)
    @ccall libaravis.g_file_query_default_handler_finish(file::Ptr{GFile}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GAppInfo}
end

"""
    g_file_load_contents(file, cancellable, contents, length, etag_out, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_load_contents (GFile *file, GCancellable *cancellable, char **contents, gsize *length, char **etag_out, GError **error);
```
"""
function g_file_load_contents(file, cancellable, contents, length, etag_out, error)
    @ccall libaravis.g_file_load_contents(file::Ptr{GFile}, cancellable::Ptr{GCancellable}, contents::Ptr{Cstring}, length::Ptr{gsize}, etag_out::Ptr{Cstring}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_load_contents_async(file, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_load_contents_async (GFile *file, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_load_contents_async(file, cancellable, callback, user_data)
    @ccall libaravis.g_file_load_contents_async(file::Ptr{GFile}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_load_contents_finish(file, res, contents, length, etag_out, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_load_contents_finish (GFile *file, GAsyncResult *res, char **contents, gsize *length, char **etag_out, GError **error);
```
"""
function g_file_load_contents_finish(file, res, contents, length, etag_out, error)
    @ccall libaravis.g_file_load_contents_finish(file::Ptr{GFile}, res::Ptr{GAsyncResult}, contents::Ptr{Cstring}, length::Ptr{gsize}, etag_out::Ptr{Cstring}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_load_partial_contents_async(file, cancellable, read_more_callback, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_load_partial_contents_async (GFile *file, GCancellable *cancellable, GFileReadMoreCallback read_more_callback, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_load_partial_contents_async(file, cancellable, read_more_callback, callback, user_data)
    @ccall libaravis.g_file_load_partial_contents_async(file::Ptr{GFile}, cancellable::Ptr{GCancellable}, read_more_callback::GFileReadMoreCallback, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_load_partial_contents_finish(file, res, contents, length, etag_out, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_load_partial_contents_finish (GFile *file, GAsyncResult *res, char **contents, gsize *length, char **etag_out, GError **error);
```
"""
function g_file_load_partial_contents_finish(file, res, contents, length, etag_out, error)
    @ccall libaravis.g_file_load_partial_contents_finish(file::Ptr{GFile}, res::Ptr{GAsyncResult}, contents::Ptr{Cstring}, length::Ptr{gsize}, etag_out::Ptr{Cstring}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_replace_contents(file, contents, length, etag, make_backup, flags, new_etag, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_replace_contents (GFile *file, const char *contents, gsize length, const char *etag, gboolean make_backup, GFileCreateFlags flags, char **new_etag, GCancellable *cancellable, GError **error);
```
"""
function g_file_replace_contents(file, contents, length, etag, make_backup, flags, new_etag, cancellable, error)
    @ccall libaravis.g_file_replace_contents(file::Ptr{GFile}, contents::Cstring, length::gsize, etag::Cstring, make_backup::gboolean, flags::GFileCreateFlags, new_etag::Ptr{Cstring}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_replace_contents_async(file, contents, length, etag, make_backup, flags, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_replace_contents_async (GFile *file, const char *contents, gsize length, const char *etag, gboolean make_backup, GFileCreateFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_replace_contents_async(file, contents, length, etag, make_backup, flags, cancellable, callback, user_data)
    @ccall libaravis.g_file_replace_contents_async(file::Ptr{GFile}, contents::Cstring, length::gsize, etag::Cstring, make_backup::gboolean, flags::GFileCreateFlags, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_replace_contents_bytes_async(file, contents, etag, make_backup, flags, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_file_replace_contents_bytes_async (GFile *file, GBytes *contents, const char *etag, gboolean make_backup, GFileCreateFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_replace_contents_bytes_async(file, contents, etag, make_backup, flags, cancellable, callback, user_data)
    @ccall libaravis.g_file_replace_contents_bytes_async(file::Ptr{GFile}, contents::Ptr{GBytes}, etag::Cstring, make_backup::gboolean, flags::GFileCreateFlags, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_replace_contents_finish(file, res, new_etag, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_replace_contents_finish (GFile *file, GAsyncResult *res, char **new_etag, GError **error);
```
"""
function g_file_replace_contents_finish(file, res, new_etag, error)
    @ccall libaravis.g_file_replace_contents_finish(file::Ptr{GFile}, res::Ptr{GAsyncResult}, new_etag::Ptr{Cstring}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_supports_thread_contexts(file)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_supports_thread_contexts (GFile *file);
```
"""
function g_file_supports_thread_contexts(file)
    @ccall libaravis.g_file_supports_thread_contexts(file::Ptr{GFile})::gboolean
end

"""
    g_file_load_bytes(file, cancellable, etag_out, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_56 GBytes *g_file_load_bytes (GFile *file, GCancellable *cancellable, gchar **etag_out, GError **error);
```
"""
function g_file_load_bytes(file, cancellable, etag_out, error)
    @ccall libaravis.g_file_load_bytes(file::Ptr{GFile}, cancellable::Ptr{GCancellable}, etag_out::Ptr{Ptr{gchar}}, error::Ptr{Ptr{GError}})::Ptr{GBytes}
end

"""
    g_file_load_bytes_async(file, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_56 void g_file_load_bytes_async (GFile *file, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_load_bytes_async(file, cancellable, callback, user_data)
    @ccall libaravis.g_file_load_bytes_async(file::Ptr{GFile}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_load_bytes_finish(file, result, etag_out, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_56 GBytes *g_file_load_bytes_finish (GFile *file, GAsyncResult *result, gchar **etag_out, GError **error);
```
"""
function g_file_load_bytes_finish(file, result, etag_out, error)
    @ccall libaravis.g_file_load_bytes_finish(file::Ptr{GFile}, result::Ptr{GAsyncResult}, etag_out::Ptr{Ptr{gchar}}, error::Ptr{Ptr{GError}})::Ptr{GBytes}
end

"""
    g_file_attribute_info_list_new()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileAttributeInfoList * g_file_attribute_info_list_new (void);
```
"""
function g_file_attribute_info_list_new()
    @ccall libaravis.g_file_attribute_info_list_new()::Ptr{GFileAttributeInfoList}
end

"""
    g_file_attribute_info_list_ref(list)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileAttributeInfoList * g_file_attribute_info_list_ref (GFileAttributeInfoList *list);
```
"""
function g_file_attribute_info_list_ref(list)
    @ccall libaravis.g_file_attribute_info_list_ref(list::Ptr{GFileAttributeInfoList})::Ptr{GFileAttributeInfoList}
end

"""
    g_file_attribute_info_list_unref(list)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_attribute_info_list_unref (GFileAttributeInfoList *list);
```
"""
function g_file_attribute_info_list_unref(list)
    @ccall libaravis.g_file_attribute_info_list_unref(list::Ptr{GFileAttributeInfoList})::Cvoid
end

"""
    g_file_attribute_info_list_dup(list)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileAttributeInfoList * g_file_attribute_info_list_dup (GFileAttributeInfoList *list);
```
"""
function g_file_attribute_info_list_dup(list)
    @ccall libaravis.g_file_attribute_info_list_dup(list::Ptr{GFileAttributeInfoList})::Ptr{GFileAttributeInfoList}
end

"""
    g_file_attribute_info_list_lookup(list, name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const GFileAttributeInfo *g_file_attribute_info_list_lookup (GFileAttributeInfoList *list, const char *name);
```
"""
function g_file_attribute_info_list_lookup(list, name)
    @ccall libaravis.g_file_attribute_info_list_lookup(list::Ptr{GFileAttributeInfoList}, name::Cstring)::Ptr{GFileAttributeInfo}
end

"""
    g_file_attribute_info_list_add(list, name, type, flags)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_attribute_info_list_add (GFileAttributeInfoList *list, const char *name, GFileAttributeType type, GFileAttributeInfoFlags flags);
```
"""
function g_file_attribute_info_list_add(list, name, type, flags)
    @ccall libaravis.g_file_attribute_info_list_add(list::Ptr{GFileAttributeInfoList}, name::Cstring, type::GFileAttributeType, flags::GFileAttributeInfoFlags)::Cvoid
end

"""
    g_file_enumerator_next_file(enumerator, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileInfo *g_file_enumerator_next_file (GFileEnumerator *enumerator, GCancellable *cancellable, GError **error);
```
"""
function g_file_enumerator_next_file(enumerator, cancellable, error)
    @ccall libaravis.g_file_enumerator_next_file(enumerator::Ptr{GFileEnumerator}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GFileInfo}
end

"""
    g_file_enumerator_close(enumerator, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_enumerator_close (GFileEnumerator *enumerator, GCancellable *cancellable, GError **error);
```
"""
function g_file_enumerator_close(enumerator, cancellable, error)
    @ccall libaravis.g_file_enumerator_close(enumerator::Ptr{GFileEnumerator}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_enumerator_next_files_async(enumerator, num_files, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_enumerator_next_files_async (GFileEnumerator *enumerator, int num_files, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_enumerator_next_files_async(enumerator, num_files, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_file_enumerator_next_files_async(enumerator::Ptr{GFileEnumerator}, num_files::Cint, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_enumerator_next_files_finish(enumerator, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GList * g_file_enumerator_next_files_finish (GFileEnumerator *enumerator, GAsyncResult *result, GError **error);
```
"""
function g_file_enumerator_next_files_finish(enumerator, result, error)
    @ccall libaravis.g_file_enumerator_next_files_finish(enumerator::Ptr{GFileEnumerator}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GList}
end

"""
    g_file_enumerator_close_async(enumerator, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_enumerator_close_async (GFileEnumerator *enumerator, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_enumerator_close_async(enumerator, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_file_enumerator_close_async(enumerator::Ptr{GFileEnumerator}, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_enumerator_close_finish(enumerator, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_enumerator_close_finish (GFileEnumerator *enumerator, GAsyncResult *result, GError **error);
```
"""
function g_file_enumerator_close_finish(enumerator, result, error)
    @ccall libaravis.g_file_enumerator_close_finish(enumerator::Ptr{GFileEnumerator}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_enumerator_is_closed(enumerator)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_enumerator_is_closed (GFileEnumerator *enumerator);
```
"""
function g_file_enumerator_is_closed(enumerator)
    @ccall libaravis.g_file_enumerator_is_closed(enumerator::Ptr{GFileEnumerator})::gboolean
end

"""
    g_file_enumerator_has_pending(enumerator)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_enumerator_has_pending (GFileEnumerator *enumerator);
```
"""
function g_file_enumerator_has_pending(enumerator)
    @ccall libaravis.g_file_enumerator_has_pending(enumerator::Ptr{GFileEnumerator})::gboolean
end

"""
    g_file_enumerator_set_pending(enumerator, pending)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_enumerator_set_pending (GFileEnumerator *enumerator, gboolean pending);
```
"""
function g_file_enumerator_set_pending(enumerator, pending)
    @ccall libaravis.g_file_enumerator_set_pending(enumerator::Ptr{GFileEnumerator}, pending::gboolean)::Cvoid
end

"""
    g_file_enumerator_get_container(enumerator)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFile * g_file_enumerator_get_container (GFileEnumerator *enumerator);
```
"""
function g_file_enumerator_get_container(enumerator)
    @ccall libaravis.g_file_enumerator_get_container(enumerator::Ptr{GFileEnumerator})::Ptr{GFile}
end

"""
    g_file_enumerator_get_child(enumerator, info)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 GFile * g_file_enumerator_get_child (GFileEnumerator *enumerator, GFileInfo *info);
```
"""
function g_file_enumerator_get_child(enumerator, info)
    @ccall libaravis.g_file_enumerator_get_child(enumerator::Ptr{GFileEnumerator}, info::Ptr{GFileInfo})::Ptr{GFile}
end

"""
    g_file_enumerator_iterate(direnum, out_info, out_child, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_44 gboolean g_file_enumerator_iterate (GFileEnumerator *direnum, GFileInfo **out_info, GFile **out_child, GCancellable *cancellable, GError **error);
```
"""
function g_file_enumerator_iterate(direnum, out_info, out_child, cancellable, error)
    @ccall libaravis.g_file_enumerator_iterate(direnum::Ptr{GFileEnumerator}, out_info::Ptr{Ptr{GFileInfo}}, out_child::Ptr{Ptr{GFile}}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_file_icon_new(file)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIcon * g_file_icon_new (GFile *file);
```
"""
function g_file_icon_new(file)
    @ccall libaravis.g_file_icon_new(file::Ptr{GFile})::Ptr{GIcon}
end

"""
    g_file_icon_get_file(icon)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFile * g_file_icon_get_file (GFileIcon *icon);
```
"""
function g_file_icon_get_file(icon)
    @ccall libaravis.g_file_icon_get_file(icon::Ptr{GFileIcon})::Ptr{GFile}
end

"""
    g_file_info_new()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileInfo * g_file_info_new (void);
```
"""
function g_file_info_new()
    @ccall libaravis.g_file_info_new()::Ptr{GFileInfo}
end

"""
    g_file_info_dup(other)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileInfo * g_file_info_dup (GFileInfo *other);
```
"""
function g_file_info_dup(other)
    @ccall libaravis.g_file_info_dup(other::Ptr{GFileInfo})::Ptr{GFileInfo}
end

"""
    g_file_info_copy_into(src_info, dest_info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_info_copy_into (GFileInfo *src_info, GFileInfo *dest_info);
```
"""
function g_file_info_copy_into(src_info, dest_info)
    @ccall libaravis.g_file_info_copy_into(src_info::Ptr{GFileInfo}, dest_info::Ptr{GFileInfo})::Cvoid
end

"""
    g_file_info_has_attribute(info, attribute)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_info_has_attribute (GFileInfo *info, const char *attribute);
```
"""
function g_file_info_has_attribute(info, attribute)
    @ccall libaravis.g_file_info_has_attribute(info::Ptr{GFileInfo}, attribute::Cstring)::gboolean
end

"""
    g_file_info_has_namespace(info, name_space)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_info_has_namespace (GFileInfo *info, const char *name_space);
```
"""
function g_file_info_has_namespace(info, name_space)
    @ccall libaravis.g_file_info_has_namespace(info::Ptr{GFileInfo}, name_space::Cstring)::gboolean
end

"""
    g_file_info_list_attributes(info, name_space)

### Prototype
```c
GIO_AVAILABLE_IN_ALL char ** g_file_info_list_attributes (GFileInfo *info, const char *name_space);
```
"""
function g_file_info_list_attributes(info, name_space)
    @ccall libaravis.g_file_info_list_attributes(info::Ptr{GFileInfo}, name_space::Cstring)::Ptr{Cstring}
end

"""
    g_file_info_get_attribute_data(info, attribute, type, value_pp, status)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_info_get_attribute_data (GFileInfo *info, const char *attribute, GFileAttributeType *type, gpointer *value_pp, GFileAttributeStatus *status);
```
"""
function g_file_info_get_attribute_data(info, attribute, type, value_pp, status)
    @ccall libaravis.g_file_info_get_attribute_data(info::Ptr{GFileInfo}, attribute::Cstring, type::Ptr{GFileAttributeType}, value_pp::Ptr{gpointer}, status::Ptr{GFileAttributeStatus})::gboolean
end

"""
    g_file_info_get_attribute_type(info, attribute)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileAttributeType g_file_info_get_attribute_type (GFileInfo *info, const char *attribute);
```
"""
function g_file_info_get_attribute_type(info, attribute)
    @ccall libaravis.g_file_info_get_attribute_type(info::Ptr{GFileInfo}, attribute::Cstring)::GFileAttributeType
end

"""
    g_file_info_remove_attribute(info, attribute)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_info_remove_attribute (GFileInfo *info, const char *attribute);
```
"""
function g_file_info_remove_attribute(info, attribute)
    @ccall libaravis.g_file_info_remove_attribute(info::Ptr{GFileInfo}, attribute::Cstring)::Cvoid
end

"""
    g_file_info_get_attribute_status(info, attribute)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileAttributeStatus g_file_info_get_attribute_status (GFileInfo *info, const char *attribute);
```
"""
function g_file_info_get_attribute_status(info, attribute)
    @ccall libaravis.g_file_info_get_attribute_status(info::Ptr{GFileInfo}, attribute::Cstring)::GFileAttributeStatus
end

"""
    g_file_info_set_attribute_status(info, attribute, status)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_info_set_attribute_status (GFileInfo *info, const char *attribute, GFileAttributeStatus status);
```
"""
function g_file_info_set_attribute_status(info, attribute, status)
    @ccall libaravis.g_file_info_set_attribute_status(info::Ptr{GFileInfo}, attribute::Cstring, status::GFileAttributeStatus)::gboolean
end

"""
    g_file_info_get_attribute_as_string(info, attribute)

### Prototype
```c
GIO_AVAILABLE_IN_ALL char * g_file_info_get_attribute_as_string (GFileInfo *info, const char *attribute);
```
"""
function g_file_info_get_attribute_as_string(info, attribute)
    @ccall libaravis.g_file_info_get_attribute_as_string(info::Ptr{GFileInfo}, attribute::Cstring)::Cstring
end

"""
    g_file_info_get_attribute_string(info, attribute)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const char * g_file_info_get_attribute_string (GFileInfo *info, const char *attribute);
```
"""
function g_file_info_get_attribute_string(info, attribute)
    @ccall libaravis.g_file_info_get_attribute_string(info::Ptr{GFileInfo}, attribute::Cstring)::Cstring
end

"""
    g_file_info_get_attribute_byte_string(info, attribute)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const char * g_file_info_get_attribute_byte_string (GFileInfo *info, const char *attribute);
```
"""
function g_file_info_get_attribute_byte_string(info, attribute)
    @ccall libaravis.g_file_info_get_attribute_byte_string(info::Ptr{GFileInfo}, attribute::Cstring)::Cstring
end

"""
    g_file_info_get_attribute_boolean(info, attribute)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_info_get_attribute_boolean (GFileInfo *info, const char *attribute);
```
"""
function g_file_info_get_attribute_boolean(info, attribute)
    @ccall libaravis.g_file_info_get_attribute_boolean(info::Ptr{GFileInfo}, attribute::Cstring)::gboolean
end

"""
    g_file_info_get_attribute_uint32(info, attribute)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint32 g_file_info_get_attribute_uint32 (GFileInfo *info, const char *attribute);
```
"""
function g_file_info_get_attribute_uint32(info, attribute)
    @ccall libaravis.g_file_info_get_attribute_uint32(info::Ptr{GFileInfo}, attribute::Cstring)::guint32
end

"""
    g_file_info_get_attribute_int32(info, attribute)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gint32 g_file_info_get_attribute_int32 (GFileInfo *info, const char *attribute);
```
"""
function g_file_info_get_attribute_int32(info, attribute)
    @ccall libaravis.g_file_info_get_attribute_int32(info::Ptr{GFileInfo}, attribute::Cstring)::gint32
end

"""
    g_file_info_get_attribute_uint64(info, attribute)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint64 g_file_info_get_attribute_uint64 (GFileInfo *info, const char *attribute);
```
"""
function g_file_info_get_attribute_uint64(info, attribute)
    @ccall libaravis.g_file_info_get_attribute_uint64(info::Ptr{GFileInfo}, attribute::Cstring)::guint64
end

"""
    g_file_info_get_attribute_int64(info, attribute)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gint64 g_file_info_get_attribute_int64 (GFileInfo *info, const char *attribute);
```
"""
function g_file_info_get_attribute_int64(info, attribute)
    @ccall libaravis.g_file_info_get_attribute_int64(info::Ptr{GFileInfo}, attribute::Cstring)::gint64
end

"""
    g_file_info_get_attribute_object(info, attribute)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GObject * g_file_info_get_attribute_object (GFileInfo *info, const char *attribute);
```
"""
function g_file_info_get_attribute_object(info, attribute)
    @ccall libaravis.g_file_info_get_attribute_object(info::Ptr{GFileInfo}, attribute::Cstring)::Ptr{GObject}
end

"""
    g_file_info_get_attribute_stringv(info, attribute)

### Prototype
```c
GIO_AVAILABLE_IN_ALL char ** g_file_info_get_attribute_stringv (GFileInfo *info, const char *attribute);
```
"""
function g_file_info_get_attribute_stringv(info, attribute)
    @ccall libaravis.g_file_info_get_attribute_stringv(info::Ptr{GFileInfo}, attribute::Cstring)::Ptr{Cstring}
end

"""
    g_file_info_get_attribute_file_path(info, attribute)

### Prototype
```c
GIO_AVAILABLE_IN_2_78 const char * g_file_info_get_attribute_file_path (GFileInfo *info, const char *attribute);
```
"""
function g_file_info_get_attribute_file_path(info, attribute)
    @ccall libaravis.g_file_info_get_attribute_file_path(info::Ptr{GFileInfo}, attribute::Cstring)::Cstring
end

"""
    g_file_info_set_attribute(info, attribute, type, value_p)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_info_set_attribute (GFileInfo *info, const char *attribute, GFileAttributeType type, gpointer value_p);
```
"""
function g_file_info_set_attribute(info, attribute, type, value_p)
    @ccall libaravis.g_file_info_set_attribute(info::Ptr{GFileInfo}, attribute::Cstring, type::GFileAttributeType, value_p::gpointer)::Cvoid
end

"""
    g_file_info_set_attribute_string(info, attribute, attr_value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_info_set_attribute_string (GFileInfo *info, const char *attribute, const char *attr_value);
```
"""
function g_file_info_set_attribute_string(info, attribute, attr_value)
    @ccall libaravis.g_file_info_set_attribute_string(info::Ptr{GFileInfo}, attribute::Cstring, attr_value::Cstring)::Cvoid
end

"""
    g_file_info_set_attribute_byte_string(info, attribute, attr_value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_info_set_attribute_byte_string (GFileInfo *info, const char *attribute, const char *attr_value);
```
"""
function g_file_info_set_attribute_byte_string(info, attribute, attr_value)
    @ccall libaravis.g_file_info_set_attribute_byte_string(info::Ptr{GFileInfo}, attribute::Cstring, attr_value::Cstring)::Cvoid
end

"""
    g_file_info_set_attribute_boolean(info, attribute, attr_value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_info_set_attribute_boolean (GFileInfo *info, const char *attribute, gboolean attr_value);
```
"""
function g_file_info_set_attribute_boolean(info, attribute, attr_value)
    @ccall libaravis.g_file_info_set_attribute_boolean(info::Ptr{GFileInfo}, attribute::Cstring, attr_value::gboolean)::Cvoid
end

"""
    g_file_info_set_attribute_uint32(info, attribute, attr_value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_info_set_attribute_uint32 (GFileInfo *info, const char *attribute, guint32 attr_value);
```
"""
function g_file_info_set_attribute_uint32(info, attribute, attr_value)
    @ccall libaravis.g_file_info_set_attribute_uint32(info::Ptr{GFileInfo}, attribute::Cstring, attr_value::guint32)::Cvoid
end

"""
    g_file_info_set_attribute_int32(info, attribute, attr_value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_info_set_attribute_int32 (GFileInfo *info, const char *attribute, gint32 attr_value);
```
"""
function g_file_info_set_attribute_int32(info, attribute, attr_value)
    @ccall libaravis.g_file_info_set_attribute_int32(info::Ptr{GFileInfo}, attribute::Cstring, attr_value::gint32)::Cvoid
end

"""
    g_file_info_set_attribute_uint64(info, attribute, attr_value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_info_set_attribute_uint64 (GFileInfo *info, const char *attribute, guint64 attr_value);
```
"""
function g_file_info_set_attribute_uint64(info, attribute, attr_value)
    @ccall libaravis.g_file_info_set_attribute_uint64(info::Ptr{GFileInfo}, attribute::Cstring, attr_value::guint64)::Cvoid
end

"""
    g_file_info_set_attribute_int64(info, attribute, attr_value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_info_set_attribute_int64 (GFileInfo *info, const char *attribute, gint64 attr_value);
```
"""
function g_file_info_set_attribute_int64(info, attribute, attr_value)
    @ccall libaravis.g_file_info_set_attribute_int64(info::Ptr{GFileInfo}, attribute::Cstring, attr_value::gint64)::Cvoid
end

"""
    g_file_info_set_attribute_object(info, attribute, attr_value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_info_set_attribute_object (GFileInfo *info, const char *attribute, GObject *attr_value);
```
"""
function g_file_info_set_attribute_object(info, attribute, attr_value)
    @ccall libaravis.g_file_info_set_attribute_object(info::Ptr{GFileInfo}, attribute::Cstring, attr_value::Ptr{GObject})::Cvoid
end

"""
    g_file_info_set_attribute_stringv(info, attribute, attr_value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_info_set_attribute_stringv (GFileInfo *info, const char *attribute, char **attr_value);
```
"""
function g_file_info_set_attribute_stringv(info, attribute, attr_value)
    @ccall libaravis.g_file_info_set_attribute_stringv(info::Ptr{GFileInfo}, attribute::Cstring, attr_value::Ptr{Cstring})::Cvoid
end

"""
    g_file_info_set_attribute_file_path(info, attribute, attr_value)

### Prototype
```c
GIO_AVAILABLE_IN_2_78 void g_file_info_set_attribute_file_path (GFileInfo *info, const char *attribute, const char *attr_value);
```
"""
function g_file_info_set_attribute_file_path(info, attribute, attr_value)
    @ccall libaravis.g_file_info_set_attribute_file_path(info::Ptr{GFileInfo}, attribute::Cstring, attr_value::Cstring)::Cvoid
end

"""
    g_file_info_clear_status(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_info_clear_status (GFileInfo *info);
```
"""
function g_file_info_clear_status(info)
    @ccall libaravis.g_file_info_clear_status(info::Ptr{GFileInfo})::Cvoid
end

"""
    g_file_info_get_deletion_date(info)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 GDateTime * g_file_info_get_deletion_date (GFileInfo *info);
```
"""
function g_file_info_get_deletion_date(info)
    @ccall libaravis.g_file_info_get_deletion_date(info::Ptr{GFileInfo})::Ptr{GDateTime}
end

"""
    g_file_info_get_file_type(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileType g_file_info_get_file_type (GFileInfo *info);
```
"""
function g_file_info_get_file_type(info)
    @ccall libaravis.g_file_info_get_file_type(info::Ptr{GFileInfo})::GFileType
end

"""
    g_file_info_get_is_hidden(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_info_get_is_hidden (GFileInfo *info);
```
"""
function g_file_info_get_is_hidden(info)
    @ccall libaravis.g_file_info_get_is_hidden(info::Ptr{GFileInfo})::gboolean
end

"""
    g_file_info_get_is_backup(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_info_get_is_backup (GFileInfo *info);
```
"""
function g_file_info_get_is_backup(info)
    @ccall libaravis.g_file_info_get_is_backup(info::Ptr{GFileInfo})::gboolean
end

"""
    g_file_info_get_is_symlink(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_info_get_is_symlink (GFileInfo *info);
```
"""
function g_file_info_get_is_symlink(info)
    @ccall libaravis.g_file_info_get_is_symlink(info::Ptr{GFileInfo})::gboolean
end

"""
    g_file_info_get_name(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const char * g_file_info_get_name (GFileInfo *info);
```
"""
function g_file_info_get_name(info)
    @ccall libaravis.g_file_info_get_name(info::Ptr{GFileInfo})::Cstring
end

"""
    g_file_info_get_display_name(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const char * g_file_info_get_display_name (GFileInfo *info);
```
"""
function g_file_info_get_display_name(info)
    @ccall libaravis.g_file_info_get_display_name(info::Ptr{GFileInfo})::Cstring
end

"""
    g_file_info_get_edit_name(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const char * g_file_info_get_edit_name (GFileInfo *info);
```
"""
function g_file_info_get_edit_name(info)
    @ccall libaravis.g_file_info_get_edit_name(info::Ptr{GFileInfo})::Cstring
end

"""
    g_file_info_get_icon(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIcon * g_file_info_get_icon (GFileInfo *info);
```
"""
function g_file_info_get_icon(info)
    @ccall libaravis.g_file_info_get_icon(info::Ptr{GFileInfo})::Ptr{GIcon}
end

"""
    g_file_info_get_symbolic_icon(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIcon * g_file_info_get_symbolic_icon (GFileInfo *info);
```
"""
function g_file_info_get_symbolic_icon(info)
    @ccall libaravis.g_file_info_get_symbolic_icon(info::Ptr{GFileInfo})::Ptr{GIcon}
end

"""
    g_file_info_get_content_type(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const char * g_file_info_get_content_type (GFileInfo *info);
```
"""
function g_file_info_get_content_type(info)
    @ccall libaravis.g_file_info_get_content_type(info::Ptr{GFileInfo})::Cstring
end

"""
    g_file_info_get_size(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL goffset g_file_info_get_size (GFileInfo *info);
```
"""
function g_file_info_get_size(info)
    @ccall libaravis.g_file_info_get_size(info::Ptr{GFileInfo})::goffset
end

"""
    g_file_info_get_modification_time(info, result)

### Prototype
```c
GIO_DEPRECATED_IN_2_62_FOR(g_file_info_get_modification_date_time) void g_file_info_get_modification_time (GFileInfo *info, GTimeVal *result);
```
"""
function g_file_info_get_modification_time(info, result)
    @ccall libaravis.g_file_info_get_modification_time(info::Ptr{GFileInfo}, result::Ptr{GTimeVal})::Cvoid
end

"""
    g_file_info_get_modification_date_time(info)

### Prototype
```c
GIO_AVAILABLE_IN_2_62 GDateTime * g_file_info_get_modification_date_time (GFileInfo *info);
```
"""
function g_file_info_get_modification_date_time(info)
    @ccall libaravis.g_file_info_get_modification_date_time(info::Ptr{GFileInfo})::Ptr{GDateTime}
end

"""
    g_file_info_get_access_date_time(info)

### Prototype
```c
GIO_AVAILABLE_IN_2_70 GDateTime * g_file_info_get_access_date_time (GFileInfo *info);
```
"""
function g_file_info_get_access_date_time(info)
    @ccall libaravis.g_file_info_get_access_date_time(info::Ptr{GFileInfo})::Ptr{GDateTime}
end

"""
    g_file_info_get_creation_date_time(info)

### Prototype
```c
GIO_AVAILABLE_IN_2_70 GDateTime * g_file_info_get_creation_date_time (GFileInfo *info);
```
"""
function g_file_info_get_creation_date_time(info)
    @ccall libaravis.g_file_info_get_creation_date_time(info::Ptr{GFileInfo})::Ptr{GDateTime}
end

"""
    g_file_info_get_symlink_target(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const char * g_file_info_get_symlink_target (GFileInfo *info);
```
"""
function g_file_info_get_symlink_target(info)
    @ccall libaravis.g_file_info_get_symlink_target(info::Ptr{GFileInfo})::Cstring
end

"""
    g_file_info_get_etag(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const char * g_file_info_get_etag (GFileInfo *info);
```
"""
function g_file_info_get_etag(info)
    @ccall libaravis.g_file_info_get_etag(info::Ptr{GFileInfo})::Cstring
end

"""
    g_file_info_get_sort_order(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gint32 g_file_info_get_sort_order (GFileInfo *info);
```
"""
function g_file_info_get_sort_order(info)
    @ccall libaravis.g_file_info_get_sort_order(info::Ptr{GFileInfo})::gint32
end

"""
    g_file_info_set_attribute_mask(info, mask)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_info_set_attribute_mask (GFileInfo *info, GFileAttributeMatcher *mask);
```
"""
function g_file_info_set_attribute_mask(info, mask)
    @ccall libaravis.g_file_info_set_attribute_mask(info::Ptr{GFileInfo}, mask::Ptr{GFileAttributeMatcher})::Cvoid
end

"""
    g_file_info_unset_attribute_mask(info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_info_unset_attribute_mask (GFileInfo *info);
```
"""
function g_file_info_unset_attribute_mask(info)
    @ccall libaravis.g_file_info_unset_attribute_mask(info::Ptr{GFileInfo})::Cvoid
end

"""
    g_file_info_set_file_type(info, type)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_info_set_file_type (GFileInfo *info, GFileType type);
```
"""
function g_file_info_set_file_type(info, type)
    @ccall libaravis.g_file_info_set_file_type(info::Ptr{GFileInfo}, type::GFileType)::Cvoid
end

"""
    g_file_info_set_is_hidden(info, is_hidden)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_info_set_is_hidden (GFileInfo *info, gboolean is_hidden);
```
"""
function g_file_info_set_is_hidden(info, is_hidden)
    @ccall libaravis.g_file_info_set_is_hidden(info::Ptr{GFileInfo}, is_hidden::gboolean)::Cvoid
end

"""
    g_file_info_set_is_symlink(info, is_symlink)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_info_set_is_symlink (GFileInfo *info, gboolean is_symlink);
```
"""
function g_file_info_set_is_symlink(info, is_symlink)
    @ccall libaravis.g_file_info_set_is_symlink(info::Ptr{GFileInfo}, is_symlink::gboolean)::Cvoid
end

"""
    g_file_info_set_name(info, name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_info_set_name (GFileInfo *info, const char *name);
```
"""
function g_file_info_set_name(info, name)
    @ccall libaravis.g_file_info_set_name(info::Ptr{GFileInfo}, name::Cstring)::Cvoid
end

"""
    g_file_info_set_display_name(info, display_name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_info_set_display_name (GFileInfo *info, const char *display_name);
```
"""
function g_file_info_set_display_name(info, display_name)
    @ccall libaravis.g_file_info_set_display_name(info::Ptr{GFileInfo}, display_name::Cstring)::Cvoid
end

"""
    g_file_info_set_edit_name(info, edit_name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_info_set_edit_name (GFileInfo *info, const char *edit_name);
```
"""
function g_file_info_set_edit_name(info, edit_name)
    @ccall libaravis.g_file_info_set_edit_name(info::Ptr{GFileInfo}, edit_name::Cstring)::Cvoid
end

"""
    g_file_info_set_icon(info, icon)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_info_set_icon (GFileInfo *info, GIcon *icon);
```
"""
function g_file_info_set_icon(info, icon)
    @ccall libaravis.g_file_info_set_icon(info::Ptr{GFileInfo}, icon::Ptr{GIcon})::Cvoid
end

"""
    g_file_info_set_symbolic_icon(info, icon)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_info_set_symbolic_icon (GFileInfo *info, GIcon *icon);
```
"""
function g_file_info_set_symbolic_icon(info, icon)
    @ccall libaravis.g_file_info_set_symbolic_icon(info::Ptr{GFileInfo}, icon::Ptr{GIcon})::Cvoid
end

"""
    g_file_info_set_content_type(info, content_type)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_info_set_content_type (GFileInfo *info, const char *content_type);
```
"""
function g_file_info_set_content_type(info, content_type)
    @ccall libaravis.g_file_info_set_content_type(info::Ptr{GFileInfo}, content_type::Cstring)::Cvoid
end

"""
    g_file_info_set_size(info, size)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_info_set_size (GFileInfo *info, goffset size);
```
"""
function g_file_info_set_size(info, size)
    @ccall libaravis.g_file_info_set_size(info::Ptr{GFileInfo}, size::goffset)::Cvoid
end

"""
    g_file_info_set_modification_time(info, mtime)

### Prototype
```c
GIO_DEPRECATED_IN_2_62_FOR(g_file_info_set_modification_date_time) void g_file_info_set_modification_time (GFileInfo *info, GTimeVal *mtime);
```
"""
function g_file_info_set_modification_time(info, mtime)
    @ccall libaravis.g_file_info_set_modification_time(info::Ptr{GFileInfo}, mtime::Ptr{GTimeVal})::Cvoid
end

"""
    g_file_info_set_modification_date_time(info, mtime)

### Prototype
```c
GIO_AVAILABLE_IN_2_62 void g_file_info_set_modification_date_time (GFileInfo *info, GDateTime *mtime);
```
"""
function g_file_info_set_modification_date_time(info, mtime)
    @ccall libaravis.g_file_info_set_modification_date_time(info::Ptr{GFileInfo}, mtime::Ptr{GDateTime})::Cvoid
end

"""
    g_file_info_set_access_date_time(info, atime)

### Prototype
```c
GIO_AVAILABLE_IN_2_70 void g_file_info_set_access_date_time (GFileInfo *info, GDateTime *atime);
```
"""
function g_file_info_set_access_date_time(info, atime)
    @ccall libaravis.g_file_info_set_access_date_time(info::Ptr{GFileInfo}, atime::Ptr{GDateTime})::Cvoid
end

"""
    g_file_info_set_creation_date_time(info, creation_time)

### Prototype
```c
GIO_AVAILABLE_IN_2_70 void g_file_info_set_creation_date_time (GFileInfo *info, GDateTime *creation_time);
```
"""
function g_file_info_set_creation_date_time(info, creation_time)
    @ccall libaravis.g_file_info_set_creation_date_time(info::Ptr{GFileInfo}, creation_time::Ptr{GDateTime})::Cvoid
end

"""
    g_file_info_set_symlink_target(info, symlink_target)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_info_set_symlink_target (GFileInfo *info, const char *symlink_target);
```
"""
function g_file_info_set_symlink_target(info, symlink_target)
    @ccall libaravis.g_file_info_set_symlink_target(info::Ptr{GFileInfo}, symlink_target::Cstring)::Cvoid
end

"""
    g_file_info_set_sort_order(info, sort_order)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_info_set_sort_order (GFileInfo *info, gint32 sort_order);
```
"""
function g_file_info_set_sort_order(info, sort_order)
    @ccall libaravis.g_file_info_set_sort_order(info::Ptr{GFileInfo}, sort_order::gint32)::Cvoid
end

"""
    g_file_attribute_matcher_new(attributes)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileAttributeMatcher *g_file_attribute_matcher_new (const char *attributes);
```
"""
function g_file_attribute_matcher_new(attributes)
    @ccall libaravis.g_file_attribute_matcher_new(attributes::Cstring)::Ptr{GFileAttributeMatcher}
end

"""
    g_file_attribute_matcher_ref(matcher)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileAttributeMatcher *g_file_attribute_matcher_ref (GFileAttributeMatcher *matcher);
```
"""
function g_file_attribute_matcher_ref(matcher)
    @ccall libaravis.g_file_attribute_matcher_ref(matcher::Ptr{GFileAttributeMatcher})::Ptr{GFileAttributeMatcher}
end

"""
    g_file_attribute_matcher_unref(matcher)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_attribute_matcher_unref (GFileAttributeMatcher *matcher);
```
"""
function g_file_attribute_matcher_unref(matcher)
    @ccall libaravis.g_file_attribute_matcher_unref(matcher::Ptr{GFileAttributeMatcher})::Cvoid
end

"""
    g_file_attribute_matcher_subtract(matcher, subtract)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileAttributeMatcher *g_file_attribute_matcher_subtract (GFileAttributeMatcher *matcher, GFileAttributeMatcher *subtract);
```
"""
function g_file_attribute_matcher_subtract(matcher, subtract)
    @ccall libaravis.g_file_attribute_matcher_subtract(matcher::Ptr{GFileAttributeMatcher}, subtract::Ptr{GFileAttributeMatcher})::Ptr{GFileAttributeMatcher}
end

"""
    g_file_attribute_matcher_matches(matcher, attribute)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_attribute_matcher_matches (GFileAttributeMatcher *matcher, const char *attribute);
```
"""
function g_file_attribute_matcher_matches(matcher, attribute)
    @ccall libaravis.g_file_attribute_matcher_matches(matcher::Ptr{GFileAttributeMatcher}, attribute::Cstring)::gboolean
end

"""
    g_file_attribute_matcher_matches_only(matcher, attribute)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_attribute_matcher_matches_only (GFileAttributeMatcher *matcher, const char *attribute);
```
"""
function g_file_attribute_matcher_matches_only(matcher, attribute)
    @ccall libaravis.g_file_attribute_matcher_matches_only(matcher::Ptr{GFileAttributeMatcher}, attribute::Cstring)::gboolean
end

"""
    g_file_attribute_matcher_enumerate_namespace(matcher, ns)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_attribute_matcher_enumerate_namespace (GFileAttributeMatcher *matcher, const char *ns);
```
"""
function g_file_attribute_matcher_enumerate_namespace(matcher, ns)
    @ccall libaravis.g_file_attribute_matcher_enumerate_namespace(matcher::Ptr{GFileAttributeMatcher}, ns::Cstring)::gboolean
end

"""
    g_file_attribute_matcher_enumerate_next(matcher)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const char * g_file_attribute_matcher_enumerate_next (GFileAttributeMatcher *matcher);
```
"""
function g_file_attribute_matcher_enumerate_next(matcher)
    @ccall libaravis.g_file_attribute_matcher_enumerate_next(matcher::Ptr{GFileAttributeMatcher})::Cstring
end

"""
    g_file_attribute_matcher_to_string(matcher)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 char * g_file_attribute_matcher_to_string (GFileAttributeMatcher *matcher);
```
"""
function g_file_attribute_matcher_to_string(matcher)
    @ccall libaravis.g_file_attribute_matcher_to_string(matcher::Ptr{GFileAttributeMatcher})::Cstring
end

"""
    g_file_input_stream_query_info(stream, attributes, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileInfo *g_file_input_stream_query_info (GFileInputStream *stream, const char *attributes, GCancellable *cancellable, GError **error);
```
"""
function g_file_input_stream_query_info(stream, attributes, cancellable, error)
    @ccall libaravis.g_file_input_stream_query_info(stream::Ptr{GFileInputStream}, attributes::Cstring, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GFileInfo}
end

"""
    g_file_input_stream_query_info_async(stream, attributes, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_input_stream_query_info_async (GFileInputStream *stream, const char *attributes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_input_stream_query_info_async(stream, attributes, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_file_input_stream_query_info_async(stream::Ptr{GFileInputStream}, attributes::Cstring, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_input_stream_query_info_finish(stream, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileInfo *g_file_input_stream_query_info_finish (GFileInputStream *stream, GAsyncResult *result, GError **error);
```
"""
function g_file_input_stream_query_info_finish(stream, result, error)
    @ccall libaravis.g_file_input_stream_query_info_finish(stream::Ptr{GFileInputStream}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GFileInfo}
end

"""
    g_io_error_from_errno(err_no)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIOErrorEnum g_io_error_from_errno (gint err_no);
```
"""
function g_io_error_from_errno(err_no)
    @ccall libaravis.g_io_error_from_errno(err_no::gint)::GIOErrorEnum
end

"""
    g_io_error_from_file_error(file_error)

### Prototype
```c
GIO_AVAILABLE_IN_2_74 GIOErrorEnum g_io_error_from_file_error (GFileError file_error);
```
"""
function g_io_error_from_file_error(file_error)
    @ccall libaravis.g_io_error_from_file_error(file_error::GFileError)::GIOErrorEnum
end

"""
    g_io_stream_get_input_stream(stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GInputStream * g_io_stream_get_input_stream (GIOStream *stream);
```
"""
function g_io_stream_get_input_stream(stream)
    @ccall libaravis.g_io_stream_get_input_stream(stream::Ptr{GIOStream})::Ptr{GInputStream}
end

"""
    g_io_stream_get_output_stream(stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GOutputStream *g_io_stream_get_output_stream (GIOStream *stream);
```
"""
function g_io_stream_get_output_stream(stream)
    @ccall libaravis.g_io_stream_get_output_stream(stream::Ptr{GIOStream})::Ptr{GOutputStream}
end

"""
    g_io_stream_splice_async(stream1, stream2, flags, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_io_stream_splice_async (GIOStream *stream1, GIOStream *stream2, GIOStreamSpliceFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_io_stream_splice_async(stream1, stream2, flags, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_io_stream_splice_async(stream1::Ptr{GIOStream}, stream2::Ptr{GIOStream}, flags::GIOStreamSpliceFlags, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_io_stream_splice_finish(result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_io_stream_splice_finish (GAsyncResult *result, GError **error);
```
"""
function g_io_stream_splice_finish(result, error)
    @ccall libaravis.g_io_stream_splice_finish(result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_io_stream_close(stream, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_io_stream_close (GIOStream *stream, GCancellable *cancellable, GError **error);
```
"""
function g_io_stream_close(stream, cancellable, error)
    @ccall libaravis.g_io_stream_close(stream::Ptr{GIOStream}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_io_stream_close_async(stream, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_io_stream_close_async (GIOStream *stream, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_io_stream_close_async(stream, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_io_stream_close_async(stream::Ptr{GIOStream}, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_io_stream_close_finish(stream, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_io_stream_close_finish (GIOStream *stream, GAsyncResult *result, GError **error);
```
"""
function g_io_stream_close_finish(stream, result, error)
    @ccall libaravis.g_io_stream_close_finish(stream::Ptr{GIOStream}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_io_stream_is_closed(stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_io_stream_is_closed (GIOStream *stream);
```
"""
function g_io_stream_is_closed(stream)
    @ccall libaravis.g_io_stream_is_closed(stream::Ptr{GIOStream})::gboolean
end

"""
    g_io_stream_has_pending(stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_io_stream_has_pending (GIOStream *stream);
```
"""
function g_io_stream_has_pending(stream)
    @ccall libaravis.g_io_stream_has_pending(stream::Ptr{GIOStream})::gboolean
end

"""
    g_io_stream_set_pending(stream, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_io_stream_set_pending (GIOStream *stream, GError **error);
```
"""
function g_io_stream_set_pending(stream, error)
    @ccall libaravis.g_io_stream_set_pending(stream::Ptr{GIOStream}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_io_stream_clear_pending(stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_io_stream_clear_pending (GIOStream *stream);
```
"""
function g_io_stream_clear_pending(stream)
    @ccall libaravis.g_io_stream_clear_pending(stream::Ptr{GIOStream})::Cvoid
end

"""
    g_file_io_stream_query_info(stream, attributes, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileInfo *g_file_io_stream_query_info (GFileIOStream *stream, const char *attributes, GCancellable *cancellable, GError **error);
```
"""
function g_file_io_stream_query_info(stream, attributes, cancellable, error)
    @ccall libaravis.g_file_io_stream_query_info(stream::Ptr{GFileIOStream}, attributes::Cstring, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GFileInfo}
end

"""
    g_file_io_stream_query_info_async(stream, attributes, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_io_stream_query_info_async (GFileIOStream *stream, const char *attributes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_io_stream_query_info_async(stream, attributes, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_file_io_stream_query_info_async(stream::Ptr{GFileIOStream}, attributes::Cstring, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_io_stream_query_info_finish(stream, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileInfo *g_file_io_stream_query_info_finish (GFileIOStream *stream, GAsyncResult *result, GError **error);
```
"""
function g_file_io_stream_query_info_finish(stream, result, error)
    @ccall libaravis.g_file_io_stream_query_info_finish(stream::Ptr{GFileIOStream}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GFileInfo}
end

"""
    g_file_io_stream_get_etag(stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL char * g_file_io_stream_get_etag (GFileIOStream *stream);
```
"""
function g_file_io_stream_get_etag(stream)
    @ccall libaravis.g_file_io_stream_get_etag(stream::Ptr{GFileIOStream})::Cstring
end

"""
    g_file_monitor_cancel(monitor)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_monitor_cancel (GFileMonitor *monitor);
```
"""
function g_file_monitor_cancel(monitor)
    @ccall libaravis.g_file_monitor_cancel(monitor::Ptr{GFileMonitor})::gboolean
end

"""
    g_file_monitor_is_cancelled(monitor)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_file_monitor_is_cancelled (GFileMonitor *monitor);
```
"""
function g_file_monitor_is_cancelled(monitor)
    @ccall libaravis.g_file_monitor_is_cancelled(monitor::Ptr{GFileMonitor})::gboolean
end

"""
    g_file_monitor_set_rate_limit(monitor, limit_msecs)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_monitor_set_rate_limit (GFileMonitor *monitor, gint limit_msecs);
```
"""
function g_file_monitor_set_rate_limit(monitor, limit_msecs)
    @ccall libaravis.g_file_monitor_set_rate_limit(monitor::Ptr{GFileMonitor}, limit_msecs::gint)::Cvoid
end

"""
    g_file_monitor_emit_event(monitor, child, other_file, event_type)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_monitor_emit_event (GFileMonitor *monitor, GFile *child, GFile *other_file, GFileMonitorEvent event_type);
```
"""
function g_file_monitor_emit_event(monitor, child, other_file, event_type)
    @ccall libaravis.g_file_monitor_emit_event(monitor::Ptr{GFileMonitor}, child::Ptr{GFile}, other_file::Ptr{GFile}, event_type::GFileMonitorEvent)::Cvoid
end

"""
    g_filename_completer_new()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFilenameCompleter *g_filename_completer_new (void);
```
"""
function g_filename_completer_new()
    @ccall libaravis.g_filename_completer_new()::Ptr{GFilenameCompleter}
end

"""
    g_filename_completer_get_completion_suffix(completer, initial_text)

### Prototype
```c
GIO_AVAILABLE_IN_ALL char * g_filename_completer_get_completion_suffix (GFilenameCompleter *completer, const char *initial_text);
```
"""
function g_filename_completer_get_completion_suffix(completer, initial_text)
    @ccall libaravis.g_filename_completer_get_completion_suffix(completer::Ptr{GFilenameCompleter}, initial_text::Cstring)::Cstring
end

"""
    g_filename_completer_get_completions(completer, initial_text)

### Prototype
```c
GIO_AVAILABLE_IN_ALL char ** g_filename_completer_get_completions (GFilenameCompleter *completer, const char *initial_text);
```
"""
function g_filename_completer_get_completions(completer, initial_text)
    @ccall libaravis.g_filename_completer_get_completions(completer::Ptr{GFilenameCompleter}, initial_text::Cstring)::Ptr{Cstring}
end

"""
    g_filename_completer_set_dirs_only(completer, dirs_only)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_filename_completer_set_dirs_only (GFilenameCompleter *completer, gboolean dirs_only);
```
"""
function g_filename_completer_set_dirs_only(completer, dirs_only)
    @ccall libaravis.g_filename_completer_set_dirs_only(completer::Ptr{GFilenameCompleter}, dirs_only::gboolean)::Cvoid
end

"""
    g_file_output_stream_query_info(stream, attributes, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileInfo *g_file_output_stream_query_info (GFileOutputStream *stream, const char *attributes, GCancellable *cancellable, GError **error);
```
"""
function g_file_output_stream_query_info(stream, attributes, cancellable, error)
    @ccall libaravis.g_file_output_stream_query_info(stream::Ptr{GFileOutputStream}, attributes::Cstring, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GFileInfo}
end

"""
    g_file_output_stream_query_info_async(stream, attributes, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_file_output_stream_query_info_async (GFileOutputStream *stream, const char *attributes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_file_output_stream_query_info_async(stream, attributes, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_file_output_stream_query_info_async(stream::Ptr{GFileOutputStream}, attributes::Cstring, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_file_output_stream_query_info_finish(stream, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileInfo *g_file_output_stream_query_info_finish (GFileOutputStream *stream, GAsyncResult *result, GError **error);
```
"""
function g_file_output_stream_query_info_finish(stream, result, error)
    @ccall libaravis.g_file_output_stream_query_info_finish(stream::Ptr{GFileOutputStream}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GFileInfo}
end

"""
    g_file_output_stream_get_etag(stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL char * g_file_output_stream_get_etag (GFileOutputStream *stream);
```
"""
function g_file_output_stream_get_etag(stream)
    @ccall libaravis.g_file_output_stream_get_etag(stream::Ptr{GFileOutputStream})::Cstring
end

"""
    g_inet_address_new_from_string(string)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GInetAddress * g_inet_address_new_from_string (const gchar *string);
```
"""
function g_inet_address_new_from_string(string)
    @ccall libaravis.g_inet_address_new_from_string(string::Ptr{gchar})::Ptr{GInetAddress}
end

"""
    g_inet_address_new_from_bytes(bytes, family)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GInetAddress * g_inet_address_new_from_bytes (const guint8 *bytes, GSocketFamily family);
```
"""
function g_inet_address_new_from_bytes(bytes, family)
    @ccall libaravis.g_inet_address_new_from_bytes(bytes::Ptr{guint8}, family::GSocketFamily)::Ptr{GInetAddress}
end

"""
    g_inet_address_new_loopback(family)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GInetAddress * g_inet_address_new_loopback (GSocketFamily family);
```
"""
function g_inet_address_new_loopback(family)
    @ccall libaravis.g_inet_address_new_loopback(family::GSocketFamily)::Ptr{GInetAddress}
end

"""
    g_inet_address_new_from_bytes_with_ipv6_info(bytes, family, flowinfo, scope_id)

### Prototype
```c
GIO_AVAILABLE_IN_2_86 GInetAddress * g_inet_address_new_from_bytes_with_ipv6_info (const guint8 *bytes, GSocketFamily family, guint32 flowinfo, guint32 scope_id);
```
"""
function g_inet_address_new_from_bytes_with_ipv6_info(bytes, family, flowinfo, scope_id)
    @ccall libaravis.g_inet_address_new_from_bytes_with_ipv6_info(bytes::Ptr{guint8}, family::GSocketFamily, flowinfo::guint32, scope_id::guint32)::Ptr{GInetAddress}
end

"""
    g_inet_address_new_any(family)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GInetAddress * g_inet_address_new_any (GSocketFamily family);
```
"""
function g_inet_address_new_any(family)
    @ccall libaravis.g_inet_address_new_any(family::GSocketFamily)::Ptr{GInetAddress}
end

"""
    g_inet_address_equal(address, other_address)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_inet_address_equal (GInetAddress *address, GInetAddress *other_address);
```
"""
function g_inet_address_equal(address, other_address)
    @ccall libaravis.g_inet_address_equal(address::Ptr{GInetAddress}, other_address::Ptr{GInetAddress})::gboolean
end

"""
    g_inet_address_to_string(address)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gchar * g_inet_address_to_string (GInetAddress *address);
```
"""
function g_inet_address_to_string(address)
    @ccall libaravis.g_inet_address_to_string(address::Ptr{GInetAddress})::Ptr{gchar}
end

"""
    g_inet_address_to_bytes(address)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const guint8 * g_inet_address_to_bytes (GInetAddress *address);
```
"""
function g_inet_address_to_bytes(address)
    @ccall libaravis.g_inet_address_to_bytes(address::Ptr{GInetAddress})::Ptr{guint8}
end

"""
    g_inet_address_get_native_size(address)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gsize g_inet_address_get_native_size (GInetAddress *address);
```
"""
function g_inet_address_get_native_size(address)
    @ccall libaravis.g_inet_address_get_native_size(address::Ptr{GInetAddress})::gsize
end

"""
    g_inet_address_get_family(address)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketFamily g_inet_address_get_family (GInetAddress *address);
```
"""
function g_inet_address_get_family(address)
    @ccall libaravis.g_inet_address_get_family(address::Ptr{GInetAddress})::GSocketFamily
end

"""
    g_inet_address_get_is_any(address)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_inet_address_get_is_any (GInetAddress *address);
```
"""
function g_inet_address_get_is_any(address)
    @ccall libaravis.g_inet_address_get_is_any(address::Ptr{GInetAddress})::gboolean
end

"""
    g_inet_address_get_is_loopback(address)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_inet_address_get_is_loopback (GInetAddress *address);
```
"""
function g_inet_address_get_is_loopback(address)
    @ccall libaravis.g_inet_address_get_is_loopback(address::Ptr{GInetAddress})::gboolean
end

"""
    g_inet_address_get_is_link_local(address)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_inet_address_get_is_link_local (GInetAddress *address);
```
"""
function g_inet_address_get_is_link_local(address)
    @ccall libaravis.g_inet_address_get_is_link_local(address::Ptr{GInetAddress})::gboolean
end

"""
    g_inet_address_get_is_site_local(address)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_inet_address_get_is_site_local (GInetAddress *address);
```
"""
function g_inet_address_get_is_site_local(address)
    @ccall libaravis.g_inet_address_get_is_site_local(address::Ptr{GInetAddress})::gboolean
end

"""
    g_inet_address_get_is_multicast(address)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_inet_address_get_is_multicast (GInetAddress *address);
```
"""
function g_inet_address_get_is_multicast(address)
    @ccall libaravis.g_inet_address_get_is_multicast(address::Ptr{GInetAddress})::gboolean
end

"""
    g_inet_address_get_is_mc_global(address)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_inet_address_get_is_mc_global (GInetAddress *address);
```
"""
function g_inet_address_get_is_mc_global(address)
    @ccall libaravis.g_inet_address_get_is_mc_global(address::Ptr{GInetAddress})::gboolean
end

"""
    g_inet_address_get_is_mc_link_local(address)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_inet_address_get_is_mc_link_local (GInetAddress *address);
```
"""
function g_inet_address_get_is_mc_link_local(address)
    @ccall libaravis.g_inet_address_get_is_mc_link_local(address::Ptr{GInetAddress})::gboolean
end

"""
    g_inet_address_get_is_mc_node_local(address)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_inet_address_get_is_mc_node_local (GInetAddress *address);
```
"""
function g_inet_address_get_is_mc_node_local(address)
    @ccall libaravis.g_inet_address_get_is_mc_node_local(address::Ptr{GInetAddress})::gboolean
end

"""
    g_inet_address_get_is_mc_org_local(address)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_inet_address_get_is_mc_org_local (GInetAddress *address);
```
"""
function g_inet_address_get_is_mc_org_local(address)
    @ccall libaravis.g_inet_address_get_is_mc_org_local(address::Ptr{GInetAddress})::gboolean
end

"""
    g_inet_address_get_is_mc_site_local(address)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_inet_address_get_is_mc_site_local (GInetAddress *address);
```
"""
function g_inet_address_get_is_mc_site_local(address)
    @ccall libaravis.g_inet_address_get_is_mc_site_local(address::Ptr{GInetAddress})::gboolean
end

"""
    g_inet_address_get_scope_id(address)

### Prototype
```c
GIO_AVAILABLE_IN_2_86 guint32 g_inet_address_get_scope_id (GInetAddress *address);
```
"""
function g_inet_address_get_scope_id(address)
    @ccall libaravis.g_inet_address_get_scope_id(address::Ptr{GInetAddress})::guint32
end

"""
    g_inet_address_get_flowinfo(address)

### Prototype
```c
GIO_AVAILABLE_IN_2_86 guint32 g_inet_address_get_flowinfo (GInetAddress *address);
```
"""
function g_inet_address_get_flowinfo(address)
    @ccall libaravis.g_inet_address_get_flowinfo(address::Ptr{GInetAddress})::guint32
end

"""
    g_inet_address_mask_new(addr, length, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GInetAddressMask *g_inet_address_mask_new (GInetAddress *addr, guint length, GError **error);
```
"""
function g_inet_address_mask_new(addr, length, error)
    @ccall libaravis.g_inet_address_mask_new(addr::Ptr{GInetAddress}, length::guint, error::Ptr{Ptr{GError}})::Ptr{GInetAddressMask}
end

"""
    g_inet_address_mask_new_from_string(mask_string, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GInetAddressMask *g_inet_address_mask_new_from_string (const gchar *mask_string, GError **error);
```
"""
function g_inet_address_mask_new_from_string(mask_string, error)
    @ccall libaravis.g_inet_address_mask_new_from_string(mask_string::Ptr{gchar}, error::Ptr{Ptr{GError}})::Ptr{GInetAddressMask}
end

"""
    g_inet_address_mask_to_string(mask)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 gchar *g_inet_address_mask_to_string (GInetAddressMask *mask);
```
"""
function g_inet_address_mask_to_string(mask)
    @ccall libaravis.g_inet_address_mask_to_string(mask::Ptr{GInetAddressMask})::Ptr{gchar}
end

"""
    g_inet_address_mask_get_family(mask)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GSocketFamily g_inet_address_mask_get_family (GInetAddressMask *mask);
```
"""
function g_inet_address_mask_get_family(mask)
    @ccall libaravis.g_inet_address_mask_get_family(mask::Ptr{GInetAddressMask})::GSocketFamily
end

"""
    g_inet_address_mask_get_address(mask)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GInetAddress *g_inet_address_mask_get_address (GInetAddressMask *mask);
```
"""
function g_inet_address_mask_get_address(mask)
    @ccall libaravis.g_inet_address_mask_get_address(mask::Ptr{GInetAddressMask})::Ptr{GInetAddress}
end

"""
    g_inet_address_mask_get_length(mask)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 guint g_inet_address_mask_get_length (GInetAddressMask *mask);
```
"""
function g_inet_address_mask_get_length(mask)
    @ccall libaravis.g_inet_address_mask_get_length(mask::Ptr{GInetAddressMask})::guint
end

"""
    g_inet_address_mask_matches(mask, address)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 gboolean g_inet_address_mask_matches (GInetAddressMask *mask, GInetAddress *address);
```
"""
function g_inet_address_mask_matches(mask, address)
    @ccall libaravis.g_inet_address_mask_matches(mask::Ptr{GInetAddressMask}, address::Ptr{GInetAddress})::gboolean
end

"""
    g_inet_address_mask_equal(mask, mask2)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 gboolean g_inet_address_mask_equal (GInetAddressMask *mask, GInetAddressMask *mask2);
```
"""
function g_inet_address_mask_equal(mask, mask2)
    @ccall libaravis.g_inet_address_mask_equal(mask::Ptr{GInetAddressMask}, mask2::Ptr{GInetAddressMask})::gboolean
end

"""
    g_socket_address_get_family(address)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketFamily g_socket_address_get_family (GSocketAddress *address);
```
"""
function g_socket_address_get_family(address)
    @ccall libaravis.g_socket_address_get_family(address::Ptr{GSocketAddress})::GSocketFamily
end

"""
    g_socket_address_new_from_native(native, len)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketAddress * g_socket_address_new_from_native (gpointer native, gsize len);
```
"""
function g_socket_address_new_from_native(native, len)
    @ccall libaravis.g_socket_address_new_from_native(native::gpointer, len::gsize)::Ptr{GSocketAddress}
end

"""
    g_socket_address_to_native(address, dest, destlen, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_socket_address_to_native (GSocketAddress *address, gpointer dest, gsize destlen, GError **error);
```
"""
function g_socket_address_to_native(address, dest, destlen, error)
    @ccall libaravis.g_socket_address_to_native(address::Ptr{GSocketAddress}, dest::gpointer, destlen::gsize, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_socket_address_get_native_size(address)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gssize g_socket_address_get_native_size (GSocketAddress *address);
```
"""
function g_socket_address_get_native_size(address)
    @ccall libaravis.g_socket_address_get_native_size(address::Ptr{GSocketAddress})::gssize
end

"""
    g_inet_socket_address_new(address, port)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketAddress *g_inet_socket_address_new (GInetAddress *address, guint16 port);
```
"""
function g_inet_socket_address_new(address, port)
    @ccall libaravis.g_inet_socket_address_new(address::Ptr{GInetAddress}, port::guint16)::Ptr{GSocketAddress}
end

"""
    g_inet_socket_address_new_from_string(address, port)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 GSocketAddress *g_inet_socket_address_new_from_string (const char *address, guint port);
```
"""
function g_inet_socket_address_new_from_string(address, port)
    @ccall libaravis.g_inet_socket_address_new_from_string(address::Cstring, port::guint)::Ptr{GSocketAddress}
end

"""
    g_inet_socket_address_get_address(address)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GInetAddress * g_inet_socket_address_get_address (GInetSocketAddress *address);
```
"""
function g_inet_socket_address_get_address(address)
    @ccall libaravis.g_inet_socket_address_get_address(address::Ptr{GInetSocketAddress})::Ptr{GInetAddress}
end

"""
    g_inet_socket_address_get_port(address)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint16 g_inet_socket_address_get_port (GInetSocketAddress *address);
```
"""
function g_inet_socket_address_get_port(address)
    @ccall libaravis.g_inet_socket_address_get_port(address::Ptr{GInetSocketAddress})::guint16
end

"""
    g_inet_socket_address_get_flowinfo(address)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 guint32 g_inet_socket_address_get_flowinfo (GInetSocketAddress *address);
```
"""
function g_inet_socket_address_get_flowinfo(address)
    @ccall libaravis.g_inet_socket_address_get_flowinfo(address::Ptr{GInetSocketAddress})::guint32
end

"""
    g_inet_socket_address_get_scope_id(address)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 guint32 g_inet_socket_address_get_scope_id (GInetSocketAddress *address);
```
"""
function g_inet_socket_address_get_scope_id(address)
    @ccall libaravis.g_inet_socket_address_get_scope_id(address::Ptr{GInetSocketAddress})::guint32
end

"""
    GModuleFlags

[`GModuleFlags`](@ref): \\_MODULE\\_BIND\\_LAZY: specifies that symbols are only resolved when needed. The default action is to bind all symbols when the module is loaded. \\_MODULE\\_BIND\\_LOCAL: specifies that symbols in the module should not be added to the global name space. The default action on most platforms is to place symbols in the module in the global name space, which may cause conflicts with existing symbols. \\_MODULE\\_BIND\\_MASK: mask for all flags.

Flags passed to [`g_module_open`](@ref)(). Note that these flags are not supported on all platforms.
"""
@cenum GModuleFlags::UInt32 begin
    G_MODULE_BIND_LAZY = 1
    G_MODULE_BIND_LOCAL = 2
    G_MODULE_BIND_MASK = 3
end

const _GModule = Cvoid

const GModule = _GModule

# typedef const gchar * ( * GModuleCheckInit ) ( GModule * module )
const GModuleCheckInit = Ptr{Cvoid}

# typedef void ( * GModuleUnload ) ( GModule * module )
const GModuleUnload = Ptr{Cvoid}

"""
    GModuleError

[`GModuleError`](@ref): \\_MODULE\\_ERROR\\_FAILED: there was an error loading or opening a module file \\_MODULE\\_ERROR\\_CHECK\\_FAILED: a module returned an error from its `g\\_module\\_check\\_init()` function

Errors returned by [`g_module_open_full`](@ref)().

Since: 2.70
"""
@cenum GModuleError::UInt32 begin
    G_MODULE_ERROR_FAILED = 0
    G_MODULE_ERROR_CHECK_FAILED = 1
end

"""
    g_module_supported()

### Prototype
```c
GMODULE_AVAILABLE_IN_ALL gboolean g_module_supported (void) G_GNUC_CONST;
```
"""
function g_module_supported()
    @ccall libaravis.g_module_supported()::gboolean
end

"""
    g_module_open(file_name, flags)

### Prototype
```c
GMODULE_AVAILABLE_IN_ALL GModule* g_module_open (const gchar *file_name, GModuleFlags flags);
```
"""
function g_module_open(file_name, flags)
    @ccall libaravis.g_module_open(file_name::Ptr{gchar}, flags::GModuleFlags)::Ptr{GModule}
end

"""
    g_module_open_full(file_name, flags, error)

### Prototype
```c
GMODULE_AVAILABLE_IN_2_70 GModule *g_module_open_full (const gchar *file_name, GModuleFlags flags, GError **error);
```
"""
function g_module_open_full(file_name, flags, error)
    @ccall libaravis.g_module_open_full(file_name::Ptr{gchar}, flags::GModuleFlags, error::Ptr{Ptr{GError}})::Ptr{GModule}
end

"""
    g_module_close(_module)

### Prototype
```c
GMODULE_AVAILABLE_IN_ALL gboolean g_module_close (GModule *module);
```
"""
function g_module_close(_module)
    @ccall libaravis.g_module_close(_module::Ptr{GModule})::gboolean
end

"""
    g_module_make_resident(_module)

### Prototype
```c
GMODULE_AVAILABLE_IN_ALL void g_module_make_resident (GModule *module);
```
"""
function g_module_make_resident(_module)
    @ccall libaravis.g_module_make_resident(_module::Ptr{GModule})::Cvoid
end

"""
    g_module_error()

### Prototype
```c
GMODULE_AVAILABLE_IN_ALL const gchar * g_module_error (void);
```
"""
function g_module_error()
    @ccall libaravis.g_module_error()::Ptr{gchar}
end

"""
    g_module_symbol(_module, symbol_name, symbol)

### Prototype
```c
GMODULE_AVAILABLE_IN_ALL gboolean g_module_symbol (GModule *module, const gchar *symbol_name, gpointer *symbol);
```
"""
function g_module_symbol(_module, symbol_name, symbol)
    @ccall libaravis.g_module_symbol(_module::Ptr{GModule}, symbol_name::Ptr{gchar}, symbol::Ptr{gpointer})::gboolean
end

"""
    g_module_name(_module)

### Prototype
```c
GMODULE_AVAILABLE_IN_ALL const gchar * g_module_name (GModule *module);
```
"""
function g_module_name(_module)
    @ccall libaravis.g_module_name(_module::Ptr{GModule})::Ptr{gchar}
end

"""
    g_module_build_path(directory, module_name)

### Prototype
```c
GMODULE_DEPRECATED_IN_2_76 gchar* g_module_build_path (const gchar *directory, const gchar *module_name);
```
"""
function g_module_build_path(directory, module_name)
    @ccall libaravis.g_module_build_path(directory::Ptr{gchar}, module_name::Ptr{gchar})::Ptr{gchar}
end

const _GIOModuleScope = Cvoid

const GIOModuleScope = _GIOModuleScope

"""
    g_io_module_scope_new(flags)

### Prototype
```c
GIO_AVAILABLE_IN_2_30 GIOModuleScope * g_io_module_scope_new (GIOModuleScopeFlags flags);
```
"""
function g_io_module_scope_new(flags)
    @ccall libaravis.g_io_module_scope_new(flags::GIOModuleScopeFlags)::Ptr{GIOModuleScope}
end

"""
    g_io_module_scope_free(scope)

### Prototype
```c
GIO_AVAILABLE_IN_2_30 void g_io_module_scope_free (GIOModuleScope *scope);
```
"""
function g_io_module_scope_free(scope)
    @ccall libaravis.g_io_module_scope_free(scope::Ptr{GIOModuleScope})::Cvoid
end

"""
    g_io_module_scope_block(scope, basename)

### Prototype
```c
GIO_AVAILABLE_IN_2_30 void g_io_module_scope_block (GIOModuleScope *scope, const gchar *basename);
```
"""
function g_io_module_scope_block(scope, basename)
    @ccall libaravis.g_io_module_scope_block(scope::Ptr{GIOModuleScope}, basename::Ptr{gchar})::Cvoid
end

"""
    g_io_module_new(filename)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIOModule *g_io_module_new (const gchar *filename);
```
"""
function g_io_module_new(filename)
    @ccall libaravis.g_io_module_new(filename::Ptr{gchar})::Ptr{GIOModule}
end

"""
    g_io_modules_scan_all_in_directory(dirname)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_io_modules_scan_all_in_directory (const char *dirname);
```
"""
function g_io_modules_scan_all_in_directory(dirname)
    @ccall libaravis.g_io_modules_scan_all_in_directory(dirname::Cstring)::Cvoid
end

"""
    g_io_modules_load_all_in_directory(dirname)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GList *g_io_modules_load_all_in_directory (const gchar *dirname);
```
"""
function g_io_modules_load_all_in_directory(dirname)
    @ccall libaravis.g_io_modules_load_all_in_directory(dirname::Ptr{gchar})::Ptr{GList}
end

"""
    g_io_modules_scan_all_in_directory_with_scope(dirname, scope)

### Prototype
```c
GIO_AVAILABLE_IN_2_30 void g_io_modules_scan_all_in_directory_with_scope (const gchar *dirname, GIOModuleScope *scope);
```
"""
function g_io_modules_scan_all_in_directory_with_scope(dirname, scope)
    @ccall libaravis.g_io_modules_scan_all_in_directory_with_scope(dirname::Ptr{gchar}, scope::Ptr{GIOModuleScope})::Cvoid
end

"""
    g_io_modules_load_all_in_directory_with_scope(dirname, scope)

### Prototype
```c
GIO_AVAILABLE_IN_2_30 GList *g_io_modules_load_all_in_directory_with_scope (const gchar *dirname, GIOModuleScope *scope);
```
"""
function g_io_modules_load_all_in_directory_with_scope(dirname, scope)
    @ccall libaravis.g_io_modules_load_all_in_directory_with_scope(dirname::Ptr{gchar}, scope::Ptr{GIOModuleScope})::Ptr{GList}
end

"""
    g_io_extension_point_register(name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIOExtensionPoint *g_io_extension_point_register (const char *name);
```
"""
function g_io_extension_point_register(name)
    @ccall libaravis.g_io_extension_point_register(name::Cstring)::Ptr{GIOExtensionPoint}
end

"""
    g_io_extension_point_lookup(name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIOExtensionPoint *g_io_extension_point_lookup (const char *name);
```
"""
function g_io_extension_point_lookup(name)
    @ccall libaravis.g_io_extension_point_lookup(name::Cstring)::Ptr{GIOExtensionPoint}
end

"""
    g_io_extension_point_set_required_type(extension_point, type)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_io_extension_point_set_required_type (GIOExtensionPoint *extension_point, GType type);
```
"""
function g_io_extension_point_set_required_type(extension_point, type)
    @ccall libaravis.g_io_extension_point_set_required_type(extension_point::Ptr{GIOExtensionPoint}, type::GType)::Cvoid
end

"""
    g_io_extension_point_get_required_type(extension_point)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_io_extension_point_get_required_type (GIOExtensionPoint *extension_point);
```
"""
function g_io_extension_point_get_required_type(extension_point)
    @ccall libaravis.g_io_extension_point_get_required_type(extension_point::Ptr{GIOExtensionPoint})::GType
end

"""
    g_io_extension_point_get_extensions(extension_point)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GList *g_io_extension_point_get_extensions (GIOExtensionPoint *extension_point);
```
"""
function g_io_extension_point_get_extensions(extension_point)
    @ccall libaravis.g_io_extension_point_get_extensions(extension_point::Ptr{GIOExtensionPoint})::Ptr{GList}
end

"""
    g_io_extension_point_get_extension_by_name(extension_point, name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIOExtension * g_io_extension_point_get_extension_by_name (GIOExtensionPoint *extension_point, const char *name);
```
"""
function g_io_extension_point_get_extension_by_name(extension_point, name)
    @ccall libaravis.g_io_extension_point_get_extension_by_name(extension_point::Ptr{GIOExtensionPoint}, name::Cstring)::Ptr{GIOExtension}
end

"""
    g_io_extension_point_implement(extension_point_name, type, extension_name, priority)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIOExtension * g_io_extension_point_implement (const char *extension_point_name, GType type, const char *extension_name, gint priority);
```
"""
function g_io_extension_point_implement(extension_point_name, type, extension_name, priority)
    @ccall libaravis.g_io_extension_point_implement(extension_point_name::Cstring, type::GType, extension_name::Cstring, priority::gint)::Ptr{GIOExtension}
end

"""
    g_io_extension_get_type(extension)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_io_extension_get_type (GIOExtension *extension);
```
"""
function g_io_extension_get_type(extension)
    @ccall libaravis.g_io_extension_get_type(extension::Ptr{GIOExtension})::GType
end

"""
    g_io_extension_get_name(extension)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const char * g_io_extension_get_name (GIOExtension *extension);
```
"""
function g_io_extension_get_name(extension)
    @ccall libaravis.g_io_extension_get_name(extension::Ptr{GIOExtension})::Cstring
end

"""
    g_io_extension_get_priority(extension)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gint g_io_extension_get_priority (GIOExtension *extension);
```
"""
function g_io_extension_get_priority(extension)
    @ccall libaravis.g_io_extension_get_priority(extension::Ptr{GIOExtension})::gint
end

"""
    g_io_extension_ref_class(extension)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GTypeClass* g_io_extension_ref_class (GIOExtension *extension);
```
"""
function g_io_extension_ref_class(extension)
    @ccall libaravis.g_io_extension_ref_class(extension::Ptr{GIOExtension})::Ptr{GTypeClass}
end

"""
    g_io_module_load(_module)

[`g_io_module_load`](@ref): (skip) : a #[`GIOModule`](@ref).

Required API for GIO modules to implement.

This function is run after the module has been loaded into GIO, to initialize the module. Typically, this function will call [`g_io_extension_point_implement`](@ref)().

Since 2.56, this function should be named `g\\_io\\_<modulename>\\_load`, where `modulename` is the plugins filename with the `lib` or `libgio` prefix and everything after the first dot removed, and with `-` replaced with `_` throughout. For example, `libgiognutls-helper.so` becomes `gnutls_helper`. Using the new symbol names avoids name clashes when building modules statically. The old symbol names continue to be supported, but cannot be used for static builds.

### Prototype
```c
G_MODULE_EXPORT void g_io_module_load (GIOModule *module);
```
"""
function g_io_module_load(_module)
    @ccall libaravis.g_io_module_load(_module::Ptr{GIOModule})::Cvoid
end

"""
    g_io_module_unload(_module)

[`g_io_module_unload`](@ref): (skip) : a #[`GIOModule`](@ref).

Required API for GIO modules to implement.

This function is run when the module is being unloaded from GIO, to finalize the module.

Since 2.56, this function should be named `g\\_io\\_<modulename>\\_unload`, where `modulename` is the plugins filename with the `lib` or `libgio` prefix and everything after the first dot removed, and with `-` replaced with `_` throughout. For example, `libgiognutls-helper.so` becomes `gnutls_helper`. Using the new symbol names avoids name clashes when building modules statically. The old symbol names continue to be supported, but cannot be used for static builds.

### Prototype
```c
G_MODULE_EXPORT void g_io_module_unload (GIOModule *module);
```
"""
function g_io_module_unload(_module)
    @ccall libaravis.g_io_module_unload(_module::Ptr{GIOModule})::Cvoid
end

"""
    g_io_module_query()

[`g_io_module_query`](@ref):

Optional API for GIO modules to implement.

Should return a list of all the extension points that may be implemented in this module.

This method will not be called in normal use, however it may be called when probing existing modules and recording which extension points that this model is used for. This means we won't have to load and initialize this module unless its needed.

If this function is not implemented by the module the module will always be loaded, initialized and then unloaded on application startup so that it can register its extension points during init.

Note that a module need not actually implement all the extension points that [`g_io_module_query`](@ref)() returns, since the exact list of extension may depend on runtime issues. However all extension points actually implemented must be returned by [`g_io_module_query`](@ref)() (if defined).

When installing a module that implements [`g_io_module_query`](@ref)() you must run gio-querymodules in order to build the cache files required for lazy loading.

Since 2.56, this function should be named `g\\_io\\_<modulename>\\_query`, where `modulename` is the plugins filename with the `lib` or `libgio` prefix and everything after the first dot removed, and with `-` replaced with `_` throughout. For example, `libgiognutls-helper.so` becomes `gnutls_helper`. Using the new symbol names avoids name clashes when building modules statically. The old symbol names continue to be supported, but cannot be used for static builds.

Returns: (transfer full): A NULL-terminated array of strings, listing the supported extension points of the module. The array must be suitable for freeing with [`g_strfreev`](@ref)().

Since: 2.24

### Prototype
```c
G_MODULE_EXPORT char **g_io_module_query (void);
```
"""
function g_io_module_query()
    @ccall libaravis.g_io_module_query()::Ptr{Cstring}
end

"""
    g_io_scheduler_push_job(job_func, user_data, notify, io_priority, cancellable)

### Prototype
```c
GIO_DEPRECATED_IN_2_36_FOR ("GThreadPool or g_task_run_in_thread") void g_io_scheduler_push_job (GIOSchedulerJobFunc job_func, gpointer user_data, GDestroyNotify notify, gint io_priority, GCancellable *cancellable);
```
"""
function g_io_scheduler_push_job(job_func, user_data, notify, io_priority, cancellable)
    @ccall libaravis.g_io_scheduler_push_job(job_func::GIOSchedulerJobFunc, user_data::gpointer, notify::GDestroyNotify, io_priority::gint, cancellable::Ptr{GCancellable})::Cvoid
end

"""
    g_io_scheduler_cancel_all_jobs()

### Prototype
```c
GIO_DEPRECATED_IN_2_36 void g_io_scheduler_cancel_all_jobs (void);
```
"""
function g_io_scheduler_cancel_all_jobs()
    @ccall libaravis.g_io_scheduler_cancel_all_jobs()::Cvoid
end

"""
    g_io_scheduler_job_send_to_mainloop(job, func, user_data, notify)

### Prototype
```c
GIO_DEPRECATED_IN_2_36_FOR (g_main_context_invoke) gboolean g_io_scheduler_job_send_to_mainloop (GIOSchedulerJob *job, GSourceFunc func, gpointer user_data, GDestroyNotify notify);
```
"""
function g_io_scheduler_job_send_to_mainloop(job, func, user_data, notify)
    @ccall libaravis.g_io_scheduler_job_send_to_mainloop(job::Ptr{GIOSchedulerJob}, func::GSourceFunc, user_data::gpointer, notify::GDestroyNotify)::gboolean
end

"""
    g_io_scheduler_job_send_to_mainloop_async(job, func, user_data, notify)

### Prototype
```c
GIO_DEPRECATED_IN_2_36_FOR (g_main_context_invoke) void g_io_scheduler_job_send_to_mainloop_async (GIOSchedulerJob *job, GSourceFunc func, gpointer user_data, GDestroyNotify notify);
```
"""
function g_io_scheduler_job_send_to_mainloop_async(job, func, user_data, notify)
    @ccall libaravis.g_io_scheduler_job_send_to_mainloop_async(job::Ptr{GIOSchedulerJob}, func::GSourceFunc, user_data::gpointer, notify::GDestroyNotify)::Cvoid
end

const _GListModel = Cvoid

const GListModel = _GListModel

struct _GListModelInterface
    g_iface::GTypeInterface
    get_item_type::Ptr{Cvoid}
    get_n_items::Ptr{Cvoid}
    get_item::Ptr{Cvoid}
end

const GListModelInterface = _GListModelInterface

const GListModel_autoptr = Ptr{GListModel}

const GListModel_listautoptr = Ptr{GList}

const GListModel_slistautoptr = Ptr{GSList}

const GListModel_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GListModel(_ptr)

### Prototype
```c
G_DECLARE_INTERFACE(GListModel, g_list_model, G, LIST_MODEL, GObject);
```
"""
function glib_autoptr_clear_GListModel(_ptr)
    @ccall libaravis.glib_autoptr_clear_GListModel(_ptr::Ptr{GListModel})::Cvoid
end

"""
    glib_autoptr_cleanup_GListModel(_ptr)

### Prototype
```c
G_DECLARE_INTERFACE(GListModel, g_list_model, G, LIST_MODEL, GObject);
```
"""
function glib_autoptr_cleanup_GListModel(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GListModel(_ptr::Ptr{Ptr{GListModel}})::Cvoid
end

"""
    glib_autoptr_destroy_GListModel(_ptr)

### Prototype
```c
G_DECLARE_INTERFACE(GListModel, g_list_model, G, LIST_MODEL, GObject);
```
"""
function glib_autoptr_destroy_GListModel(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GListModel(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GListModel(_l)

### Prototype
```c
G_DECLARE_INTERFACE(GListModel, g_list_model, G, LIST_MODEL, GObject);
```
"""
function glib_listautoptr_cleanup_GListModel(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GListModel(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GListModel(_l)

### Prototype
```c
G_DECLARE_INTERFACE(GListModel, g_list_model, G, LIST_MODEL, GObject);
```
"""
function glib_slistautoptr_cleanup_GListModel(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GListModel(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GListModel(_q)

### Prototype
```c
G_DECLARE_INTERFACE(GListModel, g_list_model, G, LIST_MODEL, GObject);
```
"""
function glib_queueautoptr_cleanup_GListModel(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GListModel(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    G_LIST_MODEL(ptr)

### Prototype
```c
G_DECLARE_INTERFACE(GListModel, g_list_model, G, LIST_MODEL, GObject);
```
"""
function G_LIST_MODEL(ptr)
    @ccall libaravis.G_LIST_MODEL(ptr::gpointer)::Ptr{GListModel}
end

"""
    G_IS_LIST_MODEL(ptr)

### Prototype
```c
G_DECLARE_INTERFACE(GListModel, g_list_model, G, LIST_MODEL, GObject);
```
"""
function G_IS_LIST_MODEL(ptr)
    @ccall libaravis.G_IS_LIST_MODEL(ptr::gpointer)::gboolean
end

"""
    G_LIST_MODEL_GET_IFACE(ptr)

### Prototype
```c
G_DECLARE_INTERFACE(GListModel, g_list_model, G, LIST_MODEL, GObject);
```
"""
function G_LIST_MODEL_GET_IFACE(ptr)
    @ccall libaravis.G_LIST_MODEL_GET_IFACE(ptr::gpointer)::Ptr{GListModelInterface}
end

"""
    g_list_model_get_item_type(list)

### Prototype
```c
GIO_AVAILABLE_IN_2_44 GType g_list_model_get_item_type (GListModel *list);
```
"""
function g_list_model_get_item_type(list)
    @ccall libaravis.g_list_model_get_item_type(list::Ptr{GListModel})::GType
end

"""
    g_list_model_get_n_items(list)

### Prototype
```c
GIO_AVAILABLE_IN_2_44 guint g_list_model_get_n_items (GListModel *list);
```
"""
function g_list_model_get_n_items(list)
    @ccall libaravis.g_list_model_get_n_items(list::Ptr{GListModel})::guint
end

"""
    g_list_model_get_item(list, position)

### Prototype
```c
GIO_AVAILABLE_IN_2_44 gpointer g_list_model_get_item (GListModel *list, guint position);
```
"""
function g_list_model_get_item(list, position)
    @ccall libaravis.g_list_model_get_item(list::Ptr{GListModel}, position::guint)::gpointer
end

"""
    g_list_model_get_object(list, position)

### Prototype
```c
GIO_AVAILABLE_IN_2_44 GObject * g_list_model_get_object (GListModel *list, guint position);
```
"""
function g_list_model_get_object(list, position)
    @ccall libaravis.g_list_model_get_object(list::Ptr{GListModel}, position::guint)::Ptr{GObject}
end

"""
    g_list_model_items_changed(list, position, removed, added)

### Prototype
```c
GIO_AVAILABLE_IN_2_44 void g_list_model_items_changed (GListModel *list, guint position, guint removed, guint added);
```
"""
function g_list_model_items_changed(list, position, removed, added)
    @ccall libaravis.g_list_model_items_changed(list::Ptr{GListModel}, position::guint, removed::guint, added::guint)::Cvoid
end

const _GListStore = Cvoid

const GListStore = _GListStore

struct GListStoreClass
    parent_class::GObjectClass
end

const GListStore_autoptr = Ptr{GListStore}

const GListStore_listautoptr = Ptr{GList}

const GListStore_slistautoptr = Ptr{GSList}

const GListStore_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GListStore(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE(GListStore, g_list_store, G, LIST_STORE, GObject);
```
"""
function glib_autoptr_clear_GListStore(_ptr)
    @ccall libaravis.glib_autoptr_clear_GListStore(_ptr::Ptr{GListStore})::Cvoid
end

"""
    glib_autoptr_cleanup_GListStore(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE(GListStore, g_list_store, G, LIST_STORE, GObject);
```
"""
function glib_autoptr_cleanup_GListStore(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GListStore(_ptr::Ptr{Ptr{GListStore}})::Cvoid
end

"""
    glib_autoptr_destroy_GListStore(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE(GListStore, g_list_store, G, LIST_STORE, GObject);
```
"""
function glib_autoptr_destroy_GListStore(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GListStore(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GListStore(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE(GListStore, g_list_store, G, LIST_STORE, GObject);
```
"""
function glib_listautoptr_cleanup_GListStore(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GListStore(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GListStore(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE(GListStore, g_list_store, G, LIST_STORE, GObject);
```
"""
function glib_slistautoptr_cleanup_GListStore(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GListStore(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GListStore(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE(GListStore, g_list_store, G, LIST_STORE, GObject);
```
"""
function glib_queueautoptr_cleanup_GListStore(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GListStore(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GListStoreClass_autoptr = Ptr{GListStoreClass}

const GListStoreClass_listautoptr = Ptr{GList}

const GListStoreClass_slistautoptr = Ptr{GSList}

const GListStoreClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GListStoreClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE(GListStore, g_list_store, G, LIST_STORE, GObject);
```
"""
function glib_autoptr_clear_GListStoreClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_GListStoreClass(_ptr::Ptr{GListStoreClass})::Cvoid
end

"""
    glib_autoptr_cleanup_GListStoreClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE(GListStore, g_list_store, G, LIST_STORE, GObject);
```
"""
function glib_autoptr_cleanup_GListStoreClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GListStoreClass(_ptr::Ptr{Ptr{GListStoreClass}})::Cvoid
end

"""
    glib_autoptr_destroy_GListStoreClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE(GListStore, g_list_store, G, LIST_STORE, GObject);
```
"""
function glib_autoptr_destroy_GListStoreClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GListStoreClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GListStoreClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE(GListStore, g_list_store, G, LIST_STORE, GObject);
```
"""
function glib_listautoptr_cleanup_GListStoreClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GListStoreClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GListStoreClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE(GListStore, g_list_store, G, LIST_STORE, GObject);
```
"""
function glib_slistautoptr_cleanup_GListStoreClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GListStoreClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GListStoreClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE(GListStore, g_list_store, G, LIST_STORE, GObject);
```
"""
function glib_queueautoptr_cleanup_GListStoreClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GListStoreClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    G_LIST_STORE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE(GListStore, g_list_store, G, LIST_STORE, GObject);
```
"""
function G_LIST_STORE(ptr)
    @ccall libaravis.G_LIST_STORE(ptr::gpointer)::Ptr{GListStore}
end

"""
    G_IS_LIST_STORE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE(GListStore, g_list_store, G, LIST_STORE, GObject);
```
"""
function G_IS_LIST_STORE(ptr)
    @ccall libaravis.G_IS_LIST_STORE(ptr::gpointer)::gboolean
end

"""
    g_list_store_new(item_type)

### Prototype
```c
GIO_AVAILABLE_IN_2_44 GListStore * g_list_store_new (GType item_type);
```
"""
function g_list_store_new(item_type)
    @ccall libaravis.g_list_store_new(item_type::GType)::Ptr{GListStore}
end

"""
    g_list_store_insert(store, position, item)

### Prototype
```c
GIO_AVAILABLE_IN_2_44 void g_list_store_insert (GListStore *store, guint position, gpointer item);
```
"""
function g_list_store_insert(store, position, item)
    @ccall libaravis.g_list_store_insert(store::Ptr{GListStore}, position::guint, item::gpointer)::Cvoid
end

"""
    g_list_store_insert_sorted(store, item, compare_func, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_44 guint g_list_store_insert_sorted (GListStore *store, gpointer item, GCompareDataFunc compare_func, gpointer user_data);
```
"""
function g_list_store_insert_sorted(store, item, compare_func, user_data)
    @ccall libaravis.g_list_store_insert_sorted(store::Ptr{GListStore}, item::gpointer, compare_func::GCompareDataFunc, user_data::gpointer)::guint
end

"""
    g_list_store_sort(store, compare_func, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_46 void g_list_store_sort (GListStore *store, GCompareDataFunc compare_func, gpointer user_data);
```
"""
function g_list_store_sort(store, compare_func, user_data)
    @ccall libaravis.g_list_store_sort(store::Ptr{GListStore}, compare_func::GCompareDataFunc, user_data::gpointer)::Cvoid
end

"""
    g_list_store_append(store, item)

### Prototype
```c
GIO_AVAILABLE_IN_2_44 void g_list_store_append (GListStore *store, gpointer item);
```
"""
function g_list_store_append(store, item)
    @ccall libaravis.g_list_store_append(store::Ptr{GListStore}, item::gpointer)::Cvoid
end

"""
    g_list_store_remove(store, position)

### Prototype
```c
GIO_AVAILABLE_IN_2_44 void g_list_store_remove (GListStore *store, guint position);
```
"""
function g_list_store_remove(store, position)
    @ccall libaravis.g_list_store_remove(store::Ptr{GListStore}, position::guint)::Cvoid
end

"""
    g_list_store_remove_all(store)

### Prototype
```c
GIO_AVAILABLE_IN_2_44 void g_list_store_remove_all (GListStore *store);
```
"""
function g_list_store_remove_all(store)
    @ccall libaravis.g_list_store_remove_all(store::Ptr{GListStore})::Cvoid
end

"""
    g_list_store_splice(store, position, n_removals, additions, n_additions)

### Prototype
```c
GIO_AVAILABLE_IN_2_44 void g_list_store_splice (GListStore *store, guint position, guint n_removals, gpointer *additions, guint n_additions);
```
"""
function g_list_store_splice(store, position, n_removals, additions, n_additions)
    @ccall libaravis.g_list_store_splice(store::Ptr{GListStore}, position::guint, n_removals::guint, additions::Ptr{gpointer}, n_additions::guint)::Cvoid
end

"""
    g_list_store_find(store, item, position)

### Prototype
```c
GIO_AVAILABLE_IN_2_64 gboolean g_list_store_find (GListStore *store, gpointer item, guint *position);
```
"""
function g_list_store_find(store, item, position)
    @ccall libaravis.g_list_store_find(store::Ptr{GListStore}, item::gpointer, position::Ptr{guint})::gboolean
end

"""
    g_list_store_find_with_equal_func(store, item, equal_func, position)

### Prototype
```c
GIO_AVAILABLE_IN_2_64 gboolean g_list_store_find_with_equal_func (GListStore *store, gpointer item, GEqualFunc equal_func, guint *position);
```
"""
function g_list_store_find_with_equal_func(store, item, equal_func, position)
    @ccall libaravis.g_list_store_find_with_equal_func(store::Ptr{GListStore}, item::gpointer, equal_func::GEqualFunc, position::Ptr{guint})::gboolean
end

"""
    g_list_store_find_with_equal_func_full(store, item, equal_func, user_data, position)

### Prototype
```c
GIO_AVAILABLE_IN_2_74 gboolean g_list_store_find_with_equal_func_full (GListStore *store, gpointer item, GEqualFuncFull equal_func, gpointer user_data, guint *position);
```
"""
function g_list_store_find_with_equal_func_full(store, item, equal_func, user_data, position)
    @ccall libaravis.g_list_store_find_with_equal_func_full(store::Ptr{GListStore}, item::gpointer, equal_func::GEqualFuncFull, user_data::gpointer, position::Ptr{guint})::gboolean
end

"""
    g_loadable_icon_load(icon, size, type, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GInputStream *g_loadable_icon_load (GLoadableIcon *icon, int size, char **type, GCancellable *cancellable, GError **error);
```
"""
function g_loadable_icon_load(icon, size, type, cancellable, error)
    @ccall libaravis.g_loadable_icon_load(icon::Ptr{GLoadableIcon}, size::Cint, type::Ptr{Cstring}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GInputStream}
end

"""
    g_loadable_icon_load_async(icon, size, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_loadable_icon_load_async (GLoadableIcon *icon, int size, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_loadable_icon_load_async(icon, size, cancellable, callback, user_data)
    @ccall libaravis.g_loadable_icon_load_async(icon::Ptr{GLoadableIcon}, size::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_loadable_icon_load_finish(icon, res, type, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GInputStream *g_loadable_icon_load_finish (GLoadableIcon *icon, GAsyncResult *res, char **type, GError **error);
```
"""
function g_loadable_icon_load_finish(icon, res, type, error)
    @ccall libaravis.g_loadable_icon_load_finish(icon::Ptr{GLoadableIcon}, res::Ptr{GAsyncResult}, type::Ptr{Cstring}, error::Ptr{Ptr{GError}})::Ptr{GInputStream}
end

"""
    g_memory_input_stream_new()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GInputStream * g_memory_input_stream_new (void);
```
"""
function g_memory_input_stream_new()
    @ccall libaravis.g_memory_input_stream_new()::Ptr{GInputStream}
end

"""
    g_memory_input_stream_new_from_data(data, len, destroy)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GInputStream * g_memory_input_stream_new_from_data (const void *data, gssize len, GDestroyNotify destroy);
```
"""
function g_memory_input_stream_new_from_data(data, len, destroy)
    @ccall libaravis.g_memory_input_stream_new_from_data(data::Ptr{Cvoid}, len::gssize, destroy::GDestroyNotify)::Ptr{GInputStream}
end

"""
    g_memory_input_stream_new_from_bytes(bytes)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 GInputStream * g_memory_input_stream_new_from_bytes (GBytes *bytes);
```
"""
function g_memory_input_stream_new_from_bytes(bytes)
    @ccall libaravis.g_memory_input_stream_new_from_bytes(bytes::Ptr{GBytes})::Ptr{GInputStream}
end

"""
    g_memory_input_stream_add_data(stream, data, len, destroy)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_memory_input_stream_add_data (GMemoryInputStream *stream, const void *data, gssize len, GDestroyNotify destroy);
```
"""
function g_memory_input_stream_add_data(stream, data, len, destroy)
    @ccall libaravis.g_memory_input_stream_add_data(stream::Ptr{GMemoryInputStream}, data::Ptr{Cvoid}, len::gssize, destroy::GDestroyNotify)::Cvoid
end

"""
    g_memory_input_stream_add_bytes(stream, bytes)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 void g_memory_input_stream_add_bytes (GMemoryInputStream *stream, GBytes *bytes);
```
"""
function g_memory_input_stream_add_bytes(stream, bytes)
    @ccall libaravis.g_memory_input_stream_add_bytes(stream::Ptr{GMemoryInputStream}, bytes::Ptr{GBytes})::Cvoid
end

const GMemoryMonitor_autoptr = Ptr{GMemoryMonitor}

const GMemoryMonitor_listautoptr = Ptr{GList}

const GMemoryMonitor_slistautoptr = Ptr{GSList}

const GMemoryMonitor_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GMemoryMonitor(_ptr)

### Prototype
```c
G_DECLARE_INTERFACE(GMemoryMonitor, g_memory_monitor, g, memory_monitor, GObject);
```
"""
function glib_autoptr_clear_GMemoryMonitor(_ptr)
    @ccall libaravis.glib_autoptr_clear_GMemoryMonitor(_ptr::Ptr{GMemoryMonitor})::Cvoid
end

"""
    glib_autoptr_cleanup_GMemoryMonitor(_ptr)

### Prototype
```c
G_DECLARE_INTERFACE(GMemoryMonitor, g_memory_monitor, g, memory_monitor, GObject);
```
"""
function glib_autoptr_cleanup_GMemoryMonitor(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GMemoryMonitor(_ptr::Ptr{Ptr{GMemoryMonitor}})::Cvoid
end

"""
    glib_autoptr_destroy_GMemoryMonitor(_ptr)

### Prototype
```c
G_DECLARE_INTERFACE(GMemoryMonitor, g_memory_monitor, g, memory_monitor, GObject);
```
"""
function glib_autoptr_destroy_GMemoryMonitor(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GMemoryMonitor(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GMemoryMonitor(_l)

### Prototype
```c
G_DECLARE_INTERFACE(GMemoryMonitor, g_memory_monitor, g, memory_monitor, GObject);
```
"""
function glib_listautoptr_cleanup_GMemoryMonitor(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GMemoryMonitor(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GMemoryMonitor(_l)

### Prototype
```c
G_DECLARE_INTERFACE(GMemoryMonitor, g_memory_monitor, g, memory_monitor, GObject);
```
"""
function glib_slistautoptr_cleanup_GMemoryMonitor(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GMemoryMonitor(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GMemoryMonitor(_q)

### Prototype
```c
G_DECLARE_INTERFACE(GMemoryMonitor, g_memory_monitor, g, memory_monitor, GObject);
```
"""
function glib_queueautoptr_cleanup_GMemoryMonitor(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GMemoryMonitor(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    g_memory_monitor(ptr)

### Prototype
```c
G_DECLARE_INTERFACE(GMemoryMonitor, g_memory_monitor, g, memory_monitor, GObject);
```
"""
function g_memory_monitor(ptr)
    @ccall libaravis.g_memory_monitor(ptr::gpointer)::Ptr{GMemoryMonitor}
end

"""
    g_IS_memory_monitor(ptr)

### Prototype
```c
G_DECLARE_INTERFACE(GMemoryMonitor, g_memory_monitor, g, memory_monitor, GObject);
```
"""
function g_IS_memory_monitor(ptr)
    @ccall libaravis.g_IS_memory_monitor(ptr::gpointer)::gboolean
end

"""
    g_memory_monitor_GET_IFACE(ptr)

### Prototype
```c
G_DECLARE_INTERFACE(GMemoryMonitor, g_memory_monitor, g, memory_monitor, GObject);
```
"""
function g_memory_monitor_GET_IFACE(ptr)
    @ccall libaravis.g_memory_monitor_GET_IFACE(ptr::gpointer)::Ptr{GMemoryMonitorInterface}
end

"""
    g_memory_monitor_dup_default()

### Prototype
```c
GIO_AVAILABLE_IN_2_64 GMemoryMonitor *g_memory_monitor_dup_default (void);
```
"""
function g_memory_monitor_dup_default()
    @ccall libaravis.g_memory_monitor_dup_default()::Ptr{GMemoryMonitor}
end

# typedef gpointer ( * GReallocFunc ) ( gpointer data , gsize size )
"""
[`GReallocFunc`](@ref):

\\date : memory block to reallocate : size to reallocate

\\date to

Changes the size of the memory block pointed to by

\\date to  bytes.

The function should have the same semantics as realloc().

Returns: a pointer to the reallocated memory
"""
const GReallocFunc = Ptr{Cvoid}

"""
    g_memory_output_stream_new(data, size, realloc_function, destroy_function)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GOutputStream *g_memory_output_stream_new (gpointer data, gsize size, GReallocFunc realloc_function, GDestroyNotify destroy_function);
```
"""
function g_memory_output_stream_new(data, size, realloc_function, destroy_function)
    @ccall libaravis.g_memory_output_stream_new(data::gpointer, size::gsize, realloc_function::GReallocFunc, destroy_function::GDestroyNotify)::Ptr{GOutputStream}
end

"""
    g_memory_output_stream_new_resizable()

### Prototype
```c
GIO_AVAILABLE_IN_2_36 GOutputStream *g_memory_output_stream_new_resizable (void);
```
"""
function g_memory_output_stream_new_resizable()
    @ccall libaravis.g_memory_output_stream_new_resizable()::Ptr{GOutputStream}
end

"""
    g_memory_output_stream_get_data(ostream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gpointer g_memory_output_stream_get_data (GMemoryOutputStream *ostream);
```
"""
function g_memory_output_stream_get_data(ostream)
    @ccall libaravis.g_memory_output_stream_get_data(ostream::Ptr{GMemoryOutputStream})::gpointer
end

"""
    g_memory_output_stream_get_size(ostream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gsize g_memory_output_stream_get_size (GMemoryOutputStream *ostream);
```
"""
function g_memory_output_stream_get_size(ostream)
    @ccall libaravis.g_memory_output_stream_get_size(ostream::Ptr{GMemoryOutputStream})::gsize
end

"""
    g_memory_output_stream_get_data_size(ostream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gsize g_memory_output_stream_get_data_size (GMemoryOutputStream *ostream);
```
"""
function g_memory_output_stream_get_data_size(ostream)
    @ccall libaravis.g_memory_output_stream_get_data_size(ostream::Ptr{GMemoryOutputStream})::gsize
end

"""
    g_memory_output_stream_steal_data(ostream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gpointer g_memory_output_stream_steal_data (GMemoryOutputStream *ostream);
```
"""
function g_memory_output_stream_steal_data(ostream)
    @ccall libaravis.g_memory_output_stream_steal_data(ostream::Ptr{GMemoryOutputStream})::gpointer
end

"""
    g_memory_output_stream_steal_as_bytes(ostream)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 GBytes * g_memory_output_stream_steal_as_bytes (GMemoryOutputStream *ostream);
```
"""
function g_memory_output_stream_steal_as_bytes(ostream)
    @ccall libaravis.g_memory_output_stream_steal_as_bytes(ostream::Ptr{GMemoryOutputStream})::Ptr{GBytes}
end

"""
    g_menu_model_is_mutable(model)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 gboolean g_menu_model_is_mutable (GMenuModel *model);
```
"""
function g_menu_model_is_mutable(model)
    @ccall libaravis.g_menu_model_is_mutable(model::Ptr{GMenuModel})::gboolean
end

"""
    g_menu_model_get_n_items(model)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 gint g_menu_model_get_n_items (GMenuModel *model);
```
"""
function g_menu_model_get_n_items(model)
    @ccall libaravis.g_menu_model_get_n_items(model::Ptr{GMenuModel})::gint
end

"""
    g_menu_model_iterate_item_attributes(model, item_index)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GMenuAttributeIter * g_menu_model_iterate_item_attributes (GMenuModel *model, gint item_index);
```
"""
function g_menu_model_iterate_item_attributes(model, item_index)
    @ccall libaravis.g_menu_model_iterate_item_attributes(model::Ptr{GMenuModel}, item_index::gint)::Ptr{GMenuAttributeIter}
end

"""
    g_menu_model_get_item_attribute_value(model, item_index, attribute, expected_type)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GVariant * g_menu_model_get_item_attribute_value (GMenuModel *model, gint item_index, const gchar *attribute, const GVariantType *expected_type);
```
"""
function g_menu_model_get_item_attribute_value(model, item_index, attribute, expected_type)
    @ccall libaravis.g_menu_model_get_item_attribute_value(model::Ptr{GMenuModel}, item_index::gint, attribute::Ptr{gchar}, expected_type::Ptr{GVariantType})::Ptr{GVariant}
end

"""
    g_menu_model_iterate_item_links(model, item_index)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GMenuLinkIter * g_menu_model_iterate_item_links (GMenuModel *model, gint item_index);
```
"""
function g_menu_model_iterate_item_links(model, item_index)
    @ccall libaravis.g_menu_model_iterate_item_links(model::Ptr{GMenuModel}, item_index::gint)::Ptr{GMenuLinkIter}
end

"""
    g_menu_model_get_item_link(model, item_index, link)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GMenuModel * g_menu_model_get_item_link (GMenuModel *model, gint item_index, const gchar *link);
```
"""
function g_menu_model_get_item_link(model, item_index, link)
    @ccall libaravis.g_menu_model_get_item_link(model::Ptr{GMenuModel}, item_index::gint, link::Ptr{gchar})::Ptr{GMenuModel}
end

"""
    g_menu_model_items_changed(model, position, removed, added)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_menu_model_items_changed (GMenuModel *model, gint position, gint removed, gint added);
```
"""
function g_menu_model_items_changed(model, position, removed, added)
    @ccall libaravis.g_menu_model_items_changed(model::Ptr{GMenuModel}, position::gint, removed::gint, added::gint)::Cvoid
end

"""
    g_menu_attribute_iter_get_next(iter, out_name, value)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 gboolean g_menu_attribute_iter_get_next (GMenuAttributeIter *iter, const gchar **out_name, GVariant **value);
```
"""
function g_menu_attribute_iter_get_next(iter, out_name, value)
    @ccall libaravis.g_menu_attribute_iter_get_next(iter::Ptr{GMenuAttributeIter}, out_name::Ptr{Ptr{gchar}}, value::Ptr{Ptr{GVariant}})::gboolean
end

"""
    g_menu_attribute_iter_next(iter)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 gboolean g_menu_attribute_iter_next (GMenuAttributeIter *iter);
```
"""
function g_menu_attribute_iter_next(iter)
    @ccall libaravis.g_menu_attribute_iter_next(iter::Ptr{GMenuAttributeIter})::gboolean
end

"""
    g_menu_attribute_iter_get_name(iter)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 const gchar * g_menu_attribute_iter_get_name (GMenuAttributeIter *iter);
```
"""
function g_menu_attribute_iter_get_name(iter)
    @ccall libaravis.g_menu_attribute_iter_get_name(iter::Ptr{GMenuAttributeIter})::Ptr{gchar}
end

"""
    g_menu_attribute_iter_get_value(iter)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GVariant * g_menu_attribute_iter_get_value (GMenuAttributeIter *iter);
```
"""
function g_menu_attribute_iter_get_value(iter)
    @ccall libaravis.g_menu_attribute_iter_get_value(iter::Ptr{GMenuAttributeIter})::Ptr{GVariant}
end

"""
    g_menu_link_iter_get_next(iter, out_link, value)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 gboolean g_menu_link_iter_get_next (GMenuLinkIter *iter, const gchar **out_link, GMenuModel **value);
```
"""
function g_menu_link_iter_get_next(iter, out_link, value)
    @ccall libaravis.g_menu_link_iter_get_next(iter::Ptr{GMenuLinkIter}, out_link::Ptr{Ptr{gchar}}, value::Ptr{Ptr{GMenuModel}})::gboolean
end

"""
    g_menu_link_iter_next(iter)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 gboolean g_menu_link_iter_next (GMenuLinkIter *iter);
```
"""
function g_menu_link_iter_next(iter)
    @ccall libaravis.g_menu_link_iter_next(iter::Ptr{GMenuLinkIter})::gboolean
end

"""
    g_menu_link_iter_get_name(iter)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 const gchar * g_menu_link_iter_get_name (GMenuLinkIter *iter);
```
"""
function g_menu_link_iter_get_name(iter)
    @ccall libaravis.g_menu_link_iter_get_name(iter::Ptr{GMenuLinkIter})::Ptr{gchar}
end

"""
    g_menu_link_iter_get_value(iter)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GMenuModel * g_menu_link_iter_get_value (GMenuLinkIter *iter);
```
"""
function g_menu_link_iter_get_value(iter)
    @ccall libaravis.g_menu_link_iter_get_value(iter::Ptr{GMenuLinkIter})::Ptr{GMenuModel}
end

"""
    g_menu_new()

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GMenu * g_menu_new (void);
```
"""
function g_menu_new()
    @ccall libaravis.g_menu_new()::Ptr{GMenu}
end

"""
    g_menu_freeze(menu)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_menu_freeze (GMenu *menu);
```
"""
function g_menu_freeze(menu)
    @ccall libaravis.g_menu_freeze(menu::Ptr{GMenu})::Cvoid
end

"""
    g_menu_insert_item(menu, position, item)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_menu_insert_item (GMenu *menu, gint position, GMenuItem *item);
```
"""
function g_menu_insert_item(menu, position, item)
    @ccall libaravis.g_menu_insert_item(menu::Ptr{GMenu}, position::gint, item::Ptr{GMenuItem})::Cvoid
end

"""
    g_menu_prepend_item(menu, item)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_menu_prepend_item (GMenu *menu, GMenuItem *item);
```
"""
function g_menu_prepend_item(menu, item)
    @ccall libaravis.g_menu_prepend_item(menu::Ptr{GMenu}, item::Ptr{GMenuItem})::Cvoid
end

"""
    g_menu_append_item(menu, item)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_menu_append_item (GMenu *menu, GMenuItem *item);
```
"""
function g_menu_append_item(menu, item)
    @ccall libaravis.g_menu_append_item(menu::Ptr{GMenu}, item::Ptr{GMenuItem})::Cvoid
end

"""
    g_menu_remove(menu, position)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_menu_remove (GMenu *menu, gint position);
```
"""
function g_menu_remove(menu, position)
    @ccall libaravis.g_menu_remove(menu::Ptr{GMenu}, position::gint)::Cvoid
end

"""
    g_menu_remove_all(menu)

### Prototype
```c
GIO_AVAILABLE_IN_2_38 void g_menu_remove_all (GMenu *menu);
```
"""
function g_menu_remove_all(menu)
    @ccall libaravis.g_menu_remove_all(menu::Ptr{GMenu})::Cvoid
end

"""
    g_menu_insert(menu, position, label, detailed_action)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_menu_insert (GMenu *menu, gint position, const gchar *label, const gchar *detailed_action);
```
"""
function g_menu_insert(menu, position, label, detailed_action)
    @ccall libaravis.g_menu_insert(menu::Ptr{GMenu}, position::gint, label::Ptr{gchar}, detailed_action::Ptr{gchar})::Cvoid
end

"""
    g_menu_prepend(menu, label, detailed_action)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_menu_prepend (GMenu *menu, const gchar *label, const gchar *detailed_action);
```
"""
function g_menu_prepend(menu, label, detailed_action)
    @ccall libaravis.g_menu_prepend(menu::Ptr{GMenu}, label::Ptr{gchar}, detailed_action::Ptr{gchar})::Cvoid
end

"""
    g_menu_append(menu, label, detailed_action)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_menu_append (GMenu *menu, const gchar *label, const gchar *detailed_action);
```
"""
function g_menu_append(menu, label, detailed_action)
    @ccall libaravis.g_menu_append(menu::Ptr{GMenu}, label::Ptr{gchar}, detailed_action::Ptr{gchar})::Cvoid
end

"""
    g_menu_insert_section(menu, position, label, section)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_menu_insert_section (GMenu *menu, gint position, const gchar *label, GMenuModel *section);
```
"""
function g_menu_insert_section(menu, position, label, section)
    @ccall libaravis.g_menu_insert_section(menu::Ptr{GMenu}, position::gint, label::Ptr{gchar}, section::Ptr{GMenuModel})::Cvoid
end

"""
    g_menu_prepend_section(menu, label, section)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_menu_prepend_section (GMenu *menu, const gchar *label, GMenuModel *section);
```
"""
function g_menu_prepend_section(menu, label, section)
    @ccall libaravis.g_menu_prepend_section(menu::Ptr{GMenu}, label::Ptr{gchar}, section::Ptr{GMenuModel})::Cvoid
end

"""
    g_menu_append_section(menu, label, section)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_menu_append_section (GMenu *menu, const gchar *label, GMenuModel *section);
```
"""
function g_menu_append_section(menu, label, section)
    @ccall libaravis.g_menu_append_section(menu::Ptr{GMenu}, label::Ptr{gchar}, section::Ptr{GMenuModel})::Cvoid
end

"""
    g_menu_insert_submenu(menu, position, label, submenu)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_menu_insert_submenu (GMenu *menu, gint position, const gchar *label, GMenuModel *submenu);
```
"""
function g_menu_insert_submenu(menu, position, label, submenu)
    @ccall libaravis.g_menu_insert_submenu(menu::Ptr{GMenu}, position::gint, label::Ptr{gchar}, submenu::Ptr{GMenuModel})::Cvoid
end

"""
    g_menu_prepend_submenu(menu, label, submenu)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_menu_prepend_submenu (GMenu *menu, const gchar *label, GMenuModel *submenu);
```
"""
function g_menu_prepend_submenu(menu, label, submenu)
    @ccall libaravis.g_menu_prepend_submenu(menu::Ptr{GMenu}, label::Ptr{gchar}, submenu::Ptr{GMenuModel})::Cvoid
end

"""
    g_menu_append_submenu(menu, label, submenu)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_menu_append_submenu (GMenu *menu, const gchar *label, GMenuModel *submenu);
```
"""
function g_menu_append_submenu(menu, label, submenu)
    @ccall libaravis.g_menu_append_submenu(menu::Ptr{GMenu}, label::Ptr{gchar}, submenu::Ptr{GMenuModel})::Cvoid
end

"""
    g_menu_item_new(label, detailed_action)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GMenuItem * g_menu_item_new (const gchar *label, const gchar *detailed_action);
```
"""
function g_menu_item_new(label, detailed_action)
    @ccall libaravis.g_menu_item_new(label::Ptr{gchar}, detailed_action::Ptr{gchar})::Ptr{GMenuItem}
end

"""
    g_menu_item_new_from_model(model, item_index)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 GMenuItem * g_menu_item_new_from_model (GMenuModel *model, gint item_index);
```
"""
function g_menu_item_new_from_model(model, item_index)
    @ccall libaravis.g_menu_item_new_from_model(model::Ptr{GMenuModel}, item_index::gint)::Ptr{GMenuItem}
end

"""
    g_menu_item_new_submenu(label, submenu)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GMenuItem * g_menu_item_new_submenu (const gchar *label, GMenuModel *submenu);
```
"""
function g_menu_item_new_submenu(label, submenu)
    @ccall libaravis.g_menu_item_new_submenu(label::Ptr{gchar}, submenu::Ptr{GMenuModel})::Ptr{GMenuItem}
end

"""
    g_menu_item_new_section(label, section)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GMenuItem * g_menu_item_new_section (const gchar *label, GMenuModel *section);
```
"""
function g_menu_item_new_section(label, section)
    @ccall libaravis.g_menu_item_new_section(label::Ptr{gchar}, section::Ptr{GMenuModel})::Ptr{GMenuItem}
end

"""
    g_menu_item_get_attribute_value(menu_item, attribute, expected_type)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 GVariant * g_menu_item_get_attribute_value (GMenuItem *menu_item, const gchar *attribute, const GVariantType *expected_type);
```
"""
function g_menu_item_get_attribute_value(menu_item, attribute, expected_type)
    @ccall libaravis.g_menu_item_get_attribute_value(menu_item::Ptr{GMenuItem}, attribute::Ptr{gchar}, expected_type::Ptr{GVariantType})::Ptr{GVariant}
end

"""
    g_menu_item_get_link(menu_item, link)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 GMenuModel *g_menu_item_get_link (GMenuItem *menu_item, const gchar *link);
```
"""
function g_menu_item_get_link(menu_item, link)
    @ccall libaravis.g_menu_item_get_link(menu_item::Ptr{GMenuItem}, link::Ptr{gchar})::Ptr{GMenuModel}
end

"""
    g_menu_item_set_attribute_value(menu_item, attribute, value)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_menu_item_set_attribute_value (GMenuItem *menu_item, const gchar *attribute, GVariant *value);
```
"""
function g_menu_item_set_attribute_value(menu_item, attribute, value)
    @ccall libaravis.g_menu_item_set_attribute_value(menu_item::Ptr{GMenuItem}, attribute::Ptr{gchar}, value::Ptr{GVariant})::Cvoid
end

"""
    g_menu_item_set_link(menu_item, link, model)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_menu_item_set_link (GMenuItem *menu_item, const gchar *link, GMenuModel *model);
```
"""
function g_menu_item_set_link(menu_item, link, model)
    @ccall libaravis.g_menu_item_set_link(menu_item::Ptr{GMenuItem}, link::Ptr{gchar}, model::Ptr{GMenuModel})::Cvoid
end

"""
    g_menu_item_set_label(menu_item, label)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_menu_item_set_label (GMenuItem *menu_item, const gchar *label);
```
"""
function g_menu_item_set_label(menu_item, label)
    @ccall libaravis.g_menu_item_set_label(menu_item::Ptr{GMenuItem}, label::Ptr{gchar})::Cvoid
end

"""
    g_menu_item_set_submenu(menu_item, submenu)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_menu_item_set_submenu (GMenuItem *menu_item, GMenuModel *submenu);
```
"""
function g_menu_item_set_submenu(menu_item, submenu)
    @ccall libaravis.g_menu_item_set_submenu(menu_item::Ptr{GMenuItem}, submenu::Ptr{GMenuModel})::Cvoid
end

"""
    g_menu_item_set_section(menu_item, section)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_menu_item_set_section (GMenuItem *menu_item, GMenuModel *section);
```
"""
function g_menu_item_set_section(menu_item, section)
    @ccall libaravis.g_menu_item_set_section(menu_item::Ptr{GMenuItem}, section::Ptr{GMenuModel})::Cvoid
end

"""
    g_menu_item_set_action_and_target_value(menu_item, action, target_value)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_menu_item_set_action_and_target_value (GMenuItem *menu_item, const gchar *action, GVariant *target_value);
```
"""
function g_menu_item_set_action_and_target_value(menu_item, action, target_value)
    @ccall libaravis.g_menu_item_set_action_and_target_value(menu_item::Ptr{GMenuItem}, action::Ptr{gchar}, target_value::Ptr{GVariant})::Cvoid
end

"""
    g_menu_item_set_detailed_action(menu_item, detailed_action)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_menu_item_set_detailed_action (GMenuItem *menu_item, const gchar *detailed_action);
```
"""
function g_menu_item_set_detailed_action(menu_item, detailed_action)
    @ccall libaravis.g_menu_item_set_detailed_action(menu_item::Ptr{GMenuItem}, detailed_action::Ptr{gchar})::Cvoid
end

"""
    g_menu_item_set_icon(menu_item, icon)

### Prototype
```c
GIO_AVAILABLE_IN_2_38 void g_menu_item_set_icon (GMenuItem *menu_item, GIcon *icon);
```
"""
function g_menu_item_set_icon(menu_item, icon)
    @ccall libaravis.g_menu_item_set_icon(menu_item::Ptr{GMenuItem}, icon::Ptr{GIcon})::Cvoid
end

"""
    g_dbus_connection_export_menu_model(connection, object_path, menu, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 guint g_dbus_connection_export_menu_model (GDBusConnection *connection, const gchar *object_path, GMenuModel *menu, GError **error);
```
"""
function g_dbus_connection_export_menu_model(connection, object_path, menu, error)
    @ccall libaravis.g_dbus_connection_export_menu_model(connection::Ptr{GDBusConnection}, object_path::Ptr{gchar}, menu::Ptr{GMenuModel}, error::Ptr{Ptr{GError}})::guint
end

"""
    g_dbus_connection_unexport_menu_model(connection, export_id)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_dbus_connection_unexport_menu_model (GDBusConnection *connection, guint export_id);
```
"""
function g_dbus_connection_unexport_menu_model(connection, export_id)
    @ccall libaravis.g_dbus_connection_unexport_menu_model(connection::Ptr{GDBusConnection}, export_id::guint)::Cvoid
end

"""
    g_mount_get_root(mount)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFile * g_mount_get_root (GMount *mount);
```
"""
function g_mount_get_root(mount)
    @ccall libaravis.g_mount_get_root(mount::Ptr{GMount})::Ptr{GFile}
end

"""
    g_mount_get_default_location(mount)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFile * g_mount_get_default_location (GMount *mount);
```
"""
function g_mount_get_default_location(mount)
    @ccall libaravis.g_mount_get_default_location(mount::Ptr{GMount})::Ptr{GFile}
end

"""
    g_mount_get_name(mount)

### Prototype
```c
GIO_AVAILABLE_IN_ALL char * g_mount_get_name (GMount *mount);
```
"""
function g_mount_get_name(mount)
    @ccall libaravis.g_mount_get_name(mount::Ptr{GMount})::Cstring
end

"""
    g_mount_get_icon(mount)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIcon * g_mount_get_icon (GMount *mount);
```
"""
function g_mount_get_icon(mount)
    @ccall libaravis.g_mount_get_icon(mount::Ptr{GMount})::Ptr{GIcon}
end

"""
    g_mount_get_symbolic_icon(mount)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIcon * g_mount_get_symbolic_icon (GMount *mount);
```
"""
function g_mount_get_symbolic_icon(mount)
    @ccall libaravis.g_mount_get_symbolic_icon(mount::Ptr{GMount})::Ptr{GIcon}
end

"""
    g_mount_get_uuid(mount)

### Prototype
```c
GIO_AVAILABLE_IN_ALL char * g_mount_get_uuid (GMount *mount);
```
"""
function g_mount_get_uuid(mount)
    @ccall libaravis.g_mount_get_uuid(mount::Ptr{GMount})::Cstring
end

"""
    g_mount_get_volume(mount)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GVolume * g_mount_get_volume (GMount *mount);
```
"""
function g_mount_get_volume(mount)
    @ccall libaravis.g_mount_get_volume(mount::Ptr{GMount})::Ptr{GVolume}
end

"""
    g_mount_get_drive(mount)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDrive * g_mount_get_drive (GMount *mount);
```
"""
function g_mount_get_drive(mount)
    @ccall libaravis.g_mount_get_drive(mount::Ptr{GMount})::Ptr{GDrive}
end

"""
    g_mount_can_unmount(mount)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_mount_can_unmount (GMount *mount);
```
"""
function g_mount_can_unmount(mount)
    @ccall libaravis.g_mount_can_unmount(mount::Ptr{GMount})::gboolean
end

"""
    g_mount_can_eject(mount)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_mount_can_eject (GMount *mount);
```
"""
function g_mount_can_eject(mount)
    @ccall libaravis.g_mount_can_eject(mount::Ptr{GMount})::gboolean
end

"""
    g_mount_unmount(mount, flags, cancellable, callback, user_data)

### Prototype
```c
GIO_DEPRECATED_FOR(g_mount_unmount_with_operation) void g_mount_unmount (GMount *mount, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_mount_unmount(mount, flags, cancellable, callback, user_data)
    @ccall libaravis.g_mount_unmount(mount::Ptr{GMount}, flags::GMountUnmountFlags, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_mount_unmount_finish(mount, result, error)

### Prototype
```c
GIO_DEPRECATED_FOR(g_mount_unmount_with_operation_finish) gboolean g_mount_unmount_finish (GMount *mount, GAsyncResult *result, GError **error);
```
"""
function g_mount_unmount_finish(mount, result, error)
    @ccall libaravis.g_mount_unmount_finish(mount::Ptr{GMount}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_mount_eject(mount, flags, cancellable, callback, user_data)

### Prototype
```c
GIO_DEPRECATED_FOR(g_mount_eject_with_operation) void g_mount_eject (GMount *mount, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_mount_eject(mount, flags, cancellable, callback, user_data)
    @ccall libaravis.g_mount_eject(mount::Ptr{GMount}, flags::GMountUnmountFlags, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_mount_eject_finish(mount, result, error)

### Prototype
```c
GIO_DEPRECATED_FOR(g_mount_eject_with_operation_finish) gboolean g_mount_eject_finish (GMount *mount, GAsyncResult *result, GError **error);
```
"""
function g_mount_eject_finish(mount, result, error)
    @ccall libaravis.g_mount_eject_finish(mount::Ptr{GMount}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_mount_remount(mount, flags, mount_operation, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_mount_remount (GMount *mount, GMountMountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_mount_remount(mount, flags, mount_operation, cancellable, callback, user_data)
    @ccall libaravis.g_mount_remount(mount::Ptr{GMount}, flags::GMountMountFlags, mount_operation::Ptr{GMountOperation}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_mount_remount_finish(mount, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_mount_remount_finish (GMount *mount, GAsyncResult *result, GError **error);
```
"""
function g_mount_remount_finish(mount, result, error)
    @ccall libaravis.g_mount_remount_finish(mount::Ptr{GMount}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_mount_guess_content_type(mount, force_rescan, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_mount_guess_content_type (GMount *mount, gboolean force_rescan, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_mount_guess_content_type(mount, force_rescan, cancellable, callback, user_data)
    @ccall libaravis.g_mount_guess_content_type(mount::Ptr{GMount}, force_rescan::gboolean, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_mount_guess_content_type_finish(mount, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gchar ** g_mount_guess_content_type_finish (GMount *mount, GAsyncResult *result, GError **error);
```
"""
function g_mount_guess_content_type_finish(mount, result, error)
    @ccall libaravis.g_mount_guess_content_type_finish(mount::Ptr{GMount}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{Ptr{gchar}}
end

"""
    g_mount_guess_content_type_sync(mount, force_rescan, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gchar ** g_mount_guess_content_type_sync (GMount *mount, gboolean force_rescan, GCancellable *cancellable, GError **error);
```
"""
function g_mount_guess_content_type_sync(mount, force_rescan, cancellable, error)
    @ccall libaravis.g_mount_guess_content_type_sync(mount::Ptr{GMount}, force_rescan::gboolean, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{Ptr{gchar}}
end

"""
    g_mount_is_shadowed(mount)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_mount_is_shadowed (GMount *mount);
```
"""
function g_mount_is_shadowed(mount)
    @ccall libaravis.g_mount_is_shadowed(mount::Ptr{GMount})::gboolean
end

"""
    g_mount_shadow(mount)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_mount_shadow (GMount *mount);
```
"""
function g_mount_shadow(mount)
    @ccall libaravis.g_mount_shadow(mount::Ptr{GMount})::Cvoid
end

"""
    g_mount_unshadow(mount)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_mount_unshadow (GMount *mount);
```
"""
function g_mount_unshadow(mount)
    @ccall libaravis.g_mount_unshadow(mount::Ptr{GMount})::Cvoid
end

"""
    g_mount_unmount_with_operation(mount, flags, mount_operation, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_mount_unmount_with_operation (GMount *mount, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_mount_unmount_with_operation(mount, flags, mount_operation, cancellable, callback, user_data)
    @ccall libaravis.g_mount_unmount_with_operation(mount::Ptr{GMount}, flags::GMountUnmountFlags, mount_operation::Ptr{GMountOperation}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_mount_unmount_with_operation_finish(mount, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_mount_unmount_with_operation_finish (GMount *mount, GAsyncResult *result, GError **error);
```
"""
function g_mount_unmount_with_operation_finish(mount, result, error)
    @ccall libaravis.g_mount_unmount_with_operation_finish(mount::Ptr{GMount}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_mount_eject_with_operation(mount, flags, mount_operation, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_mount_eject_with_operation (GMount *mount, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_mount_eject_with_operation(mount, flags, mount_operation, cancellable, callback, user_data)
    @ccall libaravis.g_mount_eject_with_operation(mount::Ptr{GMount}, flags::GMountUnmountFlags, mount_operation::Ptr{GMountOperation}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_mount_eject_with_operation_finish(mount, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_mount_eject_with_operation_finish (GMount *mount, GAsyncResult *result, GError **error);
```
"""
function g_mount_eject_with_operation_finish(mount, result, error)
    @ccall libaravis.g_mount_eject_with_operation_finish(mount::Ptr{GMount}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_mount_get_sort_key(mount)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_mount_get_sort_key (GMount *mount);
```
"""
function g_mount_get_sort_key(mount)
    @ccall libaravis.g_mount_get_sort_key(mount::Ptr{GMount})::Ptr{gchar}
end

"""
    g_mount_operation_new()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GMountOperation * g_mount_operation_new (void);
```
"""
function g_mount_operation_new()
    @ccall libaravis.g_mount_operation_new()::Ptr{GMountOperation}
end

"""
    g_mount_operation_get_username(op)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const char * g_mount_operation_get_username (GMountOperation *op);
```
"""
function g_mount_operation_get_username(op)
    @ccall libaravis.g_mount_operation_get_username(op::Ptr{GMountOperation})::Cstring
end

"""
    g_mount_operation_set_username(op, username)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_mount_operation_set_username (GMountOperation *op, const char *username);
```
"""
function g_mount_operation_set_username(op, username)
    @ccall libaravis.g_mount_operation_set_username(op::Ptr{GMountOperation}, username::Cstring)::Cvoid
end

"""
    g_mount_operation_get_password(op)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const char * g_mount_operation_get_password (GMountOperation *op);
```
"""
function g_mount_operation_get_password(op)
    @ccall libaravis.g_mount_operation_get_password(op::Ptr{GMountOperation})::Cstring
end

"""
    g_mount_operation_set_password(op, password)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_mount_operation_set_password (GMountOperation *op, const char *password);
```
"""
function g_mount_operation_set_password(op, password)
    @ccall libaravis.g_mount_operation_set_password(op::Ptr{GMountOperation}, password::Cstring)::Cvoid
end

"""
    g_mount_operation_get_anonymous(op)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_mount_operation_get_anonymous (GMountOperation *op);
```
"""
function g_mount_operation_get_anonymous(op)
    @ccall libaravis.g_mount_operation_get_anonymous(op::Ptr{GMountOperation})::gboolean
end

"""
    g_mount_operation_set_anonymous(op, anonymous)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_mount_operation_set_anonymous (GMountOperation *op, gboolean anonymous);
```
"""
function g_mount_operation_set_anonymous(op, anonymous)
    @ccall libaravis.g_mount_operation_set_anonymous(op::Ptr{GMountOperation}, anonymous::gboolean)::Cvoid
end

"""
    g_mount_operation_get_domain(op)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const char * g_mount_operation_get_domain (GMountOperation *op);
```
"""
function g_mount_operation_get_domain(op)
    @ccall libaravis.g_mount_operation_get_domain(op::Ptr{GMountOperation})::Cstring
end

"""
    g_mount_operation_set_domain(op, domain)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_mount_operation_set_domain (GMountOperation *op, const char *domain);
```
"""
function g_mount_operation_set_domain(op, domain)
    @ccall libaravis.g_mount_operation_set_domain(op::Ptr{GMountOperation}, domain::Cstring)::Cvoid
end

"""
    g_mount_operation_get_password_save(op)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GPasswordSave g_mount_operation_get_password_save (GMountOperation *op);
```
"""
function g_mount_operation_get_password_save(op)
    @ccall libaravis.g_mount_operation_get_password_save(op::Ptr{GMountOperation})::GPasswordSave
end

"""
    g_mount_operation_set_password_save(op, save)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_mount_operation_set_password_save (GMountOperation *op, GPasswordSave save);
```
"""
function g_mount_operation_set_password_save(op, save)
    @ccall libaravis.g_mount_operation_set_password_save(op::Ptr{GMountOperation}, save::GPasswordSave)::Cvoid
end

"""
    g_mount_operation_get_choice(op)

### Prototype
```c
GIO_AVAILABLE_IN_ALL int g_mount_operation_get_choice (GMountOperation *op);
```
"""
function g_mount_operation_get_choice(op)
    @ccall libaravis.g_mount_operation_get_choice(op::Ptr{GMountOperation})::Cint
end

"""
    g_mount_operation_set_choice(op, choice)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_mount_operation_set_choice (GMountOperation *op, int choice);
```
"""
function g_mount_operation_set_choice(op, choice)
    @ccall libaravis.g_mount_operation_set_choice(op::Ptr{GMountOperation}, choice::Cint)::Cvoid
end

"""
    g_mount_operation_reply(op, result)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_mount_operation_reply (GMountOperation *op, GMountOperationResult result);
```
"""
function g_mount_operation_reply(op, result)
    @ccall libaravis.g_mount_operation_reply(op::Ptr{GMountOperation}, result::GMountOperationResult)::Cvoid
end

"""
    g_mount_operation_get_is_tcrypt_hidden_volume(op)

### Prototype
```c
GIO_AVAILABLE_IN_2_58 gboolean g_mount_operation_get_is_tcrypt_hidden_volume (GMountOperation *op);
```
"""
function g_mount_operation_get_is_tcrypt_hidden_volume(op)
    @ccall libaravis.g_mount_operation_get_is_tcrypt_hidden_volume(op::Ptr{GMountOperation})::gboolean
end

"""
    g_mount_operation_set_is_tcrypt_hidden_volume(op, hidden_volume)

### Prototype
```c
GIO_AVAILABLE_IN_2_58 void g_mount_operation_set_is_tcrypt_hidden_volume (GMountOperation *op, gboolean hidden_volume);
```
"""
function g_mount_operation_set_is_tcrypt_hidden_volume(op, hidden_volume)
    @ccall libaravis.g_mount_operation_set_is_tcrypt_hidden_volume(op::Ptr{GMountOperation}, hidden_volume::gboolean)::Cvoid
end

"""
    g_mount_operation_get_is_tcrypt_system_volume(op)

### Prototype
```c
GIO_AVAILABLE_IN_2_58 gboolean g_mount_operation_get_is_tcrypt_system_volume (GMountOperation *op);
```
"""
function g_mount_operation_get_is_tcrypt_system_volume(op)
    @ccall libaravis.g_mount_operation_get_is_tcrypt_system_volume(op::Ptr{GMountOperation})::gboolean
end

"""
    g_mount_operation_set_is_tcrypt_system_volume(op, system_volume)

### Prototype
```c
GIO_AVAILABLE_IN_2_58 void g_mount_operation_set_is_tcrypt_system_volume (GMountOperation *op, gboolean system_volume);
```
"""
function g_mount_operation_set_is_tcrypt_system_volume(op, system_volume)
    @ccall libaravis.g_mount_operation_set_is_tcrypt_system_volume(op::Ptr{GMountOperation}, system_volume::gboolean)::Cvoid
end

"""
    g_mount_operation_get_pim(op)

### Prototype
```c
GIO_AVAILABLE_IN_2_58 guint g_mount_operation_get_pim (GMountOperation *op);
```
"""
function g_mount_operation_get_pim(op)
    @ccall libaravis.g_mount_operation_get_pim(op::Ptr{GMountOperation})::guint
end

"""
    g_mount_operation_set_pim(op, pim)

### Prototype
```c
GIO_AVAILABLE_IN_2_58 void g_mount_operation_set_pim (GMountOperation *op, guint pim);
```
"""
function g_mount_operation_set_pim(op, pim)
    @ccall libaravis.g_mount_operation_set_pim(op::Ptr{GMountOperation}, pim::guint)::Cvoid
end

"""
    g_native_socket_address_new(native, len)

### Prototype
```c
GIO_AVAILABLE_IN_2_46 GSocketAddress *g_native_socket_address_new (gpointer native, gsize len);
```
"""
function g_native_socket_address_new(native, len)
    @ccall libaravis.g_native_socket_address_new(native::gpointer, len::gsize)::Ptr{GSocketAddress}
end

"""
    g_volume_monitor_get()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GVolumeMonitor *g_volume_monitor_get (void);
```
"""
function g_volume_monitor_get()
    @ccall libaravis.g_volume_monitor_get()::Ptr{GVolumeMonitor}
end

"""
    g_volume_monitor_get_connected_drives(volume_monitor)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GList * g_volume_monitor_get_connected_drives (GVolumeMonitor *volume_monitor);
```
"""
function g_volume_monitor_get_connected_drives(volume_monitor)
    @ccall libaravis.g_volume_monitor_get_connected_drives(volume_monitor::Ptr{GVolumeMonitor})::Ptr{GList}
end

"""
    g_volume_monitor_get_volumes(volume_monitor)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GList * g_volume_monitor_get_volumes (GVolumeMonitor *volume_monitor);
```
"""
function g_volume_monitor_get_volumes(volume_monitor)
    @ccall libaravis.g_volume_monitor_get_volumes(volume_monitor::Ptr{GVolumeMonitor})::Ptr{GList}
end

"""
    g_volume_monitor_get_mounts(volume_monitor)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GList * g_volume_monitor_get_mounts (GVolumeMonitor *volume_monitor);
```
"""
function g_volume_monitor_get_mounts(volume_monitor)
    @ccall libaravis.g_volume_monitor_get_mounts(volume_monitor::Ptr{GVolumeMonitor})::Ptr{GList}
end

"""
    g_volume_monitor_get_volume_for_uuid(volume_monitor, uuid)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GVolume * g_volume_monitor_get_volume_for_uuid (GVolumeMonitor *volume_monitor, const char *uuid);
```
"""
function g_volume_monitor_get_volume_for_uuid(volume_monitor, uuid)
    @ccall libaravis.g_volume_monitor_get_volume_for_uuid(volume_monitor::Ptr{GVolumeMonitor}, uuid::Cstring)::Ptr{GVolume}
end

"""
    g_volume_monitor_get_mount_for_uuid(volume_monitor, uuid)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GMount * g_volume_monitor_get_mount_for_uuid (GVolumeMonitor *volume_monitor, const char *uuid);
```
"""
function g_volume_monitor_get_mount_for_uuid(volume_monitor, uuid)
    @ccall libaravis.g_volume_monitor_get_mount_for_uuid(volume_monitor::Ptr{GVolumeMonitor}, uuid::Cstring)::Ptr{GMount}
end

"""
    g_volume_monitor_adopt_orphan_mount(mount)

### Prototype
```c
GIO_DEPRECATED GVolume * g_volume_monitor_adopt_orphan_mount (GMount *mount);
```
"""
function g_volume_monitor_adopt_orphan_mount(mount)
    @ccall libaravis.g_volume_monitor_adopt_orphan_mount(mount::Ptr{GMount})::Ptr{GVolume}
end

"""
    g_network_address_new(hostname, port)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketConnectable *g_network_address_new (const gchar *hostname, guint16 port);
```
"""
function g_network_address_new(hostname, port)
    @ccall libaravis.g_network_address_new(hostname::Ptr{gchar}, port::guint16)::Ptr{GSocketConnectable}
end

"""
    g_network_address_new_loopback(port)

### Prototype
```c
GIO_AVAILABLE_IN_2_44 GSocketConnectable *g_network_address_new_loopback (guint16 port);
```
"""
function g_network_address_new_loopback(port)
    @ccall libaravis.g_network_address_new_loopback(port::guint16)::Ptr{GSocketConnectable}
end

"""
    g_network_address_parse(host_and_port, default_port, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketConnectable *g_network_address_parse (const gchar *host_and_port, guint16 default_port, GError **error);
```
"""
function g_network_address_parse(host_and_port, default_port, error)
    @ccall libaravis.g_network_address_parse(host_and_port::Ptr{gchar}, default_port::guint16, error::Ptr{Ptr{GError}})::Ptr{GSocketConnectable}
end

"""
    g_network_address_parse_uri(uri, default_port, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketConnectable *g_network_address_parse_uri (const gchar *uri, guint16 default_port, GError **error);
```
"""
function g_network_address_parse_uri(uri, default_port, error)
    @ccall libaravis.g_network_address_parse_uri(uri::Ptr{gchar}, default_port::guint16, error::Ptr{Ptr{GError}})::Ptr{GSocketConnectable}
end

"""
    g_network_address_get_hostname(addr)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_network_address_get_hostname (GNetworkAddress *addr);
```
"""
function g_network_address_get_hostname(addr)
    @ccall libaravis.g_network_address_get_hostname(addr::Ptr{GNetworkAddress})::Ptr{gchar}
end

"""
    g_network_address_get_port(addr)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint16 g_network_address_get_port (GNetworkAddress *addr);
```
"""
function g_network_address_get_port(addr)
    @ccall libaravis.g_network_address_get_port(addr::Ptr{GNetworkAddress})::guint16
end

"""
    g_network_address_get_scheme(addr)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_network_address_get_scheme (GNetworkAddress *addr);
```
"""
function g_network_address_get_scheme(addr)
    @ccall libaravis.g_network_address_get_scheme(addr::Ptr{GNetworkAddress})::Ptr{gchar}
end

"""
    g_network_monitor_get_default()

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GNetworkMonitor *g_network_monitor_get_default (void);
```
"""
function g_network_monitor_get_default()
    @ccall libaravis.g_network_monitor_get_default()::Ptr{GNetworkMonitor}
end

"""
    g_network_monitor_get_network_available(monitor)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 gboolean g_network_monitor_get_network_available (GNetworkMonitor *monitor);
```
"""
function g_network_monitor_get_network_available(monitor)
    @ccall libaravis.g_network_monitor_get_network_available(monitor::Ptr{GNetworkMonitor})::gboolean
end

"""
    g_network_monitor_get_network_metered(monitor)

### Prototype
```c
GIO_AVAILABLE_IN_2_46 gboolean g_network_monitor_get_network_metered (GNetworkMonitor *monitor);
```
"""
function g_network_monitor_get_network_metered(monitor)
    @ccall libaravis.g_network_monitor_get_network_metered(monitor::Ptr{GNetworkMonitor})::gboolean
end

"""
    g_network_monitor_get_connectivity(monitor)

### Prototype
```c
GIO_AVAILABLE_IN_2_44 GNetworkConnectivity g_network_monitor_get_connectivity (GNetworkMonitor *monitor);
```
"""
function g_network_monitor_get_connectivity(monitor)
    @ccall libaravis.g_network_monitor_get_connectivity(monitor::Ptr{GNetworkMonitor})::GNetworkConnectivity
end

"""
    g_network_monitor_can_reach(monitor, connectable, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 gboolean g_network_monitor_can_reach (GNetworkMonitor *monitor, GSocketConnectable *connectable, GCancellable *cancellable, GError **error);
```
"""
function g_network_monitor_can_reach(monitor, connectable, cancellable, error)
    @ccall libaravis.g_network_monitor_can_reach(monitor::Ptr{GNetworkMonitor}, connectable::Ptr{GSocketConnectable}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_network_monitor_can_reach_async(monitor, connectable, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_network_monitor_can_reach_async (GNetworkMonitor *monitor, GSocketConnectable *connectable, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_network_monitor_can_reach_async(monitor, connectable, cancellable, callback, user_data)
    @ccall libaravis.g_network_monitor_can_reach_async(monitor::Ptr{GNetworkMonitor}, connectable::Ptr{GSocketConnectable}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_network_monitor_can_reach_finish(monitor, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 gboolean g_network_monitor_can_reach_finish (GNetworkMonitor *monitor, GAsyncResult *result, GError **error);
```
"""
function g_network_monitor_can_reach_finish(monitor, result, error)
    @ccall libaravis.g_network_monitor_can_reach_finish(monitor::Ptr{GNetworkMonitor}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_network_service_new(service, protocol, domain)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketConnectable *g_network_service_new (const gchar *service, const gchar *protocol, const gchar *domain);
```
"""
function g_network_service_new(service, protocol, domain)
    @ccall libaravis.g_network_service_new(service::Ptr{gchar}, protocol::Ptr{gchar}, domain::Ptr{gchar})::Ptr{GSocketConnectable}
end

"""
    g_network_service_get_service(srv)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_network_service_get_service (GNetworkService *srv);
```
"""
function g_network_service_get_service(srv)
    @ccall libaravis.g_network_service_get_service(srv::Ptr{GNetworkService})::Ptr{gchar}
end

"""
    g_network_service_get_protocol(srv)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_network_service_get_protocol (GNetworkService *srv);
```
"""
function g_network_service_get_protocol(srv)
    @ccall libaravis.g_network_service_get_protocol(srv::Ptr{GNetworkService})::Ptr{gchar}
end

"""
    g_network_service_get_domain(srv)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_network_service_get_domain (GNetworkService *srv);
```
"""
function g_network_service_get_domain(srv)
    @ccall libaravis.g_network_service_get_domain(srv::Ptr{GNetworkService})::Ptr{gchar}
end

"""
    g_network_service_get_scheme(srv)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_network_service_get_scheme (GNetworkService *srv);
```
"""
function g_network_service_get_scheme(srv)
    @ccall libaravis.g_network_service_get_scheme(srv::Ptr{GNetworkService})::Ptr{gchar}
end

"""
    g_network_service_set_scheme(srv, scheme)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_network_service_set_scheme (GNetworkService *srv, const gchar *scheme);
```
"""
function g_network_service_set_scheme(srv, scheme)
    @ccall libaravis.g_network_service_set_scheme(srv::Ptr{GNetworkService}, scheme::Ptr{gchar})::Cvoid
end

"""
    g_notification_new(title)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 GNotification * g_notification_new (const gchar *title);
```
"""
function g_notification_new(title)
    @ccall libaravis.g_notification_new(title::Ptr{gchar})::Ptr{GNotification}
end

"""
    g_notification_set_title(notification, title)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_notification_set_title (GNotification *notification, const gchar *title);
```
"""
function g_notification_set_title(notification, title)
    @ccall libaravis.g_notification_set_title(notification::Ptr{GNotification}, title::Ptr{gchar})::Cvoid
end

"""
    g_notification_set_body(notification, body)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_notification_set_body (GNotification *notification, const gchar *body);
```
"""
function g_notification_set_body(notification, body)
    @ccall libaravis.g_notification_set_body(notification::Ptr{GNotification}, body::Ptr{gchar})::Cvoid
end

"""
    g_notification_set_icon(notification, icon)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_notification_set_icon (GNotification *notification, GIcon *icon);
```
"""
function g_notification_set_icon(notification, icon)
    @ccall libaravis.g_notification_set_icon(notification::Ptr{GNotification}, icon::Ptr{GIcon})::Cvoid
end

"""
    g_notification_set_urgent(notification, urgent)

### Prototype
```c
GIO_DEPRECATED_IN_2_42_FOR(g_notification_set_priority) void g_notification_set_urgent (GNotification *notification, gboolean urgent);
```
"""
function g_notification_set_urgent(notification, urgent)
    @ccall libaravis.g_notification_set_urgent(notification::Ptr{GNotification}, urgent::gboolean)::Cvoid
end

"""
    g_notification_set_priority(notification, priority)

### Prototype
```c
GIO_AVAILABLE_IN_2_42 void g_notification_set_priority (GNotification *notification, GNotificationPriority priority);
```
"""
function g_notification_set_priority(notification, priority)
    @ccall libaravis.g_notification_set_priority(notification::Ptr{GNotification}, priority::GNotificationPriority)::Cvoid
end

"""
    g_notification_set_category(notification, category)

### Prototype
```c
GIO_AVAILABLE_IN_2_70 void g_notification_set_category (GNotification *notification, const gchar *category);
```
"""
function g_notification_set_category(notification, category)
    @ccall libaravis.g_notification_set_category(notification::Ptr{GNotification}, category::Ptr{gchar})::Cvoid
end

"""
    g_notification_add_button(notification, label, detailed_action)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_notification_add_button (GNotification *notification, const gchar *label, const gchar *detailed_action);
```
"""
function g_notification_add_button(notification, label, detailed_action)
    @ccall libaravis.g_notification_add_button(notification::Ptr{GNotification}, label::Ptr{gchar}, detailed_action::Ptr{gchar})::Cvoid
end

"""
    g_notification_add_button_with_target_value(notification, label, action, target)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_notification_add_button_with_target_value (GNotification *notification, const gchar *label, const gchar *action, GVariant *target);
```
"""
function g_notification_add_button_with_target_value(notification, label, action, target)
    @ccall libaravis.g_notification_add_button_with_target_value(notification::Ptr{GNotification}, label::Ptr{gchar}, action::Ptr{gchar}, target::Ptr{GVariant})::Cvoid
end

"""
    g_notification_set_default_action(notification, detailed_action)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_notification_set_default_action (GNotification *notification, const gchar *detailed_action);
```
"""
function g_notification_set_default_action(notification, detailed_action)
    @ccall libaravis.g_notification_set_default_action(notification::Ptr{GNotification}, detailed_action::Ptr{gchar})::Cvoid
end

"""
    g_notification_set_default_action_and_target_value(notification, action, target)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_notification_set_default_action_and_target_value (GNotification *notification, const gchar *action, GVariant *target);
```
"""
function g_notification_set_default_action_and_target_value(notification, action, target)
    @ccall libaravis.g_notification_set_default_action_and_target_value(notification::Ptr{GNotification}, action::Ptr{gchar}, target::Ptr{GVariant})::Cvoid
end

"""
    g_permission_acquire(permission, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_permission_acquire (GPermission *permission, GCancellable *cancellable, GError **error);
```
"""
function g_permission_acquire(permission, cancellable, error)
    @ccall libaravis.g_permission_acquire(permission::Ptr{GPermission}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_permission_acquire_async(permission, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_permission_acquire_async (GPermission *permission, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_permission_acquire_async(permission, cancellable, callback, user_data)
    @ccall libaravis.g_permission_acquire_async(permission::Ptr{GPermission}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_permission_acquire_finish(permission, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_permission_acquire_finish (GPermission *permission, GAsyncResult *result, GError **error);
```
"""
function g_permission_acquire_finish(permission, result, error)
    @ccall libaravis.g_permission_acquire_finish(permission::Ptr{GPermission}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_permission_release(permission, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_permission_release (GPermission *permission, GCancellable *cancellable, GError **error);
```
"""
function g_permission_release(permission, cancellable, error)
    @ccall libaravis.g_permission_release(permission::Ptr{GPermission}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_permission_release_async(permission, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_permission_release_async (GPermission *permission, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_permission_release_async(permission, cancellable, callback, user_data)
    @ccall libaravis.g_permission_release_async(permission::Ptr{GPermission}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_permission_release_finish(permission, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_permission_release_finish (GPermission *permission, GAsyncResult *result, GError **error);
```
"""
function g_permission_release_finish(permission, result, error)
    @ccall libaravis.g_permission_release_finish(permission::Ptr{GPermission}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_permission_get_allowed(permission)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_permission_get_allowed (GPermission *permission);
```
"""
function g_permission_get_allowed(permission)
    @ccall libaravis.g_permission_get_allowed(permission::Ptr{GPermission})::gboolean
end

"""
    g_permission_get_can_acquire(permission)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_permission_get_can_acquire (GPermission *permission);
```
"""
function g_permission_get_can_acquire(permission)
    @ccall libaravis.g_permission_get_can_acquire(permission::Ptr{GPermission})::gboolean
end

"""
    g_permission_get_can_release(permission)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_permission_get_can_release (GPermission *permission);
```
"""
function g_permission_get_can_release(permission)
    @ccall libaravis.g_permission_get_can_release(permission::Ptr{GPermission})::gboolean
end

"""
    g_permission_impl_update(permission, allowed, can_acquire, can_release)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_permission_impl_update (GPermission *permission, gboolean allowed, gboolean can_acquire, gboolean can_release);
```
"""
function g_permission_impl_update(permission, allowed, can_acquire, can_release)
    @ccall libaravis.g_permission_impl_update(permission::Ptr{GPermission}, allowed::gboolean, can_acquire::gboolean, can_release::gboolean)::Cvoid
end

"""
    g_pollable_input_stream_can_poll(stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_pollable_input_stream_can_poll (GPollableInputStream *stream);
```
"""
function g_pollable_input_stream_can_poll(stream)
    @ccall libaravis.g_pollable_input_stream_can_poll(stream::Ptr{GPollableInputStream})::gboolean
end

"""
    g_pollable_input_stream_is_readable(stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_pollable_input_stream_is_readable (GPollableInputStream *stream);
```
"""
function g_pollable_input_stream_is_readable(stream)
    @ccall libaravis.g_pollable_input_stream_is_readable(stream::Ptr{GPollableInputStream})::gboolean
end

"""
    g_pollable_input_stream_create_source(stream, cancellable)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSource *g_pollable_input_stream_create_source (GPollableInputStream *stream, GCancellable *cancellable);
```
"""
function g_pollable_input_stream_create_source(stream, cancellable)
    @ccall libaravis.g_pollable_input_stream_create_source(stream::Ptr{GPollableInputStream}, cancellable::Ptr{GCancellable})::Ptr{GSource}
end

"""
    g_pollable_input_stream_read_nonblocking(stream, buffer, count, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gssize g_pollable_input_stream_read_nonblocking (GPollableInputStream *stream, void *buffer, gsize count, GCancellable *cancellable, GError **error);
```
"""
function g_pollable_input_stream_read_nonblocking(stream, buffer, count, cancellable, error)
    @ccall libaravis.g_pollable_input_stream_read_nonblocking(stream::Ptr{GPollableInputStream}, buffer::Ptr{Cvoid}, count::gsize, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gssize
end

"""
    g_pollable_output_stream_can_poll(stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_pollable_output_stream_can_poll (GPollableOutputStream *stream);
```
"""
function g_pollable_output_stream_can_poll(stream)
    @ccall libaravis.g_pollable_output_stream_can_poll(stream::Ptr{GPollableOutputStream})::gboolean
end

"""
    g_pollable_output_stream_is_writable(stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_pollable_output_stream_is_writable (GPollableOutputStream *stream);
```
"""
function g_pollable_output_stream_is_writable(stream)
    @ccall libaravis.g_pollable_output_stream_is_writable(stream::Ptr{GPollableOutputStream})::gboolean
end

"""
    g_pollable_output_stream_create_source(stream, cancellable)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSource *g_pollable_output_stream_create_source (GPollableOutputStream *stream, GCancellable *cancellable);
```
"""
function g_pollable_output_stream_create_source(stream, cancellable)
    @ccall libaravis.g_pollable_output_stream_create_source(stream::Ptr{GPollableOutputStream}, cancellable::Ptr{GCancellable})::Ptr{GSource}
end

"""
    g_pollable_output_stream_write_nonblocking(stream, buffer, count, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gssize g_pollable_output_stream_write_nonblocking (GPollableOutputStream *stream, const void *buffer, gsize count, GCancellable *cancellable, GError **error);
```
"""
function g_pollable_output_stream_write_nonblocking(stream, buffer, count, cancellable, error)
    @ccall libaravis.g_pollable_output_stream_write_nonblocking(stream::Ptr{GPollableOutputStream}, buffer::Ptr{Cvoid}, count::gsize, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gssize
end

"""
    g_pollable_output_stream_writev_nonblocking(stream, vectors, n_vectors, bytes_written, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_60 GPollableReturn g_pollable_output_stream_writev_nonblocking (GPollableOutputStream *stream, const GOutputVector *vectors, gsize n_vectors, gsize *bytes_written, GCancellable *cancellable, GError **error);
```
"""
function g_pollable_output_stream_writev_nonblocking(stream, vectors, n_vectors, bytes_written, cancellable, error)
    @ccall libaravis.g_pollable_output_stream_writev_nonblocking(stream::Ptr{GPollableOutputStream}, vectors::Ptr{GOutputVector}, n_vectors::gsize, bytes_written::Ptr{gsize}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::GPollableReturn
end

"""
    g_pollable_source_new(pollable_stream)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSource *g_pollable_source_new (GObject *pollable_stream);
```
"""
function g_pollable_source_new(pollable_stream)
    @ccall libaravis.g_pollable_source_new(pollable_stream::Ptr{GObject})::Ptr{GSource}
end

"""
    g_pollable_source_new_full(pollable_stream, child_source, cancellable)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 GSource *g_pollable_source_new_full (gpointer pollable_stream, GSource *child_source, GCancellable *cancellable);
```
"""
function g_pollable_source_new_full(pollable_stream, child_source, cancellable)
    @ccall libaravis.g_pollable_source_new_full(pollable_stream::gpointer, child_source::Ptr{GSource}, cancellable::Ptr{GCancellable})::Ptr{GSource}
end

"""
    g_pollable_stream_read(stream, buffer, count, blocking, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 gssize g_pollable_stream_read (GInputStream *stream, void *buffer, gsize count, gboolean blocking, GCancellable *cancellable, GError **error);
```
"""
function g_pollable_stream_read(stream, buffer, count, blocking, cancellable, error)
    @ccall libaravis.g_pollable_stream_read(stream::Ptr{GInputStream}, buffer::Ptr{Cvoid}, count::gsize, blocking::gboolean, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gssize
end

"""
    g_pollable_stream_write(stream, buffer, count, blocking, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 gssize g_pollable_stream_write (GOutputStream *stream, const void *buffer, gsize count, gboolean blocking, GCancellable *cancellable, GError **error);
```
"""
function g_pollable_stream_write(stream, buffer, count, blocking, cancellable, error)
    @ccall libaravis.g_pollable_stream_write(stream::Ptr{GOutputStream}, buffer::Ptr{Cvoid}, count::gsize, blocking::gboolean, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gssize
end

"""
    g_pollable_stream_write_all(stream, buffer, count, blocking, bytes_written, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 gboolean g_pollable_stream_write_all (GOutputStream *stream, const void *buffer, gsize count, gboolean blocking, gsize *bytes_written, GCancellable *cancellable, GError **error);
```
"""
function g_pollable_stream_write_all(stream, buffer, count, blocking, bytes_written, cancellable, error)
    @ccall libaravis.g_pollable_stream_write_all(stream::Ptr{GOutputStream}, buffer::Ptr{Cvoid}, count::gsize, blocking::gboolean, bytes_written::Ptr{gsize}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

const GPowerProfileMonitor_autoptr = Ptr{GPowerProfileMonitor}

const GPowerProfileMonitor_listautoptr = Ptr{GList}

const GPowerProfileMonitor_slistautoptr = Ptr{GSList}

const GPowerProfileMonitor_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GPowerProfileMonitor(_ptr)

### Prototype
```c
G_DECLARE_INTERFACE (GPowerProfileMonitor, g_power_profile_monitor, g, power_profile_monitor, GObject);
```
"""
function glib_autoptr_clear_GPowerProfileMonitor(_ptr)
    @ccall libaravis.glib_autoptr_clear_GPowerProfileMonitor(_ptr::Ptr{GPowerProfileMonitor})::Cvoid
end

"""
    glib_autoptr_cleanup_GPowerProfileMonitor(_ptr)

### Prototype
```c
G_DECLARE_INTERFACE (GPowerProfileMonitor, g_power_profile_monitor, g, power_profile_monitor, GObject);
```
"""
function glib_autoptr_cleanup_GPowerProfileMonitor(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GPowerProfileMonitor(_ptr::Ptr{Ptr{GPowerProfileMonitor}})::Cvoid
end

"""
    glib_autoptr_destroy_GPowerProfileMonitor(_ptr)

### Prototype
```c
G_DECLARE_INTERFACE (GPowerProfileMonitor, g_power_profile_monitor, g, power_profile_monitor, GObject);
```
"""
function glib_autoptr_destroy_GPowerProfileMonitor(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GPowerProfileMonitor(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GPowerProfileMonitor(_l)

### Prototype
```c
G_DECLARE_INTERFACE (GPowerProfileMonitor, g_power_profile_monitor, g, power_profile_monitor, GObject);
```
"""
function glib_listautoptr_cleanup_GPowerProfileMonitor(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GPowerProfileMonitor(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GPowerProfileMonitor(_l)

### Prototype
```c
G_DECLARE_INTERFACE (GPowerProfileMonitor, g_power_profile_monitor, g, power_profile_monitor, GObject);
```
"""
function glib_slistautoptr_cleanup_GPowerProfileMonitor(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GPowerProfileMonitor(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GPowerProfileMonitor(_q)

### Prototype
```c
G_DECLARE_INTERFACE (GPowerProfileMonitor, g_power_profile_monitor, g, power_profile_monitor, GObject);
```
"""
function glib_queueautoptr_cleanup_GPowerProfileMonitor(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GPowerProfileMonitor(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    g_power_profile_monitor(ptr)

### Prototype
```c
G_DECLARE_INTERFACE (GPowerProfileMonitor, g_power_profile_monitor, g, power_profile_monitor, GObject);
```
"""
function g_power_profile_monitor(ptr)
    @ccall libaravis.g_power_profile_monitor(ptr::gpointer)::Ptr{GPowerProfileMonitor}
end

"""
    g_IS_power_profile_monitor(ptr)

### Prototype
```c
G_DECLARE_INTERFACE (GPowerProfileMonitor, g_power_profile_monitor, g, power_profile_monitor, GObject);
```
"""
function g_IS_power_profile_monitor(ptr)
    @ccall libaravis.g_IS_power_profile_monitor(ptr::gpointer)::gboolean
end

"""
    g_power_profile_monitor_GET_IFACE(ptr)

### Prototype
```c
G_DECLARE_INTERFACE (GPowerProfileMonitor, g_power_profile_monitor, g, power_profile_monitor, GObject);
```
"""
function g_power_profile_monitor_GET_IFACE(ptr)
    @ccall libaravis.g_power_profile_monitor_GET_IFACE(ptr::gpointer)::Ptr{GPowerProfileMonitorInterface}
end

"""
    g_power_profile_monitor_dup_default()

### Prototype
```c
GIO_AVAILABLE_IN_2_70 GPowerProfileMonitor *g_power_profile_monitor_dup_default (void);
```
"""
function g_power_profile_monitor_dup_default()
    @ccall libaravis.g_power_profile_monitor_dup_default()::Ptr{GPowerProfileMonitor}
end

"""
    g_power_profile_monitor_get_power_saver_enabled(monitor)

### Prototype
```c
GIO_AVAILABLE_IN_2_70 gboolean g_power_profile_monitor_get_power_saver_enabled (GPowerProfileMonitor *monitor);
```
"""
function g_power_profile_monitor_get_power_saver_enabled(monitor)
    @ccall libaravis.g_power_profile_monitor_get_power_saver_enabled(monitor::Ptr{GPowerProfileMonitor})::gboolean
end

"""
    g_property_action_new(name, object, property_name)

### Prototype
```c
GIO_AVAILABLE_IN_2_38 GPropertyAction * g_property_action_new (const gchar *name, gpointer object, const gchar *property_name);
```
"""
function g_property_action_new(name, object, property_name)
    @ccall libaravis.g_property_action_new(name::Ptr{gchar}, object::gpointer, property_name::Ptr{gchar})::Ptr{GPropertyAction}
end

"""
    g_proxy_get_default_for_protocol(protocol)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GProxy *g_proxy_get_default_for_protocol (const gchar *protocol);
```
"""
function g_proxy_get_default_for_protocol(protocol)
    @ccall libaravis.g_proxy_get_default_for_protocol(protocol::Ptr{gchar})::Ptr{GProxy}
end

"""
    g_proxy_connect(proxy, connection, proxy_address, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIOStream *g_proxy_connect (GProxy *proxy, GIOStream *connection, GProxyAddress *proxy_address, GCancellable *cancellable, GError **error);
```
"""
function g_proxy_connect(proxy, connection, proxy_address, cancellable, error)
    @ccall libaravis.g_proxy_connect(proxy::Ptr{GProxy}, connection::Ptr{GIOStream}, proxy_address::Ptr{GProxyAddress}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GIOStream}
end

"""
    g_proxy_connect_async(proxy, connection, proxy_address, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_proxy_connect_async (GProxy *proxy, GIOStream *connection, GProxyAddress *proxy_address, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_proxy_connect_async(proxy, connection, proxy_address, cancellable, callback, user_data)
    @ccall libaravis.g_proxy_connect_async(proxy::Ptr{GProxy}, connection::Ptr{GIOStream}, proxy_address::Ptr{GProxyAddress}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_proxy_connect_finish(proxy, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIOStream *g_proxy_connect_finish (GProxy *proxy, GAsyncResult *result, GError **error);
```
"""
function g_proxy_connect_finish(proxy, result, error)
    @ccall libaravis.g_proxy_connect_finish(proxy::Ptr{GProxy}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GIOStream}
end

"""
    g_proxy_supports_hostname(proxy)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_proxy_supports_hostname (GProxy *proxy);
```
"""
function g_proxy_supports_hostname(proxy)
    @ccall libaravis.g_proxy_supports_hostname(proxy::Ptr{GProxy})::gboolean
end

"""
    g_proxy_address_new(inetaddr, port, protocol, dest_hostname, dest_port, username, password)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketAddress *g_proxy_address_new (GInetAddress *inetaddr, guint16 port, const gchar *protocol, const gchar *dest_hostname, guint16 dest_port, const gchar *username, const gchar *password);
```
"""
function g_proxy_address_new(inetaddr, port, protocol, dest_hostname, dest_port, username, password)
    @ccall libaravis.g_proxy_address_new(inetaddr::Ptr{GInetAddress}, port::guint16, protocol::Ptr{gchar}, dest_hostname::Ptr{gchar}, dest_port::guint16, username::Ptr{gchar}, password::Ptr{gchar})::Ptr{GSocketAddress}
end

"""
    g_proxy_address_get_protocol(proxy)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_proxy_address_get_protocol (GProxyAddress *proxy);
```
"""
function g_proxy_address_get_protocol(proxy)
    @ccall libaravis.g_proxy_address_get_protocol(proxy::Ptr{GProxyAddress})::Ptr{gchar}
end

"""
    g_proxy_address_get_destination_protocol(proxy)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 const gchar *g_proxy_address_get_destination_protocol (GProxyAddress *proxy);
```
"""
function g_proxy_address_get_destination_protocol(proxy)
    @ccall libaravis.g_proxy_address_get_destination_protocol(proxy::Ptr{GProxyAddress})::Ptr{gchar}
end

"""
    g_proxy_address_get_destination_hostname(proxy)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_proxy_address_get_destination_hostname (GProxyAddress *proxy);
```
"""
function g_proxy_address_get_destination_hostname(proxy)
    @ccall libaravis.g_proxy_address_get_destination_hostname(proxy::Ptr{GProxyAddress})::Ptr{gchar}
end

"""
    g_proxy_address_get_destination_port(proxy)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint16 g_proxy_address_get_destination_port (GProxyAddress *proxy);
```
"""
function g_proxy_address_get_destination_port(proxy)
    @ccall libaravis.g_proxy_address_get_destination_port(proxy::Ptr{GProxyAddress})::guint16
end

"""
    g_proxy_address_get_username(proxy)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_proxy_address_get_username (GProxyAddress *proxy);
```
"""
function g_proxy_address_get_username(proxy)
    @ccall libaravis.g_proxy_address_get_username(proxy::Ptr{GProxyAddress})::Ptr{gchar}
end

"""
    g_proxy_address_get_password(proxy)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_proxy_address_get_password (GProxyAddress *proxy);
```
"""
function g_proxy_address_get_password(proxy)
    @ccall libaravis.g_proxy_address_get_password(proxy::Ptr{GProxyAddress})::Ptr{gchar}
end

"""
    g_proxy_address_get_uri(proxy)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 const gchar *g_proxy_address_get_uri (GProxyAddress *proxy);
```
"""
function g_proxy_address_get_uri(proxy)
    @ccall libaravis.g_proxy_address_get_uri(proxy::Ptr{GProxyAddress})::Ptr{gchar}
end

"""
    g_socket_address_enumerator_next(enumerator, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketAddress *g_socket_address_enumerator_next (GSocketAddressEnumerator *enumerator, GCancellable *cancellable, GError **error);
```
"""
function g_socket_address_enumerator_next(enumerator, cancellable, error)
    @ccall libaravis.g_socket_address_enumerator_next(enumerator::Ptr{GSocketAddressEnumerator}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GSocketAddress}
end

"""
    g_socket_address_enumerator_next_async(enumerator, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_socket_address_enumerator_next_async (GSocketAddressEnumerator *enumerator, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_socket_address_enumerator_next_async(enumerator, cancellable, callback, user_data)
    @ccall libaravis.g_socket_address_enumerator_next_async(enumerator::Ptr{GSocketAddressEnumerator}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_socket_address_enumerator_next_finish(enumerator, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketAddress *g_socket_address_enumerator_next_finish (GSocketAddressEnumerator *enumerator, GAsyncResult *result, GError **error);
```
"""
function g_socket_address_enumerator_next_finish(enumerator, result, error)
    @ccall libaravis.g_socket_address_enumerator_next_finish(enumerator::Ptr{GSocketAddressEnumerator}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GSocketAddress}
end

"""
    g_proxy_resolver_get_default()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GProxyResolver *g_proxy_resolver_get_default (void);
```
"""
function g_proxy_resolver_get_default()
    @ccall libaravis.g_proxy_resolver_get_default()::Ptr{GProxyResolver}
end

"""
    g_proxy_resolver_is_supported(resolver)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_proxy_resolver_is_supported (GProxyResolver *resolver);
```
"""
function g_proxy_resolver_is_supported(resolver)
    @ccall libaravis.g_proxy_resolver_is_supported(resolver::Ptr{GProxyResolver})::gboolean
end

"""
    g_proxy_resolver_lookup(resolver, uri, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gchar **g_proxy_resolver_lookup (GProxyResolver *resolver, const gchar *uri, GCancellable *cancellable, GError **error);
```
"""
function g_proxy_resolver_lookup(resolver, uri, cancellable, error)
    @ccall libaravis.g_proxy_resolver_lookup(resolver::Ptr{GProxyResolver}, uri::Ptr{gchar}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{Ptr{gchar}}
end

"""
    g_proxy_resolver_lookup_async(resolver, uri, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_proxy_resolver_lookup_async (GProxyResolver *resolver, const gchar *uri, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_proxy_resolver_lookup_async(resolver, uri, cancellable, callback, user_data)
    @ccall libaravis.g_proxy_resolver_lookup_async(resolver::Ptr{GProxyResolver}, uri::Ptr{gchar}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_proxy_resolver_lookup_finish(resolver, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gchar **g_proxy_resolver_lookup_finish (GProxyResolver *resolver, GAsyncResult *result, GError **error);
```
"""
function g_proxy_resolver_lookup_finish(resolver, result, error)
    @ccall libaravis.g_proxy_resolver_lookup_finish(resolver::Ptr{GProxyResolver}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{Ptr{gchar}}
end

"""
    g_remote_action_group_activate_action_full(remote, action_name, parameter, platform_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_remote_action_group_activate_action_full (GRemoteActionGroup *remote, const gchar *action_name, GVariant *parameter, GVariant *platform_data);
```
"""
function g_remote_action_group_activate_action_full(remote, action_name, parameter, platform_data)
    @ccall libaravis.g_remote_action_group_activate_action_full(remote::Ptr{GRemoteActionGroup}, action_name::Ptr{gchar}, parameter::Ptr{GVariant}, platform_data::Ptr{GVariant})::Cvoid
end

"""
    g_remote_action_group_change_action_state_full(remote, action_name, value, platform_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_remote_action_group_change_action_state_full (GRemoteActionGroup *remote, const gchar *action_name, GVariant *value, GVariant *platform_data);
```
"""
function g_remote_action_group_change_action_state_full(remote, action_name, value, platform_data)
    @ccall libaravis.g_remote_action_group_change_action_state_full(remote::Ptr{GRemoteActionGroup}, action_name::Ptr{gchar}, value::Ptr{GVariant}, platform_data::Ptr{GVariant})::Cvoid
end

"""
    GResolverNameLookupFlags

[`GResolverNameLookupFlags`](@ref): \\_RESOLVER\\_NAME\\_LOOKUP\\_FLAGS\\_DEFAULT: default behavior (same as [`g_resolver_lookup_by_name`](@ref)()) \\_RESOLVER\\_NAME\\_LOOKUP\\_FLAGS\\_IPV4\\_ONLY: only resolve ipv4 addresses \\_RESOLVER\\_NAME\\_LOOKUP\\_FLAGS\\_IPV6\\_ONLY: only resolve ipv6 addresses

Flags to modify lookup behavior.

Since: 2.60
"""
@cenum GResolverNameLookupFlags::UInt32 begin
    G_RESOLVER_NAME_LOOKUP_FLAGS_DEFAULT = 0
    G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY = 1
    G_RESOLVER_NAME_LOOKUP_FLAGS_IPV6_ONLY = 2
end

"""
    g_resolver_get_default()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GResolver *g_resolver_get_default (void);
```
"""
function g_resolver_get_default()
    @ccall libaravis.g_resolver_get_default()::Ptr{GResolver}
end

"""
    g_resolver_set_default(resolver)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_resolver_set_default (GResolver *resolver);
```
"""
function g_resolver_set_default(resolver)
    @ccall libaravis.g_resolver_set_default(resolver::Ptr{GResolver})::Cvoid
end

"""
    g_resolver_lookup_by_name(resolver, hostname, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GList *g_resolver_lookup_by_name (GResolver *resolver, const gchar *hostname, GCancellable *cancellable, GError **error);
```
"""
function g_resolver_lookup_by_name(resolver, hostname, cancellable, error)
    @ccall libaravis.g_resolver_lookup_by_name(resolver::Ptr{GResolver}, hostname::Ptr{gchar}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GList}
end

"""
    g_resolver_lookup_by_name_async(resolver, hostname, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_resolver_lookup_by_name_async (GResolver *resolver, const gchar *hostname, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_resolver_lookup_by_name_async(resolver, hostname, cancellable, callback, user_data)
    @ccall libaravis.g_resolver_lookup_by_name_async(resolver::Ptr{GResolver}, hostname::Ptr{gchar}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_resolver_lookup_by_name_finish(resolver, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GList *g_resolver_lookup_by_name_finish (GResolver *resolver, GAsyncResult *result, GError **error);
```
"""
function g_resolver_lookup_by_name_finish(resolver, result, error)
    @ccall libaravis.g_resolver_lookup_by_name_finish(resolver::Ptr{GResolver}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GList}
end

"""
    g_resolver_lookup_by_name_with_flags_async(resolver, hostname, flags, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_60 void g_resolver_lookup_by_name_with_flags_async (GResolver *resolver, const gchar *hostname, GResolverNameLookupFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_resolver_lookup_by_name_with_flags_async(resolver, hostname, flags, cancellable, callback, user_data)
    @ccall libaravis.g_resolver_lookup_by_name_with_flags_async(resolver::Ptr{GResolver}, hostname::Ptr{gchar}, flags::GResolverNameLookupFlags, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_resolver_lookup_by_name_with_flags_finish(resolver, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_60 GList *g_resolver_lookup_by_name_with_flags_finish (GResolver *resolver, GAsyncResult *result, GError **error);
```
"""
function g_resolver_lookup_by_name_with_flags_finish(resolver, result, error)
    @ccall libaravis.g_resolver_lookup_by_name_with_flags_finish(resolver::Ptr{GResolver}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GList}
end

"""
    g_resolver_lookup_by_name_with_flags(resolver, hostname, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_60 GList *g_resolver_lookup_by_name_with_flags (GResolver *resolver, const gchar *hostname, GResolverNameLookupFlags flags, GCancellable *cancellable, GError **error);
```
"""
function g_resolver_lookup_by_name_with_flags(resolver, hostname, flags, cancellable, error)
    @ccall libaravis.g_resolver_lookup_by_name_with_flags(resolver::Ptr{GResolver}, hostname::Ptr{gchar}, flags::GResolverNameLookupFlags, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GList}
end

"""
    g_resolver_free_addresses(addresses)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_resolver_free_addresses (GList *addresses);
```
"""
function g_resolver_free_addresses(addresses)
    @ccall libaravis.g_resolver_free_addresses(addresses::Ptr{GList})::Cvoid
end

"""
    g_resolver_lookup_by_address(resolver, address, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gchar *g_resolver_lookup_by_address (GResolver *resolver, GInetAddress *address, GCancellable *cancellable, GError **error);
```
"""
function g_resolver_lookup_by_address(resolver, address, cancellable, error)
    @ccall libaravis.g_resolver_lookup_by_address(resolver::Ptr{GResolver}, address::Ptr{GInetAddress}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_resolver_lookup_by_address_async(resolver, address, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_resolver_lookup_by_address_async (GResolver *resolver, GInetAddress *address, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_resolver_lookup_by_address_async(resolver, address, cancellable, callback, user_data)
    @ccall libaravis.g_resolver_lookup_by_address_async(resolver::Ptr{GResolver}, address::Ptr{GInetAddress}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_resolver_lookup_by_address_finish(resolver, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gchar *g_resolver_lookup_by_address_finish (GResolver *resolver, GAsyncResult *result, GError **error);
```
"""
function g_resolver_lookup_by_address_finish(resolver, result, error)
    @ccall libaravis.g_resolver_lookup_by_address_finish(resolver::Ptr{GResolver}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{gchar}
end

"""
    g_resolver_lookup_service(resolver, service, protocol, domain, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GList *g_resolver_lookup_service (GResolver *resolver, const gchar *service, const gchar *protocol, const gchar *domain, GCancellable *cancellable, GError **error);
```
"""
function g_resolver_lookup_service(resolver, service, protocol, domain, cancellable, error)
    @ccall libaravis.g_resolver_lookup_service(resolver::Ptr{GResolver}, service::Ptr{gchar}, protocol::Ptr{gchar}, domain::Ptr{gchar}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GList}
end

"""
    g_resolver_lookup_service_async(resolver, service, protocol, domain, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_resolver_lookup_service_async (GResolver *resolver, const gchar *service, const gchar *protocol, const gchar *domain, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_resolver_lookup_service_async(resolver, service, protocol, domain, cancellable, callback, user_data)
    @ccall libaravis.g_resolver_lookup_service_async(resolver::Ptr{GResolver}, service::Ptr{gchar}, protocol::Ptr{gchar}, domain::Ptr{gchar}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_resolver_lookup_service_finish(resolver, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GList *g_resolver_lookup_service_finish (GResolver *resolver, GAsyncResult *result, GError **error);
```
"""
function g_resolver_lookup_service_finish(resolver, result, error)
    @ccall libaravis.g_resolver_lookup_service_finish(resolver::Ptr{GResolver}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GList}
end

"""
    g_resolver_lookup_records(resolver, rrname, record_type, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 GList *g_resolver_lookup_records (GResolver *resolver, const gchar *rrname, GResolverRecordType record_type, GCancellable *cancellable, GError **error);
```
"""
function g_resolver_lookup_records(resolver, rrname, record_type, cancellable, error)
    @ccall libaravis.g_resolver_lookup_records(resolver::Ptr{GResolver}, rrname::Ptr{gchar}, record_type::GResolverRecordType, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GList}
end

"""
    g_resolver_lookup_records_async(resolver, rrname, record_type, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 void g_resolver_lookup_records_async (GResolver *resolver, const gchar *rrname, GResolverRecordType record_type, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_resolver_lookup_records_async(resolver, rrname, record_type, cancellable, callback, user_data)
    @ccall libaravis.g_resolver_lookup_records_async(resolver::Ptr{GResolver}, rrname::Ptr{gchar}, record_type::GResolverRecordType, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_resolver_lookup_records_finish(resolver, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 GList *g_resolver_lookup_records_finish (GResolver *resolver, GAsyncResult *result, GError **error);
```
"""
function g_resolver_lookup_records_finish(resolver, result, error)
    @ccall libaravis.g_resolver_lookup_records_finish(resolver::Ptr{GResolver}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GList}
end

"""
    g_resolver_free_targets(targets)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_resolver_free_targets (GList *targets);
```
"""
function g_resolver_free_targets(targets)
    @ccall libaravis.g_resolver_free_targets(targets::Ptr{GList})::Cvoid
end

"""
    g_resolver_get_timeout(resolver)

### Prototype
```c
GIO_AVAILABLE_IN_2_78 unsigned g_resolver_get_timeout (GResolver *resolver);
```
"""
function g_resolver_get_timeout(resolver)
    @ccall libaravis.g_resolver_get_timeout(resolver::Ptr{GResolver})::Cuint
end

"""
    g_resolver_set_timeout(resolver, timeout_ms)

### Prototype
```c
GIO_AVAILABLE_IN_2_78 void g_resolver_set_timeout (GResolver *resolver, unsigned timeout_ms);
```
"""
function g_resolver_set_timeout(resolver, timeout_ms)
    @ccall libaravis.g_resolver_set_timeout(resolver::Ptr{GResolver}, timeout_ms::Cuint)::Cvoid
end

struct _GStaticResource
    data::Ptr{guint8}
    data_len::gsize
    resource::Ptr{GResource}
    next::Ptr{Cvoid} # next::Ptr{GStaticResource}
    padding::gpointer
end

function Base.getproperty(x::_GStaticResource, f::Symbol)
    f === :next && return Ptr{GStaticResource}(getfield(x, f))
    return getfield(x, f)
end

const GStaticResource = _GStaticResource

"""
    g_resource_new_from_data(data, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GResource * g_resource_new_from_data (GBytes *data, GError **error);
```
"""
function g_resource_new_from_data(data, error)
    @ccall libaravis.g_resource_new_from_data(data::Ptr{GBytes}, error::Ptr{Ptr{GError}})::Ptr{GResource}
end

"""
    g_resource_ref(resource)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GResource * g_resource_ref (GResource *resource);
```
"""
function g_resource_ref(resource)
    @ccall libaravis.g_resource_ref(resource::Ptr{GResource})::Ptr{GResource}
end

"""
    g_resource_unref(resource)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_resource_unref (GResource *resource);
```
"""
function g_resource_unref(resource)
    @ccall libaravis.g_resource_unref(resource::Ptr{GResource})::Cvoid
end

"""
    g_resource_load(filename, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GResource * g_resource_load (const gchar *filename, GError **error);
```
"""
function g_resource_load(filename, error)
    @ccall libaravis.g_resource_load(filename::Ptr{gchar}, error::Ptr{Ptr{GError}})::Ptr{GResource}
end

"""
    g_resource_open_stream(resource, path, lookup_flags, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GInputStream *g_resource_open_stream (GResource *resource, const char *path, GResourceLookupFlags lookup_flags, GError **error);
```
"""
function g_resource_open_stream(resource, path, lookup_flags, error)
    @ccall libaravis.g_resource_open_stream(resource::Ptr{GResource}, path::Cstring, lookup_flags::GResourceLookupFlags, error::Ptr{Ptr{GError}})::Ptr{GInputStream}
end

"""
    g_resource_lookup_data(resource, path, lookup_flags, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GBytes * g_resource_lookup_data (GResource *resource, const char *path, GResourceLookupFlags lookup_flags, GError **error);
```
"""
function g_resource_lookup_data(resource, path, lookup_flags, error)
    @ccall libaravis.g_resource_lookup_data(resource::Ptr{GResource}, path::Cstring, lookup_flags::GResourceLookupFlags, error::Ptr{Ptr{GError}})::Ptr{GBytes}
end

"""
    g_resource_enumerate_children(resource, path, lookup_flags, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 char ** g_resource_enumerate_children (GResource *resource, const char *path, GResourceLookupFlags lookup_flags, GError **error);
```
"""
function g_resource_enumerate_children(resource, path, lookup_flags, error)
    @ccall libaravis.g_resource_enumerate_children(resource::Ptr{GResource}, path::Cstring, lookup_flags::GResourceLookupFlags, error::Ptr{Ptr{GError}})::Ptr{Cstring}
end

"""
    g_resource_get_info(resource, path, lookup_flags, size, flags, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 gboolean g_resource_get_info (GResource *resource, const char *path, GResourceLookupFlags lookup_flags, gsize *size, guint32 *flags, GError **error);
```
"""
function g_resource_get_info(resource, path, lookup_flags, size, flags, error)
    @ccall libaravis.g_resource_get_info(resource::Ptr{GResource}, path::Cstring, lookup_flags::GResourceLookupFlags, size::Ptr{gsize}, flags::Ptr{guint32}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_resources_register(resource)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_resources_register (GResource *resource);
```
"""
function g_resources_register(resource)
    @ccall libaravis.g_resources_register(resource::Ptr{GResource})::Cvoid
end

"""
    g_resources_unregister(resource)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_resources_unregister (GResource *resource);
```
"""
function g_resources_unregister(resource)
    @ccall libaravis.g_resources_unregister(resource::Ptr{GResource})::Cvoid
end

"""
    g_resources_open_stream(path, lookup_flags, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GInputStream *g_resources_open_stream (const char *path, GResourceLookupFlags lookup_flags, GError **error);
```
"""
function g_resources_open_stream(path, lookup_flags, error)
    @ccall libaravis.g_resources_open_stream(path::Cstring, lookup_flags::GResourceLookupFlags, error::Ptr{Ptr{GError}})::Ptr{GInputStream}
end

"""
    g_resources_lookup_data(path, lookup_flags, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GBytes * g_resources_lookup_data (const char *path, GResourceLookupFlags lookup_flags, GError **error);
```
"""
function g_resources_lookup_data(path, lookup_flags, error)
    @ccall libaravis.g_resources_lookup_data(path::Cstring, lookup_flags::GResourceLookupFlags, error::Ptr{Ptr{GError}})::Ptr{GBytes}
end

"""
    g_resources_enumerate_children(path, lookup_flags, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 char ** g_resources_enumerate_children (const char *path, GResourceLookupFlags lookup_flags, GError **error);
```
"""
function g_resources_enumerate_children(path, lookup_flags, error)
    @ccall libaravis.g_resources_enumerate_children(path::Cstring, lookup_flags::GResourceLookupFlags, error::Ptr{Ptr{GError}})::Ptr{Cstring}
end

"""
    g_resources_get_info(path, lookup_flags, size, flags, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 gboolean g_resources_get_info (const char *path, GResourceLookupFlags lookup_flags, gsize *size, guint32 *flags, GError **error);
```
"""
function g_resources_get_info(path, lookup_flags, size, flags, error)
    @ccall libaravis.g_resources_get_info(path::Cstring, lookup_flags::GResourceLookupFlags, size::Ptr{gsize}, flags::Ptr{guint32}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_resource_has_children(resource, path)

### Prototype
```c
GIO_AVAILABLE_IN_2_84 gboolean g_resource_has_children (GResource *resource, const char *path);
```
"""
function g_resource_has_children(resource, path)
    @ccall libaravis.g_resource_has_children(resource::Ptr{GResource}, path::Cstring)::gboolean
end

"""
    g_resources_has_children(path)

### Prototype
```c
GIO_AVAILABLE_IN_2_84 gboolean g_resources_has_children (const char *path);
```
"""
function g_resources_has_children(path)
    @ccall libaravis.g_resources_has_children(path::Cstring)::gboolean
end

"""
    g_static_resource_init(static_resource)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_static_resource_init (GStaticResource *static_resource);
```
"""
function g_static_resource_init(static_resource)
    @ccall libaravis.g_static_resource_init(static_resource::Ptr{GStaticResource})::Cvoid
end

"""
    g_static_resource_fini(static_resource)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_static_resource_fini (GStaticResource *static_resource);
```
"""
function g_static_resource_fini(static_resource)
    @ccall libaravis.g_static_resource_fini(static_resource::Ptr{GStaticResource})::Cvoid
end

"""
    g_static_resource_get_resource(static_resource)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GResource *g_static_resource_get_resource (GStaticResource *static_resource);
```
"""
function g_static_resource_get_resource(static_resource)
    @ccall libaravis.g_static_resource_get_resource(static_resource::Ptr{GStaticResource})::Ptr{GResource}
end

"""
    g_seekable_tell(seekable)

### Prototype
```c
GIO_AVAILABLE_IN_ALL goffset g_seekable_tell (GSeekable *seekable);
```
"""
function g_seekable_tell(seekable)
    @ccall libaravis.g_seekable_tell(seekable::Ptr{GSeekable})::goffset
end

"""
    g_seekable_can_seek(seekable)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_seekable_can_seek (GSeekable *seekable);
```
"""
function g_seekable_can_seek(seekable)
    @ccall libaravis.g_seekable_can_seek(seekable::Ptr{GSeekable})::gboolean
end

"""
    g_seekable_seek(seekable, offset, type, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_seekable_seek (GSeekable *seekable, goffset offset, GSeekType type, GCancellable *cancellable, GError **error);
```
"""
function g_seekable_seek(seekable, offset, type, cancellable, error)
    @ccall libaravis.g_seekable_seek(seekable::Ptr{GSeekable}, offset::goffset, type::GSeekType, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_seekable_can_truncate(seekable)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_seekable_can_truncate (GSeekable *seekable);
```
"""
function g_seekable_can_truncate(seekable)
    @ccall libaravis.g_seekable_can_truncate(seekable::Ptr{GSeekable})::gboolean
end

"""
    g_seekable_truncate(seekable, offset, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_seekable_truncate (GSeekable *seekable, goffset offset, GCancellable *cancellable, GError **error);
```
"""
function g_seekable_truncate(seekable, offset, cancellable, error)
    @ccall libaravis.g_seekable_truncate(seekable::Ptr{GSeekable}, offset::goffset, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

const _GSettingsSchemaSource = Cvoid

const GSettingsSchemaSource = _GSettingsSchemaSource

const _GSettingsSchema = Cvoid

const GSettingsSchema = _GSettingsSchema

const _GSettingsSchemaKey = Cvoid

const GSettingsSchemaKey = _GSettingsSchemaKey

"""
    g_settings_schema_source_get_default()

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GSettingsSchemaSource * g_settings_schema_source_get_default (void);
```
"""
function g_settings_schema_source_get_default()
    @ccall libaravis.g_settings_schema_source_get_default()::Ptr{GSettingsSchemaSource}
end

"""
    g_settings_schema_source_ref(source)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GSettingsSchemaSource * g_settings_schema_source_ref (GSettingsSchemaSource *source);
```
"""
function g_settings_schema_source_ref(source)
    @ccall libaravis.g_settings_schema_source_ref(source::Ptr{GSettingsSchemaSource})::Ptr{GSettingsSchemaSource}
end

"""
    g_settings_schema_source_unref(source)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_settings_schema_source_unref (GSettingsSchemaSource *source);
```
"""
function g_settings_schema_source_unref(source)
    @ccall libaravis.g_settings_schema_source_unref(source::Ptr{GSettingsSchemaSource})::Cvoid
end

"""
    g_settings_schema_source_new_from_directory(directory, parent, trusted, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GSettingsSchemaSource * g_settings_schema_source_new_from_directory (const gchar *directory, GSettingsSchemaSource *parent, gboolean trusted, GError **error);
```
"""
function g_settings_schema_source_new_from_directory(directory, parent, trusted, error)
    @ccall libaravis.g_settings_schema_source_new_from_directory(directory::Ptr{gchar}, parent::Ptr{GSettingsSchemaSource}, trusted::gboolean, error::Ptr{Ptr{GError}})::Ptr{GSettingsSchemaSource}
end

"""
    g_settings_schema_source_lookup(source, schema_id, recursive)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GSettingsSchema * g_settings_schema_source_lookup (GSettingsSchemaSource *source, const gchar *schema_id, gboolean recursive);
```
"""
function g_settings_schema_source_lookup(source, schema_id, recursive)
    @ccall libaravis.g_settings_schema_source_lookup(source::Ptr{GSettingsSchemaSource}, schema_id::Ptr{gchar}, recursive::gboolean)::Ptr{GSettingsSchema}
end

"""
    g_settings_schema_source_list_schemas(source, recursive, non_relocatable, relocatable)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_settings_schema_source_list_schemas (GSettingsSchemaSource *source, gboolean recursive, gchar ***non_relocatable, gchar ***relocatable);
```
"""
function g_settings_schema_source_list_schemas(source, recursive, non_relocatable, relocatable)
    @ccall libaravis.g_settings_schema_source_list_schemas(source::Ptr{GSettingsSchemaSource}, recursive::gboolean, non_relocatable::Ptr{Ptr{Ptr{gchar}}}, relocatable::Ptr{Ptr{Ptr{gchar}}})::Cvoid
end

"""
    g_settings_schema_ref(schema)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GSettingsSchema * g_settings_schema_ref (GSettingsSchema *schema);
```
"""
function g_settings_schema_ref(schema)
    @ccall libaravis.g_settings_schema_ref(schema::Ptr{GSettingsSchema})::Ptr{GSettingsSchema}
end

"""
    g_settings_schema_unref(schema)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_settings_schema_unref (GSettingsSchema *schema);
```
"""
function g_settings_schema_unref(schema)
    @ccall libaravis.g_settings_schema_unref(schema::Ptr{GSettingsSchema})::Cvoid
end

"""
    g_settings_schema_get_id(schema)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 const gchar * g_settings_schema_get_id (GSettingsSchema *schema);
```
"""
function g_settings_schema_get_id(schema)
    @ccall libaravis.g_settings_schema_get_id(schema::Ptr{GSettingsSchema})::Ptr{gchar}
end

"""
    g_settings_schema_get_path(schema)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 const gchar * g_settings_schema_get_path (GSettingsSchema *schema);
```
"""
function g_settings_schema_get_path(schema)
    @ccall libaravis.g_settings_schema_get_path(schema::Ptr{GSettingsSchema})::Ptr{gchar}
end

"""
    g_settings_schema_get_key(schema, name)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 GSettingsSchemaKey * g_settings_schema_get_key (GSettingsSchema *schema, const gchar *name);
```
"""
function g_settings_schema_get_key(schema, name)
    @ccall libaravis.g_settings_schema_get_key(schema::Ptr{GSettingsSchema}, name::Ptr{gchar})::Ptr{GSettingsSchemaKey}
end

"""
    g_settings_schema_has_key(schema, name)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 gboolean g_settings_schema_has_key (GSettingsSchema *schema, const gchar *name);
```
"""
function g_settings_schema_has_key(schema, name)
    @ccall libaravis.g_settings_schema_has_key(schema::Ptr{GSettingsSchema}, name::Ptr{gchar})::gboolean
end

"""
    g_settings_schema_list_keys(schema)

### Prototype
```c
GIO_AVAILABLE_IN_2_46 gchar** g_settings_schema_list_keys (GSettingsSchema *schema);
```
"""
function g_settings_schema_list_keys(schema)
    @ccall libaravis.g_settings_schema_list_keys(schema::Ptr{GSettingsSchema})::Ptr{Ptr{gchar}}
end

"""
    g_settings_schema_list_children(schema)

### Prototype
```c
GIO_AVAILABLE_IN_2_44 gchar ** g_settings_schema_list_children (GSettingsSchema *schema);
```
"""
function g_settings_schema_list_children(schema)
    @ccall libaravis.g_settings_schema_list_children(schema::Ptr{GSettingsSchema})::Ptr{Ptr{gchar}}
end

"""
    g_settings_schema_key_ref(key)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 GSettingsSchemaKey * g_settings_schema_key_ref (GSettingsSchemaKey *key);
```
"""
function g_settings_schema_key_ref(key)
    @ccall libaravis.g_settings_schema_key_ref(key::Ptr{GSettingsSchemaKey})::Ptr{GSettingsSchemaKey}
end

"""
    g_settings_schema_key_unref(key)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_settings_schema_key_unref (GSettingsSchemaKey *key);
```
"""
function g_settings_schema_key_unref(key)
    @ccall libaravis.g_settings_schema_key_unref(key::Ptr{GSettingsSchemaKey})::Cvoid
end

"""
    g_settings_schema_key_get_value_type(key)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 const GVariantType * g_settings_schema_key_get_value_type (GSettingsSchemaKey *key);
```
"""
function g_settings_schema_key_get_value_type(key)
    @ccall libaravis.g_settings_schema_key_get_value_type(key::Ptr{GSettingsSchemaKey})::Ptr{GVariantType}
end

"""
    g_settings_schema_key_get_default_value(key)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 GVariant * g_settings_schema_key_get_default_value (GSettingsSchemaKey *key);
```
"""
function g_settings_schema_key_get_default_value(key)
    @ccall libaravis.g_settings_schema_key_get_default_value(key::Ptr{GSettingsSchemaKey})::Ptr{GVariant}
end

"""
    g_settings_schema_key_get_range(key)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 GVariant * g_settings_schema_key_get_range (GSettingsSchemaKey *key);
```
"""
function g_settings_schema_key_get_range(key)
    @ccall libaravis.g_settings_schema_key_get_range(key::Ptr{GSettingsSchemaKey})::Ptr{GVariant}
end

"""
    g_settings_schema_key_range_check(key, value)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 gboolean g_settings_schema_key_range_check (GSettingsSchemaKey *key, GVariant *value);
```
"""
function g_settings_schema_key_range_check(key, value)
    @ccall libaravis.g_settings_schema_key_range_check(key::Ptr{GSettingsSchemaKey}, value::Ptr{GVariant})::gboolean
end

"""
    g_settings_schema_key_get_name(key)

### Prototype
```c
GIO_AVAILABLE_IN_2_44 const gchar * g_settings_schema_key_get_name (GSettingsSchemaKey *key);
```
"""
function g_settings_schema_key_get_name(key)
    @ccall libaravis.g_settings_schema_key_get_name(key::Ptr{GSettingsSchemaKey})::Ptr{gchar}
end

"""
    g_settings_schema_key_get_summary(key)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 const gchar * g_settings_schema_key_get_summary (GSettingsSchemaKey *key);
```
"""
function g_settings_schema_key_get_summary(key)
    @ccall libaravis.g_settings_schema_key_get_summary(key::Ptr{GSettingsSchemaKey})::Ptr{gchar}
end

"""
    g_settings_schema_key_get_description(key)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 const gchar * g_settings_schema_key_get_description (GSettingsSchemaKey *key);
```
"""
function g_settings_schema_key_get_description(key)
    @ccall libaravis.g_settings_schema_key_get_description(key::Ptr{GSettingsSchemaKey})::Ptr{gchar}
end

"""
    g_settings_list_schemas()

### Prototype
```c
GIO_DEPRECATED_IN_2_40_FOR(g_settings_schema_source_list_schemas) const gchar * const * g_settings_list_schemas (void);
```
"""
function g_settings_list_schemas()
    @ccall libaravis.g_settings_list_schemas()::Ptr{Ptr{gchar}}
end

"""
    g_settings_list_relocatable_schemas()

### Prototype
```c
GIO_DEPRECATED_IN_2_40_FOR(g_settings_schema_source_list_schemas) const gchar * const * g_settings_list_relocatable_schemas (void);
```
"""
function g_settings_list_relocatable_schemas()
    @ccall libaravis.g_settings_list_relocatable_schemas()::Ptr{Ptr{gchar}}
end

"""
    g_settings_new(schema_id)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSettings * g_settings_new (const gchar *schema_id);
```
"""
function g_settings_new(schema_id)
    @ccall libaravis.g_settings_new(schema_id::Ptr{gchar})::Ptr{GSettings}
end

"""
    g_settings_new_with_path(schema_id, path)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSettings * g_settings_new_with_path (const gchar *schema_id, const gchar *path);
```
"""
function g_settings_new_with_path(schema_id, path)
    @ccall libaravis.g_settings_new_with_path(schema_id::Ptr{gchar}, path::Ptr{gchar})::Ptr{GSettings}
end

"""
    g_settings_new_with_backend(schema_id, backend)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSettings * g_settings_new_with_backend (const gchar *schema_id, GSettingsBackend *backend);
```
"""
function g_settings_new_with_backend(schema_id, backend)
    @ccall libaravis.g_settings_new_with_backend(schema_id::Ptr{gchar}, backend::Ptr{GSettingsBackend})::Ptr{GSettings}
end

"""
    g_settings_new_with_backend_and_path(schema_id, backend, path)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSettings * g_settings_new_with_backend_and_path (const gchar *schema_id, GSettingsBackend *backend, const gchar *path);
```
"""
function g_settings_new_with_backend_and_path(schema_id, backend, path)
    @ccall libaravis.g_settings_new_with_backend_and_path(schema_id::Ptr{gchar}, backend::Ptr{GSettingsBackend}, path::Ptr{gchar})::Ptr{GSettings}
end

"""
    g_settings_new_full(schema, backend, path)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GSettings * g_settings_new_full (GSettingsSchema *schema, GSettingsBackend *backend, const gchar *path);
```
"""
function g_settings_new_full(schema, backend, path)
    @ccall libaravis.g_settings_new_full(schema::Ptr{GSettingsSchema}, backend::Ptr{GSettingsBackend}, path::Ptr{gchar})::Ptr{GSettings}
end

"""
    g_settings_list_children(settings)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gchar ** g_settings_list_children (GSettings *settings);
```
"""
function g_settings_list_children(settings)
    @ccall libaravis.g_settings_list_children(settings::Ptr{GSettings})::Ptr{Ptr{gchar}}
end

"""
    g_settings_list_keys(settings)

### Prototype
```c
GIO_DEPRECATED_IN_2_46_FOR(g_settings_schema_list_keys) gchar ** g_settings_list_keys (GSettings *settings);
```
"""
function g_settings_list_keys(settings)
    @ccall libaravis.g_settings_list_keys(settings::Ptr{GSettings})::Ptr{Ptr{gchar}}
end

"""
    g_settings_get_range(settings, key)

### Prototype
```c
GIO_DEPRECATED_IN_2_40_FOR(g_settings_schema_key_get_range) GVariant * g_settings_get_range (GSettings *settings, const gchar *key);
```
"""
function g_settings_get_range(settings, key)
    @ccall libaravis.g_settings_get_range(settings::Ptr{GSettings}, key::Ptr{gchar})::Ptr{GVariant}
end

"""
    g_settings_range_check(settings, key, value)

### Prototype
```c
GIO_DEPRECATED_IN_2_40_FOR(g_settings_schema_key_range_check) gboolean g_settings_range_check (GSettings *settings, const gchar *key, GVariant *value);
```
"""
function g_settings_range_check(settings, key, value)
    @ccall libaravis.g_settings_range_check(settings::Ptr{GSettings}, key::Ptr{gchar}, value::Ptr{GVariant})::gboolean
end

"""
    g_settings_set_value(settings, key, value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_settings_set_value (GSettings *settings, const gchar *key, GVariant *value);
```
"""
function g_settings_set_value(settings, key, value)
    @ccall libaravis.g_settings_set_value(settings::Ptr{GSettings}, key::Ptr{gchar}, value::Ptr{GVariant})::gboolean
end

"""
    g_settings_get_value(settings, key)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GVariant * g_settings_get_value (GSettings *settings, const gchar *key);
```
"""
function g_settings_get_value(settings, key)
    @ccall libaravis.g_settings_get_value(settings::Ptr{GSettings}, key::Ptr{gchar})::Ptr{GVariant}
end

"""
    g_settings_get_user_value(settings, key)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 GVariant * g_settings_get_user_value (GSettings *settings, const gchar *key);
```
"""
function g_settings_get_user_value(settings, key)
    @ccall libaravis.g_settings_get_user_value(settings::Ptr{GSettings}, key::Ptr{gchar})::Ptr{GVariant}
end

"""
    g_settings_get_default_value(settings, key)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 GVariant * g_settings_get_default_value (GSettings *settings, const gchar *key);
```
"""
function g_settings_get_default_value(settings, key)
    @ccall libaravis.g_settings_get_default_value(settings::Ptr{GSettings}, key::Ptr{gchar})::Ptr{GVariant}
end

"""
    g_settings_reset(settings, key)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_settings_reset (GSettings *settings, const gchar *key);
```
"""
function g_settings_reset(settings, key)
    @ccall libaravis.g_settings_reset(settings::Ptr{GSettings}, key::Ptr{gchar})::Cvoid
end

"""
    g_settings_get_int(settings, key)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gint g_settings_get_int (GSettings *settings, const gchar *key);
```
"""
function g_settings_get_int(settings, key)
    @ccall libaravis.g_settings_get_int(settings::Ptr{GSettings}, key::Ptr{gchar})::gint
end

"""
    g_settings_set_int(settings, key, value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_settings_set_int (GSettings *settings, const gchar *key, gint value);
```
"""
function g_settings_set_int(settings, key, value)
    @ccall libaravis.g_settings_set_int(settings::Ptr{GSettings}, key::Ptr{gchar}, value::gint)::gboolean
end

"""
    g_settings_get_int64(settings, key)

### Prototype
```c
GIO_AVAILABLE_IN_2_50 gint64 g_settings_get_int64 (GSettings *settings, const gchar *key);
```
"""
function g_settings_get_int64(settings, key)
    @ccall libaravis.g_settings_get_int64(settings::Ptr{GSettings}, key::Ptr{gchar})::gint64
end

"""
    g_settings_set_int64(settings, key, value)

### Prototype
```c
GIO_AVAILABLE_IN_2_50 gboolean g_settings_set_int64 (GSettings *settings, const gchar *key, gint64 value);
```
"""
function g_settings_set_int64(settings, key, value)
    @ccall libaravis.g_settings_set_int64(settings::Ptr{GSettings}, key::Ptr{gchar}, value::gint64)::gboolean
end

"""
    g_settings_get_uint(settings, key)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 guint g_settings_get_uint (GSettings *settings, const gchar *key);
```
"""
function g_settings_get_uint(settings, key)
    @ccall libaravis.g_settings_get_uint(settings::Ptr{GSettings}, key::Ptr{gchar})::guint
end

"""
    g_settings_set_uint(settings, key, value)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 gboolean g_settings_set_uint (GSettings *settings, const gchar *key, guint value);
```
"""
function g_settings_set_uint(settings, key, value)
    @ccall libaravis.g_settings_set_uint(settings::Ptr{GSettings}, key::Ptr{gchar}, value::guint)::gboolean
end

"""
    g_settings_get_uint64(settings, key)

### Prototype
```c
GIO_AVAILABLE_IN_2_50 guint64 g_settings_get_uint64 (GSettings *settings, const gchar *key);
```
"""
function g_settings_get_uint64(settings, key)
    @ccall libaravis.g_settings_get_uint64(settings::Ptr{GSettings}, key::Ptr{gchar})::guint64
end

"""
    g_settings_set_uint64(settings, key, value)

### Prototype
```c
GIO_AVAILABLE_IN_2_50 gboolean g_settings_set_uint64 (GSettings *settings, const gchar *key, guint64 value);
```
"""
function g_settings_set_uint64(settings, key, value)
    @ccall libaravis.g_settings_set_uint64(settings::Ptr{GSettings}, key::Ptr{gchar}, value::guint64)::gboolean
end

"""
    g_settings_get_string(settings, key)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gchar * g_settings_get_string (GSettings *settings, const gchar *key);
```
"""
function g_settings_get_string(settings, key)
    @ccall libaravis.g_settings_get_string(settings::Ptr{GSettings}, key::Ptr{gchar})::Ptr{gchar}
end

"""
    g_settings_set_string(settings, key, value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_settings_set_string (GSettings *settings, const gchar *key, const gchar *value);
```
"""
function g_settings_set_string(settings, key, value)
    @ccall libaravis.g_settings_set_string(settings::Ptr{GSettings}, key::Ptr{gchar}, value::Ptr{gchar})::gboolean
end

"""
    g_settings_get_boolean(settings, key)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_settings_get_boolean (GSettings *settings, const gchar *key);
```
"""
function g_settings_get_boolean(settings, key)
    @ccall libaravis.g_settings_get_boolean(settings::Ptr{GSettings}, key::Ptr{gchar})::gboolean
end

"""
    g_settings_set_boolean(settings, key, value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_settings_set_boolean (GSettings *settings, const gchar *key, gboolean value);
```
"""
function g_settings_set_boolean(settings, key, value)
    @ccall libaravis.g_settings_set_boolean(settings::Ptr{GSettings}, key::Ptr{gchar}, value::gboolean)::gboolean
end

"""
    g_settings_get_double(settings, key)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gdouble g_settings_get_double (GSettings *settings, const gchar *key);
```
"""
function g_settings_get_double(settings, key)
    @ccall libaravis.g_settings_get_double(settings::Ptr{GSettings}, key::Ptr{gchar})::gdouble
end

"""
    g_settings_set_double(settings, key, value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_settings_set_double (GSettings *settings, const gchar *key, gdouble value);
```
"""
function g_settings_set_double(settings, key, value)
    @ccall libaravis.g_settings_set_double(settings::Ptr{GSettings}, key::Ptr{gchar}, value::gdouble)::gboolean
end

"""
    g_settings_get_strv(settings, key)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gchar ** g_settings_get_strv (GSettings *settings, const gchar *key);
```
"""
function g_settings_get_strv(settings, key)
    @ccall libaravis.g_settings_get_strv(settings::Ptr{GSettings}, key::Ptr{gchar})::Ptr{Ptr{gchar}}
end

"""
    g_settings_set_strv(settings, key, value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_settings_set_strv (GSettings *settings, const gchar *key, const gchar *const *value);
```
"""
function g_settings_set_strv(settings, key, value)
    @ccall libaravis.g_settings_set_strv(settings::Ptr{GSettings}, key::Ptr{gchar}, value::Ptr{Ptr{gchar}})::gboolean
end

"""
    g_settings_get_enum(settings, key)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gint g_settings_get_enum (GSettings *settings, const gchar *key);
```
"""
function g_settings_get_enum(settings, key)
    @ccall libaravis.g_settings_get_enum(settings::Ptr{GSettings}, key::Ptr{gchar})::gint
end

"""
    g_settings_set_enum(settings, key, value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_settings_set_enum (GSettings *settings, const gchar *key, gint value);
```
"""
function g_settings_set_enum(settings, key, value)
    @ccall libaravis.g_settings_set_enum(settings::Ptr{GSettings}, key::Ptr{gchar}, value::gint)::gboolean
end

"""
    g_settings_get_flags(settings, key)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint g_settings_get_flags (GSettings *settings, const gchar *key);
```
"""
function g_settings_get_flags(settings, key)
    @ccall libaravis.g_settings_get_flags(settings::Ptr{GSettings}, key::Ptr{gchar})::guint
end

"""
    g_settings_set_flags(settings, key, value)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_settings_set_flags (GSettings *settings, const gchar *key, guint value);
```
"""
function g_settings_set_flags(settings, key, value)
    @ccall libaravis.g_settings_set_flags(settings::Ptr{GSettings}, key::Ptr{gchar}, value::guint)::gboolean
end

"""
    g_settings_get_child(settings, name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSettings * g_settings_get_child (GSettings *settings, const gchar *name);
```
"""
function g_settings_get_child(settings, name)
    @ccall libaravis.g_settings_get_child(settings::Ptr{GSettings}, name::Ptr{gchar})::Ptr{GSettings}
end

"""
    g_settings_is_writable(settings, name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_settings_is_writable (GSettings *settings, const gchar *name);
```
"""
function g_settings_is_writable(settings, name)
    @ccall libaravis.g_settings_is_writable(settings::Ptr{GSettings}, name::Ptr{gchar})::gboolean
end

"""
    g_settings_delay(settings)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_settings_delay (GSettings *settings);
```
"""
function g_settings_delay(settings)
    @ccall libaravis.g_settings_delay(settings::Ptr{GSettings})::Cvoid
end

"""
    g_settings_apply(settings)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_settings_apply (GSettings *settings);
```
"""
function g_settings_apply(settings)
    @ccall libaravis.g_settings_apply(settings::Ptr{GSettings})::Cvoid
end

"""
    g_settings_revert(settings)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_settings_revert (GSettings *settings);
```
"""
function g_settings_revert(settings)
    @ccall libaravis.g_settings_revert(settings::Ptr{GSettings})::Cvoid
end

"""
    g_settings_get_has_unapplied(settings)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_settings_get_has_unapplied (GSettings *settings);
```
"""
function g_settings_get_has_unapplied(settings)
    @ccall libaravis.g_settings_get_has_unapplied(settings::Ptr{GSettings})::gboolean
end

"""
    g_settings_sync()

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_settings_sync (void);
```
"""
function g_settings_sync()
    @ccall libaravis.g_settings_sync()::Cvoid
end

# typedef GVariant * ( * GSettingsBindSetMapping ) ( const GValue * value , const GVariantType * expected_type , gpointer user_data )
"""
[`GSettingsBindSetMapping`](@ref): : the property value to map \\_type: expected type of the result \\_data: user data that was specified when the binding was created

The type for the function that is used to convert an object property value to a [struct.Variant] for storing it in [class.Settings].

Returns: (nullable): a new [struct.Variant] holding the data from , or `NULL` in case of an error
"""
const GSettingsBindSetMapping = Ptr{Cvoid}

# typedef gboolean ( * GSettingsBindGetMapping ) ( GValue * value , GVariant * variant , gpointer user_data )
"""
[`GSettingsBindGetMapping`](@ref): : return location for the property value : variant to map to the property value \\_data: user data that was specified when the binding was created

The type for the function that is used to convert from [class.Settings] to an object property.

The  is already initialized to hold values of the appropriate type.

Returns: true if the conversion succeeded, false in case of an error
"""
const GSettingsBindGetMapping = Ptr{Cvoid}

# typedef gboolean ( * GSettingsGetMapping ) ( GVariant * value , gpointer * result , gpointer user_data )
"""
[`GSettingsGetMapping`](@ref): : (nullable): variant to map to the application value

\\result : (out): the result of the mapping \\_data: (closure): the user data that was passed to [method.Settings.get\\_mapped]

The type of the function that is used to convert from a value stored in a [class.Settings] to a value that is useful to the application.

If the value is successfully mapped, the result should be stored at

\\result and true returned. If mapping fails (for example, if  is not in the right format) then false should be returned.

If  is `NULL` then it means that the mapping function is being given a last chance to successfully return a valid value. True must be returned in this case.

Returns: true if the conversion succeeded, false in case of an error
"""
const GSettingsGetMapping = Ptr{Cvoid}

"""
    GSettingsBindFlags

[`GSettingsBindFlags`](@ref): \\_SETTINGS\\_BIND\\_DEFAULT: Equivalent to `G\\_SETTINGS\\_BIND\\_GET|G\\_SETTINGS\\_BIND\\_SET` \\_SETTINGS\\_BIND\\_GET: Update the [class.Object] property when the setting changes. It is an error to use this flag if the property is not writable. \\_SETTINGS\\_BIND\\_SET: Update the setting when the [class.Object] property changes. It is an error to use this flag if the property is not readable. \\_SETTINGS\\_BIND\\_NO\\_SENSITIVITY: Do not try to bind a sensitivity property to the writability of the setting \\_SETTINGS\\_BIND\\_GET\\_NO\\_CHANGES: When set in addition to [flags.SettingsBindFlags.GET], set the [class.Object] property value initially from the setting, but do not listen for changes of the setting \\_SETTINGS\\_BIND\\_INVERT\\_BOOLEAN: When passed to [method.Settings.bind], uses a pair of mapping functions that invert the boolean value when mapping between the setting and the property. The setting and property must both be booleans. You cannot pass this flag to [method.Settings.bind\\_with\\_mapping].

Flags used when creating a binding.

These flags determine in which direction the binding works. The default is to synchronize in both directions.
"""
@cenum GSettingsBindFlags::UInt32 begin
    G_SETTINGS_BIND_DEFAULT = 0
    G_SETTINGS_BIND_GET = 1
    G_SETTINGS_BIND_SET = 2
    G_SETTINGS_BIND_NO_SENSITIVITY = 4
    G_SETTINGS_BIND_GET_NO_CHANGES = 8
    G_SETTINGS_BIND_INVERT_BOOLEAN = 16
end

"""
    g_settings_bind(settings, key, object, property, flags)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_settings_bind (GSettings *settings, const gchar *key, gpointer object, const gchar *property, GSettingsBindFlags flags);
```
"""
function g_settings_bind(settings, key, object, property, flags)
    @ccall libaravis.g_settings_bind(settings::Ptr{GSettings}, key::Ptr{gchar}, object::gpointer, property::Ptr{gchar}, flags::GSettingsBindFlags)::Cvoid
end

"""
    g_settings_bind_with_mapping(settings, key, object, property, flags, get_mapping, set_mapping, user_data, destroy)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_settings_bind_with_mapping (GSettings *settings, const gchar *key, gpointer object, const gchar *property, GSettingsBindFlags flags, GSettingsBindGetMapping get_mapping, GSettingsBindSetMapping set_mapping, gpointer user_data, GDestroyNotify destroy);
```
"""
function g_settings_bind_with_mapping(settings, key, object, property, flags, get_mapping, set_mapping, user_data, destroy)
    @ccall libaravis.g_settings_bind_with_mapping(settings::Ptr{GSettings}, key::Ptr{gchar}, object::gpointer, property::Ptr{gchar}, flags::GSettingsBindFlags, get_mapping::GSettingsBindGetMapping, set_mapping::GSettingsBindSetMapping, user_data::gpointer, destroy::GDestroyNotify)::Cvoid
end

"""
    g_settings_bind_with_mapping_closures(settings, key, object, property, flags, get_mapping, set_mapping)

### Prototype
```c
GIO_AVAILABLE_IN_2_82 void g_settings_bind_with_mapping_closures (GSettings *settings, const char *key, GObject *object, const char *property, GSettingsBindFlags flags, GClosure *get_mapping, GClosure *set_mapping);
```
"""
function g_settings_bind_with_mapping_closures(settings, key, object, property, flags, get_mapping, set_mapping)
    @ccall libaravis.g_settings_bind_with_mapping_closures(settings::Ptr{GSettings}, key::Cstring, object::Ptr{GObject}, property::Cstring, flags::GSettingsBindFlags, get_mapping::Ptr{GClosure}, set_mapping::Ptr{GClosure})::Cvoid
end

"""
    g_settings_bind_writable(settings, key, object, property, inverted)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_settings_bind_writable (GSettings *settings, const gchar *key, gpointer object, const gchar *property, gboolean inverted);
```
"""
function g_settings_bind_writable(settings, key, object, property, inverted)
    @ccall libaravis.g_settings_bind_writable(settings::Ptr{GSettings}, key::Ptr{gchar}, object::gpointer, property::Ptr{gchar}, inverted::gboolean)::Cvoid
end

"""
    g_settings_unbind(object, property)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_settings_unbind (gpointer object, const gchar *property);
```
"""
function g_settings_unbind(object, property)
    @ccall libaravis.g_settings_unbind(object::gpointer, property::Ptr{gchar})::Cvoid
end

"""
    g_settings_create_action(settings, key)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GAction * g_settings_create_action (GSettings *settings, const gchar *key);
```
"""
function g_settings_create_action(settings, key)
    @ccall libaravis.g_settings_create_action(settings::Ptr{GSettings}, key::Ptr{gchar})::Ptr{GAction}
end

"""
    g_settings_get_mapped(settings, key, mapping, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gpointer g_settings_get_mapped (GSettings *settings, const gchar *key, GSettingsGetMapping mapping, gpointer user_data);
```
"""
function g_settings_get_mapped(settings, key, mapping, user_data)
    @ccall libaravis.g_settings_get_mapped(settings::Ptr{GSettings}, key::Ptr{gchar}, mapping::GSettingsGetMapping, user_data::gpointer)::gpointer
end

"""
    g_simple_action_new(name, parameter_type)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSimpleAction * g_simple_action_new (const gchar *name, const GVariantType *parameter_type);
```
"""
function g_simple_action_new(name, parameter_type)
    @ccall libaravis.g_simple_action_new(name::Ptr{gchar}, parameter_type::Ptr{GVariantType})::Ptr{GSimpleAction}
end

"""
    g_simple_action_new_stateful(name, parameter_type, state)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSimpleAction * g_simple_action_new_stateful (const gchar *name, const GVariantType *parameter_type, GVariant *state);
```
"""
function g_simple_action_new_stateful(name, parameter_type, state)
    @ccall libaravis.g_simple_action_new_stateful(name::Ptr{gchar}, parameter_type::Ptr{GVariantType}, state::Ptr{GVariant})::Ptr{GSimpleAction}
end

"""
    g_simple_action_set_enabled(simple, enabled)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_simple_action_set_enabled (GSimpleAction *simple, gboolean enabled);
```
"""
function g_simple_action_set_enabled(simple, enabled)
    @ccall libaravis.g_simple_action_set_enabled(simple::Ptr{GSimpleAction}, enabled::gboolean)::Cvoid
end

"""
    g_simple_action_set_state(simple, value)

### Prototype
```c
GIO_AVAILABLE_IN_2_30 void g_simple_action_set_state (GSimpleAction *simple, GVariant *value);
```
"""
function g_simple_action_set_state(simple, value)
    @ccall libaravis.g_simple_action_set_state(simple::Ptr{GSimpleAction}, value::Ptr{GVariant})::Cvoid
end

"""
    g_simple_action_set_state_hint(simple, state_hint)

### Prototype
```c
GIO_AVAILABLE_IN_2_44 void g_simple_action_set_state_hint (GSimpleAction *simple, GVariant *state_hint);
```
"""
function g_simple_action_set_state_hint(simple, state_hint)
    @ccall libaravis.g_simple_action_set_state_hint(simple::Ptr{GSimpleAction}, state_hint::Ptr{GVariant})::Cvoid
end

"""
    g_simple_action_group_new()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSimpleActionGroup * g_simple_action_group_new (void);
```
"""
function g_simple_action_group_new()
    @ccall libaravis.g_simple_action_group_new()::Ptr{GSimpleActionGroup}
end

"""
    g_simple_action_group_lookup(simple, action_name)

### Prototype
```c
GIO_DEPRECATED_IN_2_38_FOR (g_action_map_lookup_action) GAction * g_simple_action_group_lookup (GSimpleActionGroup *simple, const gchar *action_name);
```
"""
function g_simple_action_group_lookup(simple, action_name)
    @ccall libaravis.g_simple_action_group_lookup(simple::Ptr{GSimpleActionGroup}, action_name::Ptr{gchar})::Ptr{GAction}
end

"""
    g_simple_action_group_insert(simple, action)

### Prototype
```c
GIO_DEPRECATED_IN_2_38_FOR (g_action_map_add_action) void g_simple_action_group_insert (GSimpleActionGroup *simple, GAction *action);
```
"""
function g_simple_action_group_insert(simple, action)
    @ccall libaravis.g_simple_action_group_insert(simple::Ptr{GSimpleActionGroup}, action::Ptr{GAction})::Cvoid
end

"""
    g_simple_action_group_remove(simple, action_name)

### Prototype
```c
GIO_DEPRECATED_IN_2_38_FOR (g_action_map_remove_action) void g_simple_action_group_remove (GSimpleActionGroup *simple, const gchar *action_name);
```
"""
function g_simple_action_group_remove(simple, action_name)
    @ccall libaravis.g_simple_action_group_remove(simple::Ptr{GSimpleActionGroup}, action_name::Ptr{gchar})::Cvoid
end

"""
    g_simple_action_group_add_entries(simple, entries, n_entries, user_data)

### Prototype
```c
GIO_DEPRECATED_IN_2_38_FOR (g_action_map_add_action_entries) void g_simple_action_group_add_entries (GSimpleActionGroup *simple, const GActionEntry *entries, gint n_entries, gpointer user_data);
```
"""
function g_simple_action_group_add_entries(simple, entries, n_entries, user_data)
    @ccall libaravis.g_simple_action_group_add_entries(simple::Ptr{GSimpleActionGroup}, entries::Ptr{GActionEntry}, n_entries::gint, user_data::gpointer)::Cvoid
end

"""
    g_simple_async_result_new(source_object, callback, user_data, source_tag)

### Prototype
```c
GIO_DEPRECATED_IN_2_46_FOR(g_task_new) GSimpleAsyncResult *g_simple_async_result_new (GObject *source_object, GAsyncReadyCallback callback, gpointer user_data, gpointer source_tag);
```
"""
function g_simple_async_result_new(source_object, callback, user_data, source_tag)
    @ccall libaravis.g_simple_async_result_new(source_object::Ptr{GObject}, callback::GAsyncReadyCallback, user_data::gpointer, source_tag::gpointer)::Ptr{GSimpleAsyncResult}
end

"""
    g_simple_async_result_new_from_error(source_object, callback, user_data, error)

### Prototype
```c
GIO_DEPRECATED_IN_2_46_FOR(g_task_new) GSimpleAsyncResult *g_simple_async_result_new_from_error (GObject *source_object, GAsyncReadyCallback callback, gpointer user_data, const GError *error);
```
"""
function g_simple_async_result_new_from_error(source_object, callback, user_data, error)
    @ccall libaravis.g_simple_async_result_new_from_error(source_object::Ptr{GObject}, callback::GAsyncReadyCallback, user_data::gpointer, error::Ptr{GError})::Ptr{GSimpleAsyncResult}
end

"""
    g_simple_async_result_new_take_error(source_object, callback, user_data, error)

### Prototype
```c
GIO_DEPRECATED_IN_2_46_FOR(g_task_new) GSimpleAsyncResult *g_simple_async_result_new_take_error (GObject *source_object, GAsyncReadyCallback callback, gpointer user_data, GError *error);
```
"""
function g_simple_async_result_new_take_error(source_object, callback, user_data, error)
    @ccall libaravis.g_simple_async_result_new_take_error(source_object::Ptr{GObject}, callback::GAsyncReadyCallback, user_data::gpointer, error::Ptr{GError})::Ptr{GSimpleAsyncResult}
end

"""
    g_simple_async_result_set_op_res_gpointer(simple, op_res, destroy_op_res)

### Prototype
```c
GIO_DEPRECATED_IN_2_46 void g_simple_async_result_set_op_res_gpointer (GSimpleAsyncResult *simple, gpointer op_res, GDestroyNotify destroy_op_res);
```
"""
function g_simple_async_result_set_op_res_gpointer(simple, op_res, destroy_op_res)
    @ccall libaravis.g_simple_async_result_set_op_res_gpointer(simple::Ptr{GSimpleAsyncResult}, op_res::gpointer, destroy_op_res::GDestroyNotify)::Cvoid
end

"""
    g_simple_async_result_get_op_res_gpointer(simple)

### Prototype
```c
GIO_DEPRECATED_IN_2_46 gpointer g_simple_async_result_get_op_res_gpointer (GSimpleAsyncResult *simple);
```
"""
function g_simple_async_result_get_op_res_gpointer(simple)
    @ccall libaravis.g_simple_async_result_get_op_res_gpointer(simple::Ptr{GSimpleAsyncResult})::gpointer
end

"""
    g_simple_async_result_set_op_res_gssize(simple, op_res)

### Prototype
```c
GIO_DEPRECATED_IN_2_46 void g_simple_async_result_set_op_res_gssize (GSimpleAsyncResult *simple, gssize op_res);
```
"""
function g_simple_async_result_set_op_res_gssize(simple, op_res)
    @ccall libaravis.g_simple_async_result_set_op_res_gssize(simple::Ptr{GSimpleAsyncResult}, op_res::gssize)::Cvoid
end

"""
    g_simple_async_result_get_op_res_gssize(simple)

### Prototype
```c
GIO_DEPRECATED_IN_2_46 gssize g_simple_async_result_get_op_res_gssize (GSimpleAsyncResult *simple);
```
"""
function g_simple_async_result_get_op_res_gssize(simple)
    @ccall libaravis.g_simple_async_result_get_op_res_gssize(simple::Ptr{GSimpleAsyncResult})::gssize
end

"""
    g_simple_async_result_set_op_res_gboolean(simple, op_res)

### Prototype
```c
GIO_DEPRECATED_IN_2_46 void g_simple_async_result_set_op_res_gboolean (GSimpleAsyncResult *simple, gboolean op_res);
```
"""
function g_simple_async_result_set_op_res_gboolean(simple, op_res)
    @ccall libaravis.g_simple_async_result_set_op_res_gboolean(simple::Ptr{GSimpleAsyncResult}, op_res::gboolean)::Cvoid
end

"""
    g_simple_async_result_get_op_res_gboolean(simple)

### Prototype
```c
GIO_DEPRECATED_IN_2_46 gboolean g_simple_async_result_get_op_res_gboolean (GSimpleAsyncResult *simple);
```
"""
function g_simple_async_result_get_op_res_gboolean(simple)
    @ccall libaravis.g_simple_async_result_get_op_res_gboolean(simple::Ptr{GSimpleAsyncResult})::gboolean
end

"""
    g_simple_async_result_set_check_cancellable(simple, check_cancellable)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_simple_async_result_set_check_cancellable (GSimpleAsyncResult *simple, GCancellable *check_cancellable);
```
"""
function g_simple_async_result_set_check_cancellable(simple, check_cancellable)
    @ccall libaravis.g_simple_async_result_set_check_cancellable(simple::Ptr{GSimpleAsyncResult}, check_cancellable::Ptr{GCancellable})::Cvoid
end

"""
    g_simple_async_result_get_source_tag(simple)

### Prototype
```c
GIO_DEPRECATED_IN_2_46 gpointer g_simple_async_result_get_source_tag (GSimpleAsyncResult *simple);
```
"""
function g_simple_async_result_get_source_tag(simple)
    @ccall libaravis.g_simple_async_result_get_source_tag(simple::Ptr{GSimpleAsyncResult})::gpointer
end

"""
    g_simple_async_result_set_handle_cancellation(simple, handle_cancellation)

### Prototype
```c
GIO_DEPRECATED_IN_2_46 void g_simple_async_result_set_handle_cancellation (GSimpleAsyncResult *simple, gboolean handle_cancellation);
```
"""
function g_simple_async_result_set_handle_cancellation(simple, handle_cancellation)
    @ccall libaravis.g_simple_async_result_set_handle_cancellation(simple::Ptr{GSimpleAsyncResult}, handle_cancellation::gboolean)::Cvoid
end

"""
    g_simple_async_result_complete(simple)

### Prototype
```c
GIO_DEPRECATED_IN_2_46 void g_simple_async_result_complete (GSimpleAsyncResult *simple);
```
"""
function g_simple_async_result_complete(simple)
    @ccall libaravis.g_simple_async_result_complete(simple::Ptr{GSimpleAsyncResult})::Cvoid
end

"""
    g_simple_async_result_complete_in_idle(simple)

### Prototype
```c
GIO_DEPRECATED_IN_2_46 void g_simple_async_result_complete_in_idle (GSimpleAsyncResult *simple);
```
"""
function g_simple_async_result_complete_in_idle(simple)
    @ccall libaravis.g_simple_async_result_complete_in_idle(simple::Ptr{GSimpleAsyncResult})::Cvoid
end

"""
    g_simple_async_result_run_in_thread(simple, func, io_priority, cancellable)

### Prototype
```c
GIO_DEPRECATED_IN_2_46 void g_simple_async_result_run_in_thread (GSimpleAsyncResult *simple, GSimpleAsyncThreadFunc func, int io_priority, GCancellable *cancellable);
```
"""
function g_simple_async_result_run_in_thread(simple, func, io_priority, cancellable)
    @ccall libaravis.g_simple_async_result_run_in_thread(simple::Ptr{GSimpleAsyncResult}, func::GSimpleAsyncThreadFunc, io_priority::Cint, cancellable::Ptr{GCancellable})::Cvoid
end

"""
    g_simple_async_result_set_from_error(simple, error)

### Prototype
```c
GIO_DEPRECATED_IN_2_46 void g_simple_async_result_set_from_error (GSimpleAsyncResult *simple, const GError *error);
```
"""
function g_simple_async_result_set_from_error(simple, error)
    @ccall libaravis.g_simple_async_result_set_from_error(simple::Ptr{GSimpleAsyncResult}, error::Ptr{GError})::Cvoid
end

"""
    g_simple_async_result_take_error(simple, error)

### Prototype
```c
GIO_DEPRECATED_IN_2_46 void g_simple_async_result_take_error (GSimpleAsyncResult *simple, GError *error);
```
"""
function g_simple_async_result_take_error(simple, error)
    @ccall libaravis.g_simple_async_result_take_error(simple::Ptr{GSimpleAsyncResult}, error::Ptr{GError})::Cvoid
end

"""
    g_simple_async_result_propagate_error(simple, dest)

### Prototype
```c
GIO_DEPRECATED_IN_2_46 gboolean g_simple_async_result_propagate_error (GSimpleAsyncResult *simple, GError **dest);
```
"""
function g_simple_async_result_propagate_error(simple, dest)
    @ccall libaravis.g_simple_async_result_propagate_error(simple::Ptr{GSimpleAsyncResult}, dest::Ptr{Ptr{GError}})::gboolean
end

"""
    g_simple_async_result_is_valid(result, source, source_tag)

### Prototype
```c
GIO_DEPRECATED_IN_2_46 gboolean g_simple_async_result_is_valid (GAsyncResult *result, GObject *source, gpointer source_tag);
```
"""
function g_simple_async_result_is_valid(result, source, source_tag)
    @ccall libaravis.g_simple_async_result_is_valid(result::Ptr{GAsyncResult}, source::Ptr{GObject}, source_tag::gpointer)::gboolean
end

"""
    g_simple_async_report_gerror_in_idle(object, callback, user_data, error)

### Prototype
```c
GIO_DEPRECATED_IN_2_46_FOR(g_task_report_error) void g_simple_async_report_gerror_in_idle (GObject *object, GAsyncReadyCallback callback, gpointer user_data, const GError *error);
```
"""
function g_simple_async_report_gerror_in_idle(object, callback, user_data, error)
    @ccall libaravis.g_simple_async_report_gerror_in_idle(object::Ptr{GObject}, callback::GAsyncReadyCallback, user_data::gpointer, error::Ptr{GError})::Cvoid
end

"""
    g_simple_async_report_take_gerror_in_idle(object, callback, user_data, error)

### Prototype
```c
GIO_DEPRECATED_IN_2_46_FOR(g_task_report_error) void g_simple_async_report_take_gerror_in_idle (GObject *object, GAsyncReadyCallback callback, gpointer user_data, GError *error);
```
"""
function g_simple_async_report_take_gerror_in_idle(object, callback, user_data, error)
    @ccall libaravis.g_simple_async_report_take_gerror_in_idle(object::Ptr{GObject}, callback::GAsyncReadyCallback, user_data::gpointer, error::Ptr{GError})::Cvoid
end

"""
    g_simple_io_stream_new(input_stream, output_stream)

### Prototype
```c
GIO_AVAILABLE_IN_2_44 GIOStream *g_simple_io_stream_new (GInputStream *input_stream, GOutputStream *output_stream);
```
"""
function g_simple_io_stream_new(input_stream, output_stream)
    @ccall libaravis.g_simple_io_stream_new(input_stream::Ptr{GInputStream}, output_stream::Ptr{GOutputStream})::Ptr{GIOStream}
end

"""
    g_simple_permission_new(allowed)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GPermission * g_simple_permission_new (gboolean allowed);
```
"""
function g_simple_permission_new(allowed)
    @ccall libaravis.g_simple_permission_new(allowed::gboolean)::Ptr{GPermission}
end

"""
    g_simple_proxy_resolver_new(default_proxy, ignore_hosts)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 GProxyResolver *g_simple_proxy_resolver_new (const gchar *default_proxy, gchar **ignore_hosts);
```
"""
function g_simple_proxy_resolver_new(default_proxy, ignore_hosts)
    @ccall libaravis.g_simple_proxy_resolver_new(default_proxy::Ptr{gchar}, ignore_hosts::Ptr{Ptr{gchar}})::Ptr{GProxyResolver}
end

"""
    g_simple_proxy_resolver_set_default_proxy(resolver, default_proxy)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 void g_simple_proxy_resolver_set_default_proxy (GSimpleProxyResolver *resolver, const gchar *default_proxy);
```
"""
function g_simple_proxy_resolver_set_default_proxy(resolver, default_proxy)
    @ccall libaravis.g_simple_proxy_resolver_set_default_proxy(resolver::Ptr{GSimpleProxyResolver}, default_proxy::Ptr{gchar})::Cvoid
end

"""
    g_simple_proxy_resolver_set_ignore_hosts(resolver, ignore_hosts)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 void g_simple_proxy_resolver_set_ignore_hosts (GSimpleProxyResolver *resolver, gchar **ignore_hosts);
```
"""
function g_simple_proxy_resolver_set_ignore_hosts(resolver, ignore_hosts)
    @ccall libaravis.g_simple_proxy_resolver_set_ignore_hosts(resolver::Ptr{GSimpleProxyResolver}, ignore_hosts::Ptr{Ptr{gchar}})::Cvoid
end

"""
    g_simple_proxy_resolver_set_uri_proxy(resolver, uri_scheme, proxy)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 void g_simple_proxy_resolver_set_uri_proxy (GSimpleProxyResolver *resolver, const gchar *uri_scheme, const gchar *proxy);
```
"""
function g_simple_proxy_resolver_set_uri_proxy(resolver, uri_scheme, proxy)
    @ccall libaravis.g_simple_proxy_resolver_set_uri_proxy(resolver::Ptr{GSimpleProxyResolver}, uri_scheme::Ptr{gchar}, proxy::Ptr{gchar})::Cvoid
end

"""
    g_socket_new(family, type, protocol, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocket * g_socket_new (GSocketFamily family, GSocketType type, GSocketProtocol protocol, GError **error);
```
"""
function g_socket_new(family, type, protocol, error)
    @ccall libaravis.g_socket_new(family::GSocketFamily, type::GSocketType, protocol::GSocketProtocol, error::Ptr{Ptr{GError}})::Ptr{GSocket}
end

"""
    g_socket_new_from_fd(fd, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocket * g_socket_new_from_fd (gint fd, GError **error);
```
"""
function g_socket_new_from_fd(fd, error)
    @ccall libaravis.g_socket_new_from_fd(fd::gint, error::Ptr{Ptr{GError}})::Ptr{GSocket}
end

"""
    g_socket_get_fd(socket)

### Prototype
```c
GIO_AVAILABLE_IN_ALL int g_socket_get_fd (GSocket *socket);
```
"""
function g_socket_get_fd(socket)
    @ccall libaravis.g_socket_get_fd(socket::Ptr{GSocket})::Cint
end

"""
    g_socket_get_family(socket)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketFamily g_socket_get_family (GSocket *socket);
```
"""
function g_socket_get_family(socket)
    @ccall libaravis.g_socket_get_family(socket::Ptr{GSocket})::GSocketFamily
end

"""
    g_socket_get_socket_type(socket)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketType g_socket_get_socket_type (GSocket *socket);
```
"""
function g_socket_get_socket_type(socket)
    @ccall libaravis.g_socket_get_socket_type(socket::Ptr{GSocket})::GSocketType
end

"""
    g_socket_get_protocol(socket)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketProtocol g_socket_get_protocol (GSocket *socket);
```
"""
function g_socket_get_protocol(socket)
    @ccall libaravis.g_socket_get_protocol(socket::Ptr{GSocket})::GSocketProtocol
end

"""
    g_socket_get_local_address(socket, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketAddress * g_socket_get_local_address (GSocket *socket, GError **error);
```
"""
function g_socket_get_local_address(socket, error)
    @ccall libaravis.g_socket_get_local_address(socket::Ptr{GSocket}, error::Ptr{Ptr{GError}})::Ptr{GSocketAddress}
end

"""
    g_socket_get_remote_address(socket, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketAddress * g_socket_get_remote_address (GSocket *socket, GError **error);
```
"""
function g_socket_get_remote_address(socket, error)
    @ccall libaravis.g_socket_get_remote_address(socket::Ptr{GSocket}, error::Ptr{Ptr{GError}})::Ptr{GSocketAddress}
end

"""
    g_socket_set_blocking(socket, blocking)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_socket_set_blocking (GSocket *socket, gboolean blocking);
```
"""
function g_socket_set_blocking(socket, blocking)
    @ccall libaravis.g_socket_set_blocking(socket::Ptr{GSocket}, blocking::gboolean)::Cvoid
end

"""
    g_socket_get_blocking(socket)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_socket_get_blocking (GSocket *socket);
```
"""
function g_socket_get_blocking(socket)
    @ccall libaravis.g_socket_get_blocking(socket::Ptr{GSocket})::gboolean
end

"""
    g_socket_set_keepalive(socket, keepalive)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_socket_set_keepalive (GSocket *socket, gboolean keepalive);
```
"""
function g_socket_set_keepalive(socket, keepalive)
    @ccall libaravis.g_socket_set_keepalive(socket::Ptr{GSocket}, keepalive::gboolean)::Cvoid
end

"""
    g_socket_get_keepalive(socket)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_socket_get_keepalive (GSocket *socket);
```
"""
function g_socket_get_keepalive(socket)
    @ccall libaravis.g_socket_get_keepalive(socket::Ptr{GSocket})::gboolean
end

"""
    g_socket_get_listen_backlog(socket)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gint g_socket_get_listen_backlog (GSocket *socket);
```
"""
function g_socket_get_listen_backlog(socket)
    @ccall libaravis.g_socket_get_listen_backlog(socket::Ptr{GSocket})::gint
end

"""
    g_socket_set_listen_backlog(socket, backlog)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_socket_set_listen_backlog (GSocket *socket, gint backlog);
```
"""
function g_socket_set_listen_backlog(socket, backlog)
    @ccall libaravis.g_socket_set_listen_backlog(socket::Ptr{GSocket}, backlog::gint)::Cvoid
end

"""
    g_socket_get_timeout(socket)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint g_socket_get_timeout (GSocket *socket);
```
"""
function g_socket_get_timeout(socket)
    @ccall libaravis.g_socket_get_timeout(socket::Ptr{GSocket})::guint
end

"""
    g_socket_set_timeout(socket, timeout)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_socket_set_timeout (GSocket *socket, guint timeout);
```
"""
function g_socket_set_timeout(socket, timeout)
    @ccall libaravis.g_socket_set_timeout(socket::Ptr{GSocket}, timeout::guint)::Cvoid
end

"""
    g_socket_get_ttl(socket)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 guint g_socket_get_ttl (GSocket *socket);
```
"""
function g_socket_get_ttl(socket)
    @ccall libaravis.g_socket_get_ttl(socket::Ptr{GSocket})::guint
end

"""
    g_socket_set_ttl(socket, ttl)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_socket_set_ttl (GSocket *socket, guint ttl);
```
"""
function g_socket_set_ttl(socket, ttl)
    @ccall libaravis.g_socket_set_ttl(socket::Ptr{GSocket}, ttl::guint)::Cvoid
end

"""
    g_socket_get_broadcast(socket)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 gboolean g_socket_get_broadcast (GSocket *socket);
```
"""
function g_socket_get_broadcast(socket)
    @ccall libaravis.g_socket_get_broadcast(socket::Ptr{GSocket})::gboolean
end

"""
    g_socket_set_broadcast(socket, broadcast)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_socket_set_broadcast (GSocket *socket, gboolean broadcast);
```
"""
function g_socket_set_broadcast(socket, broadcast)
    @ccall libaravis.g_socket_set_broadcast(socket::Ptr{GSocket}, broadcast::gboolean)::Cvoid
end

"""
    g_socket_get_multicast_loopback(socket)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 gboolean g_socket_get_multicast_loopback (GSocket *socket);
```
"""
function g_socket_get_multicast_loopback(socket)
    @ccall libaravis.g_socket_get_multicast_loopback(socket::Ptr{GSocket})::gboolean
end

"""
    g_socket_set_multicast_loopback(socket, loopback)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_socket_set_multicast_loopback (GSocket *socket, gboolean loopback);
```
"""
function g_socket_set_multicast_loopback(socket, loopback)
    @ccall libaravis.g_socket_set_multicast_loopback(socket::Ptr{GSocket}, loopback::gboolean)::Cvoid
end

"""
    g_socket_get_multicast_ttl(socket)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 guint g_socket_get_multicast_ttl (GSocket *socket);
```
"""
function g_socket_get_multicast_ttl(socket)
    @ccall libaravis.g_socket_get_multicast_ttl(socket::Ptr{GSocket})::guint
end

"""
    g_socket_set_multicast_ttl(socket, ttl)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_socket_set_multicast_ttl (GSocket *socket, guint ttl);
```
"""
function g_socket_set_multicast_ttl(socket, ttl)
    @ccall libaravis.g_socket_set_multicast_ttl(socket::Ptr{GSocket}, ttl::guint)::Cvoid
end

"""
    g_socket_is_connected(socket)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_socket_is_connected (GSocket *socket);
```
"""
function g_socket_is_connected(socket)
    @ccall libaravis.g_socket_is_connected(socket::Ptr{GSocket})::gboolean
end

"""
    g_socket_bind(socket, address, allow_reuse, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_socket_bind (GSocket *socket, GSocketAddress *address, gboolean allow_reuse, GError **error);
```
"""
function g_socket_bind(socket, address, allow_reuse, error)
    @ccall libaravis.g_socket_bind(socket::Ptr{GSocket}, address::Ptr{GSocketAddress}, allow_reuse::gboolean, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_socket_join_multicast_group(socket, group, source_specific, iface, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 gboolean g_socket_join_multicast_group (GSocket *socket, GInetAddress *group, gboolean source_specific, const gchar *iface, GError **error);
```
"""
function g_socket_join_multicast_group(socket, group, source_specific, iface, error)
    @ccall libaravis.g_socket_join_multicast_group(socket::Ptr{GSocket}, group::Ptr{GInetAddress}, source_specific::gboolean, iface::Ptr{gchar}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_socket_leave_multicast_group(socket, group, source_specific, iface, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 gboolean g_socket_leave_multicast_group (GSocket *socket, GInetAddress *group, gboolean source_specific, const gchar *iface, GError **error);
```
"""
function g_socket_leave_multicast_group(socket, group, source_specific, iface, error)
    @ccall libaravis.g_socket_leave_multicast_group(socket::Ptr{GSocket}, group::Ptr{GInetAddress}, source_specific::gboolean, iface::Ptr{gchar}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_socket_join_multicast_group_ssm(socket, group, source_specific, iface, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_56 gboolean g_socket_join_multicast_group_ssm (GSocket *socket, GInetAddress *group, GInetAddress *source_specific, const gchar *iface, GError **error);
```
"""
function g_socket_join_multicast_group_ssm(socket, group, source_specific, iface, error)
    @ccall libaravis.g_socket_join_multicast_group_ssm(socket::Ptr{GSocket}, group::Ptr{GInetAddress}, source_specific::Ptr{GInetAddress}, iface::Ptr{gchar}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_socket_leave_multicast_group_ssm(socket, group, source_specific, iface, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_56 gboolean g_socket_leave_multicast_group_ssm (GSocket *socket, GInetAddress *group, GInetAddress *source_specific, const gchar *iface, GError **error);
```
"""
function g_socket_leave_multicast_group_ssm(socket, group, source_specific, iface, error)
    @ccall libaravis.g_socket_leave_multicast_group_ssm(socket::Ptr{GSocket}, group::Ptr{GInetAddress}, source_specific::Ptr{GInetAddress}, iface::Ptr{gchar}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_socket_connect(socket, address, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_socket_connect (GSocket *socket, GSocketAddress *address, GCancellable *cancellable, GError **error);
```
"""
function g_socket_connect(socket, address, cancellable, error)
    @ccall libaravis.g_socket_connect(socket::Ptr{GSocket}, address::Ptr{GSocketAddress}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_socket_check_connect_result(socket, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_socket_check_connect_result (GSocket *socket, GError **error);
```
"""
function g_socket_check_connect_result(socket, error)
    @ccall libaravis.g_socket_check_connect_result(socket::Ptr{GSocket}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_socket_get_available_bytes(socket)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gssize g_socket_get_available_bytes (GSocket *socket);
```
"""
function g_socket_get_available_bytes(socket)
    @ccall libaravis.g_socket_get_available_bytes(socket::Ptr{GSocket})::gssize
end

"""
    g_socket_condition_check(socket, condition)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIOCondition g_socket_condition_check (GSocket *socket, GIOCondition condition);
```
"""
function g_socket_condition_check(socket, condition)
    @ccall libaravis.g_socket_condition_check(socket::Ptr{GSocket}, condition::GIOCondition)::GIOCondition
end

"""
    g_socket_condition_wait(socket, condition, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_socket_condition_wait (GSocket *socket, GIOCondition condition, GCancellable *cancellable, GError **error);
```
"""
function g_socket_condition_wait(socket, condition, cancellable, error)
    @ccall libaravis.g_socket_condition_wait(socket::Ptr{GSocket}, condition::GIOCondition, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_socket_condition_timed_wait(socket, condition, timeout_us, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 gboolean g_socket_condition_timed_wait (GSocket *socket, GIOCondition condition, gint64 timeout_us, GCancellable *cancellable, GError **error);
```
"""
function g_socket_condition_timed_wait(socket, condition, timeout_us, cancellable, error)
    @ccall libaravis.g_socket_condition_timed_wait(socket::Ptr{GSocket}, condition::GIOCondition, timeout_us::gint64, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_socket_accept(socket, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocket * g_socket_accept (GSocket *socket, GCancellable *cancellable, GError **error);
```
"""
function g_socket_accept(socket, cancellable, error)
    @ccall libaravis.g_socket_accept(socket::Ptr{GSocket}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GSocket}
end

"""
    g_socket_listen(socket, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_socket_listen (GSocket *socket, GError **error);
```
"""
function g_socket_listen(socket, error)
    @ccall libaravis.g_socket_listen(socket::Ptr{GSocket}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_socket_receive(socket, buffer, size, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gssize g_socket_receive (GSocket *socket, gchar *buffer, gsize size, GCancellable *cancellable, GError **error);
```
"""
function g_socket_receive(socket, buffer, size, cancellable, error)
    @ccall libaravis.g_socket_receive(socket::Ptr{GSocket}, buffer::Ptr{gchar}, size::gsize, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gssize
end

"""
    g_socket_receive_bytes(socket, size, timeout_us, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_80 GBytes * g_socket_receive_bytes (GSocket *socket, gsize size, gint64 timeout_us, GCancellable *cancellable, GError **error);
```
"""
function g_socket_receive_bytes(socket, size, timeout_us, cancellable, error)
    @ccall libaravis.g_socket_receive_bytes(socket::Ptr{GSocket}, size::gsize, timeout_us::gint64, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GBytes}
end

"""
    g_socket_receive_from(socket, address, buffer, size, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gssize g_socket_receive_from (GSocket *socket, GSocketAddress **address, gchar *buffer, gsize size, GCancellable *cancellable, GError **error);
```
"""
function g_socket_receive_from(socket, address, buffer, size, cancellable, error)
    @ccall libaravis.g_socket_receive_from(socket::Ptr{GSocket}, address::Ptr{Ptr{GSocketAddress}}, buffer::Ptr{gchar}, size::gsize, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gssize
end

"""
    g_socket_receive_bytes_from(socket, address, size, timeout_us, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_80 GBytes * g_socket_receive_bytes_from (GSocket *socket, GSocketAddress **address, gsize size, gint64 timeout_us, GCancellable *cancellable, GError **error);
```
"""
function g_socket_receive_bytes_from(socket, address, size, timeout_us, cancellable, error)
    @ccall libaravis.g_socket_receive_bytes_from(socket::Ptr{GSocket}, address::Ptr{Ptr{GSocketAddress}}, size::gsize, timeout_us::gint64, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GBytes}
end

"""
    g_socket_send(socket, buffer, size, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gssize g_socket_send (GSocket *socket, const gchar *buffer, gsize size, GCancellable *cancellable, GError **error);
```
"""
function g_socket_send(socket, buffer, size, cancellable, error)
    @ccall libaravis.g_socket_send(socket::Ptr{GSocket}, buffer::Ptr{gchar}, size::gsize, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gssize
end

"""
    g_socket_send_to(socket, address, buffer, size, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gssize g_socket_send_to (GSocket *socket, GSocketAddress *address, const gchar *buffer, gsize size, GCancellable *cancellable, GError **error);
```
"""
function g_socket_send_to(socket, address, buffer, size, cancellable, error)
    @ccall libaravis.g_socket_send_to(socket::Ptr{GSocket}, address::Ptr{GSocketAddress}, buffer::Ptr{gchar}, size::gsize, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gssize
end

"""
    g_socket_receive_message(socket, address, vectors, num_vectors, messages, num_messages, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gssize g_socket_receive_message (GSocket *socket, GSocketAddress **address, GInputVector *vectors, gint num_vectors, GSocketControlMessage ***messages, gint *num_messages, gint *flags, GCancellable *cancellable, GError **error);
```
"""
function g_socket_receive_message(socket, address, vectors, num_vectors, messages, num_messages, flags, cancellable, error)
    @ccall libaravis.g_socket_receive_message(socket::Ptr{GSocket}, address::Ptr{Ptr{GSocketAddress}}, vectors::Ptr{GInputVector}, num_vectors::gint, messages::Ptr{Ptr{Ptr{GSocketControlMessage}}}, num_messages::Ptr{gint}, flags::Ptr{gint}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gssize
end

"""
    g_socket_send_message(socket, address, vectors, num_vectors, messages, num_messages, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gssize g_socket_send_message (GSocket *socket, GSocketAddress *address, GOutputVector *vectors, gint num_vectors, GSocketControlMessage **messages, gint num_messages, gint flags, GCancellable *cancellable, GError **error);
```
"""
function g_socket_send_message(socket, address, vectors, num_vectors, messages, num_messages, flags, cancellable, error)
    @ccall libaravis.g_socket_send_message(socket::Ptr{GSocket}, address::Ptr{GSocketAddress}, vectors::Ptr{GOutputVector}, num_vectors::gint, messages::Ptr{Ptr{GSocketControlMessage}}, num_messages::gint, flags::gint, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gssize
end

"""
    g_socket_receive_messages(socket, messages, num_messages, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 gint g_socket_receive_messages (GSocket *socket, GInputMessage *messages, guint num_messages, gint flags, GCancellable *cancellable, GError **error);
```
"""
function g_socket_receive_messages(socket, messages, num_messages, flags, cancellable, error)
    @ccall libaravis.g_socket_receive_messages(socket::Ptr{GSocket}, messages::Ptr{GInputMessage}, num_messages::guint, flags::gint, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gint
end

"""
    g_socket_send_messages(socket, messages, num_messages, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_44 gint g_socket_send_messages (GSocket *socket, GOutputMessage *messages, guint num_messages, gint flags, GCancellable *cancellable, GError **error);
```
"""
function g_socket_send_messages(socket, messages, num_messages, flags, cancellable, error)
    @ccall libaravis.g_socket_send_messages(socket::Ptr{GSocket}, messages::Ptr{GOutputMessage}, num_messages::guint, flags::gint, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gint
end

"""
    g_socket_close(socket, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_socket_close (GSocket *socket, GError **error);
```
"""
function g_socket_close(socket, error)
    @ccall libaravis.g_socket_close(socket::Ptr{GSocket}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_socket_shutdown(socket, shutdown_read, shutdown_write, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_socket_shutdown (GSocket *socket, gboolean shutdown_read, gboolean shutdown_write, GError **error);
```
"""
function g_socket_shutdown(socket, shutdown_read, shutdown_write, error)
    @ccall libaravis.g_socket_shutdown(socket::Ptr{GSocket}, shutdown_read::gboolean, shutdown_write::gboolean, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_socket_is_closed(socket)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_socket_is_closed (GSocket *socket);
```
"""
function g_socket_is_closed(socket)
    @ccall libaravis.g_socket_is_closed(socket::Ptr{GSocket})::gboolean
end

"""
    g_socket_create_source(socket, condition, cancellable)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSource * g_socket_create_source (GSocket *socket, GIOCondition condition, GCancellable *cancellable);
```
"""
function g_socket_create_source(socket, condition, cancellable)
    @ccall libaravis.g_socket_create_source(socket::Ptr{GSocket}, condition::GIOCondition, cancellable::Ptr{GCancellable})::Ptr{GSource}
end

"""
    g_socket_speaks_ipv4(socket)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_socket_speaks_ipv4 (GSocket *socket);
```
"""
function g_socket_speaks_ipv4(socket)
    @ccall libaravis.g_socket_speaks_ipv4(socket::Ptr{GSocket})::gboolean
end

"""
    g_socket_get_credentials(socket, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GCredentials *g_socket_get_credentials (GSocket *socket, GError **error);
```
"""
function g_socket_get_credentials(socket, error)
    @ccall libaravis.g_socket_get_credentials(socket::Ptr{GSocket}, error::Ptr{Ptr{GError}})::Ptr{GCredentials}
end

"""
    g_socket_receive_with_blocking(socket, buffer, size, blocking, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gssize g_socket_receive_with_blocking (GSocket *socket, gchar *buffer, gsize size, gboolean blocking, GCancellable *cancellable, GError **error);
```
"""
function g_socket_receive_with_blocking(socket, buffer, size, blocking, cancellable, error)
    @ccall libaravis.g_socket_receive_with_blocking(socket::Ptr{GSocket}, buffer::Ptr{gchar}, size::gsize, blocking::gboolean, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gssize
end

"""
    g_socket_send_with_blocking(socket, buffer, size, blocking, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gssize g_socket_send_with_blocking (GSocket *socket, const gchar *buffer, gsize size, gboolean blocking, GCancellable *cancellable, GError **error);
```
"""
function g_socket_send_with_blocking(socket, buffer, size, blocking, cancellable, error)
    @ccall libaravis.g_socket_send_with_blocking(socket::Ptr{GSocket}, buffer::Ptr{gchar}, size::gsize, blocking::gboolean, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gssize
end

"""
    g_socket_send_message_with_timeout(socket, address, vectors, num_vectors, messages, num_messages, flags, timeout_us, bytes_written, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_60 GPollableReturn g_socket_send_message_with_timeout (GSocket *socket, GSocketAddress *address, const GOutputVector *vectors, gint num_vectors, GSocketControlMessage **messages, gint num_messages, gint flags, gint64 timeout_us, gsize *bytes_written, GCancellable *cancellable, GError **error);
```
"""
function g_socket_send_message_with_timeout(socket, address, vectors, num_vectors, messages, num_messages, flags, timeout_us, bytes_written, cancellable, error)
    @ccall libaravis.g_socket_send_message_with_timeout(socket::Ptr{GSocket}, address::Ptr{GSocketAddress}, vectors::Ptr{GOutputVector}, num_vectors::gint, messages::Ptr{Ptr{GSocketControlMessage}}, num_messages::gint, flags::gint, timeout_us::gint64, bytes_written::Ptr{gsize}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::GPollableReturn
end

"""
    g_socket_get_option(socket, level, optname, value, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 gboolean g_socket_get_option (GSocket *socket, gint level, gint optname, gint *value, GError **error);
```
"""
function g_socket_get_option(socket, level, optname, value, error)
    @ccall libaravis.g_socket_get_option(socket::Ptr{GSocket}, level::gint, optname::gint, value::Ptr{gint}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_socket_set_option(socket, level, optname, value, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 gboolean g_socket_set_option (GSocket *socket, gint level, gint optname, gint value, GError **error);
```
"""
function g_socket_set_option(socket, level, optname, value, error)
    @ccall libaravis.g_socket_set_option(socket::Ptr{GSocket}, level::gint, optname::gint, value::gint, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_socket_client_new()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketClient *g_socket_client_new (void);
```
"""
function g_socket_client_new()
    @ccall libaravis.g_socket_client_new()::Ptr{GSocketClient}
end

"""
    g_socket_client_get_family(client)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketFamily g_socket_client_get_family (GSocketClient *client);
```
"""
function g_socket_client_get_family(client)
    @ccall libaravis.g_socket_client_get_family(client::Ptr{GSocketClient})::GSocketFamily
end

"""
    g_socket_client_set_family(client, family)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_socket_client_set_family (GSocketClient *client, GSocketFamily family);
```
"""
function g_socket_client_set_family(client, family)
    @ccall libaravis.g_socket_client_set_family(client::Ptr{GSocketClient}, family::GSocketFamily)::Cvoid
end

"""
    g_socket_client_get_socket_type(client)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketType g_socket_client_get_socket_type (GSocketClient *client);
```
"""
function g_socket_client_get_socket_type(client)
    @ccall libaravis.g_socket_client_get_socket_type(client::Ptr{GSocketClient})::GSocketType
end

"""
    g_socket_client_set_socket_type(client, type)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_socket_client_set_socket_type (GSocketClient *client, GSocketType type);
```
"""
function g_socket_client_set_socket_type(client, type)
    @ccall libaravis.g_socket_client_set_socket_type(client::Ptr{GSocketClient}, type::GSocketType)::Cvoid
end

"""
    g_socket_client_get_protocol(client)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketProtocol g_socket_client_get_protocol (GSocketClient *client);
```
"""
function g_socket_client_get_protocol(client)
    @ccall libaravis.g_socket_client_get_protocol(client::Ptr{GSocketClient})::GSocketProtocol
end

"""
    g_socket_client_set_protocol(client, protocol)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_socket_client_set_protocol (GSocketClient *client, GSocketProtocol protocol);
```
"""
function g_socket_client_set_protocol(client, protocol)
    @ccall libaravis.g_socket_client_set_protocol(client::Ptr{GSocketClient}, protocol::GSocketProtocol)::Cvoid
end

"""
    g_socket_client_get_local_address(client)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketAddress *g_socket_client_get_local_address (GSocketClient *client);
```
"""
function g_socket_client_get_local_address(client)
    @ccall libaravis.g_socket_client_get_local_address(client::Ptr{GSocketClient})::Ptr{GSocketAddress}
end

"""
    g_socket_client_set_local_address(client, address)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_socket_client_set_local_address (GSocketClient *client, GSocketAddress *address);
```
"""
function g_socket_client_set_local_address(client, address)
    @ccall libaravis.g_socket_client_set_local_address(client::Ptr{GSocketClient}, address::Ptr{GSocketAddress})::Cvoid
end

"""
    g_socket_client_get_timeout(client)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint g_socket_client_get_timeout (GSocketClient *client);
```
"""
function g_socket_client_get_timeout(client)
    @ccall libaravis.g_socket_client_get_timeout(client::Ptr{GSocketClient})::guint
end

"""
    g_socket_client_set_timeout(client, timeout)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_socket_client_set_timeout (GSocketClient *client, guint timeout);
```
"""
function g_socket_client_set_timeout(client, timeout)
    @ccall libaravis.g_socket_client_set_timeout(client::Ptr{GSocketClient}, timeout::guint)::Cvoid
end

"""
    g_socket_client_get_enable_proxy(client)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_socket_client_get_enable_proxy (GSocketClient *client);
```
"""
function g_socket_client_get_enable_proxy(client)
    @ccall libaravis.g_socket_client_get_enable_proxy(client::Ptr{GSocketClient})::gboolean
end

"""
    g_socket_client_set_enable_proxy(client, enable)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_socket_client_set_enable_proxy (GSocketClient *client, gboolean enable);
```
"""
function g_socket_client_set_enable_proxy(client, enable)
    @ccall libaravis.g_socket_client_set_enable_proxy(client::Ptr{GSocketClient}, enable::gboolean)::Cvoid
end

"""
    g_socket_client_get_tls(client)

### Prototype
```c
GIO_AVAILABLE_IN_2_28 gboolean g_socket_client_get_tls (GSocketClient *client);
```
"""
function g_socket_client_get_tls(client)
    @ccall libaravis.g_socket_client_get_tls(client::Ptr{GSocketClient})::gboolean
end

"""
    g_socket_client_set_tls(client, tls)

### Prototype
```c
GIO_AVAILABLE_IN_2_28 void g_socket_client_set_tls (GSocketClient *client, gboolean tls);
```
"""
function g_socket_client_set_tls(client, tls)
    @ccall libaravis.g_socket_client_set_tls(client::Ptr{GSocketClient}, tls::gboolean)::Cvoid
end

"""
    g_socket_client_get_tls_validation_flags(client)

### Prototype
```c
GIO_DEPRECATED_IN_2_72 GTlsCertificateFlags g_socket_client_get_tls_validation_flags (GSocketClient *client);
```
"""
function g_socket_client_get_tls_validation_flags(client)
    @ccall libaravis.g_socket_client_get_tls_validation_flags(client::Ptr{GSocketClient})::GTlsCertificateFlags
end

"""
    g_socket_client_set_tls_validation_flags(client, flags)

### Prototype
```c
GIO_DEPRECATED_IN_2_72 void g_socket_client_set_tls_validation_flags (GSocketClient *client, GTlsCertificateFlags flags);
```
"""
function g_socket_client_set_tls_validation_flags(client, flags)
    @ccall libaravis.g_socket_client_set_tls_validation_flags(client::Ptr{GSocketClient}, flags::GTlsCertificateFlags)::Cvoid
end

"""
    g_socket_client_get_proxy_resolver(client)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 GProxyResolver *g_socket_client_get_proxy_resolver (GSocketClient *client);
```
"""
function g_socket_client_get_proxy_resolver(client)
    @ccall libaravis.g_socket_client_get_proxy_resolver(client::Ptr{GSocketClient})::Ptr{GProxyResolver}
end

"""
    g_socket_client_set_proxy_resolver(client, proxy_resolver)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 void g_socket_client_set_proxy_resolver (GSocketClient *client, GProxyResolver *proxy_resolver);
```
"""
function g_socket_client_set_proxy_resolver(client, proxy_resolver)
    @ccall libaravis.g_socket_client_set_proxy_resolver(client::Ptr{GSocketClient}, proxy_resolver::Ptr{GProxyResolver})::Cvoid
end

"""
    g_socket_client_connect(client, connectable, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketConnection * g_socket_client_connect (GSocketClient *client, GSocketConnectable *connectable, GCancellable *cancellable, GError **error);
```
"""
function g_socket_client_connect(client, connectable, cancellable, error)
    @ccall libaravis.g_socket_client_connect(client::Ptr{GSocketClient}, connectable::Ptr{GSocketConnectable}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GSocketConnection}
end

"""
    g_socket_client_connect_to_host(client, host_and_port, default_port, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketConnection * g_socket_client_connect_to_host (GSocketClient *client, const gchar *host_and_port, guint16 default_port, GCancellable *cancellable, GError **error);
```
"""
function g_socket_client_connect_to_host(client, host_and_port, default_port, cancellable, error)
    @ccall libaravis.g_socket_client_connect_to_host(client::Ptr{GSocketClient}, host_and_port::Ptr{gchar}, default_port::guint16, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GSocketConnection}
end

"""
    g_socket_client_connect_to_service(client, domain, service, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketConnection * g_socket_client_connect_to_service (GSocketClient *client, const gchar *domain, const gchar *service, GCancellable *cancellable, GError **error);
```
"""
function g_socket_client_connect_to_service(client, domain, service, cancellable, error)
    @ccall libaravis.g_socket_client_connect_to_service(client::Ptr{GSocketClient}, domain::Ptr{gchar}, service::Ptr{gchar}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GSocketConnection}
end

"""
    g_socket_client_connect_to_uri(client, uri, default_port, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_26 GSocketConnection * g_socket_client_connect_to_uri (GSocketClient *client, const gchar *uri, guint16 default_port, GCancellable *cancellable, GError **error);
```
"""
function g_socket_client_connect_to_uri(client, uri, default_port, cancellable, error)
    @ccall libaravis.g_socket_client_connect_to_uri(client::Ptr{GSocketClient}, uri::Ptr{gchar}, default_port::guint16, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GSocketConnection}
end

"""
    g_socket_client_connect_async(client, connectable, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_socket_client_connect_async (GSocketClient *client, GSocketConnectable *connectable, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_socket_client_connect_async(client, connectable, cancellable, callback, user_data)
    @ccall libaravis.g_socket_client_connect_async(client::Ptr{GSocketClient}, connectable::Ptr{GSocketConnectable}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_socket_client_connect_finish(client, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketConnection * g_socket_client_connect_finish (GSocketClient *client, GAsyncResult *result, GError **error);
```
"""
function g_socket_client_connect_finish(client, result, error)
    @ccall libaravis.g_socket_client_connect_finish(client::Ptr{GSocketClient}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GSocketConnection}
end

"""
    g_socket_client_connect_to_host_async(client, host_and_port, default_port, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_socket_client_connect_to_host_async (GSocketClient *client, const gchar *host_and_port, guint16 default_port, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_socket_client_connect_to_host_async(client, host_and_port, default_port, cancellable, callback, user_data)
    @ccall libaravis.g_socket_client_connect_to_host_async(client::Ptr{GSocketClient}, host_and_port::Ptr{gchar}, default_port::guint16, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_socket_client_connect_to_host_finish(client, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketConnection * g_socket_client_connect_to_host_finish (GSocketClient *client, GAsyncResult *result, GError **error);
```
"""
function g_socket_client_connect_to_host_finish(client, result, error)
    @ccall libaravis.g_socket_client_connect_to_host_finish(client::Ptr{GSocketClient}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GSocketConnection}
end

"""
    g_socket_client_connect_to_service_async(client, domain, service, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_socket_client_connect_to_service_async (GSocketClient *client, const gchar *domain, const gchar *service, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_socket_client_connect_to_service_async(client, domain, service, cancellable, callback, user_data)
    @ccall libaravis.g_socket_client_connect_to_service_async(client::Ptr{GSocketClient}, domain::Ptr{gchar}, service::Ptr{gchar}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_socket_client_connect_to_service_finish(client, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketConnection * g_socket_client_connect_to_service_finish (GSocketClient *client, GAsyncResult *result, GError **error);
```
"""
function g_socket_client_connect_to_service_finish(client, result, error)
    @ccall libaravis.g_socket_client_connect_to_service_finish(client::Ptr{GSocketClient}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GSocketConnection}
end

"""
    g_socket_client_connect_to_uri_async(client, uri, default_port, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_socket_client_connect_to_uri_async (GSocketClient *client, const gchar *uri, guint16 default_port, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_socket_client_connect_to_uri_async(client, uri, default_port, cancellable, callback, user_data)
    @ccall libaravis.g_socket_client_connect_to_uri_async(client::Ptr{GSocketClient}, uri::Ptr{gchar}, default_port::guint16, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_socket_client_connect_to_uri_finish(client, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketConnection * g_socket_client_connect_to_uri_finish (GSocketClient *client, GAsyncResult *result, GError **error);
```
"""
function g_socket_client_connect_to_uri_finish(client, result, error)
    @ccall libaravis.g_socket_client_connect_to_uri_finish(client::Ptr{GSocketClient}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GSocketConnection}
end

"""
    g_socket_client_add_application_proxy(client, protocol)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_socket_client_add_application_proxy (GSocketClient *client, const gchar *protocol);
```
"""
function g_socket_client_add_application_proxy(client, protocol)
    @ccall libaravis.g_socket_client_add_application_proxy(client::Ptr{GSocketClient}, protocol::Ptr{gchar})::Cvoid
end

"""
    g_socket_connectable_enumerate(connectable)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketAddressEnumerator *g_socket_connectable_enumerate (GSocketConnectable *connectable);
```
"""
function g_socket_connectable_enumerate(connectable)
    @ccall libaravis.g_socket_connectable_enumerate(connectable::Ptr{GSocketConnectable})::Ptr{GSocketAddressEnumerator}
end

"""
    g_socket_connectable_proxy_enumerate(connectable)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketAddressEnumerator *g_socket_connectable_proxy_enumerate (GSocketConnectable *connectable);
```
"""
function g_socket_connectable_proxy_enumerate(connectable)
    @ccall libaravis.g_socket_connectable_proxy_enumerate(connectable::Ptr{GSocketConnectable})::Ptr{GSocketAddressEnumerator}
end

"""
    g_socket_connectable_to_string(connectable)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 gchar *g_socket_connectable_to_string (GSocketConnectable *connectable);
```
"""
function g_socket_connectable_to_string(connectable)
    @ccall libaravis.g_socket_connectable_to_string(connectable::Ptr{GSocketConnectable})::Ptr{gchar}
end

"""
    g_socket_connection_is_connected(connection)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 gboolean g_socket_connection_is_connected (GSocketConnection *connection);
```
"""
function g_socket_connection_is_connected(connection)
    @ccall libaravis.g_socket_connection_is_connected(connection::Ptr{GSocketConnection})::gboolean
end

"""
    g_socket_connection_connect(connection, address, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 gboolean g_socket_connection_connect (GSocketConnection *connection, GSocketAddress *address, GCancellable *cancellable, GError **error);
```
"""
function g_socket_connection_connect(connection, address, cancellable, error)
    @ccall libaravis.g_socket_connection_connect(connection::Ptr{GSocketConnection}, address::Ptr{GSocketAddress}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_socket_connection_connect_async(connection, address, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_socket_connection_connect_async (GSocketConnection *connection, GSocketAddress *address, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_socket_connection_connect_async(connection, address, cancellable, callback, user_data)
    @ccall libaravis.g_socket_connection_connect_async(connection::Ptr{GSocketConnection}, address::Ptr{GSocketAddress}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_socket_connection_connect_finish(connection, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 gboolean g_socket_connection_connect_finish (GSocketConnection *connection, GAsyncResult *result, GError **error);
```
"""
function g_socket_connection_connect_finish(connection, result, error)
    @ccall libaravis.g_socket_connection_connect_finish(connection::Ptr{GSocketConnection}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_socket_connection_get_socket(connection)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocket *g_socket_connection_get_socket (GSocketConnection *connection);
```
"""
function g_socket_connection_get_socket(connection)
    @ccall libaravis.g_socket_connection_get_socket(connection::Ptr{GSocketConnection})::Ptr{GSocket}
end

"""
    g_socket_connection_get_local_address(connection, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketAddress *g_socket_connection_get_local_address (GSocketConnection *connection, GError **error);
```
"""
function g_socket_connection_get_local_address(connection, error)
    @ccall libaravis.g_socket_connection_get_local_address(connection::Ptr{GSocketConnection}, error::Ptr{Ptr{GError}})::Ptr{GSocketAddress}
end

"""
    g_socket_connection_get_remote_address(connection, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketAddress *g_socket_connection_get_remote_address (GSocketConnection *connection, GError **error);
```
"""
function g_socket_connection_get_remote_address(connection, error)
    @ccall libaravis.g_socket_connection_get_remote_address(connection::Ptr{GSocketConnection}, error::Ptr{Ptr{GError}})::Ptr{GSocketAddress}
end

"""
    g_socket_connection_factory_register_type(g_type, family, type, protocol)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_socket_connection_factory_register_type (GType g_type, GSocketFamily family, GSocketType type, gint protocol);
```
"""
function g_socket_connection_factory_register_type(g_type, family, type, protocol)
    @ccall libaravis.g_socket_connection_factory_register_type(g_type::GType, family::GSocketFamily, type::GSocketType, protocol::gint)::Cvoid
end

"""
    g_socket_connection_factory_lookup_type(family, type, protocol_id)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_socket_connection_factory_lookup_type (GSocketFamily family, GSocketType type, gint protocol_id);
```
"""
function g_socket_connection_factory_lookup_type(family, type, protocol_id)
    @ccall libaravis.g_socket_connection_factory_lookup_type(family::GSocketFamily, type::GSocketType, protocol_id::gint)::GType
end

"""
    g_socket_connection_factory_create_connection(socket)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketConnection *g_socket_connection_factory_create_connection (GSocket *socket);
```
"""
function g_socket_connection_factory_create_connection(socket)
    @ccall libaravis.g_socket_connection_factory_create_connection(socket::Ptr{GSocket})::Ptr{GSocketConnection}
end

"""
    g_socket_control_message_get_size(message)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gsize g_socket_control_message_get_size (GSocketControlMessage *message);
```
"""
function g_socket_control_message_get_size(message)
    @ccall libaravis.g_socket_control_message_get_size(message::Ptr{GSocketControlMessage})::gsize
end

"""
    g_socket_control_message_get_level(message)

### Prototype
```c
GIO_AVAILABLE_IN_ALL int g_socket_control_message_get_level (GSocketControlMessage *message);
```
"""
function g_socket_control_message_get_level(message)
    @ccall libaravis.g_socket_control_message_get_level(message::Ptr{GSocketControlMessage})::Cint
end

"""
    g_socket_control_message_get_msg_type(message)

### Prototype
```c
GIO_AVAILABLE_IN_ALL int g_socket_control_message_get_msg_type (GSocketControlMessage *message);
```
"""
function g_socket_control_message_get_msg_type(message)
    @ccall libaravis.g_socket_control_message_get_msg_type(message::Ptr{GSocketControlMessage})::Cint
end

"""
    g_socket_control_message_serialize(message, data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_socket_control_message_serialize (GSocketControlMessage *message, gpointer data);
```
"""
function g_socket_control_message_serialize(message, data)
    @ccall libaravis.g_socket_control_message_serialize(message::Ptr{GSocketControlMessage}, data::gpointer)::Cvoid
end

"""
    g_socket_control_message_deserialize(level, type, size, data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketControlMessage *g_socket_control_message_deserialize (int level, int type, gsize size, gpointer data);
```
"""
function g_socket_control_message_deserialize(level, type, size, data)
    @ccall libaravis.g_socket_control_message_deserialize(level::Cint, type::Cint, size::gsize, data::gpointer)::Ptr{GSocketControlMessage}
end

"""
    g_socket_listener_new()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketListener * g_socket_listener_new (void);
```
"""
function g_socket_listener_new()
    @ccall libaravis.g_socket_listener_new()::Ptr{GSocketListener}
end

"""
    g_socket_listener_set_backlog(listener, listen_backlog)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_socket_listener_set_backlog (GSocketListener *listener, int listen_backlog);
```
"""
function g_socket_listener_set_backlog(listener, listen_backlog)
    @ccall libaravis.g_socket_listener_set_backlog(listener::Ptr{GSocketListener}, listen_backlog::Cint)::Cvoid
end

"""
    g_socket_listener_add_socket(listener, socket, source_object, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_socket_listener_add_socket (GSocketListener *listener, GSocket *socket, GObject *source_object, GError **error);
```
"""
function g_socket_listener_add_socket(listener, socket, source_object, error)
    @ccall libaravis.g_socket_listener_add_socket(listener::Ptr{GSocketListener}, socket::Ptr{GSocket}, source_object::Ptr{GObject}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_socket_listener_add_address(listener, address, type, protocol, source_object, effective_address, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_socket_listener_add_address (GSocketListener *listener, GSocketAddress *address, GSocketType type, GSocketProtocol protocol, GObject *source_object, GSocketAddress **effective_address, GError **error);
```
"""
function g_socket_listener_add_address(listener, address, type, protocol, source_object, effective_address, error)
    @ccall libaravis.g_socket_listener_add_address(listener::Ptr{GSocketListener}, address::Ptr{GSocketAddress}, type::GSocketType, protocol::GSocketProtocol, source_object::Ptr{GObject}, effective_address::Ptr{Ptr{GSocketAddress}}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_socket_listener_add_inet_port(listener, port, source_object, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_socket_listener_add_inet_port (GSocketListener *listener, guint16 port, GObject *source_object, GError **error);
```
"""
function g_socket_listener_add_inet_port(listener, port, source_object, error)
    @ccall libaravis.g_socket_listener_add_inet_port(listener::Ptr{GSocketListener}, port::guint16, source_object::Ptr{GObject}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_socket_listener_add_any_inet_port(listener, source_object, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint16 g_socket_listener_add_any_inet_port (GSocketListener *listener, GObject *source_object, GError **error);
```
"""
function g_socket_listener_add_any_inet_port(listener, source_object, error)
    @ccall libaravis.g_socket_listener_add_any_inet_port(listener::Ptr{GSocketListener}, source_object::Ptr{GObject}, error::Ptr{Ptr{GError}})::guint16
end

"""
    g_socket_listener_accept_socket(listener, source_object, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocket * g_socket_listener_accept_socket (GSocketListener *listener, GObject **source_object, GCancellable *cancellable, GError **error);
```
"""
function g_socket_listener_accept_socket(listener, source_object, cancellable, error)
    @ccall libaravis.g_socket_listener_accept_socket(listener::Ptr{GSocketListener}, source_object::Ptr{Ptr{GObject}}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GSocket}
end

"""
    g_socket_listener_accept_socket_async(listener, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_socket_listener_accept_socket_async (GSocketListener *listener, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_socket_listener_accept_socket_async(listener, cancellable, callback, user_data)
    @ccall libaravis.g_socket_listener_accept_socket_async(listener::Ptr{GSocketListener}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_socket_listener_accept_socket_finish(listener, result, source_object, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocket * g_socket_listener_accept_socket_finish (GSocketListener *listener, GAsyncResult *result, GObject **source_object, GError **error);
```
"""
function g_socket_listener_accept_socket_finish(listener, result, source_object, error)
    @ccall libaravis.g_socket_listener_accept_socket_finish(listener::Ptr{GSocketListener}, result::Ptr{GAsyncResult}, source_object::Ptr{Ptr{GObject}}, error::Ptr{Ptr{GError}})::Ptr{GSocket}
end

"""
    g_socket_listener_accept(listener, source_object, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketConnection * g_socket_listener_accept (GSocketListener *listener, GObject **source_object, GCancellable *cancellable, GError **error);
```
"""
function g_socket_listener_accept(listener, source_object, cancellable, error)
    @ccall libaravis.g_socket_listener_accept(listener::Ptr{GSocketListener}, source_object::Ptr{Ptr{GObject}}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GSocketConnection}
end

"""
    g_socket_listener_accept_async(listener, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_socket_listener_accept_async (GSocketListener *listener, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_socket_listener_accept_async(listener, cancellable, callback, user_data)
    @ccall libaravis.g_socket_listener_accept_async(listener::Ptr{GSocketListener}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_socket_listener_accept_finish(listener, result, source_object, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketConnection * g_socket_listener_accept_finish (GSocketListener *listener, GAsyncResult *result, GObject **source_object, GError **error);
```
"""
function g_socket_listener_accept_finish(listener, result, source_object, error)
    @ccall libaravis.g_socket_listener_accept_finish(listener::Ptr{GSocketListener}, result::Ptr{GAsyncResult}, source_object::Ptr{Ptr{GObject}}, error::Ptr{Ptr{GError}})::Ptr{GSocketConnection}
end

"""
    g_socket_listener_close(listener)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_socket_listener_close (GSocketListener *listener);
```
"""
function g_socket_listener_close(listener)
    @ccall libaravis.g_socket_listener_close(listener::Ptr{GSocketListener})::Cvoid
end

"""
    g_socket_service_new()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketService *g_socket_service_new (void);
```
"""
function g_socket_service_new()
    @ccall libaravis.g_socket_service_new()::Ptr{GSocketService}
end

"""
    g_socket_service_start(service)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_socket_service_start (GSocketService *service);
```
"""
function g_socket_service_start(service)
    @ccall libaravis.g_socket_service_start(service::Ptr{GSocketService})::Cvoid
end

"""
    g_socket_service_stop(service)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_socket_service_stop (GSocketService *service);
```
"""
function g_socket_service_stop(service)
    @ccall libaravis.g_socket_service_stop(service::Ptr{GSocketService})::Cvoid
end

"""
    g_socket_service_is_active(service)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_socket_service_is_active (GSocketService *service);
```
"""
function g_socket_service_is_active(service)
    @ccall libaravis.g_socket_service_is_active(service::Ptr{GSocketService})::gboolean
end

"""
    g_srv_target_new(hostname, port, priority, weight)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSrvTarget *g_srv_target_new (const gchar *hostname, guint16 port, guint16 priority, guint16 weight);
```
"""
function g_srv_target_new(hostname, port, priority, weight)
    @ccall libaravis.g_srv_target_new(hostname::Ptr{gchar}, port::guint16, priority::guint16, weight::guint16)::Ptr{GSrvTarget}
end

"""
    g_srv_target_copy(target)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSrvTarget *g_srv_target_copy (GSrvTarget *target);
```
"""
function g_srv_target_copy(target)
    @ccall libaravis.g_srv_target_copy(target::Ptr{GSrvTarget})::Ptr{GSrvTarget}
end

"""
    g_srv_target_free(target)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_srv_target_free (GSrvTarget *target);
```
"""
function g_srv_target_free(target)
    @ccall libaravis.g_srv_target_free(target::Ptr{GSrvTarget})::Cvoid
end

"""
    g_srv_target_get_hostname(target)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar *g_srv_target_get_hostname (GSrvTarget *target);
```
"""
function g_srv_target_get_hostname(target)
    @ccall libaravis.g_srv_target_get_hostname(target::Ptr{GSrvTarget})::Ptr{gchar}
end

"""
    g_srv_target_get_port(target)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint16 g_srv_target_get_port (GSrvTarget *target);
```
"""
function g_srv_target_get_port(target)
    @ccall libaravis.g_srv_target_get_port(target::Ptr{GSrvTarget})::guint16
end

"""
    g_srv_target_get_priority(target)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint16 g_srv_target_get_priority (GSrvTarget *target);
```
"""
function g_srv_target_get_priority(target)
    @ccall libaravis.g_srv_target_get_priority(target::Ptr{GSrvTarget})::guint16
end

"""
    g_srv_target_get_weight(target)

### Prototype
```c
GIO_AVAILABLE_IN_ALL guint16 g_srv_target_get_weight (GSrvTarget *target);
```
"""
function g_srv_target_get_weight(target)
    @ccall libaravis.g_srv_target_get_weight(target::Ptr{GSrvTarget})::guint16
end

"""
    g_srv_target_list_sort(targets)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GList *g_srv_target_list_sort (GList *targets);
```
"""
function g_srv_target_list_sort(targets)
    @ccall libaravis.g_srv_target_list_sort(targets::Ptr{GList})::Ptr{GList}
end

"""
    g_subprocess_newv(argv, flags, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 GSubprocess * g_subprocess_newv (const gchar * const *argv, GSubprocessFlags flags, GError **error);
```
"""
function g_subprocess_newv(argv, flags, error)
    @ccall libaravis.g_subprocess_newv(argv::Ptr{Ptr{gchar}}, flags::GSubprocessFlags, error::Ptr{Ptr{GError}})::Ptr{GSubprocess}
end

"""
    g_subprocess_get_stdin_pipe(subprocess)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 GOutputStream * g_subprocess_get_stdin_pipe (GSubprocess *subprocess);
```
"""
function g_subprocess_get_stdin_pipe(subprocess)
    @ccall libaravis.g_subprocess_get_stdin_pipe(subprocess::Ptr{GSubprocess})::Ptr{GOutputStream}
end

"""
    g_subprocess_get_stdout_pipe(subprocess)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 GInputStream * g_subprocess_get_stdout_pipe (GSubprocess *subprocess);
```
"""
function g_subprocess_get_stdout_pipe(subprocess)
    @ccall libaravis.g_subprocess_get_stdout_pipe(subprocess::Ptr{GSubprocess})::Ptr{GInputStream}
end

"""
    g_subprocess_get_stderr_pipe(subprocess)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 GInputStream * g_subprocess_get_stderr_pipe (GSubprocess *subprocess);
```
"""
function g_subprocess_get_stderr_pipe(subprocess)
    @ccall libaravis.g_subprocess_get_stderr_pipe(subprocess::Ptr{GSubprocess})::Ptr{GInputStream}
end

"""
    g_subprocess_get_identifier(subprocess)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 const gchar * g_subprocess_get_identifier (GSubprocess *subprocess);
```
"""
function g_subprocess_get_identifier(subprocess)
    @ccall libaravis.g_subprocess_get_identifier(subprocess::Ptr{GSubprocess})::Ptr{gchar}
end

"""
    g_subprocess_send_signal(subprocess, signal_num)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_subprocess_send_signal (GSubprocess *subprocess, gint signal_num);
```
"""
function g_subprocess_send_signal(subprocess, signal_num)
    @ccall libaravis.g_subprocess_send_signal(subprocess::Ptr{GSubprocess}, signal_num::gint)::Cvoid
end

"""
    g_subprocess_force_exit(subprocess)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_subprocess_force_exit (GSubprocess *subprocess);
```
"""
function g_subprocess_force_exit(subprocess)
    @ccall libaravis.g_subprocess_force_exit(subprocess::Ptr{GSubprocess})::Cvoid
end

"""
    g_subprocess_wait(subprocess, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 gboolean g_subprocess_wait (GSubprocess *subprocess, GCancellable *cancellable, GError **error);
```
"""
function g_subprocess_wait(subprocess, cancellable, error)
    @ccall libaravis.g_subprocess_wait(subprocess::Ptr{GSubprocess}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_subprocess_wait_async(subprocess, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_subprocess_wait_async (GSubprocess *subprocess, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_subprocess_wait_async(subprocess, cancellable, callback, user_data)
    @ccall libaravis.g_subprocess_wait_async(subprocess::Ptr{GSubprocess}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_subprocess_wait_finish(subprocess, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 gboolean g_subprocess_wait_finish (GSubprocess *subprocess, GAsyncResult *result, GError **error);
```
"""
function g_subprocess_wait_finish(subprocess, result, error)
    @ccall libaravis.g_subprocess_wait_finish(subprocess::Ptr{GSubprocess}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_subprocess_wait_check(subprocess, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 gboolean g_subprocess_wait_check (GSubprocess *subprocess, GCancellable *cancellable, GError **error);
```
"""
function g_subprocess_wait_check(subprocess, cancellable, error)
    @ccall libaravis.g_subprocess_wait_check(subprocess::Ptr{GSubprocess}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_subprocess_wait_check_async(subprocess, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_subprocess_wait_check_async (GSubprocess *subprocess, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_subprocess_wait_check_async(subprocess, cancellable, callback, user_data)
    @ccall libaravis.g_subprocess_wait_check_async(subprocess::Ptr{GSubprocess}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_subprocess_wait_check_finish(subprocess, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 gboolean g_subprocess_wait_check_finish (GSubprocess *subprocess, GAsyncResult *result, GError **error);
```
"""
function g_subprocess_wait_check_finish(subprocess, result, error)
    @ccall libaravis.g_subprocess_wait_check_finish(subprocess::Ptr{GSubprocess}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_subprocess_get_status(subprocess)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 gint g_subprocess_get_status (GSubprocess *subprocess);
```
"""
function g_subprocess_get_status(subprocess)
    @ccall libaravis.g_subprocess_get_status(subprocess::Ptr{GSubprocess})::gint
end

"""
    g_subprocess_get_successful(subprocess)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 gboolean g_subprocess_get_successful (GSubprocess *subprocess);
```
"""
function g_subprocess_get_successful(subprocess)
    @ccall libaravis.g_subprocess_get_successful(subprocess::Ptr{GSubprocess})::gboolean
end

"""
    g_subprocess_get_if_exited(subprocess)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 gboolean g_subprocess_get_if_exited (GSubprocess *subprocess);
```
"""
function g_subprocess_get_if_exited(subprocess)
    @ccall libaravis.g_subprocess_get_if_exited(subprocess::Ptr{GSubprocess})::gboolean
end

"""
    g_subprocess_get_exit_status(subprocess)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 gint g_subprocess_get_exit_status (GSubprocess *subprocess);
```
"""
function g_subprocess_get_exit_status(subprocess)
    @ccall libaravis.g_subprocess_get_exit_status(subprocess::Ptr{GSubprocess})::gint
end

"""
    g_subprocess_get_if_signaled(subprocess)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 gboolean g_subprocess_get_if_signaled (GSubprocess *subprocess);
```
"""
function g_subprocess_get_if_signaled(subprocess)
    @ccall libaravis.g_subprocess_get_if_signaled(subprocess::Ptr{GSubprocess})::gboolean
end

"""
    g_subprocess_get_term_sig(subprocess)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 gint g_subprocess_get_term_sig (GSubprocess *subprocess);
```
"""
function g_subprocess_get_term_sig(subprocess)
    @ccall libaravis.g_subprocess_get_term_sig(subprocess::Ptr{GSubprocess})::gint
end

"""
    g_subprocess_communicate(subprocess, stdin_buf, cancellable, stdout_buf, stderr_buf, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 gboolean g_subprocess_communicate (GSubprocess *subprocess, GBytes *stdin_buf, GCancellable *cancellable, GBytes **stdout_buf, GBytes **stderr_buf, GError **error);
```
"""
function g_subprocess_communicate(subprocess, stdin_buf, cancellable, stdout_buf, stderr_buf, error)
    @ccall libaravis.g_subprocess_communicate(subprocess::Ptr{GSubprocess}, stdin_buf::Ptr{GBytes}, cancellable::Ptr{GCancellable}, stdout_buf::Ptr{Ptr{GBytes}}, stderr_buf::Ptr{Ptr{GBytes}}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_subprocess_communicate_async(subprocess, stdin_buf, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_subprocess_communicate_async (GSubprocess *subprocess, GBytes *stdin_buf, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_subprocess_communicate_async(subprocess, stdin_buf, cancellable, callback, user_data)
    @ccall libaravis.g_subprocess_communicate_async(subprocess::Ptr{GSubprocess}, stdin_buf::Ptr{GBytes}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_subprocess_communicate_finish(subprocess, result, stdout_buf, stderr_buf, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 gboolean g_subprocess_communicate_finish (GSubprocess *subprocess, GAsyncResult *result, GBytes **stdout_buf, GBytes **stderr_buf, GError **error);
```
"""
function g_subprocess_communicate_finish(subprocess, result, stdout_buf, stderr_buf, error)
    @ccall libaravis.g_subprocess_communicate_finish(subprocess::Ptr{GSubprocess}, result::Ptr{GAsyncResult}, stdout_buf::Ptr{Ptr{GBytes}}, stderr_buf::Ptr{Ptr{GBytes}}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_subprocess_communicate_utf8(subprocess, stdin_buf, cancellable, stdout_buf, stderr_buf, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 gboolean g_subprocess_communicate_utf8 (GSubprocess *subprocess, const char *stdin_buf, GCancellable *cancellable, char **stdout_buf, char **stderr_buf, GError **error);
```
"""
function g_subprocess_communicate_utf8(subprocess, stdin_buf, cancellable, stdout_buf, stderr_buf, error)
    @ccall libaravis.g_subprocess_communicate_utf8(subprocess::Ptr{GSubprocess}, stdin_buf::Cstring, cancellable::Ptr{GCancellable}, stdout_buf::Ptr{Cstring}, stderr_buf::Ptr{Cstring}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_subprocess_communicate_utf8_async(subprocess, stdin_buf, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_subprocess_communicate_utf8_async (GSubprocess *subprocess, const char *stdin_buf, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_subprocess_communicate_utf8_async(subprocess, stdin_buf, cancellable, callback, user_data)
    @ccall libaravis.g_subprocess_communicate_utf8_async(subprocess::Ptr{GSubprocess}, stdin_buf::Cstring, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_subprocess_communicate_utf8_finish(subprocess, result, stdout_buf, stderr_buf, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 gboolean g_subprocess_communicate_utf8_finish (GSubprocess *subprocess, GAsyncResult *result, char **stdout_buf, char **stderr_buf, GError **error);
```
"""
function g_subprocess_communicate_utf8_finish(subprocess, result, stdout_buf, stderr_buf, error)
    @ccall libaravis.g_subprocess_communicate_utf8_finish(subprocess::Ptr{GSubprocess}, result::Ptr{GAsyncResult}, stdout_buf::Ptr{Cstring}, stderr_buf::Ptr{Cstring}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_subprocess_launcher_new(flags)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 GSubprocessLauncher * g_subprocess_launcher_new (GSubprocessFlags flags);
```
"""
function g_subprocess_launcher_new(flags)
    @ccall libaravis.g_subprocess_launcher_new(flags::GSubprocessFlags)::Ptr{GSubprocessLauncher}
end

"""
    g_subprocess_launcher_spawnv(self, argv, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 GSubprocess * g_subprocess_launcher_spawnv (GSubprocessLauncher *self, const gchar * const *argv, GError **error);
```
"""
function g_subprocess_launcher_spawnv(self, argv, error)
    @ccall libaravis.g_subprocess_launcher_spawnv(self::Ptr{GSubprocessLauncher}, argv::Ptr{Ptr{gchar}}, error::Ptr{Ptr{GError}})::Ptr{GSubprocess}
end

"""
    g_subprocess_launcher_set_environ(self, env)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_subprocess_launcher_set_environ (GSubprocessLauncher *self, gchar **env);
```
"""
function g_subprocess_launcher_set_environ(self, env)
    @ccall libaravis.g_subprocess_launcher_set_environ(self::Ptr{GSubprocessLauncher}, env::Ptr{Ptr{gchar}})::Cvoid
end

"""
    g_subprocess_launcher_setenv(self, variable, value, overwrite)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_subprocess_launcher_setenv (GSubprocessLauncher *self, const gchar *variable, const gchar *value, gboolean overwrite);
```
"""
function g_subprocess_launcher_setenv(self, variable, value, overwrite)
    @ccall libaravis.g_subprocess_launcher_setenv(self::Ptr{GSubprocessLauncher}, variable::Ptr{gchar}, value::Ptr{gchar}, overwrite::gboolean)::Cvoid
end

"""
    g_subprocess_launcher_unsetenv(self, variable)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_subprocess_launcher_unsetenv (GSubprocessLauncher *self, const gchar *variable);
```
"""
function g_subprocess_launcher_unsetenv(self, variable)
    @ccall libaravis.g_subprocess_launcher_unsetenv(self::Ptr{GSubprocessLauncher}, variable::Ptr{gchar})::Cvoid
end

"""
    g_subprocess_launcher_getenv(self, variable)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 const gchar * g_subprocess_launcher_getenv (GSubprocessLauncher *self, const gchar *variable);
```
"""
function g_subprocess_launcher_getenv(self, variable)
    @ccall libaravis.g_subprocess_launcher_getenv(self::Ptr{GSubprocessLauncher}, variable::Ptr{gchar})::Ptr{gchar}
end

"""
    g_subprocess_launcher_set_cwd(self, cwd)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_subprocess_launcher_set_cwd (GSubprocessLauncher *self, const gchar *cwd);
```
"""
function g_subprocess_launcher_set_cwd(self, cwd)
    @ccall libaravis.g_subprocess_launcher_set_cwd(self::Ptr{GSubprocessLauncher}, cwd::Ptr{gchar})::Cvoid
end

"""
    g_subprocess_launcher_set_flags(self, flags)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_subprocess_launcher_set_flags (GSubprocessLauncher *self, GSubprocessFlags flags);
```
"""
function g_subprocess_launcher_set_flags(self, flags)
    @ccall libaravis.g_subprocess_launcher_set_flags(self::Ptr{GSubprocessLauncher}, flags::GSubprocessFlags)::Cvoid
end

"""
    g_subprocess_launcher_set_stdin_file_path(self, path)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_subprocess_launcher_set_stdin_file_path (GSubprocessLauncher *self, const gchar *path);
```
"""
function g_subprocess_launcher_set_stdin_file_path(self, path)
    @ccall libaravis.g_subprocess_launcher_set_stdin_file_path(self::Ptr{GSubprocessLauncher}, path::Ptr{gchar})::Cvoid
end

"""
    g_subprocess_launcher_take_stdin_fd(self, fd)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_subprocess_launcher_take_stdin_fd (GSubprocessLauncher *self, gint fd);
```
"""
function g_subprocess_launcher_take_stdin_fd(self, fd)
    @ccall libaravis.g_subprocess_launcher_take_stdin_fd(self::Ptr{GSubprocessLauncher}, fd::gint)::Cvoid
end

"""
    g_subprocess_launcher_set_stdout_file_path(self, path)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_subprocess_launcher_set_stdout_file_path (GSubprocessLauncher *self, const gchar *path);
```
"""
function g_subprocess_launcher_set_stdout_file_path(self, path)
    @ccall libaravis.g_subprocess_launcher_set_stdout_file_path(self::Ptr{GSubprocessLauncher}, path::Ptr{gchar})::Cvoid
end

"""
    g_subprocess_launcher_take_stdout_fd(self, fd)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_subprocess_launcher_take_stdout_fd (GSubprocessLauncher *self, gint fd);
```
"""
function g_subprocess_launcher_take_stdout_fd(self, fd)
    @ccall libaravis.g_subprocess_launcher_take_stdout_fd(self::Ptr{GSubprocessLauncher}, fd::gint)::Cvoid
end

"""
    g_subprocess_launcher_set_stderr_file_path(self, path)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_subprocess_launcher_set_stderr_file_path (GSubprocessLauncher *self, const gchar *path);
```
"""
function g_subprocess_launcher_set_stderr_file_path(self, path)
    @ccall libaravis.g_subprocess_launcher_set_stderr_file_path(self::Ptr{GSubprocessLauncher}, path::Ptr{gchar})::Cvoid
end

"""
    g_subprocess_launcher_take_stderr_fd(self, fd)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_subprocess_launcher_take_stderr_fd (GSubprocessLauncher *self, gint fd);
```
"""
function g_subprocess_launcher_take_stderr_fd(self, fd)
    @ccall libaravis.g_subprocess_launcher_take_stderr_fd(self::Ptr{GSubprocessLauncher}, fd::gint)::Cvoid
end

"""
    g_subprocess_launcher_take_fd(self, source_fd, target_fd)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_subprocess_launcher_take_fd (GSubprocessLauncher *self, gint source_fd, gint target_fd);
```
"""
function g_subprocess_launcher_take_fd(self, source_fd, target_fd)
    @ccall libaravis.g_subprocess_launcher_take_fd(self::Ptr{GSubprocessLauncher}, source_fd::gint, target_fd::gint)::Cvoid
end

"""
    g_subprocess_launcher_close(self)

### Prototype
```c
GIO_AVAILABLE_IN_2_68 void g_subprocess_launcher_close (GSubprocessLauncher *self);
```
"""
function g_subprocess_launcher_close(self)
    @ccall libaravis.g_subprocess_launcher_close(self::Ptr{GSubprocessLauncher})::Cvoid
end

"""
    g_subprocess_launcher_set_child_setup(self, child_setup, user_data, destroy_notify)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_subprocess_launcher_set_child_setup (GSubprocessLauncher *self, GSpawnChildSetupFunc child_setup, gpointer user_data, GDestroyNotify destroy_notify);
```
"""
function g_subprocess_launcher_set_child_setup(self, child_setup, user_data, destroy_notify)
    @ccall libaravis.g_subprocess_launcher_set_child_setup(self::Ptr{GSubprocessLauncher}, child_setup::GSpawnChildSetupFunc, user_data::gpointer, destroy_notify::GDestroyNotify)::Cvoid
end

"""
    g_task_new(source_object, cancellable, callback, callback_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 GTask *g_task_new (gpointer source_object, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer callback_data);
```
"""
function g_task_new(source_object, cancellable, callback, callback_data)
    @ccall libaravis.g_task_new(source_object::gpointer, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, callback_data::gpointer)::Ptr{GTask}
end

"""
    g_task_report_error(source_object, callback, callback_data, source_tag, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 void g_task_report_error (gpointer source_object, GAsyncReadyCallback callback, gpointer callback_data, gpointer source_tag, GError *error);
```
"""
function g_task_report_error(source_object, callback, callback_data, source_tag, error)
    @ccall libaravis.g_task_report_error(source_object::gpointer, callback::GAsyncReadyCallback, callback_data::gpointer, source_tag::gpointer, error::Ptr{GError})::Cvoid
end

"""
    g_task_set_task_data(task, task_data, task_data_destroy)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 void g_task_set_task_data (GTask *task, gpointer task_data, GDestroyNotify task_data_destroy);
```
"""
function g_task_set_task_data(task, task_data, task_data_destroy)
    @ccall libaravis.g_task_set_task_data(task::Ptr{GTask}, task_data::gpointer, task_data_destroy::GDestroyNotify)::Cvoid
end

"""
    g_task_set_priority(task, priority)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 void g_task_set_priority (GTask *task, gint priority);
```
"""
function g_task_set_priority(task, priority)
    @ccall libaravis.g_task_set_priority(task::Ptr{GTask}, priority::gint)::Cvoid
end

"""
    g_task_set_check_cancellable(task, check_cancellable)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 void g_task_set_check_cancellable (GTask *task, gboolean check_cancellable);
```
"""
function g_task_set_check_cancellable(task, check_cancellable)
    @ccall libaravis.g_task_set_check_cancellable(task::Ptr{GTask}, check_cancellable::gboolean)::Cvoid
end

"""
    g_task_get_source_object(task)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 gpointer g_task_get_source_object (GTask *task);
```
"""
function g_task_get_source_object(task)
    @ccall libaravis.g_task_get_source_object(task::Ptr{GTask})::gpointer
end

"""
    g_task_get_task_data(task)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 gpointer g_task_get_task_data (GTask *task);
```
"""
function g_task_get_task_data(task)
    @ccall libaravis.g_task_get_task_data(task::Ptr{GTask})::gpointer
end

"""
    g_task_get_priority(task)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 gint g_task_get_priority (GTask *task);
```
"""
function g_task_get_priority(task)
    @ccall libaravis.g_task_get_priority(task::Ptr{GTask})::gint
end

"""
    g_task_get_context(task)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 GMainContext *g_task_get_context (GTask *task);
```
"""
function g_task_get_context(task)
    @ccall libaravis.g_task_get_context(task::Ptr{GTask})::Ptr{GMainContext}
end

"""
    g_task_get_cancellable(task)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 GCancellable *g_task_get_cancellable (GTask *task);
```
"""
function g_task_get_cancellable(task)
    @ccall libaravis.g_task_get_cancellable(task::Ptr{GTask})::Ptr{GCancellable}
end

"""
    g_task_get_check_cancellable(task)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 gboolean g_task_get_check_cancellable (GTask *task);
```
"""
function g_task_get_check_cancellable(task)
    @ccall libaravis.g_task_get_check_cancellable(task::Ptr{GTask})::gboolean
end

"""
    g_task_get_source_tag(task)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 gpointer g_task_get_source_tag (GTask *task);
```
"""
function g_task_get_source_tag(task)
    @ccall libaravis.g_task_get_source_tag(task::Ptr{GTask})::gpointer
end

"""
    g_task_is_valid(result, source_object)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 gboolean g_task_is_valid (gpointer result, gpointer source_object);
```
"""
function g_task_is_valid(result, source_object)
    @ccall libaravis.g_task_is_valid(result::gpointer, source_object::gpointer)::gboolean
end

# typedef void ( * GTaskThreadFunc ) ( GTask * task , gpointer source_object , gpointer task_data , GCancellable * cancellable )
const GTaskThreadFunc = Ptr{Cvoid}

"""
    g_task_run_in_thread(task, task_func)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 void g_task_run_in_thread (GTask *task, GTaskThreadFunc task_func);
```
"""
function g_task_run_in_thread(task, task_func)
    @ccall libaravis.g_task_run_in_thread(task::Ptr{GTask}, task_func::GTaskThreadFunc)::Cvoid
end

"""
    g_task_run_in_thread_sync(task, task_func)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 void g_task_run_in_thread_sync (GTask *task, GTaskThreadFunc task_func);
```
"""
function g_task_run_in_thread_sync(task, task_func)
    @ccall libaravis.g_task_run_in_thread_sync(task::Ptr{GTask}, task_func::GTaskThreadFunc)::Cvoid
end

"""
    g_task_set_return_on_cancel(task, return_on_cancel)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 gboolean g_task_set_return_on_cancel (GTask *task, gboolean return_on_cancel);
```
"""
function g_task_set_return_on_cancel(task, return_on_cancel)
    @ccall libaravis.g_task_set_return_on_cancel(task::Ptr{GTask}, return_on_cancel::gboolean)::gboolean
end

"""
    g_task_get_return_on_cancel(task)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 gboolean g_task_get_return_on_cancel (GTask *task);
```
"""
function g_task_get_return_on_cancel(task)
    @ccall libaravis.g_task_get_return_on_cancel(task::Ptr{GTask})::gboolean
end

"""
    g_task_attach_source(task, source, callback)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 void g_task_attach_source (GTask *task, GSource *source, GSourceFunc callback);
```
"""
function g_task_attach_source(task, source, callback)
    @ccall libaravis.g_task_attach_source(task::Ptr{GTask}, source::Ptr{GSource}, callback::GSourceFunc)::Cvoid
end

"""
    g_task_return_pointer(task, result, result_destroy)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 void g_task_return_pointer (GTask *task, gpointer result, GDestroyNotify result_destroy);
```
"""
function g_task_return_pointer(task, result, result_destroy)
    @ccall libaravis.g_task_return_pointer(task::Ptr{GTask}, result::gpointer, result_destroy::GDestroyNotify)::Cvoid
end

"""
    g_task_return_boolean(task, result)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 void g_task_return_boolean (GTask *task, gboolean result);
```
"""
function g_task_return_boolean(task, result)
    @ccall libaravis.g_task_return_boolean(task::Ptr{GTask}, result::gboolean)::Cvoid
end

"""
    g_task_return_int(task, result)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 void g_task_return_int (GTask *task, gssize result);
```
"""
function g_task_return_int(task, result)
    @ccall libaravis.g_task_return_int(task::Ptr{GTask}, result::gssize)::Cvoid
end

"""
    g_task_return_error(task, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 void g_task_return_error (GTask *task, GError *error);
```
"""
function g_task_return_error(task, error)
    @ccall libaravis.g_task_return_error(task::Ptr{GTask}, error::Ptr{GError})::Cvoid
end

"""
    g_task_return_new_error_literal(task, domain, code, message)

### Prototype
```c
GIO_AVAILABLE_IN_2_80 void g_task_return_new_error_literal (GTask *task, GQuark domain, gint code, const char *message);
```
"""
function g_task_return_new_error_literal(task, domain, code, message)
    @ccall libaravis.g_task_return_new_error_literal(task::Ptr{GTask}, domain::GQuark, code::gint, message::Cstring)::Cvoid
end

"""
    g_task_return_value(task, result)

### Prototype
```c
GIO_AVAILABLE_IN_2_64 void g_task_return_value (GTask *task, GValue *result);
```
"""
function g_task_return_value(task, result)
    @ccall libaravis.g_task_return_value(task::Ptr{GTask}, result::Ptr{GValue})::Cvoid
end

"""
    g_task_return_error_if_cancelled(task)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 gboolean g_task_return_error_if_cancelled (GTask *task);
```
"""
function g_task_return_error_if_cancelled(task)
    @ccall libaravis.g_task_return_error_if_cancelled(task::Ptr{GTask})::gboolean
end

"""
    g_task_propagate_pointer(task, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 gpointer g_task_propagate_pointer (GTask *task, GError **error);
```
"""
function g_task_propagate_pointer(task, error)
    @ccall libaravis.g_task_propagate_pointer(task::Ptr{GTask}, error::Ptr{Ptr{GError}})::gpointer
end

"""
    g_task_propagate_boolean(task, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 gboolean g_task_propagate_boolean (GTask *task, GError **error);
```
"""
function g_task_propagate_boolean(task, error)
    @ccall libaravis.g_task_propagate_boolean(task::Ptr{GTask}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_task_propagate_int(task, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 gssize g_task_propagate_int (GTask *task, GError **error);
```
"""
function g_task_propagate_int(task, error)
    @ccall libaravis.g_task_propagate_int(task::Ptr{GTask}, error::Ptr{Ptr{GError}})::gssize
end

"""
    g_task_propagate_value(task, value, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_64 gboolean g_task_propagate_value (GTask *task, GValue *value, GError **error);
```
"""
function g_task_propagate_value(task, value, error)
    @ccall libaravis.g_task_propagate_value(task::Ptr{GTask}, value::Ptr{GValue}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_task_had_error(task)

### Prototype
```c
GIO_AVAILABLE_IN_2_36 gboolean g_task_had_error (GTask *task);
```
"""
function g_task_had_error(task)
    @ccall libaravis.g_task_had_error(task::Ptr{GTask})::gboolean
end

"""
    g_task_get_completed(task)

### Prototype
```c
GIO_AVAILABLE_IN_2_44 gboolean g_task_get_completed (GTask *task);
```
"""
function g_task_get_completed(task)
    @ccall libaravis.g_task_get_completed(task::Ptr{GTask})::gboolean
end

"""
    g_task_print_alive_tasks()

### Prototype
```c
void g_task_print_alive_tasks (void);
```
"""
function g_task_print_alive_tasks()
    @ccall libaravis.g_task_print_alive_tasks()::Cvoid
end

"""
    g_tcp_connection_set_graceful_disconnect(connection, graceful_disconnect)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_tcp_connection_set_graceful_disconnect (GTcpConnection *connection, gboolean graceful_disconnect);
```
"""
function g_tcp_connection_set_graceful_disconnect(connection, graceful_disconnect)
    @ccall libaravis.g_tcp_connection_set_graceful_disconnect(connection::Ptr{GTcpConnection}, graceful_disconnect::gboolean)::Cvoid
end

"""
    g_tcp_connection_get_graceful_disconnect(connection)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_tcp_connection_get_graceful_disconnect (GTcpConnection *connection);
```
"""
function g_tcp_connection_get_graceful_disconnect(connection)
    @ccall libaravis.g_tcp_connection_get_graceful_disconnect(connection::Ptr{GTcpConnection})::gboolean
end

"""
    g_tcp_wrapper_connection_new(base_io_stream, socket)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketConnection *g_tcp_wrapper_connection_new (GIOStream *base_io_stream, GSocket *socket);
```
"""
function g_tcp_wrapper_connection_new(base_io_stream, socket)
    @ccall libaravis.g_tcp_wrapper_connection_new(base_io_stream::Ptr{GIOStream}, socket::Ptr{GSocket})::Ptr{GSocketConnection}
end

"""
    g_tcp_wrapper_connection_get_base_io_stream(conn)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIOStream *g_tcp_wrapper_connection_get_base_io_stream (GTcpWrapperConnection *conn);
```
"""
function g_tcp_wrapper_connection_get_base_io_stream(conn)
    @ccall libaravis.g_tcp_wrapper_connection_get_base_io_stream(conn::Ptr{GTcpWrapperConnection})::Ptr{GIOStream}
end

"""
    g_test_dbus_new(flags)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 GTestDBus * g_test_dbus_new (GTestDBusFlags flags);
```
"""
function g_test_dbus_new(flags)
    @ccall libaravis.g_test_dbus_new(flags::GTestDBusFlags)::Ptr{GTestDBus}
end

"""
    g_test_dbus_get_flags(self)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 GTestDBusFlags g_test_dbus_get_flags (GTestDBus *self);
```
"""
function g_test_dbus_get_flags(self)
    @ccall libaravis.g_test_dbus_get_flags(self::Ptr{GTestDBus})::GTestDBusFlags
end

"""
    g_test_dbus_get_bus_address(self)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 const gchar * g_test_dbus_get_bus_address (GTestDBus *self);
```
"""
function g_test_dbus_get_bus_address(self)
    @ccall libaravis.g_test_dbus_get_bus_address(self::Ptr{GTestDBus})::Ptr{gchar}
end

"""
    g_test_dbus_add_service_dir(self, path)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 void g_test_dbus_add_service_dir (GTestDBus *self, const gchar *path);
```
"""
function g_test_dbus_add_service_dir(self, path)
    @ccall libaravis.g_test_dbus_add_service_dir(self::Ptr{GTestDBus}, path::Ptr{gchar})::Cvoid
end

"""
    g_test_dbus_up(self)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 void g_test_dbus_up (GTestDBus *self);
```
"""
function g_test_dbus_up(self)
    @ccall libaravis.g_test_dbus_up(self::Ptr{GTestDBus})::Cvoid
end

"""
    g_test_dbus_stop(self)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 void g_test_dbus_stop (GTestDBus *self);
```
"""
function g_test_dbus_stop(self)
    @ccall libaravis.g_test_dbus_stop(self::Ptr{GTestDBus})::Cvoid
end

"""
    g_test_dbus_down(self)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 void g_test_dbus_down (GTestDBus *self);
```
"""
function g_test_dbus_down(self)
    @ccall libaravis.g_test_dbus_down(self::Ptr{GTestDBus})::Cvoid
end

"""
    g_test_dbus_unset()

### Prototype
```c
GIO_AVAILABLE_IN_2_34 void g_test_dbus_unset (void);
```
"""
function g_test_dbus_unset()
    @ccall libaravis.g_test_dbus_unset()::Cvoid
end

"""
    g_themed_icon_new(iconname)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIcon *g_themed_icon_new (const char *iconname);
```
"""
function g_themed_icon_new(iconname)
    @ccall libaravis.g_themed_icon_new(iconname::Cstring)::Ptr{GIcon}
end

"""
    g_themed_icon_new_with_default_fallbacks(iconname)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIcon *g_themed_icon_new_with_default_fallbacks (const char *iconname);
```
"""
function g_themed_icon_new_with_default_fallbacks(iconname)
    @ccall libaravis.g_themed_icon_new_with_default_fallbacks(iconname::Cstring)::Ptr{GIcon}
end

"""
    g_themed_icon_new_from_names(iconnames, len)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIcon *g_themed_icon_new_from_names (char **iconnames, int len);
```
"""
function g_themed_icon_new_from_names(iconnames, len)
    @ccall libaravis.g_themed_icon_new_from_names(iconnames::Ptr{Cstring}, len::Cint)::Ptr{GIcon}
end

"""
    g_themed_icon_prepend_name(icon, iconname)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_themed_icon_prepend_name (GThemedIcon *icon, const char *iconname);
```
"""
function g_themed_icon_prepend_name(icon, iconname)
    @ccall libaravis.g_themed_icon_prepend_name(icon::Ptr{GThemedIcon}, iconname::Cstring)::Cvoid
end

"""
    g_themed_icon_append_name(icon, iconname)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_themed_icon_append_name (GThemedIcon *icon, const char *iconname);
```
"""
function g_themed_icon_append_name(icon, iconname)
    @ccall libaravis.g_themed_icon_append_name(icon::Ptr{GThemedIcon}, iconname::Cstring)::Cvoid
end

"""
    g_themed_icon_get_names(icon)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar* const * g_themed_icon_get_names (GThemedIcon *icon);
```
"""
function g_themed_icon_get_names(icon)
    @ccall libaravis.g_themed_icon_get_names(icon::Ptr{GThemedIcon})::Ptr{Ptr{gchar}}
end

"""
    g_threaded_socket_service_new(max_threads)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketService * g_threaded_socket_service_new (int max_threads);
```
"""
function g_threaded_socket_service_new(max_threads)
    @ccall libaravis.g_threaded_socket_service_new(max_threads::Cint)::Ptr{GSocketService}
end

"""
    g_tls_backend_get_default()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GTlsBackend * g_tls_backend_get_default (void);
```
"""
function g_tls_backend_get_default()
    @ccall libaravis.g_tls_backend_get_default()::Ptr{GTlsBackend}
end

"""
    g_tls_backend_get_default_database(backend)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GTlsDatabase * g_tls_backend_get_default_database (GTlsBackend *backend);
```
"""
function g_tls_backend_get_default_database(backend)
    @ccall libaravis.g_tls_backend_get_default_database(backend::Ptr{GTlsBackend})::Ptr{GTlsDatabase}
end

"""
    g_tls_backend_set_default_database(backend, database)

### Prototype
```c
GIO_AVAILABLE_IN_2_60 void g_tls_backend_set_default_database (GTlsBackend *backend, GTlsDatabase *database);
```
"""
function g_tls_backend_set_default_database(backend, database)
    @ccall libaravis.g_tls_backend_set_default_database(backend::Ptr{GTlsBackend}, database::Ptr{GTlsDatabase})::Cvoid
end

"""
    g_tls_backend_supports_tls(backend)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_tls_backend_supports_tls (GTlsBackend *backend);
```
"""
function g_tls_backend_supports_tls(backend)
    @ccall libaravis.g_tls_backend_supports_tls(backend::Ptr{GTlsBackend})::gboolean
end

"""
    g_tls_backend_supports_dtls(backend)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 gboolean g_tls_backend_supports_dtls (GTlsBackend *backend);
```
"""
function g_tls_backend_supports_dtls(backend)
    @ccall libaravis.g_tls_backend_supports_dtls(backend::Ptr{GTlsBackend})::gboolean
end

"""
    g_tls_backend_get_certificate_type(backend)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_tls_backend_get_certificate_type (GTlsBackend *backend);
```
"""
function g_tls_backend_get_certificate_type(backend)
    @ccall libaravis.g_tls_backend_get_certificate_type(backend::Ptr{GTlsBackend})::GType
end

"""
    g_tls_backend_get_client_connection_type(backend)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_tls_backend_get_client_connection_type (GTlsBackend *backend);
```
"""
function g_tls_backend_get_client_connection_type(backend)
    @ccall libaravis.g_tls_backend_get_client_connection_type(backend::Ptr{GTlsBackend})::GType
end

"""
    g_tls_backend_get_server_connection_type(backend)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_tls_backend_get_server_connection_type (GTlsBackend *backend);
```
"""
function g_tls_backend_get_server_connection_type(backend)
    @ccall libaravis.g_tls_backend_get_server_connection_type(backend::Ptr{GTlsBackend})::GType
end

"""
    g_tls_backend_get_file_database_type(backend)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GType g_tls_backend_get_file_database_type (GTlsBackend *backend);
```
"""
function g_tls_backend_get_file_database_type(backend)
    @ccall libaravis.g_tls_backend_get_file_database_type(backend::Ptr{GTlsBackend})::GType
end

"""
    g_tls_backend_get_dtls_client_connection_type(backend)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 GType g_tls_backend_get_dtls_client_connection_type (GTlsBackend *backend);
```
"""
function g_tls_backend_get_dtls_client_connection_type(backend)
    @ccall libaravis.g_tls_backend_get_dtls_client_connection_type(backend::Ptr{GTlsBackend})::GType
end

"""
    g_tls_backend_get_dtls_server_connection_type(backend)

### Prototype
```c
GIO_AVAILABLE_IN_2_48 GType g_tls_backend_get_dtls_server_connection_type (GTlsBackend *backend);
```
"""
function g_tls_backend_get_dtls_server_connection_type(backend)
    @ccall libaravis.g_tls_backend_get_dtls_server_connection_type(backend::Ptr{GTlsBackend})::GType
end

"""
    g_tls_certificate_new_from_pem(data, length, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GTlsCertificate *g_tls_certificate_new_from_pem (const gchar *data, gssize length, GError **error);
```
"""
function g_tls_certificate_new_from_pem(data, length, error)
    @ccall libaravis.g_tls_certificate_new_from_pem(data::Ptr{gchar}, length::gssize, error::Ptr{Ptr{GError}})::Ptr{GTlsCertificate}
end

"""
    g_tls_certificate_new_from_pkcs12(data, length, password, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_72 GTlsCertificate *g_tls_certificate_new_from_pkcs12 (const guint8 *data, gsize length, const gchar *password, GError **error);
```
"""
function g_tls_certificate_new_from_pkcs12(data, length, password, error)
    @ccall libaravis.g_tls_certificate_new_from_pkcs12(data::Ptr{guint8}, length::gsize, password::Ptr{gchar}, error::Ptr{Ptr{GError}})::Ptr{GTlsCertificate}
end

"""
    g_tls_certificate_new_from_file_with_password(file, password, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_72 GTlsCertificate *g_tls_certificate_new_from_file_with_password (const gchar *file, const gchar *password, GError **error);
```
"""
function g_tls_certificate_new_from_file_with_password(file, password, error)
    @ccall libaravis.g_tls_certificate_new_from_file_with_password(file::Ptr{gchar}, password::Ptr{gchar}, error::Ptr{Ptr{GError}})::Ptr{GTlsCertificate}
end

"""
    g_tls_certificate_new_from_file(file, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GTlsCertificate *g_tls_certificate_new_from_file (const gchar *file, GError **error);
```
"""
function g_tls_certificate_new_from_file(file, error)
    @ccall libaravis.g_tls_certificate_new_from_file(file::Ptr{gchar}, error::Ptr{Ptr{GError}})::Ptr{GTlsCertificate}
end

"""
    g_tls_certificate_new_from_files(cert_file, key_file, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GTlsCertificate *g_tls_certificate_new_from_files (const gchar *cert_file, const gchar *key_file, GError **error);
```
"""
function g_tls_certificate_new_from_files(cert_file, key_file, error)
    @ccall libaravis.g_tls_certificate_new_from_files(cert_file::Ptr{gchar}, key_file::Ptr{gchar}, error::Ptr{Ptr{GError}})::Ptr{GTlsCertificate}
end

"""
    g_tls_certificate_new_from_pkcs11_uris(pkcs11_uri, private_key_pkcs11_uri, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_68 GTlsCertificate *g_tls_certificate_new_from_pkcs11_uris (const gchar *pkcs11_uri, const gchar *private_key_pkcs11_uri, GError **error);
```
"""
function g_tls_certificate_new_from_pkcs11_uris(pkcs11_uri, private_key_pkcs11_uri, error)
    @ccall libaravis.g_tls_certificate_new_from_pkcs11_uris(pkcs11_uri::Ptr{gchar}, private_key_pkcs11_uri::Ptr{gchar}, error::Ptr{Ptr{GError}})::Ptr{GTlsCertificate}
end

"""
    g_tls_certificate_list_new_from_file(file, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GList *g_tls_certificate_list_new_from_file (const gchar *file, GError **error);
```
"""
function g_tls_certificate_list_new_from_file(file, error)
    @ccall libaravis.g_tls_certificate_list_new_from_file(file::Ptr{gchar}, error::Ptr{Ptr{GError}})::Ptr{GList}
end

"""
    g_tls_certificate_get_issuer(cert)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GTlsCertificate *g_tls_certificate_get_issuer (GTlsCertificate *cert);
```
"""
function g_tls_certificate_get_issuer(cert)
    @ccall libaravis.g_tls_certificate_get_issuer(cert::Ptr{GTlsCertificate})::Ptr{GTlsCertificate}
end

"""
    g_tls_certificate_verify(cert, identity, trusted_ca)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GTlsCertificateFlags g_tls_certificate_verify (GTlsCertificate *cert, GSocketConnectable *identity, GTlsCertificate *trusted_ca);
```
"""
function g_tls_certificate_verify(cert, identity, trusted_ca)
    @ccall libaravis.g_tls_certificate_verify(cert::Ptr{GTlsCertificate}, identity::Ptr{GSocketConnectable}, trusted_ca::Ptr{GTlsCertificate})::GTlsCertificateFlags
end

"""
    g_tls_certificate_is_same(cert_one, cert_two)

### Prototype
```c
GIO_AVAILABLE_IN_2_34 gboolean g_tls_certificate_is_same (GTlsCertificate *cert_one, GTlsCertificate *cert_two);
```
"""
function g_tls_certificate_is_same(cert_one, cert_two)
    @ccall libaravis.g_tls_certificate_is_same(cert_one::Ptr{GTlsCertificate}, cert_two::Ptr{GTlsCertificate})::gboolean
end

"""
    g_tls_certificate_get_not_valid_before(cert)

### Prototype
```c
GIO_AVAILABLE_IN_2_70 GDateTime *g_tls_certificate_get_not_valid_before (GTlsCertificate *cert);
```
"""
function g_tls_certificate_get_not_valid_before(cert)
    @ccall libaravis.g_tls_certificate_get_not_valid_before(cert::Ptr{GTlsCertificate})::Ptr{GDateTime}
end

"""
    g_tls_certificate_get_not_valid_after(cert)

### Prototype
```c
GIO_AVAILABLE_IN_2_70 GDateTime *g_tls_certificate_get_not_valid_after (GTlsCertificate *cert);
```
"""
function g_tls_certificate_get_not_valid_after(cert)
    @ccall libaravis.g_tls_certificate_get_not_valid_after(cert::Ptr{GTlsCertificate})::Ptr{GDateTime}
end

"""
    g_tls_certificate_get_subject_name(cert)

### Prototype
```c
GIO_AVAILABLE_IN_2_70 gchar *g_tls_certificate_get_subject_name (GTlsCertificate *cert);
```
"""
function g_tls_certificate_get_subject_name(cert)
    @ccall libaravis.g_tls_certificate_get_subject_name(cert::Ptr{GTlsCertificate})::Ptr{gchar}
end

"""
    g_tls_certificate_get_issuer_name(cert)

### Prototype
```c
GIO_AVAILABLE_IN_2_70 gchar *g_tls_certificate_get_issuer_name (GTlsCertificate *cert);
```
"""
function g_tls_certificate_get_issuer_name(cert)
    @ccall libaravis.g_tls_certificate_get_issuer_name(cert::Ptr{GTlsCertificate})::Ptr{gchar}
end

"""
    g_tls_certificate_get_dns_names(cert)

### Prototype
```c
GIO_AVAILABLE_IN_2_70 GPtrArray *g_tls_certificate_get_dns_names (GTlsCertificate *cert);
```
"""
function g_tls_certificate_get_dns_names(cert)
    @ccall libaravis.g_tls_certificate_get_dns_names(cert::Ptr{GTlsCertificate})::Ptr{GPtrArray}
end

"""
    g_tls_certificate_get_ip_addresses(cert)

### Prototype
```c
GIO_AVAILABLE_IN_2_70 GPtrArray *g_tls_certificate_get_ip_addresses (GTlsCertificate *cert);
```
"""
function g_tls_certificate_get_ip_addresses(cert)
    @ccall libaravis.g_tls_certificate_get_ip_addresses(cert::Ptr{GTlsCertificate})::Ptr{GPtrArray}
end

"""
    g_tls_connection_set_use_system_certdb(conn, use_system_certdb)

### Prototype
```c
GIO_DEPRECATED void g_tls_connection_set_use_system_certdb (GTlsConnection *conn, gboolean use_system_certdb);
```
"""
function g_tls_connection_set_use_system_certdb(conn, use_system_certdb)
    @ccall libaravis.g_tls_connection_set_use_system_certdb(conn::Ptr{GTlsConnection}, use_system_certdb::gboolean)::Cvoid
end

"""
    g_tls_connection_get_use_system_certdb(conn)

### Prototype
```c
GIO_DEPRECATED gboolean g_tls_connection_get_use_system_certdb (GTlsConnection *conn);
```
"""
function g_tls_connection_get_use_system_certdb(conn)
    @ccall libaravis.g_tls_connection_get_use_system_certdb(conn::Ptr{GTlsConnection})::gboolean
end

"""
    g_tls_connection_set_database(conn, database)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_tls_connection_set_database (GTlsConnection *conn, GTlsDatabase *database);
```
"""
function g_tls_connection_set_database(conn, database)
    @ccall libaravis.g_tls_connection_set_database(conn::Ptr{GTlsConnection}, database::Ptr{GTlsDatabase})::Cvoid
end

"""
    g_tls_connection_get_database(conn)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GTlsDatabase * g_tls_connection_get_database (GTlsConnection *conn);
```
"""
function g_tls_connection_get_database(conn)
    @ccall libaravis.g_tls_connection_get_database(conn::Ptr{GTlsConnection})::Ptr{GTlsDatabase}
end

"""
    g_tls_connection_set_certificate(conn, certificate)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_tls_connection_set_certificate (GTlsConnection *conn, GTlsCertificate *certificate);
```
"""
function g_tls_connection_set_certificate(conn, certificate)
    @ccall libaravis.g_tls_connection_set_certificate(conn::Ptr{GTlsConnection}, certificate::Ptr{GTlsCertificate})::Cvoid
end

"""
    g_tls_connection_get_certificate(conn)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GTlsCertificate *g_tls_connection_get_certificate (GTlsConnection *conn);
```
"""
function g_tls_connection_get_certificate(conn)
    @ccall libaravis.g_tls_connection_get_certificate(conn::Ptr{GTlsConnection})::Ptr{GTlsCertificate}
end

"""
    g_tls_connection_set_interaction(conn, interaction)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_tls_connection_set_interaction (GTlsConnection *conn, GTlsInteraction *interaction);
```
"""
function g_tls_connection_set_interaction(conn, interaction)
    @ccall libaravis.g_tls_connection_set_interaction(conn::Ptr{GTlsConnection}, interaction::Ptr{GTlsInteraction})::Cvoid
end

"""
    g_tls_connection_get_interaction(conn)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GTlsInteraction * g_tls_connection_get_interaction (GTlsConnection *conn);
```
"""
function g_tls_connection_get_interaction(conn)
    @ccall libaravis.g_tls_connection_get_interaction(conn::Ptr{GTlsConnection})::Ptr{GTlsInteraction}
end

"""
    g_tls_connection_get_peer_certificate(conn)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GTlsCertificate *g_tls_connection_get_peer_certificate (GTlsConnection *conn);
```
"""
function g_tls_connection_get_peer_certificate(conn)
    @ccall libaravis.g_tls_connection_get_peer_certificate(conn::Ptr{GTlsConnection})::Ptr{GTlsCertificate}
end

"""
    g_tls_connection_get_peer_certificate_errors(conn)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GTlsCertificateFlags g_tls_connection_get_peer_certificate_errors (GTlsConnection *conn);
```
"""
function g_tls_connection_get_peer_certificate_errors(conn)
    @ccall libaravis.g_tls_connection_get_peer_certificate_errors(conn::Ptr{GTlsConnection})::GTlsCertificateFlags
end

"""
    g_tls_connection_set_require_close_notify(conn, require_close_notify)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_tls_connection_set_require_close_notify (GTlsConnection *conn, gboolean require_close_notify);
```
"""
function g_tls_connection_set_require_close_notify(conn, require_close_notify)
    @ccall libaravis.g_tls_connection_set_require_close_notify(conn::Ptr{GTlsConnection}, require_close_notify::gboolean)::Cvoid
end

"""
    g_tls_connection_get_require_close_notify(conn)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_tls_connection_get_require_close_notify (GTlsConnection *conn);
```
"""
function g_tls_connection_get_require_close_notify(conn)
    @ccall libaravis.g_tls_connection_get_require_close_notify(conn::Ptr{GTlsConnection})::gboolean
end

"""
    g_tls_connection_set_rehandshake_mode(conn, mode)

### Prototype
```c
GIO_DEPRECATED_IN_2_60 void g_tls_connection_set_rehandshake_mode (GTlsConnection *conn, GTlsRehandshakeMode mode);
```
"""
function g_tls_connection_set_rehandshake_mode(conn, mode)
    @ccall libaravis.g_tls_connection_set_rehandshake_mode(conn::Ptr{GTlsConnection}, mode::GTlsRehandshakeMode)::Cvoid
end

"""
    g_tls_connection_get_rehandshake_mode(conn)

### Prototype
```c
GIO_DEPRECATED_IN_2_60 GTlsRehandshakeMode g_tls_connection_get_rehandshake_mode (GTlsConnection *conn);
```
"""
function g_tls_connection_get_rehandshake_mode(conn)
    @ccall libaravis.g_tls_connection_get_rehandshake_mode(conn::Ptr{GTlsConnection})::GTlsRehandshakeMode
end

"""
    g_tls_connection_set_advertised_protocols(conn, protocols)

### Prototype
```c
GIO_AVAILABLE_IN_2_60 void g_tls_connection_set_advertised_protocols (GTlsConnection *conn, const gchar * const *protocols);
```
"""
function g_tls_connection_set_advertised_protocols(conn, protocols)
    @ccall libaravis.g_tls_connection_set_advertised_protocols(conn::Ptr{GTlsConnection}, protocols::Ptr{Ptr{gchar}})::Cvoid
end

"""
    g_tls_connection_get_negotiated_protocol(conn)

### Prototype
```c
GIO_AVAILABLE_IN_2_60 const gchar * g_tls_connection_get_negotiated_protocol (GTlsConnection *conn);
```
"""
function g_tls_connection_get_negotiated_protocol(conn)
    @ccall libaravis.g_tls_connection_get_negotiated_protocol(conn::Ptr{GTlsConnection})::Ptr{gchar}
end

"""
    g_tls_connection_get_channel_binding_data(conn, type, data, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_66 gboolean g_tls_connection_get_channel_binding_data (GTlsConnection *conn, GTlsChannelBindingType type, GByteArray *data, GError **error);
```
"""
function g_tls_connection_get_channel_binding_data(conn, type, data, error)
    @ccall libaravis.g_tls_connection_get_channel_binding_data(conn::Ptr{GTlsConnection}, type::GTlsChannelBindingType, data::Ptr{GByteArray}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_tls_connection_handshake(conn, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_tls_connection_handshake (GTlsConnection *conn, GCancellable *cancellable, GError **error);
```
"""
function g_tls_connection_handshake(conn, cancellable, error)
    @ccall libaravis.g_tls_connection_handshake(conn::Ptr{GTlsConnection}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_tls_connection_handshake_async(conn, io_priority, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_tls_connection_handshake_async (GTlsConnection *conn, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_tls_connection_handshake_async(conn, io_priority, cancellable, callback, user_data)
    @ccall libaravis.g_tls_connection_handshake_async(conn::Ptr{GTlsConnection}, io_priority::Cint, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_tls_connection_handshake_finish(conn, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_tls_connection_handshake_finish (GTlsConnection *conn, GAsyncResult *result, GError **error);
```
"""
function g_tls_connection_handshake_finish(conn, result, error)
    @ccall libaravis.g_tls_connection_handshake_finish(conn::Ptr{GTlsConnection}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_tls_connection_get_protocol_version(conn)

### Prototype
```c
GIO_AVAILABLE_IN_2_70 GTlsProtocolVersion g_tls_connection_get_protocol_version (GTlsConnection *conn);
```
"""
function g_tls_connection_get_protocol_version(conn)
    @ccall libaravis.g_tls_connection_get_protocol_version(conn::Ptr{GTlsConnection})::GTlsProtocolVersion
end

"""
    g_tls_connection_get_ciphersuite_name(conn)

### Prototype
```c
GIO_AVAILABLE_IN_2_70 gchar * g_tls_connection_get_ciphersuite_name (GTlsConnection *conn);
```
"""
function g_tls_connection_get_ciphersuite_name(conn)
    @ccall libaravis.g_tls_connection_get_ciphersuite_name(conn::Ptr{GTlsConnection})::Ptr{gchar}
end

"""
    g_tls_connection_emit_accept_certificate(conn, peer_cert, errors)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_tls_connection_emit_accept_certificate (GTlsConnection *conn, GTlsCertificate *peer_cert, GTlsCertificateFlags errors);
```
"""
function g_tls_connection_emit_accept_certificate(conn, peer_cert, errors)
    @ccall libaravis.g_tls_connection_emit_accept_certificate(conn::Ptr{GTlsConnection}, peer_cert::Ptr{GTlsCertificate}, errors::GTlsCertificateFlags)::gboolean
end

"""
    g_tls_client_connection_new(base_io_stream, server_identity, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIOStream * g_tls_client_connection_new (GIOStream *base_io_stream, GSocketConnectable *server_identity, GError **error);
```
"""
function g_tls_client_connection_new(base_io_stream, server_identity, error)
    @ccall libaravis.g_tls_client_connection_new(base_io_stream::Ptr{GIOStream}, server_identity::Ptr{GSocketConnectable}, error::Ptr{Ptr{GError}})::Ptr{GIOStream}
end

"""
    g_tls_client_connection_get_validation_flags(conn)

### Prototype
```c
GIO_DEPRECATED_IN_2_72 GTlsCertificateFlags g_tls_client_connection_get_validation_flags (GTlsClientConnection *conn);
```
"""
function g_tls_client_connection_get_validation_flags(conn)
    @ccall libaravis.g_tls_client_connection_get_validation_flags(conn::Ptr{GTlsClientConnection})::GTlsCertificateFlags
end

"""
    g_tls_client_connection_set_validation_flags(conn, flags)

### Prototype
```c
GIO_DEPRECATED_IN_2_72 void g_tls_client_connection_set_validation_flags (GTlsClientConnection *conn, GTlsCertificateFlags flags);
```
"""
function g_tls_client_connection_set_validation_flags(conn, flags)
    @ccall libaravis.g_tls_client_connection_set_validation_flags(conn::Ptr{GTlsClientConnection}, flags::GTlsCertificateFlags)::Cvoid
end

"""
    g_tls_client_connection_get_server_identity(conn)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketConnectable *g_tls_client_connection_get_server_identity (GTlsClientConnection *conn);
```
"""
function g_tls_client_connection_get_server_identity(conn)
    @ccall libaravis.g_tls_client_connection_get_server_identity(conn::Ptr{GTlsClientConnection})::Ptr{GSocketConnectable}
end

"""
    g_tls_client_connection_set_server_identity(conn, identity)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_tls_client_connection_set_server_identity (GTlsClientConnection *conn, GSocketConnectable *identity);
```
"""
function g_tls_client_connection_set_server_identity(conn, identity)
    @ccall libaravis.g_tls_client_connection_set_server_identity(conn::Ptr{GTlsClientConnection}, identity::Ptr{GSocketConnectable})::Cvoid
end

"""
    g_tls_client_connection_get_use_ssl3(conn)

### Prototype
```c
GIO_DEPRECATED_IN_2_56 gboolean g_tls_client_connection_get_use_ssl3 (GTlsClientConnection *conn);
```
"""
function g_tls_client_connection_get_use_ssl3(conn)
    @ccall libaravis.g_tls_client_connection_get_use_ssl3(conn::Ptr{GTlsClientConnection})::gboolean
end

"""
    g_tls_client_connection_set_use_ssl3(conn, use_ssl3)

### Prototype
```c
GIO_DEPRECATED_IN_2_56 void g_tls_client_connection_set_use_ssl3 (GTlsClientConnection *conn, gboolean use_ssl3);
```
"""
function g_tls_client_connection_set_use_ssl3(conn, use_ssl3)
    @ccall libaravis.g_tls_client_connection_set_use_ssl3(conn::Ptr{GTlsClientConnection}, use_ssl3::gboolean)::Cvoid
end

"""
    g_tls_client_connection_get_accepted_cas(conn)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GList * g_tls_client_connection_get_accepted_cas (GTlsClientConnection *conn);
```
"""
function g_tls_client_connection_get_accepted_cas(conn)
    @ccall libaravis.g_tls_client_connection_get_accepted_cas(conn::Ptr{GTlsClientConnection})::Ptr{GList}
end

"""
    g_tls_client_connection_copy_session_state(conn, source)

### Prototype
```c
GIO_AVAILABLE_IN_2_46 void g_tls_client_connection_copy_session_state (GTlsClientConnection *conn, GTlsClientConnection *source);
```
"""
function g_tls_client_connection_copy_session_state(conn, source)
    @ccall libaravis.g_tls_client_connection_copy_session_state(conn::Ptr{GTlsClientConnection}, source::Ptr{GTlsClientConnection})::Cvoid
end

"""
    g_tls_database_verify_chain(self, chain, purpose, identity, interaction, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GTlsCertificateFlags g_tls_database_verify_chain (GTlsDatabase *self, GTlsCertificate *chain, const gchar *purpose, GSocketConnectable *identity, GTlsInteraction *interaction, GTlsDatabaseVerifyFlags flags, GCancellable *cancellable, GError **error);
```
"""
function g_tls_database_verify_chain(self, chain, purpose, identity, interaction, flags, cancellable, error)
    @ccall libaravis.g_tls_database_verify_chain(self::Ptr{GTlsDatabase}, chain::Ptr{GTlsCertificate}, purpose::Ptr{gchar}, identity::Ptr{GSocketConnectable}, interaction::Ptr{GTlsInteraction}, flags::GTlsDatabaseVerifyFlags, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::GTlsCertificateFlags
end

"""
    g_tls_database_verify_chain_async(self, chain, purpose, identity, interaction, flags, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_tls_database_verify_chain_async (GTlsDatabase *self, GTlsCertificate *chain, const gchar *purpose, GSocketConnectable *identity, GTlsInteraction *interaction, GTlsDatabaseVerifyFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_tls_database_verify_chain_async(self, chain, purpose, identity, interaction, flags, cancellable, callback, user_data)
    @ccall libaravis.g_tls_database_verify_chain_async(self::Ptr{GTlsDatabase}, chain::Ptr{GTlsCertificate}, purpose::Ptr{gchar}, identity::Ptr{GSocketConnectable}, interaction::Ptr{GTlsInteraction}, flags::GTlsDatabaseVerifyFlags, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_tls_database_verify_chain_finish(self, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GTlsCertificateFlags g_tls_database_verify_chain_finish (GTlsDatabase *self, GAsyncResult *result, GError **error);
```
"""
function g_tls_database_verify_chain_finish(self, result, error)
    @ccall libaravis.g_tls_database_verify_chain_finish(self::Ptr{GTlsDatabase}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::GTlsCertificateFlags
end

"""
    g_tls_database_create_certificate_handle(self, certificate)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gchar* g_tls_database_create_certificate_handle (GTlsDatabase *self, GTlsCertificate *certificate);
```
"""
function g_tls_database_create_certificate_handle(self, certificate)
    @ccall libaravis.g_tls_database_create_certificate_handle(self::Ptr{GTlsDatabase}, certificate::Ptr{GTlsCertificate})::Ptr{gchar}
end

"""
    g_tls_database_lookup_certificate_for_handle(self, handle, interaction, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GTlsCertificate* g_tls_database_lookup_certificate_for_handle (GTlsDatabase *self, const gchar *handle, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GError **error);
```
"""
function g_tls_database_lookup_certificate_for_handle(self, handle, interaction, flags, cancellable, error)
    @ccall libaravis.g_tls_database_lookup_certificate_for_handle(self::Ptr{GTlsDatabase}, handle::Ptr{gchar}, interaction::Ptr{GTlsInteraction}, flags::GTlsDatabaseLookupFlags, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GTlsCertificate}
end

"""
    g_tls_database_lookup_certificate_for_handle_async(self, handle, interaction, flags, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_tls_database_lookup_certificate_for_handle_async (GTlsDatabase *self, const gchar *handle, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_tls_database_lookup_certificate_for_handle_async(self, handle, interaction, flags, cancellable, callback, user_data)
    @ccall libaravis.g_tls_database_lookup_certificate_for_handle_async(self::Ptr{GTlsDatabase}, handle::Ptr{gchar}, interaction::Ptr{GTlsInteraction}, flags::GTlsDatabaseLookupFlags, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_tls_database_lookup_certificate_for_handle_finish(self, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GTlsCertificate* g_tls_database_lookup_certificate_for_handle_finish (GTlsDatabase *self, GAsyncResult *result, GError **error);
```
"""
function g_tls_database_lookup_certificate_for_handle_finish(self, result, error)
    @ccall libaravis.g_tls_database_lookup_certificate_for_handle_finish(self::Ptr{GTlsDatabase}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GTlsCertificate}
end

"""
    g_tls_database_lookup_certificate_issuer(self, certificate, interaction, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GTlsCertificate* g_tls_database_lookup_certificate_issuer (GTlsDatabase *self, GTlsCertificate *certificate, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GError **error);
```
"""
function g_tls_database_lookup_certificate_issuer(self, certificate, interaction, flags, cancellable, error)
    @ccall libaravis.g_tls_database_lookup_certificate_issuer(self::Ptr{GTlsDatabase}, certificate::Ptr{GTlsCertificate}, interaction::Ptr{GTlsInteraction}, flags::GTlsDatabaseLookupFlags, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GTlsCertificate}
end

"""
    g_tls_database_lookup_certificate_issuer_async(self, certificate, interaction, flags, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_tls_database_lookup_certificate_issuer_async (GTlsDatabase *self, GTlsCertificate *certificate, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_tls_database_lookup_certificate_issuer_async(self, certificate, interaction, flags, cancellable, callback, user_data)
    @ccall libaravis.g_tls_database_lookup_certificate_issuer_async(self::Ptr{GTlsDatabase}, certificate::Ptr{GTlsCertificate}, interaction::Ptr{GTlsInteraction}, flags::GTlsDatabaseLookupFlags, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_tls_database_lookup_certificate_issuer_finish(self, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GTlsCertificate* g_tls_database_lookup_certificate_issuer_finish (GTlsDatabase *self, GAsyncResult *result, GError **error);
```
"""
function g_tls_database_lookup_certificate_issuer_finish(self, result, error)
    @ccall libaravis.g_tls_database_lookup_certificate_issuer_finish(self::Ptr{GTlsDatabase}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GTlsCertificate}
end

"""
    g_tls_database_lookup_certificates_issued_by(self, issuer_raw_dn, interaction, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GList* g_tls_database_lookup_certificates_issued_by (GTlsDatabase *self, GByteArray *issuer_raw_dn, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GError **error);
```
"""
function g_tls_database_lookup_certificates_issued_by(self, issuer_raw_dn, interaction, flags, cancellable, error)
    @ccall libaravis.g_tls_database_lookup_certificates_issued_by(self::Ptr{GTlsDatabase}, issuer_raw_dn::Ptr{GByteArray}, interaction::Ptr{GTlsInteraction}, flags::GTlsDatabaseLookupFlags, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GList}
end

"""
    g_tls_database_lookup_certificates_issued_by_async(self, issuer_raw_dn, interaction, flags, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_tls_database_lookup_certificates_issued_by_async (GTlsDatabase *self, GByteArray *issuer_raw_dn, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_tls_database_lookup_certificates_issued_by_async(self, issuer_raw_dn, interaction, flags, cancellable, callback, user_data)
    @ccall libaravis.g_tls_database_lookup_certificates_issued_by_async(self::Ptr{GTlsDatabase}, issuer_raw_dn::Ptr{GByteArray}, interaction::Ptr{GTlsInteraction}, flags::GTlsDatabaseLookupFlags, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_tls_database_lookup_certificates_issued_by_finish(self, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GList* g_tls_database_lookup_certificates_issued_by_finish (GTlsDatabase *self, GAsyncResult *result, GError **error);
```
"""
function g_tls_database_lookup_certificates_issued_by_finish(self, result, error)
    @ccall libaravis.g_tls_database_lookup_certificates_issued_by_finish(self::Ptr{GTlsDatabase}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GList}
end

"""
    g_tls_file_database_new(anchors, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GTlsDatabase* g_tls_file_database_new (const gchar *anchors, GError **error);
```
"""
function g_tls_file_database_new(anchors, error)
    @ccall libaravis.g_tls_file_database_new(anchors::Ptr{gchar}, error::Ptr{Ptr{GError}})::Ptr{GTlsDatabase}
end

"""
    g_tls_interaction_invoke_ask_password(interaction, password, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GTlsInteractionResult g_tls_interaction_invoke_ask_password (GTlsInteraction *interaction, GTlsPassword *password, GCancellable *cancellable, GError **error);
```
"""
function g_tls_interaction_invoke_ask_password(interaction, password, cancellable, error)
    @ccall libaravis.g_tls_interaction_invoke_ask_password(interaction::Ptr{GTlsInteraction}, password::Ptr{GTlsPassword}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::GTlsInteractionResult
end

"""
    g_tls_interaction_ask_password(interaction, password, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GTlsInteractionResult g_tls_interaction_ask_password (GTlsInteraction *interaction, GTlsPassword *password, GCancellable *cancellable, GError **error);
```
"""
function g_tls_interaction_ask_password(interaction, password, cancellable, error)
    @ccall libaravis.g_tls_interaction_ask_password(interaction::Ptr{GTlsInteraction}, password::Ptr{GTlsPassword}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::GTlsInteractionResult
end

"""
    g_tls_interaction_ask_password_async(interaction, password, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_tls_interaction_ask_password_async (GTlsInteraction *interaction, GTlsPassword *password, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_tls_interaction_ask_password_async(interaction, password, cancellable, callback, user_data)
    @ccall libaravis.g_tls_interaction_ask_password_async(interaction::Ptr{GTlsInteraction}, password::Ptr{GTlsPassword}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_tls_interaction_ask_password_finish(interaction, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GTlsInteractionResult g_tls_interaction_ask_password_finish (GTlsInteraction *interaction, GAsyncResult *result, GError **error);
```
"""
function g_tls_interaction_ask_password_finish(interaction, result, error)
    @ccall libaravis.g_tls_interaction_ask_password_finish(interaction::Ptr{GTlsInteraction}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::GTlsInteractionResult
end

"""
    g_tls_interaction_invoke_request_certificate(interaction, connection, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 GTlsInteractionResult g_tls_interaction_invoke_request_certificate (GTlsInteraction *interaction, GTlsConnection *connection, GTlsCertificateRequestFlags flags, GCancellable *cancellable, GError **error);
```
"""
function g_tls_interaction_invoke_request_certificate(interaction, connection, flags, cancellable, error)
    @ccall libaravis.g_tls_interaction_invoke_request_certificate(interaction::Ptr{GTlsInteraction}, connection::Ptr{GTlsConnection}, flags::GTlsCertificateRequestFlags, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::GTlsInteractionResult
end

"""
    g_tls_interaction_request_certificate(interaction, connection, flags, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 GTlsInteractionResult g_tls_interaction_request_certificate (GTlsInteraction *interaction, GTlsConnection *connection, GTlsCertificateRequestFlags flags, GCancellable *cancellable, GError **error);
```
"""
function g_tls_interaction_request_certificate(interaction, connection, flags, cancellable, error)
    @ccall libaravis.g_tls_interaction_request_certificate(interaction::Ptr{GTlsInteraction}, connection::Ptr{GTlsConnection}, flags::GTlsCertificateRequestFlags, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::GTlsInteractionResult
end

"""
    g_tls_interaction_request_certificate_async(interaction, connection, flags, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 void g_tls_interaction_request_certificate_async (GTlsInteraction *interaction, GTlsConnection *connection, GTlsCertificateRequestFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_tls_interaction_request_certificate_async(interaction, connection, flags, cancellable, callback, user_data)
    @ccall libaravis.g_tls_interaction_request_certificate_async(interaction::Ptr{GTlsInteraction}, connection::Ptr{GTlsConnection}, flags::GTlsCertificateRequestFlags, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_tls_interaction_request_certificate_finish(interaction, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_40 GTlsInteractionResult g_tls_interaction_request_certificate_finish (GTlsInteraction *interaction, GAsyncResult *result, GError **error);
```
"""
function g_tls_interaction_request_certificate_finish(interaction, result, error)
    @ccall libaravis.g_tls_interaction_request_certificate_finish(interaction::Ptr{GTlsInteraction}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::GTlsInteractionResult
end

"""
    g_tls_password_new(flags, description)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GTlsPassword * g_tls_password_new (GTlsPasswordFlags flags, const gchar *description);
```
"""
function g_tls_password_new(flags, description)
    @ccall libaravis.g_tls_password_new(flags::GTlsPasswordFlags, description::Ptr{gchar})::Ptr{GTlsPassword}
end

"""
    g_tls_password_get_value(password, length)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const guchar * g_tls_password_get_value (GTlsPassword *password, gsize *length);
```
"""
function g_tls_password_get_value(password, length)
    @ccall libaravis.g_tls_password_get_value(password::Ptr{GTlsPassword}, length::Ptr{gsize})::Ptr{guchar}
end

"""
    g_tls_password_set_value(password, value, length)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_tls_password_set_value (GTlsPassword *password, const guchar *value, gssize length);
```
"""
function g_tls_password_set_value(password, value, length)
    @ccall libaravis.g_tls_password_set_value(password::Ptr{GTlsPassword}, value::Ptr{guchar}, length::gssize)::Cvoid
end

"""
    g_tls_password_set_value_full(password, value, length, destroy)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_tls_password_set_value_full (GTlsPassword *password, guchar *value, gssize length, GDestroyNotify destroy);
```
"""
function g_tls_password_set_value_full(password, value, length, destroy)
    @ccall libaravis.g_tls_password_set_value_full(password::Ptr{GTlsPassword}, value::Ptr{guchar}, length::gssize, destroy::GDestroyNotify)::Cvoid
end

"""
    g_tls_password_get_flags(password)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GTlsPasswordFlags g_tls_password_get_flags (GTlsPassword *password);
```
"""
function g_tls_password_get_flags(password)
    @ccall libaravis.g_tls_password_get_flags(password::Ptr{GTlsPassword})::GTlsPasswordFlags
end

"""
    g_tls_password_set_flags(password, flags)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_tls_password_set_flags (GTlsPassword *password, GTlsPasswordFlags flags);
```
"""
function g_tls_password_set_flags(password, flags)
    @ccall libaravis.g_tls_password_set_flags(password::Ptr{GTlsPassword}, flags::GTlsPasswordFlags)::Cvoid
end

"""
    g_tls_password_get_description(password)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar* g_tls_password_get_description (GTlsPassword *password);
```
"""
function g_tls_password_get_description(password)
    @ccall libaravis.g_tls_password_get_description(password::Ptr{GTlsPassword})::Ptr{gchar}
end

"""
    g_tls_password_set_description(password, description)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_tls_password_set_description (GTlsPassword *password, const gchar *description);
```
"""
function g_tls_password_set_description(password, description)
    @ccall libaravis.g_tls_password_set_description(password::Ptr{GTlsPassword}, description::Ptr{gchar})::Cvoid
end

"""
    g_tls_password_get_warning(password)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar * g_tls_password_get_warning (GTlsPassword *password);
```
"""
function g_tls_password_get_warning(password)
    @ccall libaravis.g_tls_password_get_warning(password::Ptr{GTlsPassword})::Ptr{gchar}
end

"""
    g_tls_password_set_warning(password, warning)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_tls_password_set_warning (GTlsPassword *password, const gchar *warning);
```
"""
function g_tls_password_set_warning(password, warning)
    @ccall libaravis.g_tls_password_set_warning(password::Ptr{GTlsPassword}, warning::Ptr{gchar})::Cvoid
end

"""
    g_tls_server_connection_new(base_io_stream, certificate, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIOStream * g_tls_server_connection_new (GIOStream *base_io_stream, GTlsCertificate *certificate, GError **error);
```
"""
function g_tls_server_connection_new(base_io_stream, certificate, error)
    @ccall libaravis.g_tls_server_connection_new(base_io_stream::Ptr{GIOStream}, certificate::Ptr{GTlsCertificate}, error::Ptr{Ptr{GError}})::Ptr{GIOStream}
end

const GUnixConnection_autoptr = Ptr{GUnixConnection}

const GUnixConnection_listautoptr = Ptr{GList}

const GUnixConnection_slistautoptr = Ptr{GSList}

const GUnixConnection_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GUnixConnection(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUnixConnection, g_object_unref);
```
"""
function glib_autoptr_clear_GUnixConnection(_ptr)
    @ccall libaravis.glib_autoptr_clear_GUnixConnection(_ptr::Ptr{GUnixConnection})::Cvoid
end

"""
    glib_autoptr_cleanup_GUnixConnection(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUnixConnection, g_object_unref);
```
"""
function glib_autoptr_cleanup_GUnixConnection(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GUnixConnection(_ptr::Ptr{Ptr{GUnixConnection}})::Cvoid
end

"""
    glib_autoptr_destroy_GUnixConnection(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUnixConnection, g_object_unref);
```
"""
function glib_autoptr_destroy_GUnixConnection(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GUnixConnection(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GUnixConnection(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUnixConnection, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GUnixConnection(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GUnixConnection(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GUnixConnection(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUnixConnection, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GUnixConnection(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GUnixConnection(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GUnixConnection(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUnixConnection, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GUnixConnection(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GUnixConnection(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    g_unix_connection_send_fd(connection, fd, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_unix_connection_send_fd (GUnixConnection *connection, gint fd, GCancellable *cancellable, GError **error);
```
"""
function g_unix_connection_send_fd(connection, fd, cancellable, error)
    @ccall libaravis.g_unix_connection_send_fd(connection::Ptr{GUnixConnection}, fd::gint, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_unix_connection_receive_fd(connection, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gint g_unix_connection_receive_fd (GUnixConnection *connection, GCancellable *cancellable, GError **error);
```
"""
function g_unix_connection_receive_fd(connection, cancellable, error)
    @ccall libaravis.g_unix_connection_receive_fd(connection::Ptr{GUnixConnection}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gint
end

"""
    g_unix_connection_send_credentials(connection, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_unix_connection_send_credentials (GUnixConnection *connection, GCancellable *cancellable, GError **error);
```
"""
function g_unix_connection_send_credentials(connection, cancellable, error)
    @ccall libaravis.g_unix_connection_send_credentials(connection::Ptr{GUnixConnection}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_unix_connection_send_credentials_async(connection, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_unix_connection_send_credentials_async (GUnixConnection *connection, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_unix_connection_send_credentials_async(connection, cancellable, callback, user_data)
    @ccall libaravis.g_unix_connection_send_credentials_async(connection::Ptr{GUnixConnection}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_unix_connection_send_credentials_finish(connection, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 gboolean g_unix_connection_send_credentials_finish (GUnixConnection *connection, GAsyncResult *result, GError **error);
```
"""
function g_unix_connection_send_credentials_finish(connection, result, error)
    @ccall libaravis.g_unix_connection_send_credentials_finish(connection::Ptr{GUnixConnection}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_unix_connection_receive_credentials(connection, cancellable, error)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 GCredentials *g_unix_connection_receive_credentials (GUnixConnection *connection, GCancellable *cancellable, GError **error);
```
"""
function g_unix_connection_receive_credentials(connection, cancellable, error)
    @ccall libaravis.g_unix_connection_receive_credentials(connection::Ptr{GUnixConnection}, cancellable::Ptr{GCancellable}, error::Ptr{Ptr{GError}})::Ptr{GCredentials}
end

"""
    g_unix_connection_receive_credentials_async(connection, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 void g_unix_connection_receive_credentials_async (GUnixConnection *connection, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_unix_connection_receive_credentials_async(connection, cancellable, callback, user_data)
    @ccall libaravis.g_unix_connection_receive_credentials_async(connection::Ptr{GUnixConnection}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_unix_connection_receive_credentials_finish(connection, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GCredentials *g_unix_connection_receive_credentials_finish (GUnixConnection *connection, GAsyncResult *result, GError **error);
```
"""
function g_unix_connection_receive_credentials_finish(connection, result, error)
    @ccall libaravis.g_unix_connection_receive_credentials_finish(connection::Ptr{GUnixConnection}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::Ptr{GCredentials}
end

const GUnixCredentialsMessage_autoptr = Ptr{GUnixCredentialsMessage}

const GUnixCredentialsMessage_listautoptr = Ptr{GList}

const GUnixCredentialsMessage_slistautoptr = Ptr{GSList}

const GUnixCredentialsMessage_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GUnixCredentialsMessage(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUnixCredentialsMessage, g_object_unref);
```
"""
function glib_autoptr_clear_GUnixCredentialsMessage(_ptr)
    @ccall libaravis.glib_autoptr_clear_GUnixCredentialsMessage(_ptr::Ptr{GUnixCredentialsMessage})::Cvoid
end

"""
    glib_autoptr_cleanup_GUnixCredentialsMessage(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUnixCredentialsMessage, g_object_unref);
```
"""
function glib_autoptr_cleanup_GUnixCredentialsMessage(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GUnixCredentialsMessage(_ptr::Ptr{Ptr{GUnixCredentialsMessage}})::Cvoid
end

"""
    glib_autoptr_destroy_GUnixCredentialsMessage(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUnixCredentialsMessage, g_object_unref);
```
"""
function glib_autoptr_destroy_GUnixCredentialsMessage(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GUnixCredentialsMessage(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GUnixCredentialsMessage(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUnixCredentialsMessage, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GUnixCredentialsMessage(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GUnixCredentialsMessage(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GUnixCredentialsMessage(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUnixCredentialsMessage, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GUnixCredentialsMessage(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GUnixCredentialsMessage(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GUnixCredentialsMessage(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUnixCredentialsMessage, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GUnixCredentialsMessage(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GUnixCredentialsMessage(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    g_unix_credentials_message_new()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketControlMessage *g_unix_credentials_message_new (void);
```
"""
function g_unix_credentials_message_new()
    @ccall libaravis.g_unix_credentials_message_new()::Ptr{GSocketControlMessage}
end

"""
    g_unix_credentials_message_new_with_credentials(credentials)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketControlMessage *g_unix_credentials_message_new_with_credentials (GCredentials *credentials);
```
"""
function g_unix_credentials_message_new_with_credentials(credentials)
    @ccall libaravis.g_unix_credentials_message_new_with_credentials(credentials::Ptr{GCredentials})::Ptr{GSocketControlMessage}
end

"""
    g_unix_credentials_message_get_credentials(message)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GCredentials *g_unix_credentials_message_get_credentials (GUnixCredentialsMessage *message);
```
"""
function g_unix_credentials_message_get_credentials(message)
    @ccall libaravis.g_unix_credentials_message_get_credentials(message::Ptr{GUnixCredentialsMessage})::Ptr{GCredentials}
end

"""
    g_unix_credentials_message_is_supported()

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_unix_credentials_message_is_supported (void);
```
"""
function g_unix_credentials_message_is_supported()
    @ccall libaravis.g_unix_credentials_message_is_supported()::gboolean
end

const GUnixFDList_autoptr = Ptr{GUnixFDList}

const GUnixFDList_listautoptr = Ptr{GList}

const GUnixFDList_slistautoptr = Ptr{GSList}

const GUnixFDList_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GUnixFDList(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUnixFDList, g_object_unref);
```
"""
function glib_autoptr_clear_GUnixFDList(_ptr)
    @ccall libaravis.glib_autoptr_clear_GUnixFDList(_ptr::Ptr{GUnixFDList})::Cvoid
end

"""
    glib_autoptr_cleanup_GUnixFDList(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUnixFDList, g_object_unref);
```
"""
function glib_autoptr_cleanup_GUnixFDList(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GUnixFDList(_ptr::Ptr{Ptr{GUnixFDList}})::Cvoid
end

"""
    glib_autoptr_destroy_GUnixFDList(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUnixFDList, g_object_unref);
```
"""
function glib_autoptr_destroy_GUnixFDList(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GUnixFDList(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GUnixFDList(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUnixFDList, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GUnixFDList(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GUnixFDList(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GUnixFDList(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUnixFDList, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GUnixFDList(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GUnixFDList(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GUnixFDList(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUnixFDList, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GUnixFDList(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GUnixFDList(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    g_unix_fd_list_new()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GUnixFDList * g_unix_fd_list_new (void);
```
"""
function g_unix_fd_list_new()
    @ccall libaravis.g_unix_fd_list_new()::Ptr{GUnixFDList}
end

"""
    g_unix_fd_list_new_from_array(fds, n_fds)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GUnixFDList * g_unix_fd_list_new_from_array (const gint *fds, gint n_fds);
```
"""
function g_unix_fd_list_new_from_array(fds, n_fds)
    @ccall libaravis.g_unix_fd_list_new_from_array(fds::Ptr{gint}, n_fds::gint)::Ptr{GUnixFDList}
end

"""
    g_unix_fd_list_append(list, fd, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gint g_unix_fd_list_append (GUnixFDList *list, gint fd, GError **error);
```
"""
function g_unix_fd_list_append(list, fd, error)
    @ccall libaravis.g_unix_fd_list_append(list::Ptr{GUnixFDList}, fd::gint, error::Ptr{Ptr{GError}})::gint
end

"""
    g_unix_fd_list_get_length(list)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gint g_unix_fd_list_get_length (GUnixFDList *list);
```
"""
function g_unix_fd_list_get_length(list)
    @ccall libaravis.g_unix_fd_list_get_length(list::Ptr{GUnixFDList})::gint
end

"""
    g_unix_fd_list_get(list, index_, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gint g_unix_fd_list_get (GUnixFDList *list, gint index_, GError **error);
```
"""
function g_unix_fd_list_get(list, index_, error)
    @ccall libaravis.g_unix_fd_list_get(list::Ptr{GUnixFDList}, index_::gint, error::Ptr{Ptr{GError}})::gint
end

"""
    g_unix_fd_list_peek_fds(list, length)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gint * g_unix_fd_list_peek_fds (GUnixFDList *list, gint *length);
```
"""
function g_unix_fd_list_peek_fds(list, length)
    @ccall libaravis.g_unix_fd_list_peek_fds(list::Ptr{GUnixFDList}, length::Ptr{gint})::Ptr{gint}
end

"""
    g_unix_fd_list_steal_fds(list, length)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gint * g_unix_fd_list_steal_fds (GUnixFDList *list, gint *length);
```
"""
function g_unix_fd_list_steal_fds(list, length)
    @ccall libaravis.g_unix_fd_list_steal_fds(list::Ptr{GUnixFDList}, length::Ptr{gint})::Ptr{gint}
end

const GUnixSocketAddress_autoptr = Ptr{GUnixSocketAddress}

const GUnixSocketAddress_listautoptr = Ptr{GList}

const GUnixSocketAddress_slistautoptr = Ptr{GSList}

const GUnixSocketAddress_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GUnixSocketAddress(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUnixSocketAddress, g_object_unref);
```
"""
function glib_autoptr_clear_GUnixSocketAddress(_ptr)
    @ccall libaravis.glib_autoptr_clear_GUnixSocketAddress(_ptr::Ptr{GUnixSocketAddress})::Cvoid
end

"""
    glib_autoptr_cleanup_GUnixSocketAddress(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUnixSocketAddress, g_object_unref);
```
"""
function glib_autoptr_cleanup_GUnixSocketAddress(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GUnixSocketAddress(_ptr::Ptr{Ptr{GUnixSocketAddress}})::Cvoid
end

"""
    glib_autoptr_destroy_GUnixSocketAddress(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUnixSocketAddress, g_object_unref);
```
"""
function glib_autoptr_destroy_GUnixSocketAddress(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GUnixSocketAddress(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GUnixSocketAddress(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUnixSocketAddress, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GUnixSocketAddress(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GUnixSocketAddress(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GUnixSocketAddress(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUnixSocketAddress, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GUnixSocketAddress(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GUnixSocketAddress(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GUnixSocketAddress(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GUnixSocketAddress, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GUnixSocketAddress(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GUnixSocketAddress(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    g_unix_socket_address_new(path)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketAddress *g_unix_socket_address_new (const gchar *path);
```
"""
function g_unix_socket_address_new(path)
    @ccall libaravis.g_unix_socket_address_new(path::Ptr{gchar})::Ptr{GSocketAddress}
end

"""
    g_unix_socket_address_new_abstract(path, path_len)

### Prototype
```c
GIO_DEPRECATED_FOR(g_unix_socket_address_new_with_type) GSocketAddress *g_unix_socket_address_new_abstract (const gchar *path, gint path_len);
```
"""
function g_unix_socket_address_new_abstract(path, path_len)
    @ccall libaravis.g_unix_socket_address_new_abstract(path::Ptr{gchar}, path_len::gint)::Ptr{GSocketAddress}
end

"""
    g_unix_socket_address_new_with_type(path, path_len, type)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GSocketAddress *g_unix_socket_address_new_with_type (const gchar *path, gint path_len, GUnixSocketAddressType type);
```
"""
function g_unix_socket_address_new_with_type(path, path_len, type)
    @ccall libaravis.g_unix_socket_address_new_with_type(path::Ptr{gchar}, path_len::gint, type::GUnixSocketAddressType)::Ptr{GSocketAddress}
end

"""
    g_unix_socket_address_get_path(address)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const char * g_unix_socket_address_get_path (GUnixSocketAddress *address);
```
"""
function g_unix_socket_address_get_path(address)
    @ccall libaravis.g_unix_socket_address_get_path(address::Ptr{GUnixSocketAddress})::Cstring
end

"""
    g_unix_socket_address_get_path_len(address)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gsize g_unix_socket_address_get_path_len (GUnixSocketAddress *address);
```
"""
function g_unix_socket_address_get_path_len(address)
    @ccall libaravis.g_unix_socket_address_get_path_len(address::Ptr{GUnixSocketAddress})::gsize
end

"""
    g_unix_socket_address_get_address_type(address)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GUnixSocketAddressType g_unix_socket_address_get_address_type (GUnixSocketAddress *address);
```
"""
function g_unix_socket_address_get_address_type(address)
    @ccall libaravis.g_unix_socket_address_get_address_type(address::Ptr{GUnixSocketAddress})::GUnixSocketAddressType
end

"""
    g_unix_socket_address_get_is_abstract(address)

### Prototype
```c
GIO_DEPRECATED gboolean g_unix_socket_address_get_is_abstract (GUnixSocketAddress *address);
```
"""
function g_unix_socket_address_get_is_abstract(address)
    @ccall libaravis.g_unix_socket_address_get_is_abstract(address::Ptr{GUnixSocketAddress})::gboolean
end

"""
    g_unix_socket_address_abstract_names_supported()

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_unix_socket_address_abstract_names_supported (void);
```
"""
function g_unix_socket_address_abstract_names_supported()
    @ccall libaravis.g_unix_socket_address_abstract_names_supported()::gboolean
end

# typedef GFile * ( * GVfsFileLookupFunc ) ( GVfs * vfs , const char * identifier , gpointer user_data )
"""
[`GVfsFileLookupFunc`](@ref): : a #[`GVfs`](@ref) : the identifier to look up a #[`GFile`](@ref) for. This can either be a URI or a parse name as returned by [`g_file_get_parse_name`](@ref)() \\_data: (nullable): user data passed to the function, or NULL

This function type is used by [`g_vfs_register_uri_scheme`](@ref)() to make it possible for a client to associate a URI scheme to a different #[`GFile`](@ref) implementation.

The client should return a reference to the new file that has been created for , or NULL to continue with the default implementation.

Returns: (nullable) (transfer full): a #[`GFile`](@ref) for .

Since: 2.50
"""
const GVfsFileLookupFunc = Ptr{Cvoid}

"""
    g_vfs_is_active(vfs)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_vfs_is_active (GVfs *vfs);
```
"""
function g_vfs_is_active(vfs)
    @ccall libaravis.g_vfs_is_active(vfs::Ptr{GVfs})::gboolean
end

"""
    g_vfs_get_file_for_path(vfs, path)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFile * g_vfs_get_file_for_path (GVfs *vfs, const char *path);
```
"""
function g_vfs_get_file_for_path(vfs, path)
    @ccall libaravis.g_vfs_get_file_for_path(vfs::Ptr{GVfs}, path::Cstring)::Ptr{GFile}
end

"""
    g_vfs_get_file_for_uri(vfs, uri)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFile * g_vfs_get_file_for_uri (GVfs *vfs, const char *uri);
```
"""
function g_vfs_get_file_for_uri(vfs, uri)
    @ccall libaravis.g_vfs_get_file_for_uri(vfs::Ptr{GVfs}, uri::Cstring)::Ptr{GFile}
end

"""
    g_vfs_get_supported_uri_schemes(vfs)

### Prototype
```c
GIO_AVAILABLE_IN_ALL const gchar* const * g_vfs_get_supported_uri_schemes (GVfs *vfs);
```
"""
function g_vfs_get_supported_uri_schemes(vfs)
    @ccall libaravis.g_vfs_get_supported_uri_schemes(vfs::Ptr{GVfs})::Ptr{Ptr{gchar}}
end

"""
    g_vfs_parse_name(vfs, parse_name)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFile * g_vfs_parse_name (GVfs *vfs, const char *parse_name);
```
"""
function g_vfs_parse_name(vfs, parse_name)
    @ccall libaravis.g_vfs_parse_name(vfs::Ptr{GVfs}, parse_name::Cstring)::Ptr{GFile}
end

"""
    g_vfs_get_default()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GVfs * g_vfs_get_default (void);
```
"""
function g_vfs_get_default()
    @ccall libaravis.g_vfs_get_default()::Ptr{GVfs}
end

"""
    g_vfs_get_local()

### Prototype
```c
GIO_AVAILABLE_IN_ALL GVfs * g_vfs_get_local (void);
```
"""
function g_vfs_get_local()
    @ccall libaravis.g_vfs_get_local()::Ptr{GVfs}
end

"""
    g_vfs_register_uri_scheme(vfs, scheme, uri_func, uri_data, uri_destroy, parse_name_func, parse_name_data, parse_name_destroy)

### Prototype
```c
GIO_AVAILABLE_IN_2_50 gboolean g_vfs_register_uri_scheme (GVfs *vfs, const char *scheme, GVfsFileLookupFunc uri_func, gpointer uri_data, GDestroyNotify uri_destroy, GVfsFileLookupFunc parse_name_func, gpointer parse_name_data, GDestroyNotify parse_name_destroy);
```
"""
function g_vfs_register_uri_scheme(vfs, scheme, uri_func, uri_data, uri_destroy, parse_name_func, parse_name_data, parse_name_destroy)
    @ccall libaravis.g_vfs_register_uri_scheme(vfs::Ptr{GVfs}, scheme::Cstring, uri_func::GVfsFileLookupFunc, uri_data::gpointer, uri_destroy::GDestroyNotify, parse_name_func::GVfsFileLookupFunc, parse_name_data::gpointer, parse_name_destroy::GDestroyNotify)::gboolean
end

"""
    g_vfs_unregister_uri_scheme(vfs, scheme)

### Prototype
```c
GIO_AVAILABLE_IN_2_50 gboolean g_vfs_unregister_uri_scheme (GVfs *vfs, const char *scheme);
```
"""
function g_vfs_unregister_uri_scheme(vfs, scheme)
    @ccall libaravis.g_vfs_unregister_uri_scheme(vfs::Ptr{GVfs}, scheme::Cstring)::gboolean
end

"""
    g_volume_get_name(volume)

### Prototype
```c
GIO_AVAILABLE_IN_ALL char * g_volume_get_name (GVolume *volume);
```
"""
function g_volume_get_name(volume)
    @ccall libaravis.g_volume_get_name(volume::Ptr{GVolume})::Cstring
end

"""
    g_volume_get_icon(volume)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIcon * g_volume_get_icon (GVolume *volume);
```
"""
function g_volume_get_icon(volume)
    @ccall libaravis.g_volume_get_icon(volume::Ptr{GVolume})::Ptr{GIcon}
end

"""
    g_volume_get_symbolic_icon(volume)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GIcon * g_volume_get_symbolic_icon (GVolume *volume);
```
"""
function g_volume_get_symbolic_icon(volume)
    @ccall libaravis.g_volume_get_symbolic_icon(volume::Ptr{GVolume})::Ptr{GIcon}
end

"""
    g_volume_get_uuid(volume)

### Prototype
```c
GIO_AVAILABLE_IN_ALL char * g_volume_get_uuid (GVolume *volume);
```
"""
function g_volume_get_uuid(volume)
    @ccall libaravis.g_volume_get_uuid(volume::Ptr{GVolume})::Cstring
end

"""
    g_volume_get_drive(volume)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GDrive * g_volume_get_drive (GVolume *volume);
```
"""
function g_volume_get_drive(volume)
    @ccall libaravis.g_volume_get_drive(volume::Ptr{GVolume})::Ptr{GDrive}
end

"""
    g_volume_get_mount(volume)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GMount * g_volume_get_mount (GVolume *volume);
```
"""
function g_volume_get_mount(volume)
    @ccall libaravis.g_volume_get_mount(volume::Ptr{GVolume})::Ptr{GMount}
end

"""
    g_volume_can_mount(volume)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_volume_can_mount (GVolume *volume);
```
"""
function g_volume_can_mount(volume)
    @ccall libaravis.g_volume_can_mount(volume::Ptr{GVolume})::gboolean
end

"""
    g_volume_can_eject(volume)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_volume_can_eject (GVolume *volume);
```
"""
function g_volume_can_eject(volume)
    @ccall libaravis.g_volume_can_eject(volume::Ptr{GVolume})::gboolean
end

"""
    g_volume_should_automount(volume)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_volume_should_automount (GVolume *volume);
```
"""
function g_volume_should_automount(volume)
    @ccall libaravis.g_volume_should_automount(volume::Ptr{GVolume})::gboolean
end

"""
    g_volume_mount(volume, flags, mount_operation, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_volume_mount (GVolume *volume, GMountMountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_volume_mount(volume, flags, mount_operation, cancellable, callback, user_data)
    @ccall libaravis.g_volume_mount(volume::Ptr{GVolume}, flags::GMountMountFlags, mount_operation::Ptr{GMountOperation}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_volume_mount_finish(volume, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_volume_mount_finish (GVolume *volume, GAsyncResult *result, GError **error);
```
"""
function g_volume_mount_finish(volume, result, error)
    @ccall libaravis.g_volume_mount_finish(volume::Ptr{GVolume}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_volume_eject(volume, flags, cancellable, callback, user_data)

### Prototype
```c
GIO_DEPRECATED_FOR(g_volume_eject_with_operation) void g_volume_eject (GVolume *volume, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_volume_eject(volume, flags, cancellable, callback, user_data)
    @ccall libaravis.g_volume_eject(volume::Ptr{GVolume}, flags::GMountUnmountFlags, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_volume_eject_finish(volume, result, error)

### Prototype
```c
GIO_DEPRECATED_FOR(g_volume_eject_with_operation_finish) gboolean g_volume_eject_finish (GVolume *volume, GAsyncResult *result, GError **error);
```
"""
function g_volume_eject_finish(volume, result, error)
    @ccall libaravis.g_volume_eject_finish(volume::Ptr{GVolume}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_volume_get_identifier(volume, kind)

### Prototype
```c
GIO_AVAILABLE_IN_ALL char * g_volume_get_identifier (GVolume *volume, const char *kind);
```
"""
function g_volume_get_identifier(volume, kind)
    @ccall libaravis.g_volume_get_identifier(volume::Ptr{GVolume}, kind::Cstring)::Cstring
end

"""
    g_volume_enumerate_identifiers(volume)

### Prototype
```c
GIO_AVAILABLE_IN_ALL char ** g_volume_enumerate_identifiers (GVolume *volume);
```
"""
function g_volume_enumerate_identifiers(volume)
    @ccall libaravis.g_volume_enumerate_identifiers(volume::Ptr{GVolume})::Ptr{Cstring}
end

"""
    g_volume_get_activation_root(volume)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFile * g_volume_get_activation_root (GVolume *volume);
```
"""
function g_volume_get_activation_root(volume)
    @ccall libaravis.g_volume_get_activation_root(volume::Ptr{GVolume})::Ptr{GFile}
end

"""
    g_volume_eject_with_operation(volume, flags, mount_operation, cancellable, callback, user_data)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_volume_eject_with_operation (GVolume *volume, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
```
"""
function g_volume_eject_with_operation(volume, flags, mount_operation, cancellable, callback, user_data)
    @ccall libaravis.g_volume_eject_with_operation(volume::Ptr{GVolume}, flags::GMountUnmountFlags, mount_operation::Ptr{GMountOperation}, cancellable::Ptr{GCancellable}, callback::GAsyncReadyCallback, user_data::gpointer)::Cvoid
end

"""
    g_volume_eject_with_operation_finish(volume, result, error)

### Prototype
```c
GIO_AVAILABLE_IN_ALL gboolean g_volume_eject_with_operation_finish (GVolume *volume, GAsyncResult *result, GError **error);
```
"""
function g_volume_eject_with_operation_finish(volume, result, error)
    @ccall libaravis.g_volume_eject_with_operation_finish(volume::Ptr{GVolume}, result::Ptr{GAsyncResult}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    g_volume_get_sort_key(volume)

### Prototype
```c
GIO_AVAILABLE_IN_2_32 const gchar *g_volume_get_sort_key (GVolume *volume);
```
"""
function g_volume_get_sort_key(volume)
    @ccall libaravis.g_volume_get_sort_key(volume::Ptr{GVolume})::Ptr{gchar}
end

"""
    g_zlib_compressor_new(format, level)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GZlibCompressor *g_zlib_compressor_new (GZlibCompressorFormat format, int level);
```
"""
function g_zlib_compressor_new(format, level)
    @ccall libaravis.g_zlib_compressor_new(format::GZlibCompressorFormat, level::Cint)::Ptr{GZlibCompressor}
end

"""
    g_zlib_compressor_get_file_info(compressor)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileInfo *g_zlib_compressor_get_file_info (GZlibCompressor *compressor);
```
"""
function g_zlib_compressor_get_file_info(compressor)
    @ccall libaravis.g_zlib_compressor_get_file_info(compressor::Ptr{GZlibCompressor})::Ptr{GFileInfo}
end

"""
    g_zlib_compressor_set_file_info(compressor, file_info)

### Prototype
```c
GIO_AVAILABLE_IN_ALL void g_zlib_compressor_set_file_info (GZlibCompressor *compressor, GFileInfo *file_info);
```
"""
function g_zlib_compressor_set_file_info(compressor, file_info)
    @ccall libaravis.g_zlib_compressor_set_file_info(compressor::Ptr{GZlibCompressor}, file_info::Ptr{GFileInfo})::Cvoid
end

"""
    g_zlib_compressor_get_os(compressor)

### Prototype
```c
GIO_AVAILABLE_IN_2_86 int g_zlib_compressor_get_os (GZlibCompressor *compressor);
```
"""
function g_zlib_compressor_get_os(compressor)
    @ccall libaravis.g_zlib_compressor_get_os(compressor::Ptr{GZlibCompressor})::Cint
end

"""
    g_zlib_compressor_set_os(compressor, os)

### Prototype
```c
GIO_AVAILABLE_IN_2_86 void g_zlib_compressor_set_os (GZlibCompressor *compressor, int os);
```
"""
function g_zlib_compressor_set_os(compressor, os)
    @ccall libaravis.g_zlib_compressor_set_os(compressor::Ptr{GZlibCompressor}, os::Cint)::Cvoid
end

"""
    g_zlib_decompressor_new(format)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GZlibDecompressor *g_zlib_decompressor_new (GZlibCompressorFormat format);
```
"""
function g_zlib_decompressor_new(format)
    @ccall libaravis.g_zlib_decompressor_new(format::GZlibCompressorFormat)::Ptr{GZlibDecompressor}
end

"""
    g_zlib_decompressor_get_file_info(decompressor)

### Prototype
```c
GIO_AVAILABLE_IN_ALL GFileInfo *g_zlib_decompressor_get_file_info (GZlibDecompressor *decompressor);
```
"""
function g_zlib_decompressor_get_file_info(decompressor)
    @ccall libaravis.g_zlib_decompressor_get_file_info(decompressor::Ptr{GZlibDecompressor})::Ptr{GFileInfo}
end

const GAction_autoptr = Ptr{GAction}

const GAction_listautoptr = Ptr{GList}

const GAction_slistautoptr = Ptr{GSList}

const GAction_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GAction(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAction, g_object_unref);
```
"""
function glib_autoptr_clear_GAction(_ptr)
    @ccall libaravis.glib_autoptr_clear_GAction(_ptr::Ptr{GAction})::Cvoid
end

"""
    glib_autoptr_cleanup_GAction(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAction, g_object_unref);
```
"""
function glib_autoptr_cleanup_GAction(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GAction(_ptr::Ptr{Ptr{GAction}})::Cvoid
end

"""
    glib_autoptr_destroy_GAction(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAction, g_object_unref);
```
"""
function glib_autoptr_destroy_GAction(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GAction(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GAction(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAction, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GAction(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GAction(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GAction(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAction, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GAction(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GAction(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GAction(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAction, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GAction(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GAction(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GActionMap_autoptr = Ptr{GActionMap}

const GActionMap_listautoptr = Ptr{GList}

const GActionMap_slistautoptr = Ptr{GSList}

const GActionMap_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GActionMap(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GActionMap, g_object_unref);
```
"""
function glib_autoptr_clear_GActionMap(_ptr)
    @ccall libaravis.glib_autoptr_clear_GActionMap(_ptr::Ptr{GActionMap})::Cvoid
end

"""
    glib_autoptr_cleanup_GActionMap(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GActionMap, g_object_unref);
```
"""
function glib_autoptr_cleanup_GActionMap(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GActionMap(_ptr::Ptr{Ptr{GActionMap}})::Cvoid
end

"""
    glib_autoptr_destroy_GActionMap(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GActionMap, g_object_unref);
```
"""
function glib_autoptr_destroy_GActionMap(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GActionMap(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GActionMap(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GActionMap, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GActionMap(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GActionMap(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GActionMap(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GActionMap, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GActionMap(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GActionMap(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GActionMap(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GActionMap, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GActionMap(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GActionMap(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GAppInfo_autoptr = Ptr{GAppInfo}

const GAppInfo_listautoptr = Ptr{GList}

const GAppInfo_slistautoptr = Ptr{GSList}

const GAppInfo_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GAppInfo(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAppInfo, g_object_unref);
```
"""
function glib_autoptr_clear_GAppInfo(_ptr)
    @ccall libaravis.glib_autoptr_clear_GAppInfo(_ptr::Ptr{GAppInfo})::Cvoid
end

"""
    glib_autoptr_cleanup_GAppInfo(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAppInfo, g_object_unref);
```
"""
function glib_autoptr_cleanup_GAppInfo(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GAppInfo(_ptr::Ptr{Ptr{GAppInfo}})::Cvoid
end

"""
    glib_autoptr_destroy_GAppInfo(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAppInfo, g_object_unref);
```
"""
function glib_autoptr_destroy_GAppInfo(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GAppInfo(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GAppInfo(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAppInfo, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GAppInfo(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GAppInfo(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GAppInfo(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAppInfo, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GAppInfo(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GAppInfo(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GAppInfo(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAppInfo, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GAppInfo(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GAppInfo(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GAppLaunchContext_autoptr = Ptr{GAppLaunchContext}

const GAppLaunchContext_listautoptr = Ptr{GList}

const GAppLaunchContext_slistautoptr = Ptr{GSList}

const GAppLaunchContext_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GAppLaunchContext(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAppLaunchContext, g_object_unref);
```
"""
function glib_autoptr_clear_GAppLaunchContext(_ptr)
    @ccall libaravis.glib_autoptr_clear_GAppLaunchContext(_ptr::Ptr{GAppLaunchContext})::Cvoid
end

"""
    glib_autoptr_cleanup_GAppLaunchContext(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAppLaunchContext, g_object_unref);
```
"""
function glib_autoptr_cleanup_GAppLaunchContext(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GAppLaunchContext(_ptr::Ptr{Ptr{GAppLaunchContext}})::Cvoid
end

"""
    glib_autoptr_destroy_GAppLaunchContext(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAppLaunchContext, g_object_unref);
```
"""
function glib_autoptr_destroy_GAppLaunchContext(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GAppLaunchContext(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GAppLaunchContext(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAppLaunchContext, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GAppLaunchContext(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GAppLaunchContext(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GAppLaunchContext(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAppLaunchContext, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GAppLaunchContext(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GAppLaunchContext(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GAppLaunchContext(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAppLaunchContext, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GAppLaunchContext(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GAppLaunchContext(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GAppInfoMonitor_autoptr = Ptr{GAppInfoMonitor}

const GAppInfoMonitor_listautoptr = Ptr{GList}

const GAppInfoMonitor_slistautoptr = Ptr{GSList}

const GAppInfoMonitor_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GAppInfoMonitor(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAppInfoMonitor, g_object_unref);
```
"""
function glib_autoptr_clear_GAppInfoMonitor(_ptr)
    @ccall libaravis.glib_autoptr_clear_GAppInfoMonitor(_ptr::Ptr{GAppInfoMonitor})::Cvoid
end

"""
    glib_autoptr_cleanup_GAppInfoMonitor(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAppInfoMonitor, g_object_unref);
```
"""
function glib_autoptr_cleanup_GAppInfoMonitor(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GAppInfoMonitor(_ptr::Ptr{Ptr{GAppInfoMonitor}})::Cvoid
end

"""
    glib_autoptr_destroy_GAppInfoMonitor(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAppInfoMonitor, g_object_unref);
```
"""
function glib_autoptr_destroy_GAppInfoMonitor(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GAppInfoMonitor(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GAppInfoMonitor(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAppInfoMonitor, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GAppInfoMonitor(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GAppInfoMonitor(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GAppInfoMonitor(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAppInfoMonitor, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GAppInfoMonitor(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GAppInfoMonitor(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GAppInfoMonitor(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAppInfoMonitor, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GAppInfoMonitor(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GAppInfoMonitor(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GApplicationCommandLine_autoptr = Ptr{GApplicationCommandLine}

const GApplicationCommandLine_listautoptr = Ptr{GList}

const GApplicationCommandLine_slistautoptr = Ptr{GSList}

const GApplicationCommandLine_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GApplicationCommandLine(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GApplicationCommandLine, g_object_unref);
```
"""
function glib_autoptr_clear_GApplicationCommandLine(_ptr)
    @ccall libaravis.glib_autoptr_clear_GApplicationCommandLine(_ptr::Ptr{GApplicationCommandLine})::Cvoid
end

"""
    glib_autoptr_cleanup_GApplicationCommandLine(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GApplicationCommandLine, g_object_unref);
```
"""
function glib_autoptr_cleanup_GApplicationCommandLine(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GApplicationCommandLine(_ptr::Ptr{Ptr{GApplicationCommandLine}})::Cvoid
end

"""
    glib_autoptr_destroy_GApplicationCommandLine(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GApplicationCommandLine, g_object_unref);
```
"""
function glib_autoptr_destroy_GApplicationCommandLine(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GApplicationCommandLine(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GApplicationCommandLine(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GApplicationCommandLine, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GApplicationCommandLine(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GApplicationCommandLine(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GApplicationCommandLine(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GApplicationCommandLine, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GApplicationCommandLine(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GApplicationCommandLine(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GApplicationCommandLine(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GApplicationCommandLine, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GApplicationCommandLine(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GApplicationCommandLine(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GApplication_autoptr = Ptr{GApplication}

const GApplication_listautoptr = Ptr{GList}

const GApplication_slistautoptr = Ptr{GSList}

const GApplication_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GApplication(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GApplication, g_object_unref);
```
"""
function glib_autoptr_clear_GApplication(_ptr)
    @ccall libaravis.glib_autoptr_clear_GApplication(_ptr::Ptr{GApplication})::Cvoid
end

"""
    glib_autoptr_cleanup_GApplication(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GApplication, g_object_unref);
```
"""
function glib_autoptr_cleanup_GApplication(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GApplication(_ptr::Ptr{Ptr{GApplication}})::Cvoid
end

"""
    glib_autoptr_destroy_GApplication(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GApplication, g_object_unref);
```
"""
function glib_autoptr_destroy_GApplication(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GApplication(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GApplication(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GApplication, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GApplication(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GApplication(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GApplication(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GApplication, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GApplication(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GApplication(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GApplication(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GApplication, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GApplication(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GApplication(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GAsyncInitable_autoptr = Ptr{GAsyncInitable}

const GAsyncInitable_listautoptr = Ptr{GList}

const GAsyncInitable_slistautoptr = Ptr{GSList}

const GAsyncInitable_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GAsyncInitable(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAsyncInitable, g_object_unref);
```
"""
function glib_autoptr_clear_GAsyncInitable(_ptr)
    @ccall libaravis.glib_autoptr_clear_GAsyncInitable(_ptr::Ptr{GAsyncInitable})::Cvoid
end

"""
    glib_autoptr_cleanup_GAsyncInitable(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAsyncInitable, g_object_unref);
```
"""
function glib_autoptr_cleanup_GAsyncInitable(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GAsyncInitable(_ptr::Ptr{Ptr{GAsyncInitable}})::Cvoid
end

"""
    glib_autoptr_destroy_GAsyncInitable(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAsyncInitable, g_object_unref);
```
"""
function glib_autoptr_destroy_GAsyncInitable(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GAsyncInitable(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GAsyncInitable(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAsyncInitable, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GAsyncInitable(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GAsyncInitable(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GAsyncInitable(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAsyncInitable, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GAsyncInitable(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GAsyncInitable(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GAsyncInitable(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAsyncInitable, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GAsyncInitable(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GAsyncInitable(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GAsyncResult_autoptr = Ptr{GAsyncResult}

const GAsyncResult_listautoptr = Ptr{GList}

const GAsyncResult_slistautoptr = Ptr{GSList}

const GAsyncResult_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GAsyncResult(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAsyncResult, g_object_unref);
```
"""
function glib_autoptr_clear_GAsyncResult(_ptr)
    @ccall libaravis.glib_autoptr_clear_GAsyncResult(_ptr::Ptr{GAsyncResult})::Cvoid
end

"""
    glib_autoptr_cleanup_GAsyncResult(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAsyncResult, g_object_unref);
```
"""
function glib_autoptr_cleanup_GAsyncResult(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GAsyncResult(_ptr::Ptr{Ptr{GAsyncResult}})::Cvoid
end

"""
    glib_autoptr_destroy_GAsyncResult(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAsyncResult, g_object_unref);
```
"""
function glib_autoptr_destroy_GAsyncResult(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GAsyncResult(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GAsyncResult(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAsyncResult, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GAsyncResult(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GAsyncResult(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GAsyncResult(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAsyncResult, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GAsyncResult(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GAsyncResult(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GAsyncResult(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GAsyncResult, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GAsyncResult(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GAsyncResult(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GBufferedInputStream_autoptr = Ptr{GBufferedInputStream}

const GBufferedInputStream_listautoptr = Ptr{GList}

const GBufferedInputStream_slistautoptr = Ptr{GSList}

const GBufferedInputStream_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GBufferedInputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBufferedInputStream, g_object_unref);
```
"""
function glib_autoptr_clear_GBufferedInputStream(_ptr)
    @ccall libaravis.glib_autoptr_clear_GBufferedInputStream(_ptr::Ptr{GBufferedInputStream})::Cvoid
end

"""
    glib_autoptr_cleanup_GBufferedInputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBufferedInputStream, g_object_unref);
```
"""
function glib_autoptr_cleanup_GBufferedInputStream(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GBufferedInputStream(_ptr::Ptr{Ptr{GBufferedInputStream}})::Cvoid
end

"""
    glib_autoptr_destroy_GBufferedInputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBufferedInputStream, g_object_unref);
```
"""
function glib_autoptr_destroy_GBufferedInputStream(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GBufferedInputStream(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GBufferedInputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBufferedInputStream, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GBufferedInputStream(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GBufferedInputStream(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GBufferedInputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBufferedInputStream, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GBufferedInputStream(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GBufferedInputStream(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GBufferedInputStream(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBufferedInputStream, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GBufferedInputStream(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GBufferedInputStream(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GBufferedOutputStream_autoptr = Ptr{GBufferedOutputStream}

const GBufferedOutputStream_listautoptr = Ptr{GList}

const GBufferedOutputStream_slistautoptr = Ptr{GSList}

const GBufferedOutputStream_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GBufferedOutputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBufferedOutputStream, g_object_unref);
```
"""
function glib_autoptr_clear_GBufferedOutputStream(_ptr)
    @ccall libaravis.glib_autoptr_clear_GBufferedOutputStream(_ptr::Ptr{GBufferedOutputStream})::Cvoid
end

"""
    glib_autoptr_cleanup_GBufferedOutputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBufferedOutputStream, g_object_unref);
```
"""
function glib_autoptr_cleanup_GBufferedOutputStream(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GBufferedOutputStream(_ptr::Ptr{Ptr{GBufferedOutputStream}})::Cvoid
end

"""
    glib_autoptr_destroy_GBufferedOutputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBufferedOutputStream, g_object_unref);
```
"""
function glib_autoptr_destroy_GBufferedOutputStream(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GBufferedOutputStream(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GBufferedOutputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBufferedOutputStream, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GBufferedOutputStream(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GBufferedOutputStream(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GBufferedOutputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBufferedOutputStream, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GBufferedOutputStream(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GBufferedOutputStream(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GBufferedOutputStream(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBufferedOutputStream, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GBufferedOutputStream(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GBufferedOutputStream(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GBytesIcon_autoptr = Ptr{GBytesIcon}

const GBytesIcon_listautoptr = Ptr{GList}

const GBytesIcon_slistautoptr = Ptr{GSList}

const GBytesIcon_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GBytesIcon(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBytesIcon, g_object_unref);
```
"""
function glib_autoptr_clear_GBytesIcon(_ptr)
    @ccall libaravis.glib_autoptr_clear_GBytesIcon(_ptr::Ptr{GBytesIcon})::Cvoid
end

"""
    glib_autoptr_cleanup_GBytesIcon(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBytesIcon, g_object_unref);
```
"""
function glib_autoptr_cleanup_GBytesIcon(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GBytesIcon(_ptr::Ptr{Ptr{GBytesIcon}})::Cvoid
end

"""
    glib_autoptr_destroy_GBytesIcon(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBytesIcon, g_object_unref);
```
"""
function glib_autoptr_destroy_GBytesIcon(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GBytesIcon(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GBytesIcon(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBytesIcon, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GBytesIcon(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GBytesIcon(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GBytesIcon(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBytesIcon, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GBytesIcon(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GBytesIcon(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GBytesIcon(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GBytesIcon, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GBytesIcon(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GBytesIcon(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GCancellable_autoptr = Ptr{GCancellable}

const GCancellable_listautoptr = Ptr{GList}

const GCancellable_slistautoptr = Ptr{GSList}

const GCancellable_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GCancellable(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GCancellable, g_object_unref);
```
"""
function glib_autoptr_clear_GCancellable(_ptr)
    @ccall libaravis.glib_autoptr_clear_GCancellable(_ptr::Ptr{GCancellable})::Cvoid
end

"""
    glib_autoptr_cleanup_GCancellable(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GCancellable, g_object_unref);
```
"""
function glib_autoptr_cleanup_GCancellable(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GCancellable(_ptr::Ptr{Ptr{GCancellable}})::Cvoid
end

"""
    glib_autoptr_destroy_GCancellable(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GCancellable, g_object_unref);
```
"""
function glib_autoptr_destroy_GCancellable(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GCancellable(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GCancellable(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GCancellable, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GCancellable(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GCancellable(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GCancellable(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GCancellable, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GCancellable(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GCancellable(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GCancellable(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GCancellable, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GCancellable(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GCancellable(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GCharsetConverter_autoptr = Ptr{GCharsetConverter}

const GCharsetConverter_listautoptr = Ptr{GList}

const GCharsetConverter_slistautoptr = Ptr{GSList}

const GCharsetConverter_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GCharsetConverter(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GCharsetConverter, g_object_unref);
```
"""
function glib_autoptr_clear_GCharsetConverter(_ptr)
    @ccall libaravis.glib_autoptr_clear_GCharsetConverter(_ptr::Ptr{GCharsetConverter})::Cvoid
end

"""
    glib_autoptr_cleanup_GCharsetConverter(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GCharsetConverter, g_object_unref);
```
"""
function glib_autoptr_cleanup_GCharsetConverter(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GCharsetConverter(_ptr::Ptr{Ptr{GCharsetConverter}})::Cvoid
end

"""
    glib_autoptr_destroy_GCharsetConverter(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GCharsetConverter, g_object_unref);
```
"""
function glib_autoptr_destroy_GCharsetConverter(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GCharsetConverter(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GCharsetConverter(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GCharsetConverter, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GCharsetConverter(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GCharsetConverter(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GCharsetConverter(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GCharsetConverter, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GCharsetConverter(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GCharsetConverter(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GCharsetConverter(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GCharsetConverter, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GCharsetConverter(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GCharsetConverter(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GConverter_autoptr = Ptr{GConverter}

const GConverter_listautoptr = Ptr{GList}

const GConverter_slistautoptr = Ptr{GSList}

const GConverter_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GConverter(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GConverter, g_object_unref);
```
"""
function glib_autoptr_clear_GConverter(_ptr)
    @ccall libaravis.glib_autoptr_clear_GConverter(_ptr::Ptr{GConverter})::Cvoid
end

"""
    glib_autoptr_cleanup_GConverter(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GConverter, g_object_unref);
```
"""
function glib_autoptr_cleanup_GConverter(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GConverter(_ptr::Ptr{Ptr{GConverter}})::Cvoid
end

"""
    glib_autoptr_destroy_GConverter(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GConverter, g_object_unref);
```
"""
function glib_autoptr_destroy_GConverter(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GConverter(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GConverter(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GConverter, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GConverter(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GConverter(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GConverter(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GConverter, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GConverter(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GConverter(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GConverter(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GConverter, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GConverter(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GConverter(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GConverterInputStream_autoptr = Ptr{GConverterInputStream}

const GConverterInputStream_listautoptr = Ptr{GList}

const GConverterInputStream_slistautoptr = Ptr{GSList}

const GConverterInputStream_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GConverterInputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GConverterInputStream, g_object_unref);
```
"""
function glib_autoptr_clear_GConverterInputStream(_ptr)
    @ccall libaravis.glib_autoptr_clear_GConverterInputStream(_ptr::Ptr{GConverterInputStream})::Cvoid
end

"""
    glib_autoptr_cleanup_GConverterInputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GConverterInputStream, g_object_unref);
```
"""
function glib_autoptr_cleanup_GConverterInputStream(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GConverterInputStream(_ptr::Ptr{Ptr{GConverterInputStream}})::Cvoid
end

"""
    glib_autoptr_destroy_GConverterInputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GConverterInputStream, g_object_unref);
```
"""
function glib_autoptr_destroy_GConverterInputStream(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GConverterInputStream(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GConverterInputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GConverterInputStream, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GConverterInputStream(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GConverterInputStream(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GConverterInputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GConverterInputStream, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GConverterInputStream(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GConverterInputStream(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GConverterInputStream(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GConverterInputStream, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GConverterInputStream(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GConverterInputStream(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GConverterOutputStream_autoptr = Ptr{GConverterOutputStream}

const GConverterOutputStream_listautoptr = Ptr{GList}

const GConverterOutputStream_slistautoptr = Ptr{GSList}

const GConverterOutputStream_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GConverterOutputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GConverterOutputStream, g_object_unref);
```
"""
function glib_autoptr_clear_GConverterOutputStream(_ptr)
    @ccall libaravis.glib_autoptr_clear_GConverterOutputStream(_ptr::Ptr{GConverterOutputStream})::Cvoid
end

"""
    glib_autoptr_cleanup_GConverterOutputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GConverterOutputStream, g_object_unref);
```
"""
function glib_autoptr_cleanup_GConverterOutputStream(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GConverterOutputStream(_ptr::Ptr{Ptr{GConverterOutputStream}})::Cvoid
end

"""
    glib_autoptr_destroy_GConverterOutputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GConverterOutputStream, g_object_unref);
```
"""
function glib_autoptr_destroy_GConverterOutputStream(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GConverterOutputStream(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GConverterOutputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GConverterOutputStream, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GConverterOutputStream(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GConverterOutputStream(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GConverterOutputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GConverterOutputStream, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GConverterOutputStream(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GConverterOutputStream(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GConverterOutputStream(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GConverterOutputStream, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GConverterOutputStream(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GConverterOutputStream(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GCredentials_autoptr = Ptr{GCredentials}

const GCredentials_listautoptr = Ptr{GList}

const GCredentials_slistautoptr = Ptr{GSList}

const GCredentials_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GCredentials(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GCredentials, g_object_unref);
```
"""
function glib_autoptr_clear_GCredentials(_ptr)
    @ccall libaravis.glib_autoptr_clear_GCredentials(_ptr::Ptr{GCredentials})::Cvoid
end

"""
    glib_autoptr_cleanup_GCredentials(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GCredentials, g_object_unref);
```
"""
function glib_autoptr_cleanup_GCredentials(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GCredentials(_ptr::Ptr{Ptr{GCredentials}})::Cvoid
end

"""
    glib_autoptr_destroy_GCredentials(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GCredentials, g_object_unref);
```
"""
function glib_autoptr_destroy_GCredentials(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GCredentials(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GCredentials(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GCredentials, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GCredentials(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GCredentials(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GCredentials(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GCredentials, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GCredentials(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GCredentials(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GCredentials(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GCredentials, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GCredentials(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GCredentials(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GDatagramBased_autoptr = Ptr{GDatagramBased}

const GDatagramBased_listautoptr = Ptr{GList}

const GDatagramBased_slistautoptr = Ptr{GSList}

const GDatagramBased_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GDatagramBased(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDatagramBased, g_object_unref);
```
"""
function glib_autoptr_clear_GDatagramBased(_ptr)
    @ccall libaravis.glib_autoptr_clear_GDatagramBased(_ptr::Ptr{GDatagramBased})::Cvoid
end

"""
    glib_autoptr_cleanup_GDatagramBased(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDatagramBased, g_object_unref);
```
"""
function glib_autoptr_cleanup_GDatagramBased(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GDatagramBased(_ptr::Ptr{Ptr{GDatagramBased}})::Cvoid
end

"""
    glib_autoptr_destroy_GDatagramBased(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDatagramBased, g_object_unref);
```
"""
function glib_autoptr_destroy_GDatagramBased(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GDatagramBased(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GDatagramBased(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDatagramBased, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GDatagramBased(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GDatagramBased(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GDatagramBased(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDatagramBased, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GDatagramBased(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GDatagramBased(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GDatagramBased(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDatagramBased, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GDatagramBased(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GDatagramBased(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GDataInputStream_autoptr = Ptr{GDataInputStream}

const GDataInputStream_listautoptr = Ptr{GList}

const GDataInputStream_slistautoptr = Ptr{GSList}

const GDataInputStream_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GDataInputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDataInputStream, g_object_unref);
```
"""
function glib_autoptr_clear_GDataInputStream(_ptr)
    @ccall libaravis.glib_autoptr_clear_GDataInputStream(_ptr::Ptr{GDataInputStream})::Cvoid
end

"""
    glib_autoptr_cleanup_GDataInputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDataInputStream, g_object_unref);
```
"""
function glib_autoptr_cleanup_GDataInputStream(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GDataInputStream(_ptr::Ptr{Ptr{GDataInputStream}})::Cvoid
end

"""
    glib_autoptr_destroy_GDataInputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDataInputStream, g_object_unref);
```
"""
function glib_autoptr_destroy_GDataInputStream(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GDataInputStream(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GDataInputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDataInputStream, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GDataInputStream(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GDataInputStream(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GDataInputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDataInputStream, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GDataInputStream(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GDataInputStream(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GDataInputStream(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDataInputStream, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GDataInputStream(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GDataInputStream(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GDataOutputStream_autoptr = Ptr{GDataOutputStream}

const GDataOutputStream_listautoptr = Ptr{GList}

const GDataOutputStream_slistautoptr = Ptr{GSList}

const GDataOutputStream_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GDataOutputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDataOutputStream, g_object_unref);
```
"""
function glib_autoptr_clear_GDataOutputStream(_ptr)
    @ccall libaravis.glib_autoptr_clear_GDataOutputStream(_ptr::Ptr{GDataOutputStream})::Cvoid
end

"""
    glib_autoptr_cleanup_GDataOutputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDataOutputStream, g_object_unref);
```
"""
function glib_autoptr_cleanup_GDataOutputStream(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GDataOutputStream(_ptr::Ptr{Ptr{GDataOutputStream}})::Cvoid
end

"""
    glib_autoptr_destroy_GDataOutputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDataOutputStream, g_object_unref);
```
"""
function glib_autoptr_destroy_GDataOutputStream(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GDataOutputStream(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GDataOutputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDataOutputStream, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GDataOutputStream(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GDataOutputStream(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GDataOutputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDataOutputStream, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GDataOutputStream(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GDataOutputStream(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GDataOutputStream(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDataOutputStream, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GDataOutputStream(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GDataOutputStream(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GDBusActionGroup_autoptr = Ptr{GDBusActionGroup}

const GDBusActionGroup_listautoptr = Ptr{GList}

const GDBusActionGroup_slistautoptr = Ptr{GSList}

const GDBusActionGroup_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GDBusActionGroup(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusActionGroup, g_object_unref);
```
"""
function glib_autoptr_clear_GDBusActionGroup(_ptr)
    @ccall libaravis.glib_autoptr_clear_GDBusActionGroup(_ptr::Ptr{GDBusActionGroup})::Cvoid
end

"""
    glib_autoptr_cleanup_GDBusActionGroup(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusActionGroup, g_object_unref);
```
"""
function glib_autoptr_cleanup_GDBusActionGroup(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GDBusActionGroup(_ptr::Ptr{Ptr{GDBusActionGroup}})::Cvoid
end

"""
    glib_autoptr_destroy_GDBusActionGroup(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusActionGroup, g_object_unref);
```
"""
function glib_autoptr_destroy_GDBusActionGroup(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GDBusActionGroup(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GDBusActionGroup(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusActionGroup, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GDBusActionGroup(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GDBusActionGroup(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GDBusActionGroup(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusActionGroup, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GDBusActionGroup(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GDBusActionGroup(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GDBusActionGroup(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusActionGroup, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GDBusActionGroup(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GDBusActionGroup(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GDBusAuthObserver_autoptr = Ptr{GDBusAuthObserver}

const GDBusAuthObserver_listautoptr = Ptr{GList}

const GDBusAuthObserver_slistautoptr = Ptr{GSList}

const GDBusAuthObserver_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GDBusAuthObserver(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusAuthObserver, g_object_unref);
```
"""
function glib_autoptr_clear_GDBusAuthObserver(_ptr)
    @ccall libaravis.glib_autoptr_clear_GDBusAuthObserver(_ptr::Ptr{GDBusAuthObserver})::Cvoid
end

"""
    glib_autoptr_cleanup_GDBusAuthObserver(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusAuthObserver, g_object_unref);
```
"""
function glib_autoptr_cleanup_GDBusAuthObserver(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GDBusAuthObserver(_ptr::Ptr{Ptr{GDBusAuthObserver}})::Cvoid
end

"""
    glib_autoptr_destroy_GDBusAuthObserver(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusAuthObserver, g_object_unref);
```
"""
function glib_autoptr_destroy_GDBusAuthObserver(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GDBusAuthObserver(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GDBusAuthObserver(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusAuthObserver, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GDBusAuthObserver(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GDBusAuthObserver(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GDBusAuthObserver(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusAuthObserver, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GDBusAuthObserver(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GDBusAuthObserver(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GDBusAuthObserver(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusAuthObserver, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GDBusAuthObserver(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GDBusAuthObserver(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GDBusConnection_autoptr = Ptr{GDBusConnection}

const GDBusConnection_listautoptr = Ptr{GList}

const GDBusConnection_slistautoptr = Ptr{GSList}

const GDBusConnection_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GDBusConnection(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusConnection, g_object_unref);
```
"""
function glib_autoptr_clear_GDBusConnection(_ptr)
    @ccall libaravis.glib_autoptr_clear_GDBusConnection(_ptr::Ptr{GDBusConnection})::Cvoid
end

"""
    glib_autoptr_cleanup_GDBusConnection(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusConnection, g_object_unref);
```
"""
function glib_autoptr_cleanup_GDBusConnection(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GDBusConnection(_ptr::Ptr{Ptr{GDBusConnection}})::Cvoid
end

"""
    glib_autoptr_destroy_GDBusConnection(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusConnection, g_object_unref);
```
"""
function glib_autoptr_destroy_GDBusConnection(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GDBusConnection(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GDBusConnection(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusConnection, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GDBusConnection(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GDBusConnection(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GDBusConnection(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusConnection, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GDBusConnection(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GDBusConnection(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GDBusConnection(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusConnection, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GDBusConnection(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GDBusConnection(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GDBusInterface_autoptr = Ptr{GDBusInterface}

const GDBusInterface_listautoptr = Ptr{GList}

const GDBusInterface_slistautoptr = Ptr{GSList}

const GDBusInterface_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GDBusInterface(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusInterface, g_object_unref);
```
"""
function glib_autoptr_clear_GDBusInterface(_ptr)
    @ccall libaravis.glib_autoptr_clear_GDBusInterface(_ptr::Ptr{GDBusInterface})::Cvoid
end

"""
    glib_autoptr_cleanup_GDBusInterface(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusInterface, g_object_unref);
```
"""
function glib_autoptr_cleanup_GDBusInterface(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GDBusInterface(_ptr::Ptr{Ptr{GDBusInterface}})::Cvoid
end

"""
    glib_autoptr_destroy_GDBusInterface(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusInterface, g_object_unref);
```
"""
function glib_autoptr_destroy_GDBusInterface(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GDBusInterface(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GDBusInterface(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusInterface, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GDBusInterface(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GDBusInterface(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GDBusInterface(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusInterface, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GDBusInterface(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GDBusInterface(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GDBusInterface(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusInterface, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GDBusInterface(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GDBusInterface(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GDBusInterfaceSkeleton_autoptr = Ptr{GDBusInterfaceSkeleton}

const GDBusInterfaceSkeleton_listautoptr = Ptr{GList}

const GDBusInterfaceSkeleton_slistautoptr = Ptr{GSList}

const GDBusInterfaceSkeleton_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GDBusInterfaceSkeleton(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusInterfaceSkeleton, g_object_unref);
```
"""
function glib_autoptr_clear_GDBusInterfaceSkeleton(_ptr)
    @ccall libaravis.glib_autoptr_clear_GDBusInterfaceSkeleton(_ptr::Ptr{GDBusInterfaceSkeleton})::Cvoid
end

"""
    glib_autoptr_cleanup_GDBusInterfaceSkeleton(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusInterfaceSkeleton, g_object_unref);
```
"""
function glib_autoptr_cleanup_GDBusInterfaceSkeleton(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GDBusInterfaceSkeleton(_ptr::Ptr{Ptr{GDBusInterfaceSkeleton}})::Cvoid
end

"""
    glib_autoptr_destroy_GDBusInterfaceSkeleton(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusInterfaceSkeleton, g_object_unref);
```
"""
function glib_autoptr_destroy_GDBusInterfaceSkeleton(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GDBusInterfaceSkeleton(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GDBusInterfaceSkeleton(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusInterfaceSkeleton, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GDBusInterfaceSkeleton(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GDBusInterfaceSkeleton(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GDBusInterfaceSkeleton(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusInterfaceSkeleton, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GDBusInterfaceSkeleton(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GDBusInterfaceSkeleton(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GDBusInterfaceSkeleton(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusInterfaceSkeleton, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GDBusInterfaceSkeleton(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GDBusInterfaceSkeleton(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GDBusMenuModel_autoptr = Ptr{GDBusMenuModel}

const GDBusMenuModel_listautoptr = Ptr{GList}

const GDBusMenuModel_slistautoptr = Ptr{GSList}

const GDBusMenuModel_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GDBusMenuModel(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusMenuModel, g_object_unref);
```
"""
function glib_autoptr_clear_GDBusMenuModel(_ptr)
    @ccall libaravis.glib_autoptr_clear_GDBusMenuModel(_ptr::Ptr{GDBusMenuModel})::Cvoid
end

"""
    glib_autoptr_cleanup_GDBusMenuModel(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusMenuModel, g_object_unref);
```
"""
function glib_autoptr_cleanup_GDBusMenuModel(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GDBusMenuModel(_ptr::Ptr{Ptr{GDBusMenuModel}})::Cvoid
end

"""
    glib_autoptr_destroy_GDBusMenuModel(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusMenuModel, g_object_unref);
```
"""
function glib_autoptr_destroy_GDBusMenuModel(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GDBusMenuModel(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GDBusMenuModel(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusMenuModel, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GDBusMenuModel(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GDBusMenuModel(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GDBusMenuModel(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusMenuModel, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GDBusMenuModel(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GDBusMenuModel(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GDBusMenuModel(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusMenuModel, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GDBusMenuModel(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GDBusMenuModel(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GDBusMessage_autoptr = Ptr{GDBusMessage}

const GDBusMessage_listautoptr = Ptr{GList}

const GDBusMessage_slistautoptr = Ptr{GSList}

const GDBusMessage_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GDBusMessage(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusMessage, g_object_unref);
```
"""
function glib_autoptr_clear_GDBusMessage(_ptr)
    @ccall libaravis.glib_autoptr_clear_GDBusMessage(_ptr::Ptr{GDBusMessage})::Cvoid
end

"""
    glib_autoptr_cleanup_GDBusMessage(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusMessage, g_object_unref);
```
"""
function glib_autoptr_cleanup_GDBusMessage(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GDBusMessage(_ptr::Ptr{Ptr{GDBusMessage}})::Cvoid
end

"""
    glib_autoptr_destroy_GDBusMessage(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusMessage, g_object_unref);
```
"""
function glib_autoptr_destroy_GDBusMessage(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GDBusMessage(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GDBusMessage(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusMessage, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GDBusMessage(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GDBusMessage(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GDBusMessage(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusMessage, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GDBusMessage(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GDBusMessage(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GDBusMessage(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusMessage, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GDBusMessage(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GDBusMessage(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GDBusMethodInvocation_autoptr = Ptr{GDBusMethodInvocation}

const GDBusMethodInvocation_listautoptr = Ptr{GList}

const GDBusMethodInvocation_slistautoptr = Ptr{GSList}

const GDBusMethodInvocation_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GDBusMethodInvocation(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusMethodInvocation, g_object_unref);
```
"""
function glib_autoptr_clear_GDBusMethodInvocation(_ptr)
    @ccall libaravis.glib_autoptr_clear_GDBusMethodInvocation(_ptr::Ptr{GDBusMethodInvocation})::Cvoid
end

"""
    glib_autoptr_cleanup_GDBusMethodInvocation(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusMethodInvocation, g_object_unref);
```
"""
function glib_autoptr_cleanup_GDBusMethodInvocation(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GDBusMethodInvocation(_ptr::Ptr{Ptr{GDBusMethodInvocation}})::Cvoid
end

"""
    glib_autoptr_destroy_GDBusMethodInvocation(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusMethodInvocation, g_object_unref);
```
"""
function glib_autoptr_destroy_GDBusMethodInvocation(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GDBusMethodInvocation(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GDBusMethodInvocation(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusMethodInvocation, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GDBusMethodInvocation(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GDBusMethodInvocation(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GDBusMethodInvocation(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusMethodInvocation, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GDBusMethodInvocation(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GDBusMethodInvocation(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GDBusMethodInvocation(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusMethodInvocation, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GDBusMethodInvocation(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GDBusMethodInvocation(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GDBusNodeInfo_autoptr = Ptr{GDBusNodeInfo}

const GDBusNodeInfo_listautoptr = Ptr{GList}

const GDBusNodeInfo_slistautoptr = Ptr{GSList}

const GDBusNodeInfo_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GDBusNodeInfo(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusNodeInfo, g_dbus_node_info_unref);
```
"""
function glib_autoptr_clear_GDBusNodeInfo(_ptr)
    @ccall libaravis.glib_autoptr_clear_GDBusNodeInfo(_ptr::Ptr{GDBusNodeInfo})::Cvoid
end

"""
    glib_autoptr_cleanup_GDBusNodeInfo(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusNodeInfo, g_dbus_node_info_unref);
```
"""
function glib_autoptr_cleanup_GDBusNodeInfo(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GDBusNodeInfo(_ptr::Ptr{Ptr{GDBusNodeInfo}})::Cvoid
end

"""
    glib_autoptr_destroy_GDBusNodeInfo(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusNodeInfo, g_dbus_node_info_unref);
```
"""
function glib_autoptr_destroy_GDBusNodeInfo(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GDBusNodeInfo(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GDBusNodeInfo(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusNodeInfo, g_dbus_node_info_unref);
```
"""
function glib_listautoptr_cleanup_GDBusNodeInfo(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GDBusNodeInfo(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GDBusNodeInfo(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusNodeInfo, g_dbus_node_info_unref);
```
"""
function glib_slistautoptr_cleanup_GDBusNodeInfo(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GDBusNodeInfo(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GDBusNodeInfo(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusNodeInfo, g_dbus_node_info_unref);
```
"""
function glib_queueautoptr_cleanup_GDBusNodeInfo(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GDBusNodeInfo(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GDBusObject_autoptr = Ptr{GDBusObject}

const GDBusObject_listautoptr = Ptr{GList}

const GDBusObject_slistautoptr = Ptr{GSList}

const GDBusObject_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GDBusObject(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObject, g_object_unref);
```
"""
function glib_autoptr_clear_GDBusObject(_ptr)
    @ccall libaravis.glib_autoptr_clear_GDBusObject(_ptr::Ptr{GDBusObject})::Cvoid
end

"""
    glib_autoptr_cleanup_GDBusObject(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObject, g_object_unref);
```
"""
function glib_autoptr_cleanup_GDBusObject(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GDBusObject(_ptr::Ptr{Ptr{GDBusObject}})::Cvoid
end

"""
    glib_autoptr_destroy_GDBusObject(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObject, g_object_unref);
```
"""
function glib_autoptr_destroy_GDBusObject(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GDBusObject(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GDBusObject(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObject, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GDBusObject(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GDBusObject(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GDBusObject(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObject, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GDBusObject(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GDBusObject(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GDBusObject(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObject, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GDBusObject(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GDBusObject(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GDBusObjectManagerClient_autoptr = Ptr{GDBusObjectManagerClient}

const GDBusObjectManagerClient_listautoptr = Ptr{GList}

const GDBusObjectManagerClient_slistautoptr = Ptr{GSList}

const GDBusObjectManagerClient_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GDBusObjectManagerClient(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectManagerClient, g_object_unref);
```
"""
function glib_autoptr_clear_GDBusObjectManagerClient(_ptr)
    @ccall libaravis.glib_autoptr_clear_GDBusObjectManagerClient(_ptr::Ptr{GDBusObjectManagerClient})::Cvoid
end

"""
    glib_autoptr_cleanup_GDBusObjectManagerClient(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectManagerClient, g_object_unref);
```
"""
function glib_autoptr_cleanup_GDBusObjectManagerClient(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GDBusObjectManagerClient(_ptr::Ptr{Ptr{GDBusObjectManagerClient}})::Cvoid
end

"""
    glib_autoptr_destroy_GDBusObjectManagerClient(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectManagerClient, g_object_unref);
```
"""
function glib_autoptr_destroy_GDBusObjectManagerClient(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GDBusObjectManagerClient(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GDBusObjectManagerClient(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectManagerClient, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GDBusObjectManagerClient(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GDBusObjectManagerClient(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GDBusObjectManagerClient(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectManagerClient, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GDBusObjectManagerClient(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GDBusObjectManagerClient(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GDBusObjectManagerClient(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectManagerClient, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GDBusObjectManagerClient(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GDBusObjectManagerClient(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GDBusObjectManager_autoptr = Ptr{GDBusObjectManager}

const GDBusObjectManager_listautoptr = Ptr{GList}

const GDBusObjectManager_slistautoptr = Ptr{GSList}

const GDBusObjectManager_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GDBusObjectManager(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectManager, g_object_unref);
```
"""
function glib_autoptr_clear_GDBusObjectManager(_ptr)
    @ccall libaravis.glib_autoptr_clear_GDBusObjectManager(_ptr::Ptr{GDBusObjectManager})::Cvoid
end

"""
    glib_autoptr_cleanup_GDBusObjectManager(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectManager, g_object_unref);
```
"""
function glib_autoptr_cleanup_GDBusObjectManager(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GDBusObjectManager(_ptr::Ptr{Ptr{GDBusObjectManager}})::Cvoid
end

"""
    glib_autoptr_destroy_GDBusObjectManager(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectManager, g_object_unref);
```
"""
function glib_autoptr_destroy_GDBusObjectManager(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GDBusObjectManager(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GDBusObjectManager(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectManager, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GDBusObjectManager(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GDBusObjectManager(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GDBusObjectManager(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectManager, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GDBusObjectManager(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GDBusObjectManager(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GDBusObjectManager(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectManager, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GDBusObjectManager(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GDBusObjectManager(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GDBusObjectManagerServer_autoptr = Ptr{GDBusObjectManagerServer}

const GDBusObjectManagerServer_listautoptr = Ptr{GList}

const GDBusObjectManagerServer_slistautoptr = Ptr{GSList}

const GDBusObjectManagerServer_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GDBusObjectManagerServer(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectManagerServer, g_object_unref);
```
"""
function glib_autoptr_clear_GDBusObjectManagerServer(_ptr)
    @ccall libaravis.glib_autoptr_clear_GDBusObjectManagerServer(_ptr::Ptr{GDBusObjectManagerServer})::Cvoid
end

"""
    glib_autoptr_cleanup_GDBusObjectManagerServer(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectManagerServer, g_object_unref);
```
"""
function glib_autoptr_cleanup_GDBusObjectManagerServer(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GDBusObjectManagerServer(_ptr::Ptr{Ptr{GDBusObjectManagerServer}})::Cvoid
end

"""
    glib_autoptr_destroy_GDBusObjectManagerServer(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectManagerServer, g_object_unref);
```
"""
function glib_autoptr_destroy_GDBusObjectManagerServer(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GDBusObjectManagerServer(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GDBusObjectManagerServer(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectManagerServer, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GDBusObjectManagerServer(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GDBusObjectManagerServer(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GDBusObjectManagerServer(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectManagerServer, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GDBusObjectManagerServer(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GDBusObjectManagerServer(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GDBusObjectManagerServer(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectManagerServer, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GDBusObjectManagerServer(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GDBusObjectManagerServer(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GDBusObjectProxy_autoptr = Ptr{GDBusObjectProxy}

const GDBusObjectProxy_listautoptr = Ptr{GList}

const GDBusObjectProxy_slistautoptr = Ptr{GSList}

const GDBusObjectProxy_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GDBusObjectProxy(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectProxy, g_object_unref);
```
"""
function glib_autoptr_clear_GDBusObjectProxy(_ptr)
    @ccall libaravis.glib_autoptr_clear_GDBusObjectProxy(_ptr::Ptr{GDBusObjectProxy})::Cvoid
end

"""
    glib_autoptr_cleanup_GDBusObjectProxy(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectProxy, g_object_unref);
```
"""
function glib_autoptr_cleanup_GDBusObjectProxy(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GDBusObjectProxy(_ptr::Ptr{Ptr{GDBusObjectProxy}})::Cvoid
end

"""
    glib_autoptr_destroy_GDBusObjectProxy(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectProxy, g_object_unref);
```
"""
function glib_autoptr_destroy_GDBusObjectProxy(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GDBusObjectProxy(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GDBusObjectProxy(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectProxy, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GDBusObjectProxy(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GDBusObjectProxy(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GDBusObjectProxy(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectProxy, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GDBusObjectProxy(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GDBusObjectProxy(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GDBusObjectProxy(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectProxy, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GDBusObjectProxy(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GDBusObjectProxy(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GDBusObjectSkeleton_autoptr = Ptr{GDBusObjectSkeleton}

const GDBusObjectSkeleton_listautoptr = Ptr{GList}

const GDBusObjectSkeleton_slistautoptr = Ptr{GSList}

const GDBusObjectSkeleton_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GDBusObjectSkeleton(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectSkeleton, g_object_unref);
```
"""
function glib_autoptr_clear_GDBusObjectSkeleton(_ptr)
    @ccall libaravis.glib_autoptr_clear_GDBusObjectSkeleton(_ptr::Ptr{GDBusObjectSkeleton})::Cvoid
end

"""
    glib_autoptr_cleanup_GDBusObjectSkeleton(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectSkeleton, g_object_unref);
```
"""
function glib_autoptr_cleanup_GDBusObjectSkeleton(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GDBusObjectSkeleton(_ptr::Ptr{Ptr{GDBusObjectSkeleton}})::Cvoid
end

"""
    glib_autoptr_destroy_GDBusObjectSkeleton(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectSkeleton, g_object_unref);
```
"""
function glib_autoptr_destroy_GDBusObjectSkeleton(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GDBusObjectSkeleton(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GDBusObjectSkeleton(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectSkeleton, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GDBusObjectSkeleton(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GDBusObjectSkeleton(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GDBusObjectSkeleton(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectSkeleton, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GDBusObjectSkeleton(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GDBusObjectSkeleton(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GDBusObjectSkeleton(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusObjectSkeleton, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GDBusObjectSkeleton(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GDBusObjectSkeleton(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GDBusProxy_autoptr = Ptr{GDBusProxy}

const GDBusProxy_listautoptr = Ptr{GList}

const GDBusProxy_slistautoptr = Ptr{GSList}

const GDBusProxy_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GDBusProxy(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusProxy, g_object_unref);
```
"""
function glib_autoptr_clear_GDBusProxy(_ptr)
    @ccall libaravis.glib_autoptr_clear_GDBusProxy(_ptr::Ptr{GDBusProxy})::Cvoid
end

"""
    glib_autoptr_cleanup_GDBusProxy(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusProxy, g_object_unref);
```
"""
function glib_autoptr_cleanup_GDBusProxy(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GDBusProxy(_ptr::Ptr{Ptr{GDBusProxy}})::Cvoid
end

"""
    glib_autoptr_destroy_GDBusProxy(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusProxy, g_object_unref);
```
"""
function glib_autoptr_destroy_GDBusProxy(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GDBusProxy(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GDBusProxy(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusProxy, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GDBusProxy(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GDBusProxy(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GDBusProxy(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusProxy, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GDBusProxy(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GDBusProxy(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GDBusProxy(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusProxy, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GDBusProxy(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GDBusProxy(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GDBusServer_autoptr = Ptr{GDBusServer}

const GDBusServer_listautoptr = Ptr{GList}

const GDBusServer_slistautoptr = Ptr{GSList}

const GDBusServer_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GDBusServer(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusServer, g_object_unref);
```
"""
function glib_autoptr_clear_GDBusServer(_ptr)
    @ccall libaravis.glib_autoptr_clear_GDBusServer(_ptr::Ptr{GDBusServer})::Cvoid
end

"""
    glib_autoptr_cleanup_GDBusServer(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusServer, g_object_unref);
```
"""
function glib_autoptr_cleanup_GDBusServer(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GDBusServer(_ptr::Ptr{Ptr{GDBusServer}})::Cvoid
end

"""
    glib_autoptr_destroy_GDBusServer(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusServer, g_object_unref);
```
"""
function glib_autoptr_destroy_GDBusServer(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GDBusServer(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GDBusServer(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusServer, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GDBusServer(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GDBusServer(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GDBusServer(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusServer, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GDBusServer(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GDBusServer(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GDBusServer(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDBusServer, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GDBusServer(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GDBusServer(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GDrive_autoptr = Ptr{GDrive}

const GDrive_listautoptr = Ptr{GList}

const GDrive_slistautoptr = Ptr{GSList}

const GDrive_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GDrive(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDrive, g_object_unref);
```
"""
function glib_autoptr_clear_GDrive(_ptr)
    @ccall libaravis.glib_autoptr_clear_GDrive(_ptr::Ptr{GDrive})::Cvoid
end

"""
    glib_autoptr_cleanup_GDrive(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDrive, g_object_unref);
```
"""
function glib_autoptr_cleanup_GDrive(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GDrive(_ptr::Ptr{Ptr{GDrive}})::Cvoid
end

"""
    glib_autoptr_destroy_GDrive(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDrive, g_object_unref);
```
"""
function glib_autoptr_destroy_GDrive(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GDrive(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GDrive(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDrive, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GDrive(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GDrive(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GDrive(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDrive, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GDrive(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GDrive(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GDrive(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GDrive, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GDrive(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GDrive(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GEmblemedIcon_autoptr = Ptr{GEmblemedIcon}

const GEmblemedIcon_listautoptr = Ptr{GList}

const GEmblemedIcon_slistautoptr = Ptr{GSList}

const GEmblemedIcon_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GEmblemedIcon(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GEmblemedIcon, g_object_unref);
```
"""
function glib_autoptr_clear_GEmblemedIcon(_ptr)
    @ccall libaravis.glib_autoptr_clear_GEmblemedIcon(_ptr::Ptr{GEmblemedIcon})::Cvoid
end

"""
    glib_autoptr_cleanup_GEmblemedIcon(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GEmblemedIcon, g_object_unref);
```
"""
function glib_autoptr_cleanup_GEmblemedIcon(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GEmblemedIcon(_ptr::Ptr{Ptr{GEmblemedIcon}})::Cvoid
end

"""
    glib_autoptr_destroy_GEmblemedIcon(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GEmblemedIcon, g_object_unref);
```
"""
function glib_autoptr_destroy_GEmblemedIcon(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GEmblemedIcon(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GEmblemedIcon(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GEmblemedIcon, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GEmblemedIcon(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GEmblemedIcon(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GEmblemedIcon(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GEmblemedIcon, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GEmblemedIcon(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GEmblemedIcon(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GEmblemedIcon(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GEmblemedIcon, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GEmblemedIcon(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GEmblemedIcon(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GEmblem_autoptr = Ptr{GEmblem}

const GEmblem_listautoptr = Ptr{GList}

const GEmblem_slistautoptr = Ptr{GSList}

const GEmblem_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GEmblem(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GEmblem, g_object_unref);
```
"""
function glib_autoptr_clear_GEmblem(_ptr)
    @ccall libaravis.glib_autoptr_clear_GEmblem(_ptr::Ptr{GEmblem})::Cvoid
end

"""
    glib_autoptr_cleanup_GEmblem(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GEmblem, g_object_unref);
```
"""
function glib_autoptr_cleanup_GEmblem(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GEmblem(_ptr::Ptr{Ptr{GEmblem}})::Cvoid
end

"""
    glib_autoptr_destroy_GEmblem(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GEmblem, g_object_unref);
```
"""
function glib_autoptr_destroy_GEmblem(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GEmblem(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GEmblem(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GEmblem, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GEmblem(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GEmblem(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GEmblem(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GEmblem, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GEmblem(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GEmblem(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GEmblem(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GEmblem, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GEmblem(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GEmblem(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GFileEnumerator_autoptr = Ptr{GFileEnumerator}

const GFileEnumerator_listautoptr = Ptr{GList}

const GFileEnumerator_slistautoptr = Ptr{GSList}

const GFileEnumerator_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GFileEnumerator(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileEnumerator, g_object_unref);
```
"""
function glib_autoptr_clear_GFileEnumerator(_ptr)
    @ccall libaravis.glib_autoptr_clear_GFileEnumerator(_ptr::Ptr{GFileEnumerator})::Cvoid
end

"""
    glib_autoptr_cleanup_GFileEnumerator(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileEnumerator, g_object_unref);
```
"""
function glib_autoptr_cleanup_GFileEnumerator(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GFileEnumerator(_ptr::Ptr{Ptr{GFileEnumerator}})::Cvoid
end

"""
    glib_autoptr_destroy_GFileEnumerator(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileEnumerator, g_object_unref);
```
"""
function glib_autoptr_destroy_GFileEnumerator(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GFileEnumerator(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GFileEnumerator(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileEnumerator, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GFileEnumerator(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GFileEnumerator(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GFileEnumerator(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileEnumerator, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GFileEnumerator(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GFileEnumerator(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GFileEnumerator(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileEnumerator, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GFileEnumerator(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GFileEnumerator(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GFile_autoptr = Ptr{GFile}

const GFile_listautoptr = Ptr{GList}

const GFile_slistautoptr = Ptr{GSList}

const GFile_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GFile(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFile, g_object_unref);
```
"""
function glib_autoptr_clear_GFile(_ptr)
    @ccall libaravis.glib_autoptr_clear_GFile(_ptr::Ptr{GFile})::Cvoid
end

"""
    glib_autoptr_cleanup_GFile(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFile, g_object_unref);
```
"""
function glib_autoptr_cleanup_GFile(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GFile(_ptr::Ptr{Ptr{GFile}})::Cvoid
end

"""
    glib_autoptr_destroy_GFile(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFile, g_object_unref);
```
"""
function glib_autoptr_destroy_GFile(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GFile(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GFile(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFile, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GFile(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GFile(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GFile(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFile, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GFile(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GFile(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GFile(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFile, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GFile(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GFile(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GFileAttributeInfoList_autoptr = Ptr{GFileAttributeInfoList}

const GFileAttributeInfoList_listautoptr = Ptr{GList}

const GFileAttributeInfoList_slistautoptr = Ptr{GSList}

const GFileAttributeInfoList_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GFileAttributeInfoList(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileAttributeInfoList, g_file_attribute_info_list_unref);
```
"""
function glib_autoptr_clear_GFileAttributeInfoList(_ptr)
    @ccall libaravis.glib_autoptr_clear_GFileAttributeInfoList(_ptr::Ptr{GFileAttributeInfoList})::Cvoid
end

"""
    glib_autoptr_cleanup_GFileAttributeInfoList(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileAttributeInfoList, g_file_attribute_info_list_unref);
```
"""
function glib_autoptr_cleanup_GFileAttributeInfoList(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GFileAttributeInfoList(_ptr::Ptr{Ptr{GFileAttributeInfoList}})::Cvoid
end

"""
    glib_autoptr_destroy_GFileAttributeInfoList(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileAttributeInfoList, g_file_attribute_info_list_unref);
```
"""
function glib_autoptr_destroy_GFileAttributeInfoList(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GFileAttributeInfoList(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GFileAttributeInfoList(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileAttributeInfoList, g_file_attribute_info_list_unref);
```
"""
function glib_listautoptr_cleanup_GFileAttributeInfoList(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GFileAttributeInfoList(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GFileAttributeInfoList(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileAttributeInfoList, g_file_attribute_info_list_unref);
```
"""
function glib_slistautoptr_cleanup_GFileAttributeInfoList(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GFileAttributeInfoList(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GFileAttributeInfoList(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileAttributeInfoList, g_file_attribute_info_list_unref);
```
"""
function glib_queueautoptr_cleanup_GFileAttributeInfoList(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GFileAttributeInfoList(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GFileIcon_autoptr = Ptr{GFileIcon}

const GFileIcon_listautoptr = Ptr{GList}

const GFileIcon_slistautoptr = Ptr{GSList}

const GFileIcon_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GFileIcon(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileIcon, g_object_unref);
```
"""
function glib_autoptr_clear_GFileIcon(_ptr)
    @ccall libaravis.glib_autoptr_clear_GFileIcon(_ptr::Ptr{GFileIcon})::Cvoid
end

"""
    glib_autoptr_cleanup_GFileIcon(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileIcon, g_object_unref);
```
"""
function glib_autoptr_cleanup_GFileIcon(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GFileIcon(_ptr::Ptr{Ptr{GFileIcon}})::Cvoid
end

"""
    glib_autoptr_destroy_GFileIcon(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileIcon, g_object_unref);
```
"""
function glib_autoptr_destroy_GFileIcon(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GFileIcon(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GFileIcon(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileIcon, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GFileIcon(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GFileIcon(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GFileIcon(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileIcon, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GFileIcon(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GFileIcon(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GFileIcon(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileIcon, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GFileIcon(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GFileIcon(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GFileInfo_autoptr = Ptr{GFileInfo}

const GFileInfo_listautoptr = Ptr{GList}

const GFileInfo_slistautoptr = Ptr{GSList}

const GFileInfo_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GFileInfo(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileInfo, g_object_unref);
```
"""
function glib_autoptr_clear_GFileInfo(_ptr)
    @ccall libaravis.glib_autoptr_clear_GFileInfo(_ptr::Ptr{GFileInfo})::Cvoid
end

"""
    glib_autoptr_cleanup_GFileInfo(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileInfo, g_object_unref);
```
"""
function glib_autoptr_cleanup_GFileInfo(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GFileInfo(_ptr::Ptr{Ptr{GFileInfo}})::Cvoid
end

"""
    glib_autoptr_destroy_GFileInfo(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileInfo, g_object_unref);
```
"""
function glib_autoptr_destroy_GFileInfo(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GFileInfo(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GFileInfo(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileInfo, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GFileInfo(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GFileInfo(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GFileInfo(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileInfo, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GFileInfo(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GFileInfo(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GFileInfo(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileInfo, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GFileInfo(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GFileInfo(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GFileInputStream_autoptr = Ptr{GFileInputStream}

const GFileInputStream_listautoptr = Ptr{GList}

const GFileInputStream_slistautoptr = Ptr{GSList}

const GFileInputStream_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GFileInputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileInputStream, g_object_unref);
```
"""
function glib_autoptr_clear_GFileInputStream(_ptr)
    @ccall libaravis.glib_autoptr_clear_GFileInputStream(_ptr::Ptr{GFileInputStream})::Cvoid
end

"""
    glib_autoptr_cleanup_GFileInputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileInputStream, g_object_unref);
```
"""
function glib_autoptr_cleanup_GFileInputStream(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GFileInputStream(_ptr::Ptr{Ptr{GFileInputStream}})::Cvoid
end

"""
    glib_autoptr_destroy_GFileInputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileInputStream, g_object_unref);
```
"""
function glib_autoptr_destroy_GFileInputStream(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GFileInputStream(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GFileInputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileInputStream, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GFileInputStream(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GFileInputStream(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GFileInputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileInputStream, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GFileInputStream(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GFileInputStream(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GFileInputStream(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileInputStream, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GFileInputStream(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GFileInputStream(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GFileIOStream_autoptr = Ptr{GFileIOStream}

const GFileIOStream_listautoptr = Ptr{GList}

const GFileIOStream_slistautoptr = Ptr{GSList}

const GFileIOStream_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GFileIOStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileIOStream, g_object_unref);
```
"""
function glib_autoptr_clear_GFileIOStream(_ptr)
    @ccall libaravis.glib_autoptr_clear_GFileIOStream(_ptr::Ptr{GFileIOStream})::Cvoid
end

"""
    glib_autoptr_cleanup_GFileIOStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileIOStream, g_object_unref);
```
"""
function glib_autoptr_cleanup_GFileIOStream(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GFileIOStream(_ptr::Ptr{Ptr{GFileIOStream}})::Cvoid
end

"""
    glib_autoptr_destroy_GFileIOStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileIOStream, g_object_unref);
```
"""
function glib_autoptr_destroy_GFileIOStream(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GFileIOStream(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GFileIOStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileIOStream, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GFileIOStream(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GFileIOStream(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GFileIOStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileIOStream, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GFileIOStream(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GFileIOStream(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GFileIOStream(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileIOStream, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GFileIOStream(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GFileIOStream(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GFileMonitor_autoptr = Ptr{GFileMonitor}

const GFileMonitor_listautoptr = Ptr{GList}

const GFileMonitor_slistautoptr = Ptr{GSList}

const GFileMonitor_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GFileMonitor(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileMonitor, g_object_unref);
```
"""
function glib_autoptr_clear_GFileMonitor(_ptr)
    @ccall libaravis.glib_autoptr_clear_GFileMonitor(_ptr::Ptr{GFileMonitor})::Cvoid
end

"""
    glib_autoptr_cleanup_GFileMonitor(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileMonitor, g_object_unref);
```
"""
function glib_autoptr_cleanup_GFileMonitor(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GFileMonitor(_ptr::Ptr{Ptr{GFileMonitor}})::Cvoid
end

"""
    glib_autoptr_destroy_GFileMonitor(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileMonitor, g_object_unref);
```
"""
function glib_autoptr_destroy_GFileMonitor(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GFileMonitor(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GFileMonitor(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileMonitor, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GFileMonitor(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GFileMonitor(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GFileMonitor(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileMonitor, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GFileMonitor(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GFileMonitor(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GFileMonitor(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileMonitor, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GFileMonitor(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GFileMonitor(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GFilenameCompleter_autoptr = Ptr{GFilenameCompleter}

const GFilenameCompleter_listautoptr = Ptr{GList}

const GFilenameCompleter_slistautoptr = Ptr{GSList}

const GFilenameCompleter_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GFilenameCompleter(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFilenameCompleter, g_object_unref);
```
"""
function glib_autoptr_clear_GFilenameCompleter(_ptr)
    @ccall libaravis.glib_autoptr_clear_GFilenameCompleter(_ptr::Ptr{GFilenameCompleter})::Cvoid
end

"""
    glib_autoptr_cleanup_GFilenameCompleter(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFilenameCompleter, g_object_unref);
```
"""
function glib_autoptr_cleanup_GFilenameCompleter(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GFilenameCompleter(_ptr::Ptr{Ptr{GFilenameCompleter}})::Cvoid
end

"""
    glib_autoptr_destroy_GFilenameCompleter(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFilenameCompleter, g_object_unref);
```
"""
function glib_autoptr_destroy_GFilenameCompleter(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GFilenameCompleter(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GFilenameCompleter(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFilenameCompleter, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GFilenameCompleter(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GFilenameCompleter(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GFilenameCompleter(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFilenameCompleter, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GFilenameCompleter(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GFilenameCompleter(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GFilenameCompleter(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFilenameCompleter, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GFilenameCompleter(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GFilenameCompleter(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GFileOutputStream_autoptr = Ptr{GFileOutputStream}

const GFileOutputStream_listautoptr = Ptr{GList}

const GFileOutputStream_slistautoptr = Ptr{GSList}

const GFileOutputStream_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GFileOutputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileOutputStream, g_object_unref);
```
"""
function glib_autoptr_clear_GFileOutputStream(_ptr)
    @ccall libaravis.glib_autoptr_clear_GFileOutputStream(_ptr::Ptr{GFileOutputStream})::Cvoid
end

"""
    glib_autoptr_cleanup_GFileOutputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileOutputStream, g_object_unref);
```
"""
function glib_autoptr_cleanup_GFileOutputStream(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GFileOutputStream(_ptr::Ptr{Ptr{GFileOutputStream}})::Cvoid
end

"""
    glib_autoptr_destroy_GFileOutputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileOutputStream, g_object_unref);
```
"""
function glib_autoptr_destroy_GFileOutputStream(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GFileOutputStream(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GFileOutputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileOutputStream, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GFileOutputStream(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GFileOutputStream(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GFileOutputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileOutputStream, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GFileOutputStream(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GFileOutputStream(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GFileOutputStream(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFileOutputStream, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GFileOutputStream(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GFileOutputStream(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GFilterInputStream_autoptr = Ptr{GFilterInputStream}

const GFilterInputStream_listautoptr = Ptr{GList}

const GFilterInputStream_slistautoptr = Ptr{GSList}

const GFilterInputStream_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GFilterInputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFilterInputStream, g_object_unref);
```
"""
function glib_autoptr_clear_GFilterInputStream(_ptr)
    @ccall libaravis.glib_autoptr_clear_GFilterInputStream(_ptr::Ptr{GFilterInputStream})::Cvoid
end

"""
    glib_autoptr_cleanup_GFilterInputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFilterInputStream, g_object_unref);
```
"""
function glib_autoptr_cleanup_GFilterInputStream(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GFilterInputStream(_ptr::Ptr{Ptr{GFilterInputStream}})::Cvoid
end

"""
    glib_autoptr_destroy_GFilterInputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFilterInputStream, g_object_unref);
```
"""
function glib_autoptr_destroy_GFilterInputStream(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GFilterInputStream(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GFilterInputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFilterInputStream, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GFilterInputStream(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GFilterInputStream(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GFilterInputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFilterInputStream, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GFilterInputStream(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GFilterInputStream(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GFilterInputStream(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFilterInputStream, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GFilterInputStream(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GFilterInputStream(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GFilterOutputStream_autoptr = Ptr{GFilterOutputStream}

const GFilterOutputStream_listautoptr = Ptr{GList}

const GFilterOutputStream_slistautoptr = Ptr{GSList}

const GFilterOutputStream_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GFilterOutputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFilterOutputStream, g_object_unref);
```
"""
function glib_autoptr_clear_GFilterOutputStream(_ptr)
    @ccall libaravis.glib_autoptr_clear_GFilterOutputStream(_ptr::Ptr{GFilterOutputStream})::Cvoid
end

"""
    glib_autoptr_cleanup_GFilterOutputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFilterOutputStream, g_object_unref);
```
"""
function glib_autoptr_cleanup_GFilterOutputStream(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GFilterOutputStream(_ptr::Ptr{Ptr{GFilterOutputStream}})::Cvoid
end

"""
    glib_autoptr_destroy_GFilterOutputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFilterOutputStream, g_object_unref);
```
"""
function glib_autoptr_destroy_GFilterOutputStream(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GFilterOutputStream(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GFilterOutputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFilterOutputStream, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GFilterOutputStream(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GFilterOutputStream(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GFilterOutputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFilterOutputStream, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GFilterOutputStream(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GFilterOutputStream(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GFilterOutputStream(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GFilterOutputStream, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GFilterOutputStream(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GFilterOutputStream(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GIcon_autoptr = Ptr{GIcon}

const GIcon_listautoptr = Ptr{GList}

const GIcon_slistautoptr = Ptr{GSList}

const GIcon_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GIcon(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GIcon, g_object_unref);
```
"""
function glib_autoptr_clear_GIcon(_ptr)
    @ccall libaravis.glib_autoptr_clear_GIcon(_ptr::Ptr{GIcon})::Cvoid
end

"""
    glib_autoptr_cleanup_GIcon(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GIcon, g_object_unref);
```
"""
function glib_autoptr_cleanup_GIcon(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GIcon(_ptr::Ptr{Ptr{GIcon}})::Cvoid
end

"""
    glib_autoptr_destroy_GIcon(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GIcon, g_object_unref);
```
"""
function glib_autoptr_destroy_GIcon(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GIcon(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GIcon(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GIcon, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GIcon(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GIcon(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GIcon(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GIcon, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GIcon(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GIcon(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GIcon(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GIcon, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GIcon(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GIcon(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GInetAddress_autoptr = Ptr{GInetAddress}

const GInetAddress_listautoptr = Ptr{GList}

const GInetAddress_slistautoptr = Ptr{GSList}

const GInetAddress_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GInetAddress(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInetAddress, g_object_unref);
```
"""
function glib_autoptr_clear_GInetAddress(_ptr)
    @ccall libaravis.glib_autoptr_clear_GInetAddress(_ptr::Ptr{GInetAddress})::Cvoid
end

"""
    glib_autoptr_cleanup_GInetAddress(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInetAddress, g_object_unref);
```
"""
function glib_autoptr_cleanup_GInetAddress(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GInetAddress(_ptr::Ptr{Ptr{GInetAddress}})::Cvoid
end

"""
    glib_autoptr_destroy_GInetAddress(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInetAddress, g_object_unref);
```
"""
function glib_autoptr_destroy_GInetAddress(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GInetAddress(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GInetAddress(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInetAddress, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GInetAddress(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GInetAddress(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GInetAddress(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInetAddress, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GInetAddress(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GInetAddress(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GInetAddress(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInetAddress, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GInetAddress(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GInetAddress(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GInetAddressMask_autoptr = Ptr{GInetAddressMask}

const GInetAddressMask_listautoptr = Ptr{GList}

const GInetAddressMask_slistautoptr = Ptr{GSList}

const GInetAddressMask_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GInetAddressMask(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInetAddressMask, g_object_unref);
```
"""
function glib_autoptr_clear_GInetAddressMask(_ptr)
    @ccall libaravis.glib_autoptr_clear_GInetAddressMask(_ptr::Ptr{GInetAddressMask})::Cvoid
end

"""
    glib_autoptr_cleanup_GInetAddressMask(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInetAddressMask, g_object_unref);
```
"""
function glib_autoptr_cleanup_GInetAddressMask(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GInetAddressMask(_ptr::Ptr{Ptr{GInetAddressMask}})::Cvoid
end

"""
    glib_autoptr_destroy_GInetAddressMask(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInetAddressMask, g_object_unref);
```
"""
function glib_autoptr_destroy_GInetAddressMask(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GInetAddressMask(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GInetAddressMask(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInetAddressMask, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GInetAddressMask(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GInetAddressMask(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GInetAddressMask(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInetAddressMask, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GInetAddressMask(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GInetAddressMask(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GInetAddressMask(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInetAddressMask, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GInetAddressMask(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GInetAddressMask(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GInetSocketAddress_autoptr = Ptr{GInetSocketAddress}

const GInetSocketAddress_listautoptr = Ptr{GList}

const GInetSocketAddress_slistautoptr = Ptr{GSList}

const GInetSocketAddress_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GInetSocketAddress(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInetSocketAddress, g_object_unref);
```
"""
function glib_autoptr_clear_GInetSocketAddress(_ptr)
    @ccall libaravis.glib_autoptr_clear_GInetSocketAddress(_ptr::Ptr{GInetSocketAddress})::Cvoid
end

"""
    glib_autoptr_cleanup_GInetSocketAddress(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInetSocketAddress, g_object_unref);
```
"""
function glib_autoptr_cleanup_GInetSocketAddress(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GInetSocketAddress(_ptr::Ptr{Ptr{GInetSocketAddress}})::Cvoid
end

"""
    glib_autoptr_destroy_GInetSocketAddress(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInetSocketAddress, g_object_unref);
```
"""
function glib_autoptr_destroy_GInetSocketAddress(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GInetSocketAddress(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GInetSocketAddress(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInetSocketAddress, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GInetSocketAddress(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GInetSocketAddress(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GInetSocketAddress(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInetSocketAddress, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GInetSocketAddress(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GInetSocketAddress(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GInetSocketAddress(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInetSocketAddress, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GInetSocketAddress(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GInetSocketAddress(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GInitable_autoptr = Ptr{GInitable}

const GInitable_listautoptr = Ptr{GList}

const GInitable_slistautoptr = Ptr{GSList}

const GInitable_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GInitable(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInitable, g_object_unref);
```
"""
function glib_autoptr_clear_GInitable(_ptr)
    @ccall libaravis.glib_autoptr_clear_GInitable(_ptr::Ptr{GInitable})::Cvoid
end

"""
    glib_autoptr_cleanup_GInitable(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInitable, g_object_unref);
```
"""
function glib_autoptr_cleanup_GInitable(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GInitable(_ptr::Ptr{Ptr{GInitable}})::Cvoid
end

"""
    glib_autoptr_destroy_GInitable(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInitable, g_object_unref);
```
"""
function glib_autoptr_destroy_GInitable(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GInitable(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GInitable(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInitable, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GInitable(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GInitable(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GInitable(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInitable, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GInitable(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GInitable(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GInitable(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInitable, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GInitable(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GInitable(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GInputStream_autoptr = Ptr{GInputStream}

const GInputStream_listautoptr = Ptr{GList}

const GInputStream_slistautoptr = Ptr{GSList}

const GInputStream_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GInputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInputStream, g_object_unref);
```
"""
function glib_autoptr_clear_GInputStream(_ptr)
    @ccall libaravis.glib_autoptr_clear_GInputStream(_ptr::Ptr{GInputStream})::Cvoid
end

"""
    glib_autoptr_cleanup_GInputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInputStream, g_object_unref);
```
"""
function glib_autoptr_cleanup_GInputStream(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GInputStream(_ptr::Ptr{Ptr{GInputStream}})::Cvoid
end

"""
    glib_autoptr_destroy_GInputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInputStream, g_object_unref);
```
"""
function glib_autoptr_destroy_GInputStream(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GInputStream(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GInputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInputStream, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GInputStream(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GInputStream(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GInputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInputStream, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GInputStream(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GInputStream(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GInputStream(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GInputStream, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GInputStream(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GInputStream(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GIOModule_autoptr = Ptr{GIOModule}

const GIOModule_listautoptr = Ptr{GList}

const GIOModule_slistautoptr = Ptr{GSList}

const GIOModule_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GIOModule(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GIOModule, g_object_unref);
```
"""
function glib_autoptr_clear_GIOModule(_ptr)
    @ccall libaravis.glib_autoptr_clear_GIOModule(_ptr::Ptr{GIOModule})::Cvoid
end

"""
    glib_autoptr_cleanup_GIOModule(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GIOModule, g_object_unref);
```
"""
function glib_autoptr_cleanup_GIOModule(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GIOModule(_ptr::Ptr{Ptr{GIOModule}})::Cvoid
end

"""
    glib_autoptr_destroy_GIOModule(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GIOModule, g_object_unref);
```
"""
function glib_autoptr_destroy_GIOModule(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GIOModule(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GIOModule(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GIOModule, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GIOModule(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GIOModule(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GIOModule(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GIOModule, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GIOModule(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GIOModule(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GIOModule(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GIOModule, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GIOModule(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GIOModule(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GIOStream_autoptr = Ptr{GIOStream}

const GIOStream_listautoptr = Ptr{GList}

const GIOStream_slistautoptr = Ptr{GSList}

const GIOStream_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GIOStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GIOStream, g_object_unref);
```
"""
function glib_autoptr_clear_GIOStream(_ptr)
    @ccall libaravis.glib_autoptr_clear_GIOStream(_ptr::Ptr{GIOStream})::Cvoid
end

"""
    glib_autoptr_cleanup_GIOStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GIOStream, g_object_unref);
```
"""
function glib_autoptr_cleanup_GIOStream(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GIOStream(_ptr::Ptr{Ptr{GIOStream}})::Cvoid
end

"""
    glib_autoptr_destroy_GIOStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GIOStream, g_object_unref);
```
"""
function glib_autoptr_destroy_GIOStream(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GIOStream(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GIOStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GIOStream, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GIOStream(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GIOStream(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GIOStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GIOStream, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GIOStream(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GIOStream(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GIOStream(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GIOStream, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GIOStream(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GIOStream(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GLoadableIcon_autoptr = Ptr{GLoadableIcon}

const GLoadableIcon_listautoptr = Ptr{GList}

const GLoadableIcon_slistautoptr = Ptr{GSList}

const GLoadableIcon_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GLoadableIcon(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GLoadableIcon, g_object_unref);
```
"""
function glib_autoptr_clear_GLoadableIcon(_ptr)
    @ccall libaravis.glib_autoptr_clear_GLoadableIcon(_ptr::Ptr{GLoadableIcon})::Cvoid
end

"""
    glib_autoptr_cleanup_GLoadableIcon(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GLoadableIcon, g_object_unref);
```
"""
function glib_autoptr_cleanup_GLoadableIcon(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GLoadableIcon(_ptr::Ptr{Ptr{GLoadableIcon}})::Cvoid
end

"""
    glib_autoptr_destroy_GLoadableIcon(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GLoadableIcon, g_object_unref);
```
"""
function glib_autoptr_destroy_GLoadableIcon(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GLoadableIcon(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GLoadableIcon(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GLoadableIcon, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GLoadableIcon(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GLoadableIcon(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GLoadableIcon(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GLoadableIcon, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GLoadableIcon(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GLoadableIcon(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GLoadableIcon(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GLoadableIcon, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GLoadableIcon(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GLoadableIcon(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GMemoryInputStream_autoptr = Ptr{GMemoryInputStream}

const GMemoryInputStream_listautoptr = Ptr{GList}

const GMemoryInputStream_slistautoptr = Ptr{GSList}

const GMemoryInputStream_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GMemoryInputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMemoryInputStream, g_object_unref);
```
"""
function glib_autoptr_clear_GMemoryInputStream(_ptr)
    @ccall libaravis.glib_autoptr_clear_GMemoryInputStream(_ptr::Ptr{GMemoryInputStream})::Cvoid
end

"""
    glib_autoptr_cleanup_GMemoryInputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMemoryInputStream, g_object_unref);
```
"""
function glib_autoptr_cleanup_GMemoryInputStream(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GMemoryInputStream(_ptr::Ptr{Ptr{GMemoryInputStream}})::Cvoid
end

"""
    glib_autoptr_destroy_GMemoryInputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMemoryInputStream, g_object_unref);
```
"""
function glib_autoptr_destroy_GMemoryInputStream(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GMemoryInputStream(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GMemoryInputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMemoryInputStream, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GMemoryInputStream(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GMemoryInputStream(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GMemoryInputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMemoryInputStream, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GMemoryInputStream(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GMemoryInputStream(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GMemoryInputStream(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMemoryInputStream, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GMemoryInputStream(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GMemoryInputStream(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GMemoryOutputStream_autoptr = Ptr{GMemoryOutputStream}

const GMemoryOutputStream_listautoptr = Ptr{GList}

const GMemoryOutputStream_slistautoptr = Ptr{GSList}

const GMemoryOutputStream_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GMemoryOutputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMemoryOutputStream, g_object_unref);
```
"""
function glib_autoptr_clear_GMemoryOutputStream(_ptr)
    @ccall libaravis.glib_autoptr_clear_GMemoryOutputStream(_ptr::Ptr{GMemoryOutputStream})::Cvoid
end

"""
    glib_autoptr_cleanup_GMemoryOutputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMemoryOutputStream, g_object_unref);
```
"""
function glib_autoptr_cleanup_GMemoryOutputStream(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GMemoryOutputStream(_ptr::Ptr{Ptr{GMemoryOutputStream}})::Cvoid
end

"""
    glib_autoptr_destroy_GMemoryOutputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMemoryOutputStream, g_object_unref);
```
"""
function glib_autoptr_destroy_GMemoryOutputStream(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GMemoryOutputStream(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GMemoryOutputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMemoryOutputStream, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GMemoryOutputStream(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GMemoryOutputStream(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GMemoryOutputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMemoryOutputStream, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GMemoryOutputStream(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GMemoryOutputStream(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GMemoryOutputStream(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMemoryOutputStream, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GMemoryOutputStream(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GMemoryOutputStream(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GMenu_autoptr = Ptr{GMenu}

const GMenu_listautoptr = Ptr{GList}

const GMenu_slistautoptr = Ptr{GSList}

const GMenu_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GMenu(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenu, g_object_unref);
```
"""
function glib_autoptr_clear_GMenu(_ptr)
    @ccall libaravis.glib_autoptr_clear_GMenu(_ptr::Ptr{GMenu})::Cvoid
end

"""
    glib_autoptr_cleanup_GMenu(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenu, g_object_unref);
```
"""
function glib_autoptr_cleanup_GMenu(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GMenu(_ptr::Ptr{Ptr{GMenu}})::Cvoid
end

"""
    glib_autoptr_destroy_GMenu(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenu, g_object_unref);
```
"""
function glib_autoptr_destroy_GMenu(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GMenu(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GMenu(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenu, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GMenu(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GMenu(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GMenu(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenu, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GMenu(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GMenu(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GMenu(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenu, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GMenu(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GMenu(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GMenuItem_autoptr = Ptr{GMenuItem}

const GMenuItem_listautoptr = Ptr{GList}

const GMenuItem_slistautoptr = Ptr{GSList}

const GMenuItem_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GMenuItem(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenuItem, g_object_unref);
```
"""
function glib_autoptr_clear_GMenuItem(_ptr)
    @ccall libaravis.glib_autoptr_clear_GMenuItem(_ptr::Ptr{GMenuItem})::Cvoid
end

"""
    glib_autoptr_cleanup_GMenuItem(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenuItem, g_object_unref);
```
"""
function glib_autoptr_cleanup_GMenuItem(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GMenuItem(_ptr::Ptr{Ptr{GMenuItem}})::Cvoid
end

"""
    glib_autoptr_destroy_GMenuItem(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenuItem, g_object_unref);
```
"""
function glib_autoptr_destroy_GMenuItem(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GMenuItem(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GMenuItem(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenuItem, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GMenuItem(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GMenuItem(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GMenuItem(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenuItem, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GMenuItem(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GMenuItem(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GMenuItem(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenuItem, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GMenuItem(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GMenuItem(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GMenuModel_autoptr = Ptr{GMenuModel}

const GMenuModel_listautoptr = Ptr{GList}

const GMenuModel_slistautoptr = Ptr{GSList}

const GMenuModel_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GMenuModel(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenuModel, g_object_unref);
```
"""
function glib_autoptr_clear_GMenuModel(_ptr)
    @ccall libaravis.glib_autoptr_clear_GMenuModel(_ptr::Ptr{GMenuModel})::Cvoid
end

"""
    glib_autoptr_cleanup_GMenuModel(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenuModel, g_object_unref);
```
"""
function glib_autoptr_cleanup_GMenuModel(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GMenuModel(_ptr::Ptr{Ptr{GMenuModel}})::Cvoid
end

"""
    glib_autoptr_destroy_GMenuModel(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenuModel, g_object_unref);
```
"""
function glib_autoptr_destroy_GMenuModel(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GMenuModel(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GMenuModel(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenuModel, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GMenuModel(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GMenuModel(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GMenuModel(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenuModel, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GMenuModel(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GMenuModel(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GMenuModel(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenuModel, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GMenuModel(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GMenuModel(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GMenuAttributeIter_autoptr = Ptr{GMenuAttributeIter}

const GMenuAttributeIter_listautoptr = Ptr{GList}

const GMenuAttributeIter_slistautoptr = Ptr{GSList}

const GMenuAttributeIter_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GMenuAttributeIter(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenuAttributeIter, g_object_unref);
```
"""
function glib_autoptr_clear_GMenuAttributeIter(_ptr)
    @ccall libaravis.glib_autoptr_clear_GMenuAttributeIter(_ptr::Ptr{GMenuAttributeIter})::Cvoid
end

"""
    glib_autoptr_cleanup_GMenuAttributeIter(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenuAttributeIter, g_object_unref);
```
"""
function glib_autoptr_cleanup_GMenuAttributeIter(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GMenuAttributeIter(_ptr::Ptr{Ptr{GMenuAttributeIter}})::Cvoid
end

"""
    glib_autoptr_destroy_GMenuAttributeIter(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenuAttributeIter, g_object_unref);
```
"""
function glib_autoptr_destroy_GMenuAttributeIter(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GMenuAttributeIter(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GMenuAttributeIter(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenuAttributeIter, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GMenuAttributeIter(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GMenuAttributeIter(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GMenuAttributeIter(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenuAttributeIter, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GMenuAttributeIter(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GMenuAttributeIter(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GMenuAttributeIter(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenuAttributeIter, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GMenuAttributeIter(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GMenuAttributeIter(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GMenuLinkIter_autoptr = Ptr{GMenuLinkIter}

const GMenuLinkIter_listautoptr = Ptr{GList}

const GMenuLinkIter_slistautoptr = Ptr{GSList}

const GMenuLinkIter_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GMenuLinkIter(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenuLinkIter, g_object_unref);
```
"""
function glib_autoptr_clear_GMenuLinkIter(_ptr)
    @ccall libaravis.glib_autoptr_clear_GMenuLinkIter(_ptr::Ptr{GMenuLinkIter})::Cvoid
end

"""
    glib_autoptr_cleanup_GMenuLinkIter(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenuLinkIter, g_object_unref);
```
"""
function glib_autoptr_cleanup_GMenuLinkIter(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GMenuLinkIter(_ptr::Ptr{Ptr{GMenuLinkIter}})::Cvoid
end

"""
    glib_autoptr_destroy_GMenuLinkIter(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenuLinkIter, g_object_unref);
```
"""
function glib_autoptr_destroy_GMenuLinkIter(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GMenuLinkIter(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GMenuLinkIter(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenuLinkIter, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GMenuLinkIter(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GMenuLinkIter(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GMenuLinkIter(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenuLinkIter, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GMenuLinkIter(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GMenuLinkIter(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GMenuLinkIter(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMenuLinkIter, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GMenuLinkIter(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GMenuLinkIter(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GMount_autoptr = Ptr{GMount}

const GMount_listautoptr = Ptr{GList}

const GMount_slistautoptr = Ptr{GSList}

const GMount_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GMount(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMount, g_object_unref);
```
"""
function glib_autoptr_clear_GMount(_ptr)
    @ccall libaravis.glib_autoptr_clear_GMount(_ptr::Ptr{GMount})::Cvoid
end

"""
    glib_autoptr_cleanup_GMount(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMount, g_object_unref);
```
"""
function glib_autoptr_cleanup_GMount(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GMount(_ptr::Ptr{Ptr{GMount}})::Cvoid
end

"""
    glib_autoptr_destroy_GMount(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMount, g_object_unref);
```
"""
function glib_autoptr_destroy_GMount(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GMount(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GMount(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMount, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GMount(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GMount(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GMount(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMount, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GMount(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GMount(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GMount(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMount, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GMount(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GMount(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GMountOperation_autoptr = Ptr{GMountOperation}

const GMountOperation_listautoptr = Ptr{GList}

const GMountOperation_slistautoptr = Ptr{GSList}

const GMountOperation_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GMountOperation(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMountOperation, g_object_unref);
```
"""
function glib_autoptr_clear_GMountOperation(_ptr)
    @ccall libaravis.glib_autoptr_clear_GMountOperation(_ptr::Ptr{GMountOperation})::Cvoid
end

"""
    glib_autoptr_cleanup_GMountOperation(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMountOperation, g_object_unref);
```
"""
function glib_autoptr_cleanup_GMountOperation(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GMountOperation(_ptr::Ptr{Ptr{GMountOperation}})::Cvoid
end

"""
    glib_autoptr_destroy_GMountOperation(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMountOperation, g_object_unref);
```
"""
function glib_autoptr_destroy_GMountOperation(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GMountOperation(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GMountOperation(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMountOperation, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GMountOperation(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GMountOperation(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GMountOperation(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMountOperation, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GMountOperation(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GMountOperation(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GMountOperation(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GMountOperation, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GMountOperation(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GMountOperation(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GNativeVolumeMonitor_autoptr = Ptr{GNativeVolumeMonitor}

const GNativeVolumeMonitor_listautoptr = Ptr{GList}

const GNativeVolumeMonitor_slistautoptr = Ptr{GSList}

const GNativeVolumeMonitor_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GNativeVolumeMonitor(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNativeVolumeMonitor, g_object_unref);
```
"""
function glib_autoptr_clear_GNativeVolumeMonitor(_ptr)
    @ccall libaravis.glib_autoptr_clear_GNativeVolumeMonitor(_ptr::Ptr{GNativeVolumeMonitor})::Cvoid
end

"""
    glib_autoptr_cleanup_GNativeVolumeMonitor(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNativeVolumeMonitor, g_object_unref);
```
"""
function glib_autoptr_cleanup_GNativeVolumeMonitor(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GNativeVolumeMonitor(_ptr::Ptr{Ptr{GNativeVolumeMonitor}})::Cvoid
end

"""
    glib_autoptr_destroy_GNativeVolumeMonitor(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNativeVolumeMonitor, g_object_unref);
```
"""
function glib_autoptr_destroy_GNativeVolumeMonitor(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GNativeVolumeMonitor(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GNativeVolumeMonitor(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNativeVolumeMonitor, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GNativeVolumeMonitor(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GNativeVolumeMonitor(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GNativeVolumeMonitor(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNativeVolumeMonitor, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GNativeVolumeMonitor(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GNativeVolumeMonitor(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GNativeVolumeMonitor(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNativeVolumeMonitor, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GNativeVolumeMonitor(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GNativeVolumeMonitor(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GNetworkAddress_autoptr = Ptr{GNetworkAddress}

const GNetworkAddress_listautoptr = Ptr{GList}

const GNetworkAddress_slistautoptr = Ptr{GSList}

const GNetworkAddress_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GNetworkAddress(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNetworkAddress, g_object_unref);
```
"""
function glib_autoptr_clear_GNetworkAddress(_ptr)
    @ccall libaravis.glib_autoptr_clear_GNetworkAddress(_ptr::Ptr{GNetworkAddress})::Cvoid
end

"""
    glib_autoptr_cleanup_GNetworkAddress(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNetworkAddress, g_object_unref);
```
"""
function glib_autoptr_cleanup_GNetworkAddress(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GNetworkAddress(_ptr::Ptr{Ptr{GNetworkAddress}})::Cvoid
end

"""
    glib_autoptr_destroy_GNetworkAddress(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNetworkAddress, g_object_unref);
```
"""
function glib_autoptr_destroy_GNetworkAddress(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GNetworkAddress(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GNetworkAddress(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNetworkAddress, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GNetworkAddress(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GNetworkAddress(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GNetworkAddress(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNetworkAddress, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GNetworkAddress(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GNetworkAddress(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GNetworkAddress(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNetworkAddress, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GNetworkAddress(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GNetworkAddress(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GNetworkMonitor_autoptr = Ptr{GNetworkMonitor}

const GNetworkMonitor_listautoptr = Ptr{GList}

const GNetworkMonitor_slistautoptr = Ptr{GSList}

const GNetworkMonitor_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GNetworkMonitor(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNetworkMonitor, g_object_unref);
```
"""
function glib_autoptr_clear_GNetworkMonitor(_ptr)
    @ccall libaravis.glib_autoptr_clear_GNetworkMonitor(_ptr::Ptr{GNetworkMonitor})::Cvoid
end

"""
    glib_autoptr_cleanup_GNetworkMonitor(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNetworkMonitor, g_object_unref);
```
"""
function glib_autoptr_cleanup_GNetworkMonitor(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GNetworkMonitor(_ptr::Ptr{Ptr{GNetworkMonitor}})::Cvoid
end

"""
    glib_autoptr_destroy_GNetworkMonitor(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNetworkMonitor, g_object_unref);
```
"""
function glib_autoptr_destroy_GNetworkMonitor(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GNetworkMonitor(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GNetworkMonitor(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNetworkMonitor, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GNetworkMonitor(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GNetworkMonitor(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GNetworkMonitor(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNetworkMonitor, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GNetworkMonitor(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GNetworkMonitor(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GNetworkMonitor(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNetworkMonitor, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GNetworkMonitor(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GNetworkMonitor(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GNetworkService_autoptr = Ptr{GNetworkService}

const GNetworkService_listautoptr = Ptr{GList}

const GNetworkService_slistautoptr = Ptr{GSList}

const GNetworkService_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GNetworkService(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNetworkService, g_object_unref);
```
"""
function glib_autoptr_clear_GNetworkService(_ptr)
    @ccall libaravis.glib_autoptr_clear_GNetworkService(_ptr::Ptr{GNetworkService})::Cvoid
end

"""
    glib_autoptr_cleanup_GNetworkService(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNetworkService, g_object_unref);
```
"""
function glib_autoptr_cleanup_GNetworkService(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GNetworkService(_ptr::Ptr{Ptr{GNetworkService}})::Cvoid
end

"""
    glib_autoptr_destroy_GNetworkService(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNetworkService, g_object_unref);
```
"""
function glib_autoptr_destroy_GNetworkService(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GNetworkService(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GNetworkService(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNetworkService, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GNetworkService(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GNetworkService(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GNetworkService(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNetworkService, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GNetworkService(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GNetworkService(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GNetworkService(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNetworkService, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GNetworkService(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GNetworkService(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GNotification_autoptr = Ptr{GNotification}

const GNotification_listautoptr = Ptr{GList}

const GNotification_slistautoptr = Ptr{GSList}

const GNotification_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GNotification(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNotification, g_object_unref);
```
"""
function glib_autoptr_clear_GNotification(_ptr)
    @ccall libaravis.glib_autoptr_clear_GNotification(_ptr::Ptr{GNotification})::Cvoid
end

"""
    glib_autoptr_cleanup_GNotification(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNotification, g_object_unref);
```
"""
function glib_autoptr_cleanup_GNotification(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GNotification(_ptr::Ptr{Ptr{GNotification}})::Cvoid
end

"""
    glib_autoptr_destroy_GNotification(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNotification, g_object_unref);
```
"""
function glib_autoptr_destroy_GNotification(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GNotification(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GNotification(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNotification, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GNotification(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GNotification(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GNotification(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNotification, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GNotification(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GNotification(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GNotification(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GNotification, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GNotification(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GNotification(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GOutputStream_autoptr = Ptr{GOutputStream}

const GOutputStream_listautoptr = Ptr{GList}

const GOutputStream_slistautoptr = Ptr{GSList}

const GOutputStream_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GOutputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GOutputStream, g_object_unref);
```
"""
function glib_autoptr_clear_GOutputStream(_ptr)
    @ccall libaravis.glib_autoptr_clear_GOutputStream(_ptr::Ptr{GOutputStream})::Cvoid
end

"""
    glib_autoptr_cleanup_GOutputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GOutputStream, g_object_unref);
```
"""
function glib_autoptr_cleanup_GOutputStream(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GOutputStream(_ptr::Ptr{Ptr{GOutputStream}})::Cvoid
end

"""
    glib_autoptr_destroy_GOutputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GOutputStream, g_object_unref);
```
"""
function glib_autoptr_destroy_GOutputStream(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GOutputStream(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GOutputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GOutputStream, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GOutputStream(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GOutputStream(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GOutputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GOutputStream, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GOutputStream(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GOutputStream(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GOutputStream(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GOutputStream, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GOutputStream(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GOutputStream(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GPermission_autoptr = Ptr{GPermission}

const GPermission_listautoptr = Ptr{GList}

const GPermission_slistautoptr = Ptr{GSList}

const GPermission_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GPermission(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPermission, g_object_unref);
```
"""
function glib_autoptr_clear_GPermission(_ptr)
    @ccall libaravis.glib_autoptr_clear_GPermission(_ptr::Ptr{GPermission})::Cvoid
end

"""
    glib_autoptr_cleanup_GPermission(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPermission, g_object_unref);
```
"""
function glib_autoptr_cleanup_GPermission(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GPermission(_ptr::Ptr{Ptr{GPermission}})::Cvoid
end

"""
    glib_autoptr_destroy_GPermission(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPermission, g_object_unref);
```
"""
function glib_autoptr_destroy_GPermission(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GPermission(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GPermission(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPermission, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GPermission(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GPermission(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GPermission(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPermission, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GPermission(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GPermission(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GPermission(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPermission, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GPermission(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GPermission(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GPollableInputStream_autoptr = Ptr{GPollableInputStream}

const GPollableInputStream_listautoptr = Ptr{GList}

const GPollableInputStream_slistautoptr = Ptr{GSList}

const GPollableInputStream_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GPollableInputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPollableInputStream, g_object_unref);
```
"""
function glib_autoptr_clear_GPollableInputStream(_ptr)
    @ccall libaravis.glib_autoptr_clear_GPollableInputStream(_ptr::Ptr{GPollableInputStream})::Cvoid
end

"""
    glib_autoptr_cleanup_GPollableInputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPollableInputStream, g_object_unref);
```
"""
function glib_autoptr_cleanup_GPollableInputStream(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GPollableInputStream(_ptr::Ptr{Ptr{GPollableInputStream}})::Cvoid
end

"""
    glib_autoptr_destroy_GPollableInputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPollableInputStream, g_object_unref);
```
"""
function glib_autoptr_destroy_GPollableInputStream(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GPollableInputStream(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GPollableInputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPollableInputStream, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GPollableInputStream(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GPollableInputStream(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GPollableInputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPollableInputStream, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GPollableInputStream(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GPollableInputStream(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GPollableInputStream(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPollableInputStream, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GPollableInputStream(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GPollableInputStream(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GPollableOutputStream_autoptr = Ptr{GPollableOutputStream}

const GPollableOutputStream_listautoptr = Ptr{GList}

const GPollableOutputStream_slistautoptr = Ptr{GSList}

const GPollableOutputStream_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GPollableOutputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPollableOutputStream, g_object_unref);
```
"""
function glib_autoptr_clear_GPollableOutputStream(_ptr)
    @ccall libaravis.glib_autoptr_clear_GPollableOutputStream(_ptr::Ptr{GPollableOutputStream})::Cvoid
end

"""
    glib_autoptr_cleanup_GPollableOutputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPollableOutputStream, g_object_unref);
```
"""
function glib_autoptr_cleanup_GPollableOutputStream(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GPollableOutputStream(_ptr::Ptr{Ptr{GPollableOutputStream}})::Cvoid
end

"""
    glib_autoptr_destroy_GPollableOutputStream(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPollableOutputStream, g_object_unref);
```
"""
function glib_autoptr_destroy_GPollableOutputStream(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GPollableOutputStream(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GPollableOutputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPollableOutputStream, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GPollableOutputStream(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GPollableOutputStream(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GPollableOutputStream(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPollableOutputStream, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GPollableOutputStream(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GPollableOutputStream(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GPollableOutputStream(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPollableOutputStream, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GPollableOutputStream(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GPollableOutputStream(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GPropertyAction_autoptr = Ptr{GPropertyAction}

const GPropertyAction_listautoptr = Ptr{GList}

const GPropertyAction_slistautoptr = Ptr{GSList}

const GPropertyAction_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GPropertyAction(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPropertyAction, g_object_unref);
```
"""
function glib_autoptr_clear_GPropertyAction(_ptr)
    @ccall libaravis.glib_autoptr_clear_GPropertyAction(_ptr::Ptr{GPropertyAction})::Cvoid
end

"""
    glib_autoptr_cleanup_GPropertyAction(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPropertyAction, g_object_unref);
```
"""
function glib_autoptr_cleanup_GPropertyAction(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GPropertyAction(_ptr::Ptr{Ptr{GPropertyAction}})::Cvoid
end

"""
    glib_autoptr_destroy_GPropertyAction(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPropertyAction, g_object_unref);
```
"""
function glib_autoptr_destroy_GPropertyAction(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GPropertyAction(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GPropertyAction(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPropertyAction, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GPropertyAction(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GPropertyAction(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GPropertyAction(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPropertyAction, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GPropertyAction(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GPropertyAction(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GPropertyAction(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GPropertyAction, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GPropertyAction(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GPropertyAction(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GProxyAddressEnumerator_autoptr = Ptr{GProxyAddressEnumerator}

const GProxyAddressEnumerator_listautoptr = Ptr{GList}

const GProxyAddressEnumerator_slistautoptr = Ptr{GSList}

const GProxyAddressEnumerator_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GProxyAddressEnumerator(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GProxyAddressEnumerator, g_object_unref);
```
"""
function glib_autoptr_clear_GProxyAddressEnumerator(_ptr)
    @ccall libaravis.glib_autoptr_clear_GProxyAddressEnumerator(_ptr::Ptr{GProxyAddressEnumerator})::Cvoid
end

"""
    glib_autoptr_cleanup_GProxyAddressEnumerator(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GProxyAddressEnumerator, g_object_unref);
```
"""
function glib_autoptr_cleanup_GProxyAddressEnumerator(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GProxyAddressEnumerator(_ptr::Ptr{Ptr{GProxyAddressEnumerator}})::Cvoid
end

"""
    glib_autoptr_destroy_GProxyAddressEnumerator(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GProxyAddressEnumerator, g_object_unref);
```
"""
function glib_autoptr_destroy_GProxyAddressEnumerator(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GProxyAddressEnumerator(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GProxyAddressEnumerator(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GProxyAddressEnumerator, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GProxyAddressEnumerator(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GProxyAddressEnumerator(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GProxyAddressEnumerator(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GProxyAddressEnumerator, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GProxyAddressEnumerator(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GProxyAddressEnumerator(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GProxyAddressEnumerator(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GProxyAddressEnumerator, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GProxyAddressEnumerator(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GProxyAddressEnumerator(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GProxyAddress_autoptr = Ptr{GProxyAddress}

const GProxyAddress_listautoptr = Ptr{GList}

const GProxyAddress_slistautoptr = Ptr{GSList}

const GProxyAddress_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GProxyAddress(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GProxyAddress, g_object_unref);
```
"""
function glib_autoptr_clear_GProxyAddress(_ptr)
    @ccall libaravis.glib_autoptr_clear_GProxyAddress(_ptr::Ptr{GProxyAddress})::Cvoid
end

"""
    glib_autoptr_cleanup_GProxyAddress(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GProxyAddress, g_object_unref);
```
"""
function glib_autoptr_cleanup_GProxyAddress(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GProxyAddress(_ptr::Ptr{Ptr{GProxyAddress}})::Cvoid
end

"""
    glib_autoptr_destroy_GProxyAddress(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GProxyAddress, g_object_unref);
```
"""
function glib_autoptr_destroy_GProxyAddress(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GProxyAddress(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GProxyAddress(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GProxyAddress, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GProxyAddress(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GProxyAddress(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GProxyAddress(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GProxyAddress, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GProxyAddress(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GProxyAddress(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GProxyAddress(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GProxyAddress, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GProxyAddress(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GProxyAddress(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GProxy_autoptr = Ptr{GProxy}

const GProxy_listautoptr = Ptr{GList}

const GProxy_slistautoptr = Ptr{GSList}

const GProxy_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GProxy(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GProxy, g_object_unref);
```
"""
function glib_autoptr_clear_GProxy(_ptr)
    @ccall libaravis.glib_autoptr_clear_GProxy(_ptr::Ptr{GProxy})::Cvoid
end

"""
    glib_autoptr_cleanup_GProxy(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GProxy, g_object_unref);
```
"""
function glib_autoptr_cleanup_GProxy(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GProxy(_ptr::Ptr{Ptr{GProxy}})::Cvoid
end

"""
    glib_autoptr_destroy_GProxy(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GProxy, g_object_unref);
```
"""
function glib_autoptr_destroy_GProxy(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GProxy(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GProxy(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GProxy, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GProxy(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GProxy(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GProxy(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GProxy, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GProxy(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GProxy(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GProxy(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GProxy, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GProxy(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GProxy(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GProxyResolver_autoptr = Ptr{GProxyResolver}

const GProxyResolver_listautoptr = Ptr{GList}

const GProxyResolver_slistautoptr = Ptr{GSList}

const GProxyResolver_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GProxyResolver(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GProxyResolver, g_object_unref);
```
"""
function glib_autoptr_clear_GProxyResolver(_ptr)
    @ccall libaravis.glib_autoptr_clear_GProxyResolver(_ptr::Ptr{GProxyResolver})::Cvoid
end

"""
    glib_autoptr_cleanup_GProxyResolver(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GProxyResolver, g_object_unref);
```
"""
function glib_autoptr_cleanup_GProxyResolver(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GProxyResolver(_ptr::Ptr{Ptr{GProxyResolver}})::Cvoid
end

"""
    glib_autoptr_destroy_GProxyResolver(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GProxyResolver, g_object_unref);
```
"""
function glib_autoptr_destroy_GProxyResolver(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GProxyResolver(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GProxyResolver(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GProxyResolver, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GProxyResolver(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GProxyResolver(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GProxyResolver(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GProxyResolver, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GProxyResolver(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GProxyResolver(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GProxyResolver(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GProxyResolver, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GProxyResolver(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GProxyResolver(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GRemoteActionGroup_autoptr = Ptr{GRemoteActionGroup}

const GRemoteActionGroup_listautoptr = Ptr{GList}

const GRemoteActionGroup_slistautoptr = Ptr{GSList}

const GRemoteActionGroup_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GRemoteActionGroup(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRemoteActionGroup, g_object_unref);
```
"""
function glib_autoptr_clear_GRemoteActionGroup(_ptr)
    @ccall libaravis.glib_autoptr_clear_GRemoteActionGroup(_ptr::Ptr{GRemoteActionGroup})::Cvoid
end

"""
    glib_autoptr_cleanup_GRemoteActionGroup(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRemoteActionGroup, g_object_unref);
```
"""
function glib_autoptr_cleanup_GRemoteActionGroup(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GRemoteActionGroup(_ptr::Ptr{Ptr{GRemoteActionGroup}})::Cvoid
end

"""
    glib_autoptr_destroy_GRemoteActionGroup(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRemoteActionGroup, g_object_unref);
```
"""
function glib_autoptr_destroy_GRemoteActionGroup(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GRemoteActionGroup(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GRemoteActionGroup(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRemoteActionGroup, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GRemoteActionGroup(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GRemoteActionGroup(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GRemoteActionGroup(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRemoteActionGroup, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GRemoteActionGroup(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GRemoteActionGroup(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GRemoteActionGroup(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GRemoteActionGroup, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GRemoteActionGroup(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GRemoteActionGroup(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GResolver_autoptr = Ptr{GResolver}

const GResolver_listautoptr = Ptr{GList}

const GResolver_slistautoptr = Ptr{GSList}

const GResolver_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GResolver(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GResolver, g_object_unref);
```
"""
function glib_autoptr_clear_GResolver(_ptr)
    @ccall libaravis.glib_autoptr_clear_GResolver(_ptr::Ptr{GResolver})::Cvoid
end

"""
    glib_autoptr_cleanup_GResolver(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GResolver, g_object_unref);
```
"""
function glib_autoptr_cleanup_GResolver(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GResolver(_ptr::Ptr{Ptr{GResolver}})::Cvoid
end

"""
    glib_autoptr_destroy_GResolver(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GResolver, g_object_unref);
```
"""
function glib_autoptr_destroy_GResolver(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GResolver(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GResolver(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GResolver, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GResolver(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GResolver(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GResolver(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GResolver, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GResolver(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GResolver(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GResolver(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GResolver, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GResolver(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GResolver(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GResource_autoptr = Ptr{GResource}

const GResource_listautoptr = Ptr{GList}

const GResource_slistautoptr = Ptr{GSList}

const GResource_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GResource(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GResource, g_resource_unref);
```
"""
function glib_autoptr_clear_GResource(_ptr)
    @ccall libaravis.glib_autoptr_clear_GResource(_ptr::Ptr{GResource})::Cvoid
end

"""
    glib_autoptr_cleanup_GResource(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GResource, g_resource_unref);
```
"""
function glib_autoptr_cleanup_GResource(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GResource(_ptr::Ptr{Ptr{GResource}})::Cvoid
end

"""
    glib_autoptr_destroy_GResource(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GResource, g_resource_unref);
```
"""
function glib_autoptr_destroy_GResource(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GResource(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GResource(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GResource, g_resource_unref);
```
"""
function glib_listautoptr_cleanup_GResource(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GResource(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GResource(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GResource, g_resource_unref);
```
"""
function glib_slistautoptr_cleanup_GResource(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GResource(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GResource(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GResource, g_resource_unref);
```
"""
function glib_queueautoptr_cleanup_GResource(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GResource(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GSeekable_autoptr = Ptr{GSeekable}

const GSeekable_listautoptr = Ptr{GList}

const GSeekable_slistautoptr = Ptr{GSList}

const GSeekable_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GSeekable(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSeekable, g_object_unref);
```
"""
function glib_autoptr_clear_GSeekable(_ptr)
    @ccall libaravis.glib_autoptr_clear_GSeekable(_ptr::Ptr{GSeekable})::Cvoid
end

"""
    glib_autoptr_cleanup_GSeekable(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSeekable, g_object_unref);
```
"""
function glib_autoptr_cleanup_GSeekable(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GSeekable(_ptr::Ptr{Ptr{GSeekable}})::Cvoid
end

"""
    glib_autoptr_destroy_GSeekable(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSeekable, g_object_unref);
```
"""
function glib_autoptr_destroy_GSeekable(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GSeekable(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GSeekable(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSeekable, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GSeekable(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GSeekable(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GSeekable(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSeekable, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GSeekable(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GSeekable(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GSeekable(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSeekable, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GSeekable(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GSeekable(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GSettingsBackend_autoptr = Ptr{GSettingsBackend}

const GSettingsBackend_listautoptr = Ptr{GList}

const GSettingsBackend_slistautoptr = Ptr{GSList}

const GSettingsBackend_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GSettingsBackend(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettingsBackend, g_object_unref);
```
"""
function glib_autoptr_clear_GSettingsBackend(_ptr)
    @ccall libaravis.glib_autoptr_clear_GSettingsBackend(_ptr::Ptr{GSettingsBackend})::Cvoid
end

"""
    glib_autoptr_cleanup_GSettingsBackend(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettingsBackend, g_object_unref);
```
"""
function glib_autoptr_cleanup_GSettingsBackend(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GSettingsBackend(_ptr::Ptr{Ptr{GSettingsBackend}})::Cvoid
end

"""
    glib_autoptr_destroy_GSettingsBackend(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettingsBackend, g_object_unref);
```
"""
function glib_autoptr_destroy_GSettingsBackend(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GSettingsBackend(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GSettingsBackend(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettingsBackend, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GSettingsBackend(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GSettingsBackend(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GSettingsBackend(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettingsBackend, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GSettingsBackend(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GSettingsBackend(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GSettingsBackend(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettingsBackend, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GSettingsBackend(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GSettingsBackend(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GSettingsSchema_autoptr = Ptr{GSettingsSchema}

const GSettingsSchema_listautoptr = Ptr{GList}

const GSettingsSchema_slistautoptr = Ptr{GSList}

const GSettingsSchema_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GSettingsSchema(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettingsSchema, g_settings_schema_unref);
```
"""
function glib_autoptr_clear_GSettingsSchema(_ptr)
    @ccall libaravis.glib_autoptr_clear_GSettingsSchema(_ptr::Ptr{GSettingsSchema})::Cvoid
end

"""
    glib_autoptr_cleanup_GSettingsSchema(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettingsSchema, g_settings_schema_unref);
```
"""
function glib_autoptr_cleanup_GSettingsSchema(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GSettingsSchema(_ptr::Ptr{Ptr{GSettingsSchema}})::Cvoid
end

"""
    glib_autoptr_destroy_GSettingsSchema(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettingsSchema, g_settings_schema_unref);
```
"""
function glib_autoptr_destroy_GSettingsSchema(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GSettingsSchema(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GSettingsSchema(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettingsSchema, g_settings_schema_unref);
```
"""
function glib_listautoptr_cleanup_GSettingsSchema(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GSettingsSchema(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GSettingsSchema(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettingsSchema, g_settings_schema_unref);
```
"""
function glib_slistautoptr_cleanup_GSettingsSchema(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GSettingsSchema(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GSettingsSchema(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettingsSchema, g_settings_schema_unref);
```
"""
function glib_queueautoptr_cleanup_GSettingsSchema(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GSettingsSchema(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GSettingsSchemaKey_autoptr = Ptr{GSettingsSchemaKey}

const GSettingsSchemaKey_listautoptr = Ptr{GList}

const GSettingsSchemaKey_slistautoptr = Ptr{GSList}

const GSettingsSchemaKey_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GSettingsSchemaKey(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettingsSchemaKey, g_settings_schema_key_unref);
```
"""
function glib_autoptr_clear_GSettingsSchemaKey(_ptr)
    @ccall libaravis.glib_autoptr_clear_GSettingsSchemaKey(_ptr::Ptr{GSettingsSchemaKey})::Cvoid
end

"""
    glib_autoptr_cleanup_GSettingsSchemaKey(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettingsSchemaKey, g_settings_schema_key_unref);
```
"""
function glib_autoptr_cleanup_GSettingsSchemaKey(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GSettingsSchemaKey(_ptr::Ptr{Ptr{GSettingsSchemaKey}})::Cvoid
end

"""
    glib_autoptr_destroy_GSettingsSchemaKey(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettingsSchemaKey, g_settings_schema_key_unref);
```
"""
function glib_autoptr_destroy_GSettingsSchemaKey(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GSettingsSchemaKey(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GSettingsSchemaKey(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettingsSchemaKey, g_settings_schema_key_unref);
```
"""
function glib_listautoptr_cleanup_GSettingsSchemaKey(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GSettingsSchemaKey(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GSettingsSchemaKey(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettingsSchemaKey, g_settings_schema_key_unref);
```
"""
function glib_slistautoptr_cleanup_GSettingsSchemaKey(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GSettingsSchemaKey(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GSettingsSchemaKey(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettingsSchemaKey, g_settings_schema_key_unref);
```
"""
function glib_queueautoptr_cleanup_GSettingsSchemaKey(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GSettingsSchemaKey(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GSettingsSchemaSource_autoptr = Ptr{GSettingsSchemaSource}

const GSettingsSchemaSource_listautoptr = Ptr{GList}

const GSettingsSchemaSource_slistautoptr = Ptr{GSList}

const GSettingsSchemaSource_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GSettingsSchemaSource(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettingsSchemaSource, g_settings_schema_source_unref);
```
"""
function glib_autoptr_clear_GSettingsSchemaSource(_ptr)
    @ccall libaravis.glib_autoptr_clear_GSettingsSchemaSource(_ptr::Ptr{GSettingsSchemaSource})::Cvoid
end

"""
    glib_autoptr_cleanup_GSettingsSchemaSource(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettingsSchemaSource, g_settings_schema_source_unref);
```
"""
function glib_autoptr_cleanup_GSettingsSchemaSource(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GSettingsSchemaSource(_ptr::Ptr{Ptr{GSettingsSchemaSource}})::Cvoid
end

"""
    glib_autoptr_destroy_GSettingsSchemaSource(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettingsSchemaSource, g_settings_schema_source_unref);
```
"""
function glib_autoptr_destroy_GSettingsSchemaSource(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GSettingsSchemaSource(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GSettingsSchemaSource(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettingsSchemaSource, g_settings_schema_source_unref);
```
"""
function glib_listautoptr_cleanup_GSettingsSchemaSource(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GSettingsSchemaSource(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GSettingsSchemaSource(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettingsSchemaSource, g_settings_schema_source_unref);
```
"""
function glib_slistautoptr_cleanup_GSettingsSchemaSource(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GSettingsSchemaSource(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GSettingsSchemaSource(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettingsSchemaSource, g_settings_schema_source_unref);
```
"""
function glib_queueautoptr_cleanup_GSettingsSchemaSource(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GSettingsSchemaSource(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GSettings_autoptr = Ptr{GSettings}

const GSettings_listautoptr = Ptr{GList}

const GSettings_slistautoptr = Ptr{GSList}

const GSettings_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GSettings(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettings, g_object_unref);
```
"""
function glib_autoptr_clear_GSettings(_ptr)
    @ccall libaravis.glib_autoptr_clear_GSettings(_ptr::Ptr{GSettings})::Cvoid
end

"""
    glib_autoptr_cleanup_GSettings(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettings, g_object_unref);
```
"""
function glib_autoptr_cleanup_GSettings(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GSettings(_ptr::Ptr{Ptr{GSettings}})::Cvoid
end

"""
    glib_autoptr_destroy_GSettings(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettings, g_object_unref);
```
"""
function glib_autoptr_destroy_GSettings(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GSettings(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GSettings(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettings, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GSettings(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GSettings(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GSettings(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettings, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GSettings(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GSettings(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GSettings(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSettings, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GSettings(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GSettings(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GSimpleActionGroup_autoptr = Ptr{GSimpleActionGroup}

const GSimpleActionGroup_listautoptr = Ptr{GList}

const GSimpleActionGroup_slistautoptr = Ptr{GSList}

const GSimpleActionGroup_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GSimpleActionGroup(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimpleActionGroup, g_object_unref);
```
"""
function glib_autoptr_clear_GSimpleActionGroup(_ptr)
    @ccall libaravis.glib_autoptr_clear_GSimpleActionGroup(_ptr::Ptr{GSimpleActionGroup})::Cvoid
end

"""
    glib_autoptr_cleanup_GSimpleActionGroup(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimpleActionGroup, g_object_unref);
```
"""
function glib_autoptr_cleanup_GSimpleActionGroup(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GSimpleActionGroup(_ptr::Ptr{Ptr{GSimpleActionGroup}})::Cvoid
end

"""
    glib_autoptr_destroy_GSimpleActionGroup(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimpleActionGroup, g_object_unref);
```
"""
function glib_autoptr_destroy_GSimpleActionGroup(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GSimpleActionGroup(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GSimpleActionGroup(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimpleActionGroup, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GSimpleActionGroup(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GSimpleActionGroup(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GSimpleActionGroup(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimpleActionGroup, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GSimpleActionGroup(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GSimpleActionGroup(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GSimpleActionGroup(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimpleActionGroup, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GSimpleActionGroup(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GSimpleActionGroup(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GSimpleAction_autoptr = Ptr{GSimpleAction}

const GSimpleAction_listautoptr = Ptr{GList}

const GSimpleAction_slistautoptr = Ptr{GSList}

const GSimpleAction_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GSimpleAction(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimpleAction, g_object_unref);
```
"""
function glib_autoptr_clear_GSimpleAction(_ptr)
    @ccall libaravis.glib_autoptr_clear_GSimpleAction(_ptr::Ptr{GSimpleAction})::Cvoid
end

"""
    glib_autoptr_cleanup_GSimpleAction(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimpleAction, g_object_unref);
```
"""
function glib_autoptr_cleanup_GSimpleAction(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GSimpleAction(_ptr::Ptr{Ptr{GSimpleAction}})::Cvoid
end

"""
    glib_autoptr_destroy_GSimpleAction(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimpleAction, g_object_unref);
```
"""
function glib_autoptr_destroy_GSimpleAction(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GSimpleAction(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GSimpleAction(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimpleAction, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GSimpleAction(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GSimpleAction(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GSimpleAction(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimpleAction, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GSimpleAction(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GSimpleAction(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GSimpleAction(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimpleAction, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GSimpleAction(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GSimpleAction(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GSimpleAsyncResult_autoptr = Ptr{GSimpleAsyncResult}

const GSimpleAsyncResult_listautoptr = Ptr{GList}

const GSimpleAsyncResult_slistautoptr = Ptr{GSList}

const GSimpleAsyncResult_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GSimpleAsyncResult(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimpleAsyncResult, g_object_unref);
```
"""
function glib_autoptr_clear_GSimpleAsyncResult(_ptr)
    @ccall libaravis.glib_autoptr_clear_GSimpleAsyncResult(_ptr::Ptr{GSimpleAsyncResult})::Cvoid
end

"""
    glib_autoptr_cleanup_GSimpleAsyncResult(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimpleAsyncResult, g_object_unref);
```
"""
function glib_autoptr_cleanup_GSimpleAsyncResult(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GSimpleAsyncResult(_ptr::Ptr{Ptr{GSimpleAsyncResult}})::Cvoid
end

"""
    glib_autoptr_destroy_GSimpleAsyncResult(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimpleAsyncResult, g_object_unref);
```
"""
function glib_autoptr_destroy_GSimpleAsyncResult(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GSimpleAsyncResult(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GSimpleAsyncResult(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimpleAsyncResult, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GSimpleAsyncResult(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GSimpleAsyncResult(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GSimpleAsyncResult(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimpleAsyncResult, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GSimpleAsyncResult(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GSimpleAsyncResult(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GSimpleAsyncResult(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimpleAsyncResult, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GSimpleAsyncResult(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GSimpleAsyncResult(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GSimplePermission_autoptr = Ptr{GSimplePermission}

const GSimplePermission_listautoptr = Ptr{GList}

const GSimplePermission_slistautoptr = Ptr{GSList}

const GSimplePermission_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GSimplePermission(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimplePermission, g_object_unref);
```
"""
function glib_autoptr_clear_GSimplePermission(_ptr)
    @ccall libaravis.glib_autoptr_clear_GSimplePermission(_ptr::Ptr{GSimplePermission})::Cvoid
end

"""
    glib_autoptr_cleanup_GSimplePermission(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimplePermission, g_object_unref);
```
"""
function glib_autoptr_cleanup_GSimplePermission(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GSimplePermission(_ptr::Ptr{Ptr{GSimplePermission}})::Cvoid
end

"""
    glib_autoptr_destroy_GSimplePermission(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimplePermission, g_object_unref);
```
"""
function glib_autoptr_destroy_GSimplePermission(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GSimplePermission(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GSimplePermission(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimplePermission, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GSimplePermission(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GSimplePermission(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GSimplePermission(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimplePermission, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GSimplePermission(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GSimplePermission(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GSimplePermission(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimplePermission, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GSimplePermission(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GSimplePermission(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GSimpleProxyResolver_autoptr = Ptr{GSimpleProxyResolver}

const GSimpleProxyResolver_listautoptr = Ptr{GList}

const GSimpleProxyResolver_slistautoptr = Ptr{GSList}

const GSimpleProxyResolver_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GSimpleProxyResolver(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimpleProxyResolver, g_object_unref);
```
"""
function glib_autoptr_clear_GSimpleProxyResolver(_ptr)
    @ccall libaravis.glib_autoptr_clear_GSimpleProxyResolver(_ptr::Ptr{GSimpleProxyResolver})::Cvoid
end

"""
    glib_autoptr_cleanup_GSimpleProxyResolver(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimpleProxyResolver, g_object_unref);
```
"""
function glib_autoptr_cleanup_GSimpleProxyResolver(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GSimpleProxyResolver(_ptr::Ptr{Ptr{GSimpleProxyResolver}})::Cvoid
end

"""
    glib_autoptr_destroy_GSimpleProxyResolver(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimpleProxyResolver, g_object_unref);
```
"""
function glib_autoptr_destroy_GSimpleProxyResolver(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GSimpleProxyResolver(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GSimpleProxyResolver(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimpleProxyResolver, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GSimpleProxyResolver(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GSimpleProxyResolver(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GSimpleProxyResolver(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimpleProxyResolver, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GSimpleProxyResolver(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GSimpleProxyResolver(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GSimpleProxyResolver(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSimpleProxyResolver, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GSimpleProxyResolver(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GSimpleProxyResolver(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GSocketAddressEnumerator_autoptr = Ptr{GSocketAddressEnumerator}

const GSocketAddressEnumerator_listautoptr = Ptr{GList}

const GSocketAddressEnumerator_slistautoptr = Ptr{GSList}

const GSocketAddressEnumerator_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GSocketAddressEnumerator(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketAddressEnumerator, g_object_unref);
```
"""
function glib_autoptr_clear_GSocketAddressEnumerator(_ptr)
    @ccall libaravis.glib_autoptr_clear_GSocketAddressEnumerator(_ptr::Ptr{GSocketAddressEnumerator})::Cvoid
end

"""
    glib_autoptr_cleanup_GSocketAddressEnumerator(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketAddressEnumerator, g_object_unref);
```
"""
function glib_autoptr_cleanup_GSocketAddressEnumerator(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GSocketAddressEnumerator(_ptr::Ptr{Ptr{GSocketAddressEnumerator}})::Cvoid
end

"""
    glib_autoptr_destroy_GSocketAddressEnumerator(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketAddressEnumerator, g_object_unref);
```
"""
function glib_autoptr_destroy_GSocketAddressEnumerator(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GSocketAddressEnumerator(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GSocketAddressEnumerator(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketAddressEnumerator, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GSocketAddressEnumerator(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GSocketAddressEnumerator(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GSocketAddressEnumerator(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketAddressEnumerator, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GSocketAddressEnumerator(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GSocketAddressEnumerator(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GSocketAddressEnumerator(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketAddressEnumerator, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GSocketAddressEnumerator(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GSocketAddressEnumerator(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GSocketAddress_autoptr = Ptr{GSocketAddress}

const GSocketAddress_listautoptr = Ptr{GList}

const GSocketAddress_slistautoptr = Ptr{GSList}

const GSocketAddress_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GSocketAddress(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketAddress, g_object_unref);
```
"""
function glib_autoptr_clear_GSocketAddress(_ptr)
    @ccall libaravis.glib_autoptr_clear_GSocketAddress(_ptr::Ptr{GSocketAddress})::Cvoid
end

"""
    glib_autoptr_cleanup_GSocketAddress(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketAddress, g_object_unref);
```
"""
function glib_autoptr_cleanup_GSocketAddress(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GSocketAddress(_ptr::Ptr{Ptr{GSocketAddress}})::Cvoid
end

"""
    glib_autoptr_destroy_GSocketAddress(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketAddress, g_object_unref);
```
"""
function glib_autoptr_destroy_GSocketAddress(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GSocketAddress(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GSocketAddress(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketAddress, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GSocketAddress(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GSocketAddress(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GSocketAddress(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketAddress, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GSocketAddress(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GSocketAddress(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GSocketAddress(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketAddress, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GSocketAddress(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GSocketAddress(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GSocketClient_autoptr = Ptr{GSocketClient}

const GSocketClient_listautoptr = Ptr{GList}

const GSocketClient_slistautoptr = Ptr{GSList}

const GSocketClient_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GSocketClient(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketClient, g_object_unref);
```
"""
function glib_autoptr_clear_GSocketClient(_ptr)
    @ccall libaravis.glib_autoptr_clear_GSocketClient(_ptr::Ptr{GSocketClient})::Cvoid
end

"""
    glib_autoptr_cleanup_GSocketClient(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketClient, g_object_unref);
```
"""
function glib_autoptr_cleanup_GSocketClient(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GSocketClient(_ptr::Ptr{Ptr{GSocketClient}})::Cvoid
end

"""
    glib_autoptr_destroy_GSocketClient(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketClient, g_object_unref);
```
"""
function glib_autoptr_destroy_GSocketClient(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GSocketClient(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GSocketClient(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketClient, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GSocketClient(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GSocketClient(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GSocketClient(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketClient, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GSocketClient(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GSocketClient(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GSocketClient(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketClient, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GSocketClient(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GSocketClient(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GSocketConnectable_autoptr = Ptr{GSocketConnectable}

const GSocketConnectable_listautoptr = Ptr{GList}

const GSocketConnectable_slistautoptr = Ptr{GSList}

const GSocketConnectable_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GSocketConnectable(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketConnectable, g_object_unref);
```
"""
function glib_autoptr_clear_GSocketConnectable(_ptr)
    @ccall libaravis.glib_autoptr_clear_GSocketConnectable(_ptr::Ptr{GSocketConnectable})::Cvoid
end

"""
    glib_autoptr_cleanup_GSocketConnectable(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketConnectable, g_object_unref);
```
"""
function glib_autoptr_cleanup_GSocketConnectable(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GSocketConnectable(_ptr::Ptr{Ptr{GSocketConnectable}})::Cvoid
end

"""
    glib_autoptr_destroy_GSocketConnectable(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketConnectable, g_object_unref);
```
"""
function glib_autoptr_destroy_GSocketConnectable(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GSocketConnectable(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GSocketConnectable(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketConnectable, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GSocketConnectable(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GSocketConnectable(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GSocketConnectable(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketConnectable, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GSocketConnectable(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GSocketConnectable(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GSocketConnectable(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketConnectable, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GSocketConnectable(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GSocketConnectable(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GSocketConnection_autoptr = Ptr{GSocketConnection}

const GSocketConnection_listautoptr = Ptr{GList}

const GSocketConnection_slistautoptr = Ptr{GSList}

const GSocketConnection_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GSocketConnection(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketConnection, g_object_unref);
```
"""
function glib_autoptr_clear_GSocketConnection(_ptr)
    @ccall libaravis.glib_autoptr_clear_GSocketConnection(_ptr::Ptr{GSocketConnection})::Cvoid
end

"""
    glib_autoptr_cleanup_GSocketConnection(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketConnection, g_object_unref);
```
"""
function glib_autoptr_cleanup_GSocketConnection(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GSocketConnection(_ptr::Ptr{Ptr{GSocketConnection}})::Cvoid
end

"""
    glib_autoptr_destroy_GSocketConnection(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketConnection, g_object_unref);
```
"""
function glib_autoptr_destroy_GSocketConnection(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GSocketConnection(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GSocketConnection(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketConnection, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GSocketConnection(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GSocketConnection(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GSocketConnection(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketConnection, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GSocketConnection(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GSocketConnection(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GSocketConnection(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketConnection, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GSocketConnection(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GSocketConnection(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GSocketControlMessage_autoptr = Ptr{GSocketControlMessage}

const GSocketControlMessage_listautoptr = Ptr{GList}

const GSocketControlMessage_slistautoptr = Ptr{GSList}

const GSocketControlMessage_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GSocketControlMessage(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketControlMessage, g_object_unref);
```
"""
function glib_autoptr_clear_GSocketControlMessage(_ptr)
    @ccall libaravis.glib_autoptr_clear_GSocketControlMessage(_ptr::Ptr{GSocketControlMessage})::Cvoid
end

"""
    glib_autoptr_cleanup_GSocketControlMessage(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketControlMessage, g_object_unref);
```
"""
function glib_autoptr_cleanup_GSocketControlMessage(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GSocketControlMessage(_ptr::Ptr{Ptr{GSocketControlMessage}})::Cvoid
end

"""
    glib_autoptr_destroy_GSocketControlMessage(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketControlMessage, g_object_unref);
```
"""
function glib_autoptr_destroy_GSocketControlMessage(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GSocketControlMessage(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GSocketControlMessage(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketControlMessage, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GSocketControlMessage(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GSocketControlMessage(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GSocketControlMessage(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketControlMessage, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GSocketControlMessage(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GSocketControlMessage(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GSocketControlMessage(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketControlMessage, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GSocketControlMessage(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GSocketControlMessage(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GSocket_autoptr = Ptr{GSocket}

const GSocket_listautoptr = Ptr{GList}

const GSocket_slistautoptr = Ptr{GSList}

const GSocket_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GSocket(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocket, g_object_unref);
```
"""
function glib_autoptr_clear_GSocket(_ptr)
    @ccall libaravis.glib_autoptr_clear_GSocket(_ptr::Ptr{GSocket})::Cvoid
end

"""
    glib_autoptr_cleanup_GSocket(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocket, g_object_unref);
```
"""
function glib_autoptr_cleanup_GSocket(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GSocket(_ptr::Ptr{Ptr{GSocket}})::Cvoid
end

"""
    glib_autoptr_destroy_GSocket(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocket, g_object_unref);
```
"""
function glib_autoptr_destroy_GSocket(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GSocket(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GSocket(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocket, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GSocket(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GSocket(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GSocket(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocket, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GSocket(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GSocket(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GSocket(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocket, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GSocket(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GSocket(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GSocketListener_autoptr = Ptr{GSocketListener}

const GSocketListener_listautoptr = Ptr{GList}

const GSocketListener_slistautoptr = Ptr{GSList}

const GSocketListener_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GSocketListener(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketListener, g_object_unref);
```
"""
function glib_autoptr_clear_GSocketListener(_ptr)
    @ccall libaravis.glib_autoptr_clear_GSocketListener(_ptr::Ptr{GSocketListener})::Cvoid
end

"""
    glib_autoptr_cleanup_GSocketListener(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketListener, g_object_unref);
```
"""
function glib_autoptr_cleanup_GSocketListener(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GSocketListener(_ptr::Ptr{Ptr{GSocketListener}})::Cvoid
end

"""
    glib_autoptr_destroy_GSocketListener(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketListener, g_object_unref);
```
"""
function glib_autoptr_destroy_GSocketListener(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GSocketListener(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GSocketListener(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketListener, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GSocketListener(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GSocketListener(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GSocketListener(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketListener, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GSocketListener(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GSocketListener(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GSocketListener(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketListener, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GSocketListener(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GSocketListener(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GSocketService_autoptr = Ptr{GSocketService}

const GSocketService_listautoptr = Ptr{GList}

const GSocketService_slistautoptr = Ptr{GSList}

const GSocketService_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GSocketService(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketService, g_object_unref);
```
"""
function glib_autoptr_clear_GSocketService(_ptr)
    @ccall libaravis.glib_autoptr_clear_GSocketService(_ptr::Ptr{GSocketService})::Cvoid
end

"""
    glib_autoptr_cleanup_GSocketService(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketService, g_object_unref);
```
"""
function glib_autoptr_cleanup_GSocketService(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GSocketService(_ptr::Ptr{Ptr{GSocketService}})::Cvoid
end

"""
    glib_autoptr_destroy_GSocketService(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketService, g_object_unref);
```
"""
function glib_autoptr_destroy_GSocketService(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GSocketService(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GSocketService(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketService, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GSocketService(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GSocketService(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GSocketService(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketService, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GSocketService(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GSocketService(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GSocketService(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSocketService, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GSocketService(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GSocketService(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GSubprocess_autoptr = Ptr{GSubprocess}

const GSubprocess_listautoptr = Ptr{GList}

const GSubprocess_slistautoptr = Ptr{GSList}

const GSubprocess_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GSubprocess(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSubprocess, g_object_unref);
```
"""
function glib_autoptr_clear_GSubprocess(_ptr)
    @ccall libaravis.glib_autoptr_clear_GSubprocess(_ptr::Ptr{GSubprocess})::Cvoid
end

"""
    glib_autoptr_cleanup_GSubprocess(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSubprocess, g_object_unref);
```
"""
function glib_autoptr_cleanup_GSubprocess(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GSubprocess(_ptr::Ptr{Ptr{GSubprocess}})::Cvoid
end

"""
    glib_autoptr_destroy_GSubprocess(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSubprocess, g_object_unref);
```
"""
function glib_autoptr_destroy_GSubprocess(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GSubprocess(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GSubprocess(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSubprocess, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GSubprocess(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GSubprocess(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GSubprocess(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSubprocess, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GSubprocess(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GSubprocess(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GSubprocess(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSubprocess, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GSubprocess(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GSubprocess(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GSubprocessLauncher_autoptr = Ptr{GSubprocessLauncher}

const GSubprocessLauncher_listautoptr = Ptr{GList}

const GSubprocessLauncher_slistautoptr = Ptr{GSList}

const GSubprocessLauncher_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GSubprocessLauncher(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSubprocessLauncher, g_object_unref);
```
"""
function glib_autoptr_clear_GSubprocessLauncher(_ptr)
    @ccall libaravis.glib_autoptr_clear_GSubprocessLauncher(_ptr::Ptr{GSubprocessLauncher})::Cvoid
end

"""
    glib_autoptr_cleanup_GSubprocessLauncher(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSubprocessLauncher, g_object_unref);
```
"""
function glib_autoptr_cleanup_GSubprocessLauncher(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GSubprocessLauncher(_ptr::Ptr{Ptr{GSubprocessLauncher}})::Cvoid
end

"""
    glib_autoptr_destroy_GSubprocessLauncher(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSubprocessLauncher, g_object_unref);
```
"""
function glib_autoptr_destroy_GSubprocessLauncher(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GSubprocessLauncher(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GSubprocessLauncher(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSubprocessLauncher, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GSubprocessLauncher(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GSubprocessLauncher(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GSubprocessLauncher(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSubprocessLauncher, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GSubprocessLauncher(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GSubprocessLauncher(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GSubprocessLauncher(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GSubprocessLauncher, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GSubprocessLauncher(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GSubprocessLauncher(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GTask_autoptr = Ptr{GTask}

const GTask_listautoptr = Ptr{GList}

const GTask_slistautoptr = Ptr{GSList}

const GTask_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GTask(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTask, g_object_unref);
```
"""
function glib_autoptr_clear_GTask(_ptr)
    @ccall libaravis.glib_autoptr_clear_GTask(_ptr::Ptr{GTask})::Cvoid
end

"""
    glib_autoptr_cleanup_GTask(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTask, g_object_unref);
```
"""
function glib_autoptr_cleanup_GTask(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GTask(_ptr::Ptr{Ptr{GTask}})::Cvoid
end

"""
    glib_autoptr_destroy_GTask(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTask, g_object_unref);
```
"""
function glib_autoptr_destroy_GTask(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GTask(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GTask(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTask, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GTask(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GTask(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GTask(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTask, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GTask(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GTask(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GTask(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTask, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GTask(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GTask(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GTcpConnection_autoptr = Ptr{GTcpConnection}

const GTcpConnection_listautoptr = Ptr{GList}

const GTcpConnection_slistautoptr = Ptr{GSList}

const GTcpConnection_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GTcpConnection(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTcpConnection, g_object_unref);
```
"""
function glib_autoptr_clear_GTcpConnection(_ptr)
    @ccall libaravis.glib_autoptr_clear_GTcpConnection(_ptr::Ptr{GTcpConnection})::Cvoid
end

"""
    glib_autoptr_cleanup_GTcpConnection(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTcpConnection, g_object_unref);
```
"""
function glib_autoptr_cleanup_GTcpConnection(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GTcpConnection(_ptr::Ptr{Ptr{GTcpConnection}})::Cvoid
end

"""
    glib_autoptr_destroy_GTcpConnection(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTcpConnection, g_object_unref);
```
"""
function glib_autoptr_destroy_GTcpConnection(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GTcpConnection(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GTcpConnection(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTcpConnection, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GTcpConnection(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GTcpConnection(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GTcpConnection(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTcpConnection, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GTcpConnection(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GTcpConnection(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GTcpConnection(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTcpConnection, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GTcpConnection(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GTcpConnection(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GTcpWrapperConnection_autoptr = Ptr{GTcpWrapperConnection}

const GTcpWrapperConnection_listautoptr = Ptr{GList}

const GTcpWrapperConnection_slistautoptr = Ptr{GSList}

const GTcpWrapperConnection_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GTcpWrapperConnection(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTcpWrapperConnection, g_object_unref);
```
"""
function glib_autoptr_clear_GTcpWrapperConnection(_ptr)
    @ccall libaravis.glib_autoptr_clear_GTcpWrapperConnection(_ptr::Ptr{GTcpWrapperConnection})::Cvoid
end

"""
    glib_autoptr_cleanup_GTcpWrapperConnection(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTcpWrapperConnection, g_object_unref);
```
"""
function glib_autoptr_cleanup_GTcpWrapperConnection(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GTcpWrapperConnection(_ptr::Ptr{Ptr{GTcpWrapperConnection}})::Cvoid
end

"""
    glib_autoptr_destroy_GTcpWrapperConnection(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTcpWrapperConnection, g_object_unref);
```
"""
function glib_autoptr_destroy_GTcpWrapperConnection(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GTcpWrapperConnection(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GTcpWrapperConnection(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTcpWrapperConnection, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GTcpWrapperConnection(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GTcpWrapperConnection(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GTcpWrapperConnection(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTcpWrapperConnection, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GTcpWrapperConnection(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GTcpWrapperConnection(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GTcpWrapperConnection(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTcpWrapperConnection, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GTcpWrapperConnection(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GTcpWrapperConnection(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GTestDBus_autoptr = Ptr{GTestDBus}

const GTestDBus_listautoptr = Ptr{GList}

const GTestDBus_slistautoptr = Ptr{GSList}

const GTestDBus_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GTestDBus(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTestDBus, g_object_unref);
```
"""
function glib_autoptr_clear_GTestDBus(_ptr)
    @ccall libaravis.glib_autoptr_clear_GTestDBus(_ptr::Ptr{GTestDBus})::Cvoid
end

"""
    glib_autoptr_cleanup_GTestDBus(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTestDBus, g_object_unref);
```
"""
function glib_autoptr_cleanup_GTestDBus(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GTestDBus(_ptr::Ptr{Ptr{GTestDBus}})::Cvoid
end

"""
    glib_autoptr_destroy_GTestDBus(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTestDBus, g_object_unref);
```
"""
function glib_autoptr_destroy_GTestDBus(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GTestDBus(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GTestDBus(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTestDBus, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GTestDBus(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GTestDBus(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GTestDBus(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTestDBus, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GTestDBus(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GTestDBus(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GTestDBus(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTestDBus, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GTestDBus(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GTestDBus(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GThemedIcon_autoptr = Ptr{GThemedIcon}

const GThemedIcon_listautoptr = Ptr{GList}

const GThemedIcon_slistautoptr = Ptr{GSList}

const GThemedIcon_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GThemedIcon(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GThemedIcon, g_object_unref);
```
"""
function glib_autoptr_clear_GThemedIcon(_ptr)
    @ccall libaravis.glib_autoptr_clear_GThemedIcon(_ptr::Ptr{GThemedIcon})::Cvoid
end

"""
    glib_autoptr_cleanup_GThemedIcon(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GThemedIcon, g_object_unref);
```
"""
function glib_autoptr_cleanup_GThemedIcon(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GThemedIcon(_ptr::Ptr{Ptr{GThemedIcon}})::Cvoid
end

"""
    glib_autoptr_destroy_GThemedIcon(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GThemedIcon, g_object_unref);
```
"""
function glib_autoptr_destroy_GThemedIcon(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GThemedIcon(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GThemedIcon(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GThemedIcon, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GThemedIcon(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GThemedIcon(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GThemedIcon(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GThemedIcon, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GThemedIcon(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GThemedIcon(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GThemedIcon(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GThemedIcon, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GThemedIcon(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GThemedIcon(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GThreadedSocketService_autoptr = Ptr{GThreadedSocketService}

const GThreadedSocketService_listautoptr = Ptr{GList}

const GThreadedSocketService_slistautoptr = Ptr{GSList}

const GThreadedSocketService_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GThreadedSocketService(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GThreadedSocketService, g_object_unref);
```
"""
function glib_autoptr_clear_GThreadedSocketService(_ptr)
    @ccall libaravis.glib_autoptr_clear_GThreadedSocketService(_ptr::Ptr{GThreadedSocketService})::Cvoid
end

"""
    glib_autoptr_cleanup_GThreadedSocketService(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GThreadedSocketService, g_object_unref);
```
"""
function glib_autoptr_cleanup_GThreadedSocketService(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GThreadedSocketService(_ptr::Ptr{Ptr{GThreadedSocketService}})::Cvoid
end

"""
    glib_autoptr_destroy_GThreadedSocketService(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GThreadedSocketService, g_object_unref);
```
"""
function glib_autoptr_destroy_GThreadedSocketService(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GThreadedSocketService(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GThreadedSocketService(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GThreadedSocketService, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GThreadedSocketService(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GThreadedSocketService(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GThreadedSocketService(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GThreadedSocketService, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GThreadedSocketService(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GThreadedSocketService(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GThreadedSocketService(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GThreadedSocketService, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GThreadedSocketService(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GThreadedSocketService(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GTlsBackend_autoptr = Ptr{GTlsBackend}

const GTlsBackend_listautoptr = Ptr{GList}

const GTlsBackend_slistautoptr = Ptr{GSList}

const GTlsBackend_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GTlsBackend(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsBackend, g_object_unref);
```
"""
function glib_autoptr_clear_GTlsBackend(_ptr)
    @ccall libaravis.glib_autoptr_clear_GTlsBackend(_ptr::Ptr{GTlsBackend})::Cvoid
end

"""
    glib_autoptr_cleanup_GTlsBackend(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsBackend, g_object_unref);
```
"""
function glib_autoptr_cleanup_GTlsBackend(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GTlsBackend(_ptr::Ptr{Ptr{GTlsBackend}})::Cvoid
end

"""
    glib_autoptr_destroy_GTlsBackend(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsBackend, g_object_unref);
```
"""
function glib_autoptr_destroy_GTlsBackend(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GTlsBackend(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GTlsBackend(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsBackend, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GTlsBackend(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GTlsBackend(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GTlsBackend(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsBackend, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GTlsBackend(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GTlsBackend(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GTlsBackend(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsBackend, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GTlsBackend(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GTlsBackend(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GTlsCertificate_autoptr = Ptr{GTlsCertificate}

const GTlsCertificate_listautoptr = Ptr{GList}

const GTlsCertificate_slistautoptr = Ptr{GSList}

const GTlsCertificate_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GTlsCertificate(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsCertificate, g_object_unref);
```
"""
function glib_autoptr_clear_GTlsCertificate(_ptr)
    @ccall libaravis.glib_autoptr_clear_GTlsCertificate(_ptr::Ptr{GTlsCertificate})::Cvoid
end

"""
    glib_autoptr_cleanup_GTlsCertificate(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsCertificate, g_object_unref);
```
"""
function glib_autoptr_cleanup_GTlsCertificate(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GTlsCertificate(_ptr::Ptr{Ptr{GTlsCertificate}})::Cvoid
end

"""
    glib_autoptr_destroy_GTlsCertificate(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsCertificate, g_object_unref);
```
"""
function glib_autoptr_destroy_GTlsCertificate(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GTlsCertificate(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GTlsCertificate(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsCertificate, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GTlsCertificate(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GTlsCertificate(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GTlsCertificate(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsCertificate, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GTlsCertificate(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GTlsCertificate(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GTlsCertificate(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsCertificate, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GTlsCertificate(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GTlsCertificate(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GTlsClientConnection_autoptr = Ptr{GTlsClientConnection}

const GTlsClientConnection_listautoptr = Ptr{GList}

const GTlsClientConnection_slistautoptr = Ptr{GSList}

const GTlsClientConnection_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GTlsClientConnection(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsClientConnection, g_object_unref);
```
"""
function glib_autoptr_clear_GTlsClientConnection(_ptr)
    @ccall libaravis.glib_autoptr_clear_GTlsClientConnection(_ptr::Ptr{GTlsClientConnection})::Cvoid
end

"""
    glib_autoptr_cleanup_GTlsClientConnection(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsClientConnection, g_object_unref);
```
"""
function glib_autoptr_cleanup_GTlsClientConnection(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GTlsClientConnection(_ptr::Ptr{Ptr{GTlsClientConnection}})::Cvoid
end

"""
    glib_autoptr_destroy_GTlsClientConnection(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsClientConnection, g_object_unref);
```
"""
function glib_autoptr_destroy_GTlsClientConnection(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GTlsClientConnection(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GTlsClientConnection(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsClientConnection, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GTlsClientConnection(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GTlsClientConnection(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GTlsClientConnection(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsClientConnection, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GTlsClientConnection(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GTlsClientConnection(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GTlsClientConnection(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsClientConnection, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GTlsClientConnection(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GTlsClientConnection(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GTlsConnection_autoptr = Ptr{GTlsConnection}

const GTlsConnection_listautoptr = Ptr{GList}

const GTlsConnection_slistautoptr = Ptr{GSList}

const GTlsConnection_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GTlsConnection(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsConnection, g_object_unref);
```
"""
function glib_autoptr_clear_GTlsConnection(_ptr)
    @ccall libaravis.glib_autoptr_clear_GTlsConnection(_ptr::Ptr{GTlsConnection})::Cvoid
end

"""
    glib_autoptr_cleanup_GTlsConnection(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsConnection, g_object_unref);
```
"""
function glib_autoptr_cleanup_GTlsConnection(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GTlsConnection(_ptr::Ptr{Ptr{GTlsConnection}})::Cvoid
end

"""
    glib_autoptr_destroy_GTlsConnection(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsConnection, g_object_unref);
```
"""
function glib_autoptr_destroy_GTlsConnection(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GTlsConnection(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GTlsConnection(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsConnection, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GTlsConnection(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GTlsConnection(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GTlsConnection(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsConnection, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GTlsConnection(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GTlsConnection(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GTlsConnection(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsConnection, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GTlsConnection(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GTlsConnection(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GTlsDatabase_autoptr = Ptr{GTlsDatabase}

const GTlsDatabase_listautoptr = Ptr{GList}

const GTlsDatabase_slistautoptr = Ptr{GSList}

const GTlsDatabase_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GTlsDatabase(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsDatabase, g_object_unref);
```
"""
function glib_autoptr_clear_GTlsDatabase(_ptr)
    @ccall libaravis.glib_autoptr_clear_GTlsDatabase(_ptr::Ptr{GTlsDatabase})::Cvoid
end

"""
    glib_autoptr_cleanup_GTlsDatabase(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsDatabase, g_object_unref);
```
"""
function glib_autoptr_cleanup_GTlsDatabase(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GTlsDatabase(_ptr::Ptr{Ptr{GTlsDatabase}})::Cvoid
end

"""
    glib_autoptr_destroy_GTlsDatabase(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsDatabase, g_object_unref);
```
"""
function glib_autoptr_destroy_GTlsDatabase(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GTlsDatabase(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GTlsDatabase(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsDatabase, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GTlsDatabase(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GTlsDatabase(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GTlsDatabase(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsDatabase, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GTlsDatabase(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GTlsDatabase(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GTlsDatabase(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsDatabase, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GTlsDatabase(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GTlsDatabase(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GTlsFileDatabase_autoptr = Ptr{GTlsFileDatabase}

const GTlsFileDatabase_listautoptr = Ptr{GList}

const GTlsFileDatabase_slistautoptr = Ptr{GSList}

const GTlsFileDatabase_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GTlsFileDatabase(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsFileDatabase, g_object_unref);
```
"""
function glib_autoptr_clear_GTlsFileDatabase(_ptr)
    @ccall libaravis.glib_autoptr_clear_GTlsFileDatabase(_ptr::Ptr{GTlsFileDatabase})::Cvoid
end

"""
    glib_autoptr_cleanup_GTlsFileDatabase(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsFileDatabase, g_object_unref);
```
"""
function glib_autoptr_cleanup_GTlsFileDatabase(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GTlsFileDatabase(_ptr::Ptr{Ptr{GTlsFileDatabase}})::Cvoid
end

"""
    glib_autoptr_destroy_GTlsFileDatabase(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsFileDatabase, g_object_unref);
```
"""
function glib_autoptr_destroy_GTlsFileDatabase(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GTlsFileDatabase(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GTlsFileDatabase(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsFileDatabase, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GTlsFileDatabase(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GTlsFileDatabase(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GTlsFileDatabase(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsFileDatabase, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GTlsFileDatabase(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GTlsFileDatabase(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GTlsFileDatabase(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsFileDatabase, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GTlsFileDatabase(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GTlsFileDatabase(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GTlsInteraction_autoptr = Ptr{GTlsInteraction}

const GTlsInteraction_listautoptr = Ptr{GList}

const GTlsInteraction_slistautoptr = Ptr{GSList}

const GTlsInteraction_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GTlsInteraction(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsInteraction, g_object_unref);
```
"""
function glib_autoptr_clear_GTlsInteraction(_ptr)
    @ccall libaravis.glib_autoptr_clear_GTlsInteraction(_ptr::Ptr{GTlsInteraction})::Cvoid
end

"""
    glib_autoptr_cleanup_GTlsInteraction(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsInteraction, g_object_unref);
```
"""
function glib_autoptr_cleanup_GTlsInteraction(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GTlsInteraction(_ptr::Ptr{Ptr{GTlsInteraction}})::Cvoid
end

"""
    glib_autoptr_destroy_GTlsInteraction(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsInteraction, g_object_unref);
```
"""
function glib_autoptr_destroy_GTlsInteraction(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GTlsInteraction(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GTlsInteraction(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsInteraction, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GTlsInteraction(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GTlsInteraction(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GTlsInteraction(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsInteraction, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GTlsInteraction(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GTlsInteraction(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GTlsInteraction(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsInteraction, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GTlsInteraction(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GTlsInteraction(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GTlsPassword_autoptr = Ptr{GTlsPassword}

const GTlsPassword_listautoptr = Ptr{GList}

const GTlsPassword_slistautoptr = Ptr{GSList}

const GTlsPassword_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GTlsPassword(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsPassword, g_object_unref);
```
"""
function glib_autoptr_clear_GTlsPassword(_ptr)
    @ccall libaravis.glib_autoptr_clear_GTlsPassword(_ptr::Ptr{GTlsPassword})::Cvoid
end

"""
    glib_autoptr_cleanup_GTlsPassword(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsPassword, g_object_unref);
```
"""
function glib_autoptr_cleanup_GTlsPassword(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GTlsPassword(_ptr::Ptr{Ptr{GTlsPassword}})::Cvoid
end

"""
    glib_autoptr_destroy_GTlsPassword(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsPassword, g_object_unref);
```
"""
function glib_autoptr_destroy_GTlsPassword(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GTlsPassword(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GTlsPassword(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsPassword, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GTlsPassword(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GTlsPassword(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GTlsPassword(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsPassword, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GTlsPassword(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GTlsPassword(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GTlsPassword(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsPassword, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GTlsPassword(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GTlsPassword(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GTlsServerConnection_autoptr = Ptr{GTlsServerConnection}

const GTlsServerConnection_listautoptr = Ptr{GList}

const GTlsServerConnection_slistautoptr = Ptr{GSList}

const GTlsServerConnection_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GTlsServerConnection(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsServerConnection, g_object_unref);
```
"""
function glib_autoptr_clear_GTlsServerConnection(_ptr)
    @ccall libaravis.glib_autoptr_clear_GTlsServerConnection(_ptr::Ptr{GTlsServerConnection})::Cvoid
end

"""
    glib_autoptr_cleanup_GTlsServerConnection(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsServerConnection, g_object_unref);
```
"""
function glib_autoptr_cleanup_GTlsServerConnection(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GTlsServerConnection(_ptr::Ptr{Ptr{GTlsServerConnection}})::Cvoid
end

"""
    glib_autoptr_destroy_GTlsServerConnection(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsServerConnection, g_object_unref);
```
"""
function glib_autoptr_destroy_GTlsServerConnection(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GTlsServerConnection(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GTlsServerConnection(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsServerConnection, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GTlsServerConnection(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GTlsServerConnection(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GTlsServerConnection(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsServerConnection, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GTlsServerConnection(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GTlsServerConnection(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GTlsServerConnection(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GTlsServerConnection, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GTlsServerConnection(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GTlsServerConnection(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GVfs_autoptr = Ptr{GVfs}

const GVfs_listautoptr = Ptr{GList}

const GVfs_slistautoptr = Ptr{GSList}

const GVfs_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GVfs(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVfs, g_object_unref);
```
"""
function glib_autoptr_clear_GVfs(_ptr)
    @ccall libaravis.glib_autoptr_clear_GVfs(_ptr::Ptr{GVfs})::Cvoid
end

"""
    glib_autoptr_cleanup_GVfs(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVfs, g_object_unref);
```
"""
function glib_autoptr_cleanup_GVfs(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GVfs(_ptr::Ptr{Ptr{GVfs}})::Cvoid
end

"""
    glib_autoptr_destroy_GVfs(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVfs, g_object_unref);
```
"""
function glib_autoptr_destroy_GVfs(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GVfs(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GVfs(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVfs, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GVfs(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GVfs(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GVfs(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVfs, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GVfs(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GVfs(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GVfs(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVfs, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GVfs(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GVfs(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GVolume_autoptr = Ptr{GVolume}

const GVolume_listautoptr = Ptr{GList}

const GVolume_slistautoptr = Ptr{GSList}

const GVolume_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GVolume(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVolume, g_object_unref);
```
"""
function glib_autoptr_clear_GVolume(_ptr)
    @ccall libaravis.glib_autoptr_clear_GVolume(_ptr::Ptr{GVolume})::Cvoid
end

"""
    glib_autoptr_cleanup_GVolume(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVolume, g_object_unref);
```
"""
function glib_autoptr_cleanup_GVolume(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GVolume(_ptr::Ptr{Ptr{GVolume}})::Cvoid
end

"""
    glib_autoptr_destroy_GVolume(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVolume, g_object_unref);
```
"""
function glib_autoptr_destroy_GVolume(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GVolume(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GVolume(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVolume, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GVolume(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GVolume(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GVolume(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVolume, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GVolume(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GVolume(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GVolume(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVolume, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GVolume(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GVolume(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GVolumeMonitor_autoptr = Ptr{GVolumeMonitor}

const GVolumeMonitor_listautoptr = Ptr{GList}

const GVolumeMonitor_slistautoptr = Ptr{GSList}

const GVolumeMonitor_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GVolumeMonitor(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVolumeMonitor, g_object_unref);
```
"""
function glib_autoptr_clear_GVolumeMonitor(_ptr)
    @ccall libaravis.glib_autoptr_clear_GVolumeMonitor(_ptr::Ptr{GVolumeMonitor})::Cvoid
end

"""
    glib_autoptr_cleanup_GVolumeMonitor(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVolumeMonitor, g_object_unref);
```
"""
function glib_autoptr_cleanup_GVolumeMonitor(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GVolumeMonitor(_ptr::Ptr{Ptr{GVolumeMonitor}})::Cvoid
end

"""
    glib_autoptr_destroy_GVolumeMonitor(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVolumeMonitor, g_object_unref);
```
"""
function glib_autoptr_destroy_GVolumeMonitor(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GVolumeMonitor(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GVolumeMonitor(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVolumeMonitor, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GVolumeMonitor(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GVolumeMonitor(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GVolumeMonitor(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVolumeMonitor, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GVolumeMonitor(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GVolumeMonitor(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GVolumeMonitor(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GVolumeMonitor, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GVolumeMonitor(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GVolumeMonitor(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GZlibCompressor_autoptr = Ptr{GZlibCompressor}

const GZlibCompressor_listautoptr = Ptr{GList}

const GZlibCompressor_slistautoptr = Ptr{GSList}

const GZlibCompressor_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GZlibCompressor(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GZlibCompressor, g_object_unref);
```
"""
function glib_autoptr_clear_GZlibCompressor(_ptr)
    @ccall libaravis.glib_autoptr_clear_GZlibCompressor(_ptr::Ptr{GZlibCompressor})::Cvoid
end

"""
    glib_autoptr_cleanup_GZlibCompressor(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GZlibCompressor, g_object_unref);
```
"""
function glib_autoptr_cleanup_GZlibCompressor(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GZlibCompressor(_ptr::Ptr{Ptr{GZlibCompressor}})::Cvoid
end

"""
    glib_autoptr_destroy_GZlibCompressor(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GZlibCompressor, g_object_unref);
```
"""
function glib_autoptr_destroy_GZlibCompressor(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GZlibCompressor(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GZlibCompressor(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GZlibCompressor, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GZlibCompressor(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GZlibCompressor(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GZlibCompressor(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GZlibCompressor, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GZlibCompressor(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GZlibCompressor(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GZlibCompressor(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GZlibCompressor, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GZlibCompressor(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GZlibCompressor(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const GZlibDecompressor_autoptr = Ptr{GZlibDecompressor}

const GZlibDecompressor_listautoptr = Ptr{GList}

const GZlibDecompressor_slistautoptr = Ptr{GSList}

const GZlibDecompressor_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_GZlibDecompressor(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GZlibDecompressor, g_object_unref);
```
"""
function glib_autoptr_clear_GZlibDecompressor(_ptr)
    @ccall libaravis.glib_autoptr_clear_GZlibDecompressor(_ptr::Ptr{GZlibDecompressor})::Cvoid
end

"""
    glib_autoptr_cleanup_GZlibDecompressor(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GZlibDecompressor, g_object_unref);
```
"""
function glib_autoptr_cleanup_GZlibDecompressor(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_GZlibDecompressor(_ptr::Ptr{Ptr{GZlibDecompressor}})::Cvoid
end

"""
    glib_autoptr_destroy_GZlibDecompressor(_ptr)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GZlibDecompressor, g_object_unref);
```
"""
function glib_autoptr_destroy_GZlibDecompressor(_ptr)
    @ccall libaravis.glib_autoptr_destroy_GZlibDecompressor(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_GZlibDecompressor(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GZlibDecompressor, g_object_unref);
```
"""
function glib_listautoptr_cleanup_GZlibDecompressor(_l)
    @ccall libaravis.glib_listautoptr_cleanup_GZlibDecompressor(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_GZlibDecompressor(_l)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GZlibDecompressor, g_object_unref);
```
"""
function glib_slistautoptr_cleanup_GZlibDecompressor(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_GZlibDecompressor(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_GZlibDecompressor(_q)

### Prototype
```c
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GZlibDecompressor, g_object_unref);
```
"""
function glib_queueautoptr_cleanup_GZlibDecompressor(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_GZlibDecompressor(_q::Ptr{Ptr{GQueue}})::Cvoid
end

@cenum ArvDomNodeType::UInt32 begin
    ARV_DOM_NODE_TYPE_ELEMENT_NODE = 1
    ARV_DOM_NODE_TYPE_ATTRIBUTE_NODE = 2
    ARV_DOM_NODE_TYPE_TEXT_NODE = 3
    ARV_DOM_NODE_TYPE_CDATA_SECTION_NODE = 4
    ARV_DOM_NODE_TYPE_ENTITY_REFERENCE_NODE = 5
    ARV_DOM_NODE_TYPE_ENTITY_NODE = 6
    ARV_DOM_NODE_TYPE_PROCESSING_INSTRUCTION_NODE = 7
    ARV_DOM_NODE_TYPE_COMMENT_NODE = 8
    ARV_DOM_NODE_TYPE_DOCUMENT_NODE = 9
    ARV_DOM_NODE_TYPE_DOCUMENT_TYPE_NODE = 10
    ARV_DOM_NODE_TYPE_DOCUMENT_FRAGMENT_NODE = 11
    ARV_DOM_NODE_TYPE_NOTATION_NODE = 12
end

struct _ArvDomNodeClass
    parent_class::GObjectClass
    get_node_name::Ptr{Cvoid}
    get_node_value::Ptr{Cvoid}
    set_node_value::Ptr{Cvoid}
    get_node_type::Ptr{Cvoid}
    can_append_child::Ptr{Cvoid}
    post_new_child::Ptr{Cvoid}
    pre_remove_child::Ptr{Cvoid}
    changed::Ptr{Cvoid}
    child_changed::Ptr{Cvoid}
end

const ArvDomNodeClass = _ArvDomNodeClass

const ArvDomNode_autoptr = Ptr{ArvDomNode}

const ArvDomNode_listautoptr = Ptr{GList}

const ArvDomNode_slistautoptr = Ptr{GSList}

const ArvDomNode_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvDomNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNode, arv_dom_node, ARV, DOM_NODE, GObject);
```
"""
function glib_autoptr_clear_ArvDomNode(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvDomNode(_ptr::Ptr{ArvDomNode})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvDomNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNode, arv_dom_node, ARV, DOM_NODE, GObject);
```
"""
function glib_autoptr_cleanup_ArvDomNode(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvDomNode(_ptr::Ptr{Ptr{ArvDomNode}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvDomNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNode, arv_dom_node, ARV, DOM_NODE, GObject);
```
"""
function glib_autoptr_destroy_ArvDomNode(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvDomNode(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvDomNode(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNode, arv_dom_node, ARV, DOM_NODE, GObject);
```
"""
function glib_listautoptr_cleanup_ArvDomNode(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvDomNode(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvDomNode(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNode, arv_dom_node, ARV, DOM_NODE, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvDomNode(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvDomNode(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvDomNode(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNode, arv_dom_node, ARV, DOM_NODE, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvDomNode(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvDomNode(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvDomNodeClass_autoptr = Ptr{ArvDomNodeClass}

const ArvDomNodeClass_listautoptr = Ptr{GList}

const ArvDomNodeClass_slistautoptr = Ptr{GSList}

const ArvDomNodeClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvDomNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNode, arv_dom_node, ARV, DOM_NODE, GObject);
```
"""
function glib_autoptr_clear_ArvDomNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvDomNodeClass(_ptr::Ptr{ArvDomNodeClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvDomNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNode, arv_dom_node, ARV, DOM_NODE, GObject);
```
"""
function glib_autoptr_cleanup_ArvDomNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvDomNodeClass(_ptr::Ptr{Ptr{ArvDomNodeClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvDomNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNode, arv_dom_node, ARV, DOM_NODE, GObject);
```
"""
function glib_autoptr_destroy_ArvDomNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvDomNodeClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvDomNodeClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNode, arv_dom_node, ARV, DOM_NODE, GObject);
```
"""
function glib_listautoptr_cleanup_ArvDomNodeClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvDomNodeClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvDomNodeClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNode, arv_dom_node, ARV, DOM_NODE, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvDomNodeClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvDomNodeClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvDomNodeClass(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNode, arv_dom_node, ARV, DOM_NODE, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvDomNodeClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvDomNodeClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_DOM_NODE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNode, arv_dom_node, ARV, DOM_NODE, GObject);
```
"""
function ARV_DOM_NODE(ptr)
    @ccall libaravis.ARV_DOM_NODE(ptr::gpointer)::Ptr{ArvDomNode}
end

"""
    ARV_DOM_NODE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNode, arv_dom_node, ARV, DOM_NODE, GObject);
```
"""
function ARV_DOM_NODE_CLASS(ptr)
    @ccall libaravis.ARV_DOM_NODE_CLASS(ptr::gpointer)::Ptr{ArvDomNodeClass}
end

"""
    ARV_IS_DOM_NODE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNode, arv_dom_node, ARV, DOM_NODE, GObject);
```
"""
function ARV_IS_DOM_NODE(ptr)
    @ccall libaravis.ARV_IS_DOM_NODE(ptr::gpointer)::gboolean
end

"""
    ARV_IS_DOM_NODE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNode, arv_dom_node, ARV, DOM_NODE, GObject);
```
"""
function ARV_IS_DOM_NODE_CLASS(ptr)
    @ccall libaravis.ARV_IS_DOM_NODE_CLASS(ptr::gpointer)::gboolean
end

"""
    ARV_DOM_NODE_GET_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNode, arv_dom_node, ARV, DOM_NODE, GObject);
```
"""
function ARV_DOM_NODE_GET_CLASS(ptr)
    @ccall libaravis.ARV_DOM_NODE_GET_CLASS(ptr::gpointer)::Ptr{ArvDomNodeClass}
end

"""
    arv_dom_node_get_node_name(self)

### Prototype
```c
ARV_API const char * arv_dom_node_get_node_name (ArvDomNode *self);
```
"""
function arv_dom_node_get_node_name(self)
    @ccall libaravis.arv_dom_node_get_node_name(self::Ptr{ArvDomNode})::Cstring
end

"""
    arv_dom_node_get_node_value(self)

### Prototype
```c
ARV_API const char * arv_dom_node_get_node_value (ArvDomNode *self);
```
"""
function arv_dom_node_get_node_value(self)
    @ccall libaravis.arv_dom_node_get_node_value(self::Ptr{ArvDomNode})::Cstring
end

"""
    arv_dom_node_set_node_value(self, new_value)

### Prototype
```c
ARV_API void arv_dom_node_set_node_value (ArvDomNode *self, const char *new_value);
```
"""
function arv_dom_node_set_node_value(self, new_value)
    @ccall libaravis.arv_dom_node_set_node_value(self::Ptr{ArvDomNode}, new_value::Cstring)::Cvoid
end

"""
    arv_dom_node_get_node_type(self)

### Prototype
```c
ARV_API ArvDomNodeType arv_dom_node_get_node_type (ArvDomNode *self);
```
"""
function arv_dom_node_get_node_type(self)
    @ccall libaravis.arv_dom_node_get_node_type(self::Ptr{ArvDomNode})::ArvDomNodeType
end

"""
    arv_dom_node_get_parent_node(self)

### Prototype
```c
ARV_API ArvDomNode * arv_dom_node_get_parent_node (ArvDomNode *self);
```
"""
function arv_dom_node_get_parent_node(self)
    @ccall libaravis.arv_dom_node_get_parent_node(self::Ptr{ArvDomNode})::Ptr{ArvDomNode}
end

"""
    arv_dom_node_get_child_nodes(self)

### Prototype
```c
ARV_API ArvDomNodeList * arv_dom_node_get_child_nodes (ArvDomNode *self);
```
"""
function arv_dom_node_get_child_nodes(self)
    @ccall libaravis.arv_dom_node_get_child_nodes(self::Ptr{ArvDomNode})::Ptr{ArvDomNodeList}
end

"""
    arv_dom_node_get_first_child(self)

### Prototype
```c
ARV_API ArvDomNode * arv_dom_node_get_first_child (ArvDomNode *self);
```
"""
function arv_dom_node_get_first_child(self)
    @ccall libaravis.arv_dom_node_get_first_child(self::Ptr{ArvDomNode})::Ptr{ArvDomNode}
end

"""
    arv_dom_node_get_last_child(self)

### Prototype
```c
ARV_API ArvDomNode * arv_dom_node_get_last_child (ArvDomNode *self);
```
"""
function arv_dom_node_get_last_child(self)
    @ccall libaravis.arv_dom_node_get_last_child(self::Ptr{ArvDomNode})::Ptr{ArvDomNode}
end

"""
    arv_dom_node_get_previous_sibling(self)

### Prototype
```c
ARV_API ArvDomNode * arv_dom_node_get_previous_sibling (ArvDomNode *self);
```
"""
function arv_dom_node_get_previous_sibling(self)
    @ccall libaravis.arv_dom_node_get_previous_sibling(self::Ptr{ArvDomNode})::Ptr{ArvDomNode}
end

"""
    arv_dom_node_get_next_sibling(self)

### Prototype
```c
ARV_API ArvDomNode * arv_dom_node_get_next_sibling (ArvDomNode *self);
```
"""
function arv_dom_node_get_next_sibling(self)
    @ccall libaravis.arv_dom_node_get_next_sibling(self::Ptr{ArvDomNode})::Ptr{ArvDomNode}
end

"""
    arv_dom_node_insert_before(self, new_child, ref_child)

### Prototype
```c
ARV_API ArvDomNode * arv_dom_node_insert_before (ArvDomNode *self, ArvDomNode *new_child, ArvDomNode *ref_child);
```
"""
function arv_dom_node_insert_before(self, new_child, ref_child)
    @ccall libaravis.arv_dom_node_insert_before(self::Ptr{ArvDomNode}, new_child::Ptr{ArvDomNode}, ref_child::Ptr{ArvDomNode})::Ptr{ArvDomNode}
end

"""
    arv_dom_node_replace_child(self, new_child, old_child)

### Prototype
```c
ARV_API ArvDomNode * arv_dom_node_replace_child (ArvDomNode *self, ArvDomNode *new_child, ArvDomNode *old_child);
```
"""
function arv_dom_node_replace_child(self, new_child, old_child)
    @ccall libaravis.arv_dom_node_replace_child(self::Ptr{ArvDomNode}, new_child::Ptr{ArvDomNode}, old_child::Ptr{ArvDomNode})::Ptr{ArvDomNode}
end

"""
    arv_dom_node_append_child(self, new_child)

### Prototype
```c
ARV_API ArvDomNode * arv_dom_node_append_child (ArvDomNode *self, ArvDomNode *new_child);
```
"""
function arv_dom_node_append_child(self, new_child)
    @ccall libaravis.arv_dom_node_append_child(self::Ptr{ArvDomNode}, new_child::Ptr{ArvDomNode})::Ptr{ArvDomNode}
end

"""
    arv_dom_node_remove_child(self, old_child)

### Prototype
```c
ARV_API ArvDomNode * arv_dom_node_remove_child (ArvDomNode *self, ArvDomNode *old_child);
```
"""
function arv_dom_node_remove_child(self, old_child)
    @ccall libaravis.arv_dom_node_remove_child(self::Ptr{ArvDomNode}, old_child::Ptr{ArvDomNode})::Ptr{ArvDomNode}
end

"""
    arv_dom_node_has_child_nodes(self)

### Prototype
```c
ARV_API gboolean arv_dom_node_has_child_nodes (ArvDomNode *self);
```
"""
function arv_dom_node_has_child_nodes(self)
    @ccall libaravis.arv_dom_node_has_child_nodes(self::Ptr{ArvDomNode})::gboolean
end

"""
    arv_dom_node_changed(self)

### Prototype
```c
ARV_API void arv_dom_node_changed (ArvDomNode *self);
```
"""
function arv_dom_node_changed(self)
    @ccall libaravis.arv_dom_node_changed(self::Ptr{ArvDomNode})::Cvoid
end

"""
    arv_dom_node_get_owner_document(self)

### Prototype
```c
ARV_API ArvDomDocument * arv_dom_node_get_owner_document (ArvDomNode *self);
```
"""
function arv_dom_node_get_owner_document(self)
    @ccall libaravis.arv_dom_node_get_owner_document(self::Ptr{ArvDomNode})::Ptr{ArvDomDocument}
end

struct _ArvDomDocumentClass
    parent_class::ArvDomNodeClass
    get_document_element::Ptr{Cvoid}
    create_element::Ptr{Cvoid}
    create_text_node::Ptr{Cvoid}
end

const ArvDomDocumentClass = _ArvDomDocumentClass

const ArvDomDocument_autoptr = Ptr{ArvDomDocument}

const ArvDomDocument_listautoptr = Ptr{GList}

const ArvDomDocument_slistautoptr = Ptr{GSList}

const ArvDomDocument_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvDomDocument(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocument, arv_dom_document, ARV, DOM_DOCUMENT, ArvDomNode);
```
"""
function glib_autoptr_clear_ArvDomDocument(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvDomDocument(_ptr::Ptr{ArvDomDocument})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvDomDocument(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocument, arv_dom_document, ARV, DOM_DOCUMENT, ArvDomNode);
```
"""
function glib_autoptr_cleanup_ArvDomDocument(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvDomDocument(_ptr::Ptr{Ptr{ArvDomDocument}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvDomDocument(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocument, arv_dom_document, ARV, DOM_DOCUMENT, ArvDomNode);
```
"""
function glib_autoptr_destroy_ArvDomDocument(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvDomDocument(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvDomDocument(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocument, arv_dom_document, ARV, DOM_DOCUMENT, ArvDomNode);
```
"""
function glib_listautoptr_cleanup_ArvDomDocument(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvDomDocument(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvDomDocument(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocument, arv_dom_document, ARV, DOM_DOCUMENT, ArvDomNode);
```
"""
function glib_slistautoptr_cleanup_ArvDomDocument(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvDomDocument(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvDomDocument(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocument, arv_dom_document, ARV, DOM_DOCUMENT, ArvDomNode);
```
"""
function glib_queueautoptr_cleanup_ArvDomDocument(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvDomDocument(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvDomDocumentClass_autoptr = Ptr{ArvDomDocumentClass}

const ArvDomDocumentClass_listautoptr = Ptr{GList}

const ArvDomDocumentClass_slistautoptr = Ptr{GSList}

const ArvDomDocumentClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvDomDocumentClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocument, arv_dom_document, ARV, DOM_DOCUMENT, ArvDomNode);
```
"""
function glib_autoptr_clear_ArvDomDocumentClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvDomDocumentClass(_ptr::Ptr{ArvDomDocumentClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvDomDocumentClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocument, arv_dom_document, ARV, DOM_DOCUMENT, ArvDomNode);
```
"""
function glib_autoptr_cleanup_ArvDomDocumentClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvDomDocumentClass(_ptr::Ptr{Ptr{ArvDomDocumentClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvDomDocumentClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocument, arv_dom_document, ARV, DOM_DOCUMENT, ArvDomNode);
```
"""
function glib_autoptr_destroy_ArvDomDocumentClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvDomDocumentClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvDomDocumentClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocument, arv_dom_document, ARV, DOM_DOCUMENT, ArvDomNode);
```
"""
function glib_listautoptr_cleanup_ArvDomDocumentClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvDomDocumentClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvDomDocumentClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocument, arv_dom_document, ARV, DOM_DOCUMENT, ArvDomNode);
```
"""
function glib_slistautoptr_cleanup_ArvDomDocumentClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvDomDocumentClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvDomDocumentClass(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocument, arv_dom_document, ARV, DOM_DOCUMENT, ArvDomNode);
```
"""
function glib_queueautoptr_cleanup_ArvDomDocumentClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvDomDocumentClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_DOM_DOCUMENT(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocument, arv_dom_document, ARV, DOM_DOCUMENT, ArvDomNode);
```
"""
function ARV_DOM_DOCUMENT(ptr)
    @ccall libaravis.ARV_DOM_DOCUMENT(ptr::gpointer)::Ptr{ArvDomDocument}
end

"""
    ARV_DOM_DOCUMENT_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocument, arv_dom_document, ARV, DOM_DOCUMENT, ArvDomNode);
```
"""
function ARV_DOM_DOCUMENT_CLASS(ptr)
    @ccall libaravis.ARV_DOM_DOCUMENT_CLASS(ptr::gpointer)::Ptr{ArvDomDocumentClass}
end

"""
    ARV_IS_DOM_DOCUMENT(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocument, arv_dom_document, ARV, DOM_DOCUMENT, ArvDomNode);
```
"""
function ARV_IS_DOM_DOCUMENT(ptr)
    @ccall libaravis.ARV_IS_DOM_DOCUMENT(ptr::gpointer)::gboolean
end

"""
    ARV_IS_DOM_DOCUMENT_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocument, arv_dom_document, ARV, DOM_DOCUMENT, ArvDomNode);
```
"""
function ARV_IS_DOM_DOCUMENT_CLASS(ptr)
    @ccall libaravis.ARV_IS_DOM_DOCUMENT_CLASS(ptr::gpointer)::gboolean
end

"""
    ARV_DOM_DOCUMENT_GET_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocument, arv_dom_document, ARV, DOM_DOCUMENT, ArvDomNode);
```
"""
function ARV_DOM_DOCUMENT_GET_CLASS(ptr)
    @ccall libaravis.ARV_DOM_DOCUMENT_GET_CLASS(ptr::gpointer)::Ptr{ArvDomDocumentClass}
end

"""
    arv_dom_document_get_document_element(self)

### Prototype
```c
ARV_API ArvDomElement* arv_dom_document_get_document_element (ArvDomDocument *self);
```
"""
function arv_dom_document_get_document_element(self)
    @ccall libaravis.arv_dom_document_get_document_element(self::Ptr{ArvDomDocument})::Ptr{ArvDomElement}
end

"""
    arv_dom_document_create_element(self, tag_name)

### Prototype
```c
ARV_API ArvDomElement* arv_dom_document_create_element (ArvDomDocument *self, const char *tag_name);
```
"""
function arv_dom_document_create_element(self, tag_name)
    @ccall libaravis.arv_dom_document_create_element(self::Ptr{ArvDomDocument}, tag_name::Cstring)::Ptr{ArvDomElement}
end

"""
    arv_dom_document_create_text_node(self, data)

### Prototype
```c
ARV_API ArvDomText* arv_dom_document_create_text_node (ArvDomDocument *self, const char *data);
```
"""
function arv_dom_document_create_text_node(self, data)
    @ccall libaravis.arv_dom_document_create_text_node(self::Ptr{ArvDomDocument}, data::Cstring)::Ptr{ArvDomText}
end

"""
    arv_dom_document_get_url(self)

### Prototype
```c
ARV_API const char * arv_dom_document_get_url (ArvDomDocument *self);
```
"""
function arv_dom_document_get_url(self)
    @ccall libaravis.arv_dom_document_get_url(self::Ptr{ArvDomDocument})::Cstring
end

"""
    arv_dom_document_set_url(self, url)

### Prototype
```c
ARV_API void arv_dom_document_set_url (ArvDomDocument *self, const char *url);
```
"""
function arv_dom_document_set_url(self, url)
    @ccall libaravis.arv_dom_document_set_url(self::Ptr{ArvDomDocument}, url::Cstring)::Cvoid
end

"""
    arv_dom_document_set_path(self, path)

### Prototype
```c
ARV_API void arv_dom_document_set_path (ArvDomDocument *self, const char *path);
```
"""
function arv_dom_document_set_path(self, path)
    @ccall libaravis.arv_dom_document_set_path(self::Ptr{ArvDomDocument}, path::Cstring)::Cvoid
end

"""
    arv_dom_document_get_href_data(self, href, size)

### Prototype
```c
ARV_API void * arv_dom_document_get_href_data (ArvDomDocument *self, const char *href, gsize *size);
```
"""
function arv_dom_document_get_href_data(self, href, size)
    @ccall libaravis.arv_dom_document_get_href_data(self::Ptr{ArvDomDocument}, href::Cstring, size::Ptr{gsize})::Ptr{Cvoid}
end

@cenum ArvGcError::UInt32 begin
    ARV_GC_ERROR_PROPERTY_NOT_DEFINED = 0
    ARV_GC_ERROR_PVALUE_NOT_DEFINED = 1
    ARV_GC_ERROR_INVALID_PVALUE = 2
    ARV_GC_ERROR_EMPTY_ENUMERATION = 3
    ARV_GC_ERROR_OUT_OF_RANGE = 4
    ARV_GC_ERROR_NO_DEVICE_SET = 5
    ARV_GC_ERROR_NO_EVENT_IMPLEMENTATION = 6
    ARV_GC_ERROR_NODE_NOT_FOUND = 7
    ARV_GC_ERROR_ENUM_ENTRY_NOT_FOUND = 8
    ARV_GC_ERROR_INVALID_LENGTH = 9
    ARV_GC_ERROR_READ_ONLY = 10
    ARV_GC_ERROR_SET_FROM_STRING_UNDEFINED = 11
    ARV_GC_ERROR_GET_AS_STRING_UNDEFINED = 12
    ARV_GC_ERROR_INVALID_BIT_RANGE = 13
    ARV_GC_ERROR_INVALID_SYNTAX = 14
end

"""
    ArvRegisterCachePolicy

[`ArvRegisterCachePolicy`](@ref): \\_REGISTER\\_CACHE\\_POLICY\\_DISABLE: disable register caching \\_REGISTER\\_CACHE\\_POLICY\\_ENABLE: enable register caching \\_REGISTER\\_CACHE\\_POLICY\\_DEBUG: enable register caching, but read the acual register value for comparison \\_REGISTER\\_CACHE\\_POLICY\\_DEFAULT: default cache policy

Since: 0.8.0
"""
@cenum ArvRegisterCachePolicy::UInt32 begin
    ARV_REGISTER_CACHE_POLICY_DISABLE = 0
    ARV_REGISTER_CACHE_POLICY_ENABLE = 1
    ARV_REGISTER_CACHE_POLICY_DEBUG = 2
    ARV_REGISTER_CACHE_POLICY_DEFAULT = 0
end

"""
    ArvRangeCheckPolicy

[`ArvRangeCheckPolicy`](@ref): \\_RANGE\\_CHECK\\_POLICY\\_DISABLE: never check if float or integer node value is in min/max range \\_RANGE\\_CHECK\\_POLICY\\_ENABLE: always check if if float or integer node is in min/max range \\_RANGE\\_CHECK\\_POLICY\\_DEBUG: check the value, but only display an error message if the value is not allowed (Since 0.8.8) \\_RANGE\\_CHECK\\_POLICY\\_DEFAULT: default range check policy

Since: 0.8.6
"""
@cenum ArvRangeCheckPolicy::UInt32 begin
    ARV_RANGE_CHECK_POLICY_DISABLE = 0
    ARV_RANGE_CHECK_POLICY_ENABLE = 1
    ARV_RANGE_CHECK_POLICY_DEBUG = 2
    ARV_RANGE_CHECK_POLICY_DEFAULT = 0
end

"""
    ArvAccessCheckPolicy

[`ArvAccessCheckPolicy`](@ref): \\_ACCESS\\_CHECK\\_POLICY\\_DISABLE: never check the register access mode \\_ACCESS\\_CHECK\\_POLICY\\_ENABLE: always check the register access mode \\_ACCESSE\\_CHECK\\_POLICY\\_DEFAULT: default access check policy

Since: 0.8.6
"""
@cenum ArvAccessCheckPolicy::UInt32 begin
    ARV_ACCESS_CHECK_POLICY_DISABLE = 0
    ARV_ACCESS_CHECK_POLICY_ENABLE = 1
    ARV_ACCESS_CHECK_POLICY_DEFAULT = 0
end

struct ArvGcClass
    parent_class::ArvDomDocumentClass
end

const ArvGc_autoptr = Ptr{ArvGc}

const ArvGc_listautoptr = Ptr{GList}

const ArvGc_slistautoptr = Ptr{GSList}

const ArvGc_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGc(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGc, arv_gc, ARV, GC, ArvDomDocument);
```
"""
function glib_autoptr_clear_ArvGc(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGc(_ptr::Ptr{ArvGc})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGc(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGc, arv_gc, ARV, GC, ArvDomDocument);
```
"""
function glib_autoptr_cleanup_ArvGc(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGc(_ptr::Ptr{Ptr{ArvGc}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGc(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGc, arv_gc, ARV, GC, ArvDomDocument);
```
"""
function glib_autoptr_destroy_ArvGc(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGc(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGc(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGc, arv_gc, ARV, GC, ArvDomDocument);
```
"""
function glib_listautoptr_cleanup_ArvGc(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGc(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGc(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGc, arv_gc, ARV, GC, ArvDomDocument);
```
"""
function glib_slistautoptr_cleanup_ArvGc(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGc(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGc(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGc, arv_gc, ARV, GC, ArvDomDocument);
```
"""
function glib_queueautoptr_cleanup_ArvGc(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGc(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcClass_autoptr = Ptr{ArvGcClass}

const ArvGcClass_listautoptr = Ptr{GList}

const ArvGcClass_slistautoptr = Ptr{GSList}

const ArvGcClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGc, arv_gc, ARV, GC, ArvDomDocument);
```
"""
function glib_autoptr_clear_ArvGcClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcClass(_ptr::Ptr{ArvGcClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGc, arv_gc, ARV, GC, ArvDomDocument);
```
"""
function glib_autoptr_cleanup_ArvGcClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcClass(_ptr::Ptr{Ptr{ArvGcClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGc, arv_gc, ARV, GC, ArvDomDocument);
```
"""
function glib_autoptr_destroy_ArvGcClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGc, arv_gc, ARV, GC, ArvDomDocument);
```
"""
function glib_listautoptr_cleanup_ArvGcClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGc, arv_gc, ARV, GC, ArvDomDocument);
```
"""
function glib_slistautoptr_cleanup_ArvGcClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGc, arv_gc, ARV, GC, ArvDomDocument);
```
"""
function glib_queueautoptr_cleanup_ArvGcClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGc, arv_gc, ARV, GC, ArvDomDocument);
```
"""
function ARV_GC(ptr)
    @ccall libaravis.ARV_GC(ptr::gpointer)::Ptr{ArvGc}
end

"""
    ARV_IS_GC(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGc, arv_gc, ARV, GC, ArvDomDocument);
```
"""
function ARV_IS_GC(ptr)
    @ccall libaravis.ARV_IS_GC(ptr::gpointer)::gboolean
end

"""
    arv_gc_new(device, xml, size)

### Prototype
```c
ARV_API ArvGc * arv_gc_new (ArvDevice *device, const void *xml, size_t size);
```
"""
function arv_gc_new(device, xml, size)
    @ccall libaravis.arv_gc_new(device::Ptr{ArvDevice}, xml::Ptr{Cvoid}, size::Csize_t)::Ptr{ArvGc}
end

"""
    arv_gc_register_feature_node(genicam, node)

### Prototype
```c
ARV_API void arv_gc_register_feature_node (ArvGc *genicam, ArvGcFeatureNode *node);
```
"""
function arv_gc_register_feature_node(genicam, node)
    @ccall libaravis.arv_gc_register_feature_node(genicam::Ptr{ArvGc}, node::Ptr{ArvGcFeatureNode})::Cvoid
end

"""
    arv_gc_set_register_cache_policy(genicam, policy)

### Prototype
```c
ARV_API void arv_gc_set_register_cache_policy (ArvGc *genicam, ArvRegisterCachePolicy policy);
```
"""
function arv_gc_set_register_cache_policy(genicam, policy)
    @ccall libaravis.arv_gc_set_register_cache_policy(genicam::Ptr{ArvGc}, policy::ArvRegisterCachePolicy)::Cvoid
end

"""
    arv_gc_get_register_cache_policy(genicam)

### Prototype
```c
ARV_API ArvRegisterCachePolicy arv_gc_get_register_cache_policy (ArvGc *genicam);
```
"""
function arv_gc_get_register_cache_policy(genicam)
    @ccall libaravis.arv_gc_get_register_cache_policy(genicam::Ptr{ArvGc})::ArvRegisterCachePolicy
end

"""
    arv_gc_set_range_check_policy(genicam, policy)

### Prototype
```c
ARV_API void arv_gc_set_range_check_policy (ArvGc *genicam, ArvRangeCheckPolicy policy);
```
"""
function arv_gc_set_range_check_policy(genicam, policy)
    @ccall libaravis.arv_gc_set_range_check_policy(genicam::Ptr{ArvGc}, policy::ArvRangeCheckPolicy)::Cvoid
end

"""
    arv_gc_get_range_check_policy(genicam)

### Prototype
```c
ARV_API ArvRangeCheckPolicy arv_gc_get_range_check_policy (ArvGc *genicam);
```
"""
function arv_gc_get_range_check_policy(genicam)
    @ccall libaravis.arv_gc_get_range_check_policy(genicam::Ptr{ArvGc})::ArvRangeCheckPolicy
end

"""
    arv_gc_set_access_check_policy(genicam, policy)

### Prototype
```c
ARV_API void arv_gc_set_access_check_policy (ArvGc *genicam, ArvAccessCheckPolicy policy);
```
"""
function arv_gc_set_access_check_policy(genicam, policy)
    @ccall libaravis.arv_gc_set_access_check_policy(genicam::Ptr{ArvGc}, policy::ArvAccessCheckPolicy)::Cvoid
end

"""
    arv_gc_get_access_check_policy(genicam)

### Prototype
```c
ARV_API ArvAccessCheckPolicy arv_gc_get_access_check_policy (ArvGc *genicam);
```
"""
function arv_gc_get_access_check_policy(genicam)
    @ccall libaravis.arv_gc_get_access_check_policy(genicam::Ptr{ArvGc})::ArvAccessCheckPolicy
end

"""
    arv_gc_get_node(genicam, name)

### Prototype
```c
ARV_API ArvGcNode * arv_gc_get_node (ArvGc *genicam, const char *name);
```
"""
function arv_gc_get_node(genicam, name)
    @ccall libaravis.arv_gc_get_node(genicam::Ptr{ArvGc}, name::Cstring)::Ptr{ArvGcNode}
end

"""
    arv_gc_get_device(genicam)

### Prototype
```c
ARV_API ArvDevice * arv_gc_get_device (ArvGc *genicam);
```
"""
function arv_gc_get_device(genicam)
    @ccall libaravis.arv_gc_get_device(genicam::Ptr{ArvGc})::Ptr{ArvDevice}
end

"""
    arv_gc_set_buffer(genicam, buffer)

### Prototype
```c
ARV_API void arv_gc_set_buffer (ArvGc *genicam, ArvBuffer *buffer);
```
"""
function arv_gc_set_buffer(genicam, buffer)
    @ccall libaravis.arv_gc_set_buffer(genicam::Ptr{ArvGc}, buffer::Ptr{ArvBuffer})::Cvoid
end

"""
    arv_gc_get_buffer(genicam)

### Prototype
```c
ARV_API ArvBuffer * arv_gc_get_buffer (ArvGc *genicam);
```
"""
function arv_gc_get_buffer(genicam)
    @ccall libaravis.arv_gc_get_buffer(genicam::Ptr{ArvGc})::Ptr{ArvBuffer}
end

"""
    ArvChunkParserError

[`ArvChunkParserError`](@ref): \\_CHUNK\\_PARSER\\_ERROR\\_INVALID\\_FEATURE\\_TYPE: invalid feature type \\_CHUNK\\_PARSER\\_ERROR\\_BUFFER\\_NOT\\_FOUND: a buffer is not attached to the chunk parser \\_CHUNK\\_PARSER\\_ERROR\\_CHUNK\\_NOT\\_FOUND: the requested chunk is not found in the buffer data
"""
@cenum ArvChunkParserError::UInt32 begin
    ARV_CHUNK_PARSER_ERROR_INVALID_FEATURE_TYPE = 0
    ARV_CHUNK_PARSER_ERROR_BUFFER_NOT_FOUND = 1
    ARV_CHUNK_PARSER_ERROR_CHUNK_NOT_FOUND = 2
    ARV_CHUNK_PARSER_ERROR_FEATURE_NOT_FOUND = 3
end

struct ArvChunkParserClass
    parent_class::GObjectClass
end

const ArvChunkParser_autoptr = Ptr{ArvChunkParser}

const ArvChunkParser_listautoptr = Ptr{GList}

const ArvChunkParser_slistautoptr = Ptr{GSList}

const ArvChunkParser_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvChunkParser(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvChunkParser, arv_chunk_parser, ARV, CHUNK_PARSER, GObject);
```
"""
function glib_autoptr_clear_ArvChunkParser(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvChunkParser(_ptr::Ptr{ArvChunkParser})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvChunkParser(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvChunkParser, arv_chunk_parser, ARV, CHUNK_PARSER, GObject);
```
"""
function glib_autoptr_cleanup_ArvChunkParser(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvChunkParser(_ptr::Ptr{Ptr{ArvChunkParser}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvChunkParser(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvChunkParser, arv_chunk_parser, ARV, CHUNK_PARSER, GObject);
```
"""
function glib_autoptr_destroy_ArvChunkParser(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvChunkParser(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvChunkParser(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvChunkParser, arv_chunk_parser, ARV, CHUNK_PARSER, GObject);
```
"""
function glib_listautoptr_cleanup_ArvChunkParser(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvChunkParser(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvChunkParser(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvChunkParser, arv_chunk_parser, ARV, CHUNK_PARSER, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvChunkParser(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvChunkParser(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvChunkParser(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvChunkParser, arv_chunk_parser, ARV, CHUNK_PARSER, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvChunkParser(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvChunkParser(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvChunkParserClass_autoptr = Ptr{ArvChunkParserClass}

const ArvChunkParserClass_listautoptr = Ptr{GList}

const ArvChunkParserClass_slistautoptr = Ptr{GSList}

const ArvChunkParserClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvChunkParserClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvChunkParser, arv_chunk_parser, ARV, CHUNK_PARSER, GObject);
```
"""
function glib_autoptr_clear_ArvChunkParserClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvChunkParserClass(_ptr::Ptr{ArvChunkParserClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvChunkParserClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvChunkParser, arv_chunk_parser, ARV, CHUNK_PARSER, GObject);
```
"""
function glib_autoptr_cleanup_ArvChunkParserClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvChunkParserClass(_ptr::Ptr{Ptr{ArvChunkParserClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvChunkParserClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvChunkParser, arv_chunk_parser, ARV, CHUNK_PARSER, GObject);
```
"""
function glib_autoptr_destroy_ArvChunkParserClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvChunkParserClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvChunkParserClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvChunkParser, arv_chunk_parser, ARV, CHUNK_PARSER, GObject);
```
"""
function glib_listautoptr_cleanup_ArvChunkParserClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvChunkParserClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvChunkParserClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvChunkParser, arv_chunk_parser, ARV, CHUNK_PARSER, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvChunkParserClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvChunkParserClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvChunkParserClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvChunkParser, arv_chunk_parser, ARV, CHUNK_PARSER, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvChunkParserClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvChunkParserClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_CHUNK_PARSER(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvChunkParser, arv_chunk_parser, ARV, CHUNK_PARSER, GObject);
```
"""
function ARV_CHUNK_PARSER(ptr)
    @ccall libaravis.ARV_CHUNK_PARSER(ptr::gpointer)::Ptr{ArvChunkParser}
end

"""
    ARV_IS_CHUNK_PARSER(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvChunkParser, arv_chunk_parser, ARV, CHUNK_PARSER, GObject);
```
"""
function ARV_IS_CHUNK_PARSER(ptr)
    @ccall libaravis.ARV_IS_CHUNK_PARSER(ptr::gpointer)::gboolean
end

"""
    arv_chunk_parser_new(xml, size)

### Prototype
```c
ARV_API ArvChunkParser * arv_chunk_parser_new (const char *xml, gsize size);
```
"""
function arv_chunk_parser_new(xml, size)
    @ccall libaravis.arv_chunk_parser_new(xml::Cstring, size::gsize)::Ptr{ArvChunkParser}
end

"""
    arv_chunk_parser_get_boolean_value(parser, buffer, chunk, error)

### Prototype
```c
ARV_API gboolean arv_chunk_parser_get_boolean_value (ArvChunkParser *parser, ArvBuffer *buffer, const char *chunk, GError **error);
```
"""
function arv_chunk_parser_get_boolean_value(parser, buffer, chunk, error)
    @ccall libaravis.arv_chunk_parser_get_boolean_value(parser::Ptr{ArvChunkParser}, buffer::Ptr{ArvBuffer}, chunk::Cstring, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_chunk_parser_get_string_value(parser, buffer, chunk, error)

### Prototype
```c
ARV_API const char * arv_chunk_parser_get_string_value (ArvChunkParser *parser, ArvBuffer *buffer, const char *chunk, GError **error);
```
"""
function arv_chunk_parser_get_string_value(parser, buffer, chunk, error)
    @ccall libaravis.arv_chunk_parser_get_string_value(parser::Ptr{ArvChunkParser}, buffer::Ptr{ArvBuffer}, chunk::Cstring, error::Ptr{Ptr{GError}})::Cstring
end

"""
    arv_chunk_parser_get_integer_value(parser, buffer, chunk, error)

### Prototype
```c
ARV_API gint64 arv_chunk_parser_get_integer_value (ArvChunkParser *parser, ArvBuffer *buffer, const char *chunk, GError **error);
```
"""
function arv_chunk_parser_get_integer_value(parser, buffer, chunk, error)
    @ccall libaravis.arv_chunk_parser_get_integer_value(parser::Ptr{ArvChunkParser}, buffer::Ptr{ArvBuffer}, chunk::Cstring, error::Ptr{Ptr{GError}})::gint64
end

"""
    arv_chunk_parser_get_float_value(parser, buffer, chunk, error)

### Prototype
```c
ARV_API double arv_chunk_parser_get_float_value (ArvChunkParser *parser, ArvBuffer *buffer, const char *chunk, GError **error);
```
"""
function arv_chunk_parser_get_float_value(parser, buffer, chunk, error)
    @ccall libaravis.arv_chunk_parser_get_float_value(parser::Ptr{ArvChunkParser}, buffer::Ptr{ArvBuffer}, chunk::Cstring, error::Ptr{Ptr{GError}})::Cdouble
end

"""
    arv_chunk_parser_set_string_feature_value(parser, feature, value, error)

### Prototype
```c
ARV_API void arv_chunk_parser_set_string_feature_value (ArvChunkParser *parser, const char *feature, const char *value, GError **error);
```
"""
function arv_chunk_parser_set_string_feature_value(parser, feature, value, error)
    @ccall libaravis.arv_chunk_parser_set_string_feature_value(parser::Ptr{ArvChunkParser}, feature::Cstring, value::Cstring, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_chunk_parser_set_integer_feature_value(parser, feature, value, error)

### Prototype
```c
ARV_API void arv_chunk_parser_set_integer_feature_value (ArvChunkParser *parser, const char *feature, gint64 value, GError **error);
```
"""
function arv_chunk_parser_set_integer_feature_value(parser, feature, value, error)
    @ccall libaravis.arv_chunk_parser_set_integer_feature_value(parser::Ptr{ArvChunkParser}, feature::Cstring, value::gint64, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    ArvDeviceError

[`ArvDeviceError`](@ref): \\_DEVICE\\_ERROR\\_WRONG\\_FEATURE: Wrong feature type \\_DEVICE\\_ERROR\\_FEATURE\\_NOT\\_FOUND: Feature node not found \\_DEVICE\\_ERROR\\_NOT\\_CONNECTED: Device is not connected \\_DEVICE\\_ERROR\\_PROTOCOL\\_ERROR: Protocol error \\_DEVICE\\_ERROR\\_TRANSFER\\_ERROR: Transfer error \\_DEVICE\\_ERROR\\_TIMEOUT: Timeout detected \\_DEVICE\\_ERROR\\_NOT\\_FOUND: Device not found \\_DEVICE\\_ERROR\\_INVALID\\_PARAMETER: Invalid construction parameter \\_DEVICE\\_ERROR\\_GENICAM\\_NOT\\_FOUND: Missing Genicam data \\_DEVICE\\_ERROR\\_NO\\_STREAM\\_CHANNEL: No stream channel found \\_DEVICE\\_ERROR\\_NOT\\_CONTROLLER: Controller privilege required \\_DEVICE\\_ERROR\\_UNKNOWN: Unknown error
"""
@cenum ArvDeviceError::UInt32 begin
    ARV_DEVICE_ERROR_WRONG_FEATURE = 0
    ARV_DEVICE_ERROR_FEATURE_NOT_FOUND = 1
    ARV_DEVICE_ERROR_NOT_CONNECTED = 2
    ARV_DEVICE_ERROR_PROTOCOL_ERROR = 3
    ARV_DEVICE_ERROR_TRANSFER_ERROR = 4
    ARV_DEVICE_ERROR_TIMEOUT = 5
    ARV_DEVICE_ERROR_NOT_FOUND = 6
    ARV_DEVICE_ERROR_INVALID_PARAMETER = 7
    ARV_DEVICE_ERROR_GENICAM_NOT_FOUND = 8
    ARV_DEVICE_ERROR_NO_STREAM_CHANNEL = 9
    ARV_DEVICE_ERROR_NOT_CONTROLLER = 10
    ARV_DEVICE_ERROR_UNKNOWN = 11
    ARV_DEVICE_ERROR_PROTOCOL_ERROR_NOT_IMPLEMENTED = 12
    ARV_DEVICE_ERROR_PROTOCOL_ERROR_INVALID_PARAMETER = 13
    ARV_DEVICE_ERROR_PROTOCOL_ERROR_INVALID_ADDRESS = 14
    ARV_DEVICE_ERROR_PROTOCOL_ERROR_WRITE_PROTECT = 15
    ARV_DEVICE_ERROR_PROTOCOL_ERROR_BAD_ALIGNMENT = 16
    ARV_DEVICE_ERROR_PROTOCOL_ERROR_ACCESS_DENIED = 17
    ARV_DEVICE_ERROR_PROTOCOL_ERROR_BUSY = 18
end

struct _ArvDeviceClass
    parent_class::GObjectClass
    create_stream::Ptr{Cvoid}
    get_genicam_xml::Ptr{Cvoid}
    get_genicam::Ptr{Cvoid}
    read_memory::Ptr{Cvoid}
    write_memory::Ptr{Cvoid}
    read_register::Ptr{Cvoid}
    write_register::Ptr{Cvoid}
    control_lost::Ptr{Cvoid}
end

const ArvDeviceClass = _ArvDeviceClass

const ArvDevice_autoptr = Ptr{ArvDevice}

const ArvDevice_listautoptr = Ptr{GList}

const ArvDevice_slistautoptr = Ptr{GSList}

const ArvDevice_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvDevice(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDevice, arv_device, ARV, DEVICE, GObject);
```
"""
function glib_autoptr_clear_ArvDevice(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvDevice(_ptr::Ptr{ArvDevice})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvDevice(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDevice, arv_device, ARV, DEVICE, GObject);
```
"""
function glib_autoptr_cleanup_ArvDevice(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvDevice(_ptr::Ptr{Ptr{ArvDevice}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvDevice(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDevice, arv_device, ARV, DEVICE, GObject);
```
"""
function glib_autoptr_destroy_ArvDevice(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvDevice(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvDevice(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDevice, arv_device, ARV, DEVICE, GObject);
```
"""
function glib_listautoptr_cleanup_ArvDevice(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvDevice(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvDevice(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDevice, arv_device, ARV, DEVICE, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvDevice(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvDevice(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvDevice(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDevice, arv_device, ARV, DEVICE, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvDevice(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvDevice(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvDeviceClass_autoptr = Ptr{ArvDeviceClass}

const ArvDeviceClass_listautoptr = Ptr{GList}

const ArvDeviceClass_slistautoptr = Ptr{GSList}

const ArvDeviceClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvDeviceClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDevice, arv_device, ARV, DEVICE, GObject);
```
"""
function glib_autoptr_clear_ArvDeviceClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvDeviceClass(_ptr::Ptr{ArvDeviceClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvDeviceClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDevice, arv_device, ARV, DEVICE, GObject);
```
"""
function glib_autoptr_cleanup_ArvDeviceClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvDeviceClass(_ptr::Ptr{Ptr{ArvDeviceClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvDeviceClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDevice, arv_device, ARV, DEVICE, GObject);
```
"""
function glib_autoptr_destroy_ArvDeviceClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvDeviceClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvDeviceClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDevice, arv_device, ARV, DEVICE, GObject);
```
"""
function glib_listautoptr_cleanup_ArvDeviceClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvDeviceClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvDeviceClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDevice, arv_device, ARV, DEVICE, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvDeviceClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvDeviceClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvDeviceClass(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDevice, arv_device, ARV, DEVICE, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvDeviceClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvDeviceClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_DEVICE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDevice, arv_device, ARV, DEVICE, GObject);
```
"""
function ARV_DEVICE(ptr)
    @ccall libaravis.ARV_DEVICE(ptr::gpointer)::Ptr{ArvDevice}
end

"""
    ARV_DEVICE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDevice, arv_device, ARV, DEVICE, GObject);
```
"""
function ARV_DEVICE_CLASS(ptr)
    @ccall libaravis.ARV_DEVICE_CLASS(ptr::gpointer)::Ptr{ArvDeviceClass}
end

"""
    ARV_IS_DEVICE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDevice, arv_device, ARV, DEVICE, GObject);
```
"""
function ARV_IS_DEVICE(ptr)
    @ccall libaravis.ARV_IS_DEVICE(ptr::gpointer)::gboolean
end

"""
    ARV_IS_DEVICE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDevice, arv_device, ARV, DEVICE, GObject);
```
"""
function ARV_IS_DEVICE_CLASS(ptr)
    @ccall libaravis.ARV_IS_DEVICE_CLASS(ptr::gpointer)::gboolean
end

"""
    ARV_DEVICE_GET_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDevice, arv_device, ARV, DEVICE, GObject);
```
"""
function ARV_DEVICE_GET_CLASS(ptr)
    @ccall libaravis.ARV_DEVICE_GET_CLASS(ptr::gpointer)::Ptr{ArvDeviceClass}
end

"""
    arv_device_create_stream(device, callback, user_data, error)

### Prototype
```c
ARV_API ArvStream * arv_device_create_stream (ArvDevice *device, ArvStreamCallback callback, void *user_data, GError **error);
```
"""
function arv_device_create_stream(device, callback, user_data, error)
    @ccall libaravis.arv_device_create_stream(device::Ptr{ArvDevice}, callback::ArvStreamCallback, user_data::Ptr{Cvoid}, error::Ptr{Ptr{GError}})::Ptr{ArvStream}
end

"""
    arv_device_create_stream_full(device, callback, user_data, destroy, error)

### Prototype
```c
ARV_API ArvStream * arv_device_create_stream_full (ArvDevice *device, ArvStreamCallback callback, void *user_data, GDestroyNotify destroy, GError **error);
```
"""
function arv_device_create_stream_full(device, callback, user_data, destroy, error)
    @ccall libaravis.arv_device_create_stream_full(device::Ptr{ArvDevice}, callback::ArvStreamCallback, user_data::Ptr{Cvoid}, destroy::GDestroyNotify, error::Ptr{Ptr{GError}})::Ptr{ArvStream}
end

"""
    arv_device_read_memory(device, address, size, buffer, error)

### Prototype
```c
ARV_API gboolean arv_device_read_memory (ArvDevice *device, guint64 address, guint32 size, void *buffer, GError **error);
```
"""
function arv_device_read_memory(device, address, size, buffer, error)
    @ccall libaravis.arv_device_read_memory(device::Ptr{ArvDevice}, address::guint64, size::guint32, buffer::Ptr{Cvoid}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_device_write_memory(device, address, size, buffer, error)

### Prototype
```c
ARV_API gboolean arv_device_write_memory (ArvDevice *device, guint64 address, guint32 size, const void *buffer, GError **error);
```
"""
function arv_device_write_memory(device, address, size, buffer, error)
    @ccall libaravis.arv_device_write_memory(device::Ptr{ArvDevice}, address::guint64, size::guint32, buffer::Ptr{Cvoid}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_device_read_register(device, address, value, error)

### Prototype
```c
ARV_API gboolean arv_device_read_register (ArvDevice *device, guint64 address, guint32 *value, GError **error);
```
"""
function arv_device_read_register(device, address, value, error)
    @ccall libaravis.arv_device_read_register(device::Ptr{ArvDevice}, address::guint64, value::Ptr{guint32}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_device_write_register(device, address, value, error)

### Prototype
```c
ARV_API gboolean arv_device_write_register (ArvDevice *device, guint64 address, guint32 value, GError **error);
```
"""
function arv_device_write_register(device, address, value, error)
    @ccall libaravis.arv_device_write_register(device::Ptr{ArvDevice}, address::guint64, value::guint32, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_device_get_genicam_xml(device, size)

### Prototype
```c
ARV_API const char * arv_device_get_genicam_xml (ArvDevice *device, size_t *size);
```
"""
function arv_device_get_genicam_xml(device, size)
    @ccall libaravis.arv_device_get_genicam_xml(device::Ptr{ArvDevice}, size::Ptr{Csize_t})::Cstring
end

"""
    arv_device_get_genicam(device)

### Prototype
```c
ARV_API ArvGc * arv_device_get_genicam (ArvDevice *device);
```
"""
function arv_device_get_genicam(device)
    @ccall libaravis.arv_device_get_genicam(device::Ptr{ArvDevice})::Ptr{ArvGc}
end

"""
    arv_device_is_feature_available(device, feature, error)

### Prototype
```c
ARV_API gboolean arv_device_is_feature_available (ArvDevice *device, const char *feature, GError **error);
```
"""
function arv_device_is_feature_available(device, feature, error)
    @ccall libaravis.arv_device_is_feature_available(device::Ptr{ArvDevice}, feature::Cstring, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_device_is_feature_implemented(device, feature, error)

### Prototype
```c
ARV_API gboolean arv_device_is_feature_implemented (ArvDevice *device, const char *feature, GError **error);
```
"""
function arv_device_is_feature_implemented(device, feature, error)
    @ccall libaravis.arv_device_is_feature_implemented(device::Ptr{ArvDevice}, feature::Cstring, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_device_get_feature(device, feature)

### Prototype
```c
ARV_API ArvGcNode * arv_device_get_feature (ArvDevice *device, const char *feature);
```
"""
function arv_device_get_feature(device, feature)
    @ccall libaravis.arv_device_get_feature(device::Ptr{ArvDevice}, feature::Cstring)::Ptr{ArvGcNode}
end

"""
    arv_device_get_feature_access_mode(device, feature)

### Prototype
```c
ARV_API ArvGcAccessMode arv_device_get_feature_access_mode (ArvDevice *device, const char *feature);
```
"""
function arv_device_get_feature_access_mode(device, feature)
    @ccall libaravis.arv_device_get_feature_access_mode(device::Ptr{ArvDevice}, feature::Cstring)::ArvGcAccessMode
end

"""
    arv_device_get_feature_representation(device, feature)

### Prototype
```c
ARV_API ArvGcRepresentation arv_device_get_feature_representation (ArvDevice *device, const char *feature);
```
"""
function arv_device_get_feature_representation(device, feature)
    @ccall libaravis.arv_device_get_feature_representation(device::Ptr{ArvDevice}, feature::Cstring)::ArvGcRepresentation
end

"""
    arv_device_create_chunk_parser(device)

### Prototype
```c
ARV_API ArvChunkParser *arv_device_create_chunk_parser (ArvDevice *device);
```
"""
function arv_device_create_chunk_parser(device)
    @ccall libaravis.arv_device_create_chunk_parser(device::Ptr{ArvDevice})::Ptr{ArvChunkParser}
end

"""
    arv_device_execute_command(device, feature, error)

### Prototype
```c
ARV_API void arv_device_execute_command (ArvDevice *device, const char *feature, GError **error);
```
"""
function arv_device_execute_command(device, feature, error)
    @ccall libaravis.arv_device_execute_command(device::Ptr{ArvDevice}, feature::Cstring, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_device_get_feature_value(device, feature, value, error)

### Prototype
```c
ARV_API void arv_device_get_feature_value (ArvDevice *device, const char *feature, GValue *value, GError **error);
```
"""
function arv_device_get_feature_value(device, feature, value, error)
    @ccall libaravis.arv_device_get_feature_value(device::Ptr{ArvDevice}, feature::Cstring, value::Ptr{GValue}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_device_set_feature_value(device, feature, value, error)

### Prototype
```c
ARV_API void arv_device_set_feature_value (ArvDevice *device, const char *feature, const GValue *value, GError **error);
```
"""
function arv_device_set_feature_value(device, feature, value, error)
    @ccall libaravis.arv_device_set_feature_value(device::Ptr{ArvDevice}, feature::Cstring, value::Ptr{GValue}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_device_set_boolean_feature_value(device, feature, value, error)

### Prototype
```c
ARV_API void arv_device_set_boolean_feature_value (ArvDevice *device, const char *feature, gboolean value, GError **error);
```
"""
function arv_device_set_boolean_feature_value(device, feature, value, error)
    @ccall libaravis.arv_device_set_boolean_feature_value(device::Ptr{ArvDevice}, feature::Cstring, value::gboolean, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_device_get_boolean_feature_value(device, feature, error)

### Prototype
```c
ARV_API gboolean arv_device_get_boolean_feature_value (ArvDevice *device, const char *feature, GError **error);
```
"""
function arv_device_get_boolean_feature_value(device, feature, error)
    @ccall libaravis.arv_device_get_boolean_feature_value(device::Ptr{ArvDevice}, feature::Cstring, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_device_get_boolean_feature_value_gi(device, feature, value, error)

### Prototype
```c
ARV_API void arv_device_get_boolean_feature_value_gi (ArvDevice *device, const char *feature, gboolean *value, GError **error);
```
"""
function arv_device_get_boolean_feature_value_gi(device, feature, value, error)
    @ccall libaravis.arv_device_get_boolean_feature_value_gi(device::Ptr{ArvDevice}, feature::Cstring, value::Ptr{gboolean}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_device_set_string_feature_value(device, feature, value, error)

### Prototype
```c
ARV_API void arv_device_set_string_feature_value (ArvDevice *device, const char *feature, const char *value, GError **error);
```
"""
function arv_device_set_string_feature_value(device, feature, value, error)
    @ccall libaravis.arv_device_set_string_feature_value(device::Ptr{ArvDevice}, feature::Cstring, value::Cstring, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_device_get_string_feature_value(device, feature, error)

### Prototype
```c
ARV_API const char * arv_device_get_string_feature_value (ArvDevice *device, const char *feature, GError **error);
```
"""
function arv_device_get_string_feature_value(device, feature, error)
    @ccall libaravis.arv_device_get_string_feature_value(device::Ptr{ArvDevice}, feature::Cstring, error::Ptr{Ptr{GError}})::Cstring
end

"""
    arv_device_set_integer_feature_value(device, feature, value, error)

### Prototype
```c
ARV_API void arv_device_set_integer_feature_value (ArvDevice *device, const char *feature, gint64 value, GError **error);
```
"""
function arv_device_set_integer_feature_value(device, feature, value, error)
    @ccall libaravis.arv_device_set_integer_feature_value(device::Ptr{ArvDevice}, feature::Cstring, value::gint64, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_device_get_integer_feature_value(device, feature, error)

### Prototype
```c
ARV_API gint64 arv_device_get_integer_feature_value (ArvDevice *device, const char *feature, GError **error);
```
"""
function arv_device_get_integer_feature_value(device, feature, error)
    @ccall libaravis.arv_device_get_integer_feature_value(device::Ptr{ArvDevice}, feature::Cstring, error::Ptr{Ptr{GError}})::gint64
end

"""
    arv_device_get_integer_feature_bounds(device, feature, min, max, error)

### Prototype
```c
ARV_API void arv_device_get_integer_feature_bounds (ArvDevice *device, const char *feature, gint64 *min, gint64 *max, GError **error);
```
"""
function arv_device_get_integer_feature_bounds(device, feature, min, max, error)
    @ccall libaravis.arv_device_get_integer_feature_bounds(device::Ptr{ArvDevice}, feature::Cstring, min::Ptr{gint64}, max::Ptr{gint64}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_device_get_integer_feature_increment(device, feature, error)

### Prototype
```c
ARV_API gint64 arv_device_get_integer_feature_increment(ArvDevice *device, const char *feature, GError **error);
```
"""
function arv_device_get_integer_feature_increment(device, feature, error)
    @ccall libaravis.arv_device_get_integer_feature_increment(device::Ptr{ArvDevice}, feature::Cstring, error::Ptr{Ptr{GError}})::gint64
end

"""
    arv_device_set_float_feature_value(device, feature, value, error)

### Prototype
```c
ARV_API void arv_device_set_float_feature_value (ArvDevice *device, const char *feature, double value, GError **error);
```
"""
function arv_device_set_float_feature_value(device, feature, value, error)
    @ccall libaravis.arv_device_set_float_feature_value(device::Ptr{ArvDevice}, feature::Cstring, value::Cdouble, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_device_get_float_feature_value(device, feature, error)

### Prototype
```c
ARV_API double arv_device_get_float_feature_value (ArvDevice *device, const char *feature, GError **error);
```
"""
function arv_device_get_float_feature_value(device, feature, error)
    @ccall libaravis.arv_device_get_float_feature_value(device::Ptr{ArvDevice}, feature::Cstring, error::Ptr{Ptr{GError}})::Cdouble
end

"""
    arv_device_get_float_feature_bounds(device, feature, min, max, error)

### Prototype
```c
ARV_API void arv_device_get_float_feature_bounds (ArvDevice *device, const char *feature, double *min, double *max, GError **error);
```
"""
function arv_device_get_float_feature_bounds(device, feature, min, max, error)
    @ccall libaravis.arv_device_get_float_feature_bounds(device::Ptr{ArvDevice}, feature::Cstring, min::Ptr{Cdouble}, max::Ptr{Cdouble}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_device_get_float_feature_increment(device, feature, error)

### Prototype
```c
ARV_API double arv_device_get_float_feature_increment (ArvDevice *device, const char *feature, GError **error);
```
"""
function arv_device_get_float_feature_increment(device, feature, error)
    @ccall libaravis.arv_device_get_float_feature_increment(device::Ptr{ArvDevice}, feature::Cstring, error::Ptr{Ptr{GError}})::Cdouble
end

"""
    arv_device_set_register_feature_value(device, feature, length, value, error)

### Prototype
```c
ARV_API void arv_device_set_register_feature_value (ArvDevice *device, const char *feature, guint64 length, void* value, GError **error);
```
"""
function arv_device_set_register_feature_value(device, feature, length, value, error)
    @ccall libaravis.arv_device_set_register_feature_value(device::Ptr{ArvDevice}, feature::Cstring, length::guint64, value::Ptr{Cvoid}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_device_dup_register_feature_value(device, feature, length, error)

### Prototype
```c
ARV_API void * arv_device_dup_register_feature_value (ArvDevice *device, const char *feature, guint64 *length, GError **error);
```
"""
function arv_device_dup_register_feature_value(device, feature, length, error)
    @ccall libaravis.arv_device_dup_register_feature_value(device::Ptr{ArvDevice}, feature::Cstring, length::Ptr{guint64}, error::Ptr{Ptr{GError}})::Ptr{Cvoid}
end

"""
    arv_device_dup_available_enumeration_feature_values(device, feature, n_values, error)

### Prototype
```c
ARV_API gint64 * arv_device_dup_available_enumeration_feature_values (ArvDevice *device, const char *feature, guint *n_values, GError **error);
```
"""
function arv_device_dup_available_enumeration_feature_values(device, feature, n_values, error)
    @ccall libaravis.arv_device_dup_available_enumeration_feature_values(device::Ptr{ArvDevice}, feature::Cstring, n_values::Ptr{guint}, error::Ptr{Ptr{GError}})::Ptr{gint64}
end

"""
    arv_device_dup_available_enumeration_feature_values_as_strings(device, feature, n_values, error)

### Prototype
```c
ARV_API const char ** arv_device_dup_available_enumeration_feature_values_as_strings (ArvDevice *device, const char *feature, guint *n_values, GError **error);
```
"""
function arv_device_dup_available_enumeration_feature_values_as_strings(device, feature, n_values, error)
    @ccall libaravis.arv_device_dup_available_enumeration_feature_values_as_strings(device::Ptr{ArvDevice}, feature::Cstring, n_values::Ptr{guint}, error::Ptr{Ptr{GError}})::Ptr{Cstring}
end

"""
    arv_device_dup_available_enumeration_feature_values_as_display_names(device, feature, n_values, error)

### Prototype
```c
ARV_API const char ** arv_device_dup_available_enumeration_feature_values_as_display_names (ArvDevice *device, const char *feature, guint *n_values, GError **error);
```
"""
function arv_device_dup_available_enumeration_feature_values_as_display_names(device, feature, n_values, error)
    @ccall libaravis.arv_device_dup_available_enumeration_feature_values_as_display_names(device::Ptr{ArvDevice}, feature::Cstring, n_values::Ptr{guint}, error::Ptr{Ptr{GError}})::Ptr{Cstring}
end

"""
    arv_device_is_enumeration_entry_available(device, feature, entry, error)

### Prototype
```c
ARV_API gboolean arv_device_is_enumeration_entry_available (ArvDevice *device, const char *feature, const char *entry, GError **error);
```
"""
function arv_device_is_enumeration_entry_available(device, feature, entry, error)
    @ccall libaravis.arv_device_is_enumeration_entry_available(device::Ptr{ArvDevice}, feature::Cstring, entry::Cstring, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_device_set_features_from_string(device, string, error)

### Prototype
```c
ARV_API gboolean arv_device_set_features_from_string (ArvDevice *device, const char *string, GError **error);
```
"""
function arv_device_set_features_from_string(device, string, error)
    @ccall libaravis.arv_device_set_features_from_string(device::Ptr{ArvDevice}, string::Cstring, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_device_set_register_cache_policy(device, policy)

### Prototype
```c
ARV_API void arv_device_set_register_cache_policy (ArvDevice *device, ArvRegisterCachePolicy policy);
```
"""
function arv_device_set_register_cache_policy(device, policy)
    @ccall libaravis.arv_device_set_register_cache_policy(device::Ptr{ArvDevice}, policy::ArvRegisterCachePolicy)::Cvoid
end

"""
    arv_device_set_range_check_policy(device, policy)

### Prototype
```c
ARV_API void arv_device_set_range_check_policy (ArvDevice *device, ArvRangeCheckPolicy policy);
```
"""
function arv_device_set_range_check_policy(device, policy)
    @ccall libaravis.arv_device_set_range_check_policy(device::Ptr{ArvDevice}, policy::ArvRangeCheckPolicy)::Cvoid
end

"""
    arv_device_set_access_check_policy(device, policy)

### Prototype
```c
ARV_API void arv_device_set_access_check_policy (ArvDevice *device, ArvAccessCheckPolicy policy);
```
"""
function arv_device_set_access_check_policy(device, policy)
    @ccall libaravis.arv_device_set_access_check_policy(device::Ptr{ArvDevice}, policy::ArvAccessCheckPolicy)::Cvoid
end

"""
    ArvGvPacketSizeAdjustment

[`ArvGvPacketSizeAdjustment`](@ref): \\_GV\\_PACKET\\_SIZE\\_ADJUSTMENT\\_NEVER: never adjust packet size \\_GV\\_PACKET\\_SIZE\\_ADJUSTMENT\\_ON\\_FAILURE\\_ONCE: adjust packet size if test packet check fails the with current packet size, only on the first stream creation \\_GV\\_PACKET\\_SIZE\\_ADJUSTMENT\\_ON\\_FAILURE: adjust packet size if test packet check fails with current packet size \\_GV\\_PACKET\\_SIZE\\_ADJUSTMENT\\_ONCE: adjust packet size on the first stream creation \\_GV\\_PACKET\\_SIZE\\_ADJUSTMENT\\_ALWAYS: always adjust the stream packet size \\_GV\\_PACKET\\_SIZE\\_ADJUSTMENT\\_DEFAULT: default adjustment, which is ON\\_FAILURE\\_ONCE (Since 0.8.8)
"""
@cenum ArvGvPacketSizeAdjustment::UInt32 begin
    ARV_GV_PACKET_SIZE_ADJUSTMENT_NEVER = 0
    ARV_GV_PACKET_SIZE_ADJUSTMENT_ON_FAILURE_ONCE = 1
    ARV_GV_PACKET_SIZE_ADJUSTMENT_ON_FAILURE = 2
    ARV_GV_PACKET_SIZE_ADJUSTMENT_ONCE = 3
    ARV_GV_PACKET_SIZE_ADJUSTMENT_ALWAYS = 4
    ARV_GV_PACKET_SIZE_ADJUSTMENT_DEFAULT = 1
end

@cenum ArvGvIpConfigurationMode::UInt32 begin
    ARV_GV_IP_CONFIGURATION_MODE_NONE = 0
    ARV_GV_IP_CONFIGURATION_MODE_PERSISTENT_IP = 1
    ARV_GV_IP_CONFIGURATION_MODE_DHCP = 2
    ARV_GV_IP_CONFIGURATION_MODE_LLA = 3
    ARV_GV_IP_CONFIGURATION_MODE_FORCE_IP = 4
end

struct ArvGvDeviceClass
    parent_class::ArvDeviceClass
end

const ArvGvDevice_autoptr = Ptr{ArvGvDevice}

const ArvGvDevice_listautoptr = Ptr{GList}

const ArvGvDevice_slistautoptr = Ptr{GSList}

const ArvGvDevice_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGvDevice(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvDevice, arv_gv_device, ARV, GV_DEVICE, ArvDevice);
```
"""
function glib_autoptr_clear_ArvGvDevice(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGvDevice(_ptr::Ptr{ArvGvDevice})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGvDevice(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvDevice, arv_gv_device, ARV, GV_DEVICE, ArvDevice);
```
"""
function glib_autoptr_cleanup_ArvGvDevice(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGvDevice(_ptr::Ptr{Ptr{ArvGvDevice}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGvDevice(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvDevice, arv_gv_device, ARV, GV_DEVICE, ArvDevice);
```
"""
function glib_autoptr_destroy_ArvGvDevice(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGvDevice(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGvDevice(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvDevice, arv_gv_device, ARV, GV_DEVICE, ArvDevice);
```
"""
function glib_listautoptr_cleanup_ArvGvDevice(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGvDevice(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGvDevice(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvDevice, arv_gv_device, ARV, GV_DEVICE, ArvDevice);
```
"""
function glib_slistautoptr_cleanup_ArvGvDevice(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGvDevice(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGvDevice(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvDevice, arv_gv_device, ARV, GV_DEVICE, ArvDevice);
```
"""
function glib_queueautoptr_cleanup_ArvGvDevice(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGvDevice(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGvDeviceClass_autoptr = Ptr{ArvGvDeviceClass}

const ArvGvDeviceClass_listautoptr = Ptr{GList}

const ArvGvDeviceClass_slistautoptr = Ptr{GSList}

const ArvGvDeviceClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGvDeviceClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvDevice, arv_gv_device, ARV, GV_DEVICE, ArvDevice);
```
"""
function glib_autoptr_clear_ArvGvDeviceClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGvDeviceClass(_ptr::Ptr{ArvGvDeviceClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGvDeviceClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvDevice, arv_gv_device, ARV, GV_DEVICE, ArvDevice);
```
"""
function glib_autoptr_cleanup_ArvGvDeviceClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGvDeviceClass(_ptr::Ptr{Ptr{ArvGvDeviceClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGvDeviceClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvDevice, arv_gv_device, ARV, GV_DEVICE, ArvDevice);
```
"""
function glib_autoptr_destroy_ArvGvDeviceClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGvDeviceClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGvDeviceClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvDevice, arv_gv_device, ARV, GV_DEVICE, ArvDevice);
```
"""
function glib_listautoptr_cleanup_ArvGvDeviceClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGvDeviceClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGvDeviceClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvDevice, arv_gv_device, ARV, GV_DEVICE, ArvDevice);
```
"""
function glib_slistautoptr_cleanup_ArvGvDeviceClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGvDeviceClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGvDeviceClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvDevice, arv_gv_device, ARV, GV_DEVICE, ArvDevice);
```
"""
function glib_queueautoptr_cleanup_ArvGvDeviceClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGvDeviceClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GV_DEVICE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvDevice, arv_gv_device, ARV, GV_DEVICE, ArvDevice);
```
"""
function ARV_GV_DEVICE(ptr)
    @ccall libaravis.ARV_GV_DEVICE(ptr::gpointer)::Ptr{ArvGvDevice}
end

"""
    ARV_IS_GV_DEVICE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvDevice, arv_gv_device, ARV, GV_DEVICE, ArvDevice);
```
"""
function ARV_IS_GV_DEVICE(ptr)
    @ccall libaravis.ARV_IS_GV_DEVICE(ptr::gpointer)::gboolean
end

"""
    arv_gv_device_new(interface_address, device_address, error)

### Prototype
```c
ARV_API ArvDevice * arv_gv_device_new (GInetAddress *interface_address, GInetAddress *device_address, GError **error);
```
"""
function arv_gv_device_new(interface_address, device_address, error)
    @ccall libaravis.arv_gv_device_new(interface_address::Ptr{GInetAddress}, device_address::Ptr{GInetAddress}, error::Ptr{Ptr{GError}})::Ptr{ArvDevice}
end

"""
    arv_gv_device_take_control(gv_device, error)

### Prototype
```c
ARV_API gboolean arv_gv_device_take_control (ArvGvDevice *gv_device, GError **error);
```
"""
function arv_gv_device_take_control(gv_device, error)
    @ccall libaravis.arv_gv_device_take_control(gv_device::Ptr{ArvGvDevice}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_gv_device_leave_control(gv_device, error)

### Prototype
```c
ARV_API gboolean arv_gv_device_leave_control (ArvGvDevice *gv_device, GError **error);
```
"""
function arv_gv_device_leave_control(gv_device, error)
    @ccall libaravis.arv_gv_device_leave_control(gv_device::Ptr{ArvGvDevice}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_gv_device_get_timestamp_tick_frequency(gv_device, error)

### Prototype
```c
ARV_API guint64 arv_gv_device_get_timestamp_tick_frequency (ArvGvDevice *gv_device, GError **error);
```
"""
function arv_gv_device_get_timestamp_tick_frequency(gv_device, error)
    @ccall libaravis.arv_gv_device_get_timestamp_tick_frequency(gv_device::Ptr{ArvGvDevice}, error::Ptr{Ptr{GError}})::guint64
end

"""
    arv_gv_device_get_interface_address(device)

### Prototype
```c
ARV_API GSocketAddress * arv_gv_device_get_interface_address (ArvGvDevice *device);
```
"""
function arv_gv_device_get_interface_address(device)
    @ccall libaravis.arv_gv_device_get_interface_address(device::Ptr{ArvGvDevice})::Ptr{GSocketAddress}
end

"""
    arv_gv_device_get_device_address(device)

### Prototype
```c
ARV_API GSocketAddress * arv_gv_device_get_device_address (ArvGvDevice *device);
```
"""
function arv_gv_device_get_device_address(device)
    @ccall libaravis.arv_gv_device_get_device_address(device::Ptr{ArvGvDevice})::Ptr{GSocketAddress}
end

"""
    arv_gv_device_get_packet_size(gv_device, error)

### Prototype
```c
ARV_API guint arv_gv_device_get_packet_size (ArvGvDevice *gv_device, GError **error);
```
"""
function arv_gv_device_get_packet_size(gv_device, error)
    @ccall libaravis.arv_gv_device_get_packet_size(gv_device::Ptr{ArvGvDevice}, error::Ptr{Ptr{GError}})::guint
end

"""
    arv_gv_device_set_packet_size(gv_device, packet_size, error)

### Prototype
```c
ARV_API void arv_gv_device_set_packet_size (ArvGvDevice *gv_device, gint packet_size, GError **error);
```
"""
function arv_gv_device_set_packet_size(gv_device, packet_size, error)
    @ccall libaravis.arv_gv_device_set_packet_size(gv_device::Ptr{ArvGvDevice}, packet_size::gint, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_gv_device_set_packet_size_adjustment(gv_device, adjustment)

### Prototype
```c
ARV_API void arv_gv_device_set_packet_size_adjustment (ArvGvDevice *gv_device, ArvGvPacketSizeAdjustment adjustment);
```
"""
function arv_gv_device_set_packet_size_adjustment(gv_device, adjustment)
    @ccall libaravis.arv_gv_device_set_packet_size_adjustment(gv_device::Ptr{ArvGvDevice}, adjustment::ArvGvPacketSizeAdjustment)::Cvoid
end

"""
    arv_gv_device_auto_packet_size(gv_device, error)

### Prototype
```c
ARV_API guint arv_gv_device_auto_packet_size (ArvGvDevice *gv_device, GError **error);
```
"""
function arv_gv_device_auto_packet_size(gv_device, error)
    @ccall libaravis.arv_gv_device_auto_packet_size(gv_device::Ptr{ArvGvDevice}, error::Ptr{Ptr{GError}})::guint
end

"""
    arv_gv_device_get_stream_options(gv_device)

### Prototype
```c
ARV_API ArvGvStreamOption arv_gv_device_get_stream_options (ArvGvDevice *gv_device);
```
"""
function arv_gv_device_get_stream_options(gv_device)
    @ccall libaravis.arv_gv_device_get_stream_options(gv_device::Ptr{ArvGvDevice})::ArvGvStreamOption
end

"""
    arv_gv_device_set_stream_options(gv_device, options)

### Prototype
```c
ARV_API void arv_gv_device_set_stream_options (ArvGvDevice *gv_device, ArvGvStreamOption options);
```
"""
function arv_gv_device_set_stream_options(gv_device, options)
    @ccall libaravis.arv_gv_device_set_stream_options(gv_device::Ptr{ArvGvDevice}, options::ArvGvStreamOption)::Cvoid
end

"""
    arv_gv_device_get_current_ip(gv_device, ip, mask, gateway, error)

### Prototype
```c
ARV_API gboolean arv_gv_device_get_current_ip (ArvGvDevice *gv_device, GInetAddress **ip, GInetAddressMask **mask, GInetAddress **gateway, GError **error);
```
"""
function arv_gv_device_get_current_ip(gv_device, ip, mask, gateway, error)
    @ccall libaravis.arv_gv_device_get_current_ip(gv_device::Ptr{ArvGvDevice}, ip::Ptr{Ptr{GInetAddress}}, mask::Ptr{Ptr{GInetAddressMask}}, gateway::Ptr{Ptr{GInetAddress}}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_gv_device_get_persistent_ip(gv_device, ip, mask, gateway, error)

### Prototype
```c
ARV_API gboolean arv_gv_device_get_persistent_ip (ArvGvDevice *gv_device, GInetAddress **ip, GInetAddressMask **mask, GInetAddress **gateway, GError **error);
```
"""
function arv_gv_device_get_persistent_ip(gv_device, ip, mask, gateway, error)
    @ccall libaravis.arv_gv_device_get_persistent_ip(gv_device::Ptr{ArvGvDevice}, ip::Ptr{Ptr{GInetAddress}}, mask::Ptr{Ptr{GInetAddressMask}}, gateway::Ptr{Ptr{GInetAddress}}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_gv_device_set_persistent_ip(gv_device, ip, mask, gateway, error)

### Prototype
```c
ARV_API gboolean arv_gv_device_set_persistent_ip (ArvGvDevice *gv_device, GInetAddress *ip, GInetAddressMask *mask, GInetAddress *gateway, GError **error);
```
"""
function arv_gv_device_set_persistent_ip(gv_device, ip, mask, gateway, error)
    @ccall libaravis.arv_gv_device_set_persistent_ip(gv_device::Ptr{ArvGvDevice}, ip::Ptr{GInetAddress}, mask::Ptr{GInetAddressMask}, gateway::Ptr{GInetAddress}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_gv_device_set_persistent_ip_from_string(gv_device, ip, mask, gateway, error)

### Prototype
```c
ARV_API gboolean arv_gv_device_set_persistent_ip_from_string (ArvGvDevice *gv_device, const char *ip, const char *mask, const char *gateway, GError **error);
```
"""
function arv_gv_device_set_persistent_ip_from_string(gv_device, ip, mask, gateway, error)
    @ccall libaravis.arv_gv_device_set_persistent_ip_from_string(gv_device::Ptr{ArvGvDevice}, ip::Cstring, mask::Cstring, gateway::Cstring, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_gv_device_get_ip_configuration_mode(gv_device, error)

### Prototype
```c
ARV_API ArvGvIpConfigurationMode arv_gv_device_get_ip_configuration_mode (ArvGvDevice *gv_device, GError **error);
```
"""
function arv_gv_device_get_ip_configuration_mode(gv_device, error)
    @ccall libaravis.arv_gv_device_get_ip_configuration_mode(gv_device::Ptr{ArvGvDevice}, error::Ptr{Ptr{GError}})::ArvGvIpConfigurationMode
end

"""
    arv_gv_device_set_ip_configuration_mode(gv_device, mode, error)

### Prototype
```c
ARV_API gboolean arv_gv_device_set_ip_configuration_mode (ArvGvDevice *gv_device, ArvGvIpConfigurationMode mode, GError **error);
```
"""
function arv_gv_device_set_ip_configuration_mode(gv_device, mode, error)
    @ccall libaravis.arv_gv_device_set_ip_configuration_mode(gv_device::Ptr{ArvGvDevice}, mode::ArvGvIpConfigurationMode, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_gv_device_is_controller(gv_device)

### Prototype
```c
ARV_API gboolean arv_gv_device_is_controller (ArvGvDevice *gv_device);
```
"""
function arv_gv_device_is_controller(gv_device)
    @ccall libaravis.arv_gv_device_is_controller(gv_device::Ptr{ArvGvDevice})::gboolean
end

@cenum ArvComponentSelectionFlags::UInt32 begin
    ARV_COMPONENT_SELECTION_FLAGS_NONE = 0
    ARV_COMPONENT_SELECTION_FLAGS_ENABLE = 1
    ARV_COMPONENT_SELECTION_FLAGS_DISABLE = 2
    ARV_COMPONENT_SELECTION_FLAGS_EXCLUSIVE_ENABLE = 3
    ARV_COMPONENT_SELECTION_FLAGS_ENABLE_ALL = 4
end

struct _ArvCameraClass
    parent_class::GObjectClass
end

const ArvCameraClass = _ArvCameraClass

const ArvCamera_autoptr = Ptr{ArvCamera}

const ArvCamera_listautoptr = Ptr{GList}

const ArvCamera_slistautoptr = Ptr{GSList}

const ArvCamera_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvCamera(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvCamera, arv_camera, ARV, CAMERA, GObject);
```
"""
function glib_autoptr_clear_ArvCamera(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvCamera(_ptr::Ptr{ArvCamera})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvCamera(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvCamera, arv_camera, ARV, CAMERA, GObject);
```
"""
function glib_autoptr_cleanup_ArvCamera(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvCamera(_ptr::Ptr{Ptr{ArvCamera}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvCamera(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvCamera, arv_camera, ARV, CAMERA, GObject);
```
"""
function glib_autoptr_destroy_ArvCamera(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvCamera(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvCamera(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvCamera, arv_camera, ARV, CAMERA, GObject);
```
"""
function glib_listautoptr_cleanup_ArvCamera(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvCamera(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvCamera(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvCamera, arv_camera, ARV, CAMERA, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvCamera(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvCamera(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvCamera(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvCamera, arv_camera, ARV, CAMERA, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvCamera(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvCamera(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvCameraClass_autoptr = Ptr{ArvCameraClass}

const ArvCameraClass_listautoptr = Ptr{GList}

const ArvCameraClass_slistautoptr = Ptr{GSList}

const ArvCameraClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvCameraClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvCamera, arv_camera, ARV, CAMERA, GObject);
```
"""
function glib_autoptr_clear_ArvCameraClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvCameraClass(_ptr::Ptr{ArvCameraClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvCameraClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvCamera, arv_camera, ARV, CAMERA, GObject);
```
"""
function glib_autoptr_cleanup_ArvCameraClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvCameraClass(_ptr::Ptr{Ptr{ArvCameraClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvCameraClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvCamera, arv_camera, ARV, CAMERA, GObject);
```
"""
function glib_autoptr_destroy_ArvCameraClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvCameraClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvCameraClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvCamera, arv_camera, ARV, CAMERA, GObject);
```
"""
function glib_listautoptr_cleanup_ArvCameraClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvCameraClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvCameraClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvCamera, arv_camera, ARV, CAMERA, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvCameraClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvCameraClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvCameraClass(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvCamera, arv_camera, ARV, CAMERA, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvCameraClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvCameraClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_CAMERA(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvCamera, arv_camera, ARV, CAMERA, GObject);
```
"""
function ARV_CAMERA(ptr)
    @ccall libaravis.ARV_CAMERA(ptr::gpointer)::Ptr{ArvCamera}
end

"""
    ARV_CAMERA_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvCamera, arv_camera, ARV, CAMERA, GObject);
```
"""
function ARV_CAMERA_CLASS(ptr)
    @ccall libaravis.ARV_CAMERA_CLASS(ptr::gpointer)::Ptr{ArvCameraClass}
end

"""
    ARV_IS_CAMERA(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvCamera, arv_camera, ARV, CAMERA, GObject);
```
"""
function ARV_IS_CAMERA(ptr)
    @ccall libaravis.ARV_IS_CAMERA(ptr::gpointer)::gboolean
end

"""
    ARV_IS_CAMERA_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvCamera, arv_camera, ARV, CAMERA, GObject);
```
"""
function ARV_IS_CAMERA_CLASS(ptr)
    @ccall libaravis.ARV_IS_CAMERA_CLASS(ptr::gpointer)::gboolean
end

"""
    ARV_CAMERA_GET_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvCamera, arv_camera, ARV, CAMERA, GObject);
```
"""
function ARV_CAMERA_GET_CLASS(ptr)
    @ccall libaravis.ARV_CAMERA_GET_CLASS(ptr::gpointer)::Ptr{ArvCameraClass}
end

"""
    arv_camera_new(name, error)

### Prototype
```c
ARV_API ArvCamera * arv_camera_new (const char *name, GError **error);
```
"""
function arv_camera_new(name, error)
    @ccall libaravis.arv_camera_new(name::Cstring, error::Ptr{Ptr{GError}})::Ptr{ArvCamera}
end

"""
    arv_camera_new_with_device(device, error)

### Prototype
```c
ARV_API ArvCamera * arv_camera_new_with_device (ArvDevice *device, GError **error);
```
"""
function arv_camera_new_with_device(device, error)
    @ccall libaravis.arv_camera_new_with_device(device::Ptr{ArvDevice}, error::Ptr{Ptr{GError}})::Ptr{ArvCamera}
end

"""
    arv_camera_get_device(camera)

### Prototype
```c
ARV_API ArvDevice * arv_camera_get_device (ArvCamera *camera);
```
"""
function arv_camera_get_device(camera)
    @ccall libaravis.arv_camera_get_device(camera::Ptr{ArvCamera})::Ptr{ArvDevice}
end

"""
    arv_camera_create_stream(camera, callback, user_data, error)

### Prototype
```c
ARV_API ArvStream * arv_camera_create_stream (ArvCamera *camera, ArvStreamCallback callback, void *user_data, GError **error);
```
"""
function arv_camera_create_stream(camera, callback, user_data, error)
    @ccall libaravis.arv_camera_create_stream(camera::Ptr{ArvCamera}, callback::ArvStreamCallback, user_data::Ptr{Cvoid}, error::Ptr{Ptr{GError}})::Ptr{ArvStream}
end

"""
    arv_camera_create_stream_full(camera, callback, user_data, destroy, error)

### Prototype
```c
ARV_API ArvStream * arv_camera_create_stream_full (ArvCamera *camera, ArvStreamCallback callback, void *user_data, GDestroyNotify destroy, GError **error);
```
"""
function arv_camera_create_stream_full(camera, callback, user_data, destroy, error)
    @ccall libaravis.arv_camera_create_stream_full(camera::Ptr{ArvCamera}, callback::ArvStreamCallback, user_data::Ptr{Cvoid}, destroy::GDestroyNotify, error::Ptr{Ptr{GError}})::Ptr{ArvStream}
end

"""
    arv_camera_get_vendor_name(camera, error)

### Prototype
```c
ARV_API const char * arv_camera_get_vendor_name (ArvCamera *camera, GError **error);
```
"""
function arv_camera_get_vendor_name(camera, error)
    @ccall libaravis.arv_camera_get_vendor_name(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::Cstring
end

"""
    arv_camera_get_model_name(camera, error)

### Prototype
```c
ARV_API const char * arv_camera_get_model_name (ArvCamera *camera, GError **error);
```
"""
function arv_camera_get_model_name(camera, error)
    @ccall libaravis.arv_camera_get_model_name(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::Cstring
end

"""
    arv_camera_get_device_serial_number(camera, error)

### Prototype
```c
ARV_API const char * arv_camera_get_device_serial_number (ArvCamera *camera, GError **error);
```
"""
function arv_camera_get_device_serial_number(camera, error)
    @ccall libaravis.arv_camera_get_device_serial_number(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::Cstring
end

"""
    arv_camera_get_device_id(camera, error)

### Prototype
```c
ARV_API const char * arv_camera_get_device_id (ArvCamera *camera, GError **error);
```
"""
function arv_camera_get_device_id(camera, error)
    @ccall libaravis.arv_camera_get_device_id(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::Cstring
end

"""
    arv_camera_is_region_offset_available(camera, error)

### Prototype
```c
ARV_API gboolean arv_camera_is_region_offset_available (ArvCamera *camera, GError **error);
```
"""
function arv_camera_is_region_offset_available(camera, error)
    @ccall libaravis.arv_camera_is_region_offset_available(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_camera_get_sensor_size(camera, width, height, error)

### Prototype
```c
ARV_API void arv_camera_get_sensor_size (ArvCamera *camera, gint *width, gint *height, GError **error);
```
"""
function arv_camera_get_sensor_size(camera, width, height, error)
    @ccall libaravis.arv_camera_get_sensor_size(camera::Ptr{ArvCamera}, width::Ptr{gint}, height::Ptr{gint}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_set_region(camera, x, y, width, height, error)

### Prototype
```c
ARV_API void arv_camera_set_region (ArvCamera *camera, gint x, gint y, gint width, gint height, GError **error);
```
"""
function arv_camera_set_region(camera, x, y, width, height, error)
    @ccall libaravis.arv_camera_set_region(camera::Ptr{ArvCamera}, x::gint, y::gint, width::gint, height::gint, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_region(camera, x, y, width, height, error)

### Prototype
```c
ARV_API void arv_camera_get_region (ArvCamera *camera, gint *x, gint *y, gint *width, gint *height, GError **error);
```
"""
function arv_camera_get_region(camera, x, y, width, height, error)
    @ccall libaravis.arv_camera_get_region(camera::Ptr{ArvCamera}, x::Ptr{gint}, y::Ptr{gint}, width::Ptr{gint}, height::Ptr{gint}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_x_offset_bounds(camera, min, max, error)

### Prototype
```c
ARV_API void arv_camera_get_x_offset_bounds (ArvCamera *camera, gint *min, gint *max, GError **error);
```
"""
function arv_camera_get_x_offset_bounds(camera, min, max, error)
    @ccall libaravis.arv_camera_get_x_offset_bounds(camera::Ptr{ArvCamera}, min::Ptr{gint}, max::Ptr{gint}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_x_offset_increment(camera, error)

### Prototype
```c
ARV_API gint arv_camera_get_x_offset_increment (ArvCamera *camera, GError **error);
```
"""
function arv_camera_get_x_offset_increment(camera, error)
    @ccall libaravis.arv_camera_get_x_offset_increment(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::gint
end

"""
    arv_camera_get_y_offset_bounds(camera, min, max, error)

### Prototype
```c
ARV_API void arv_camera_get_y_offset_bounds (ArvCamera *camera, gint *min, gint *max, GError **error);
```
"""
function arv_camera_get_y_offset_bounds(camera, min, max, error)
    @ccall libaravis.arv_camera_get_y_offset_bounds(camera::Ptr{ArvCamera}, min::Ptr{gint}, max::Ptr{gint}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_y_offset_increment(camera, error)

### Prototype
```c
ARV_API gint arv_camera_get_y_offset_increment (ArvCamera *camera, GError **error);
```
"""
function arv_camera_get_y_offset_increment(camera, error)
    @ccall libaravis.arv_camera_get_y_offset_increment(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::gint
end

"""
    arv_camera_get_width_bounds(camera, min, max, error)

### Prototype
```c
ARV_API void arv_camera_get_width_bounds (ArvCamera *camera, gint *min, gint *max, GError **error);
```
"""
function arv_camera_get_width_bounds(camera, min, max, error)
    @ccall libaravis.arv_camera_get_width_bounds(camera::Ptr{ArvCamera}, min::Ptr{gint}, max::Ptr{gint}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_width_increment(camera, error)

### Prototype
```c
ARV_API gint arv_camera_get_width_increment (ArvCamera *camera, GError **error);
```
"""
function arv_camera_get_width_increment(camera, error)
    @ccall libaravis.arv_camera_get_width_increment(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::gint
end

"""
    arv_camera_get_height_bounds(camera, min, max, error)

### Prototype
```c
ARV_API void arv_camera_get_height_bounds (ArvCamera *camera, gint *min, gint *max, GError **error);
```
"""
function arv_camera_get_height_bounds(camera, min, max, error)
    @ccall libaravis.arv_camera_get_height_bounds(camera::Ptr{ArvCamera}, min::Ptr{gint}, max::Ptr{gint}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_height_increment(camera, error)

### Prototype
```c
ARV_API gint arv_camera_get_height_increment (ArvCamera *camera, GError **error);
```
"""
function arv_camera_get_height_increment(camera, error)
    @ccall libaravis.arv_camera_get_height_increment(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::gint
end

"""
    arv_camera_set_binning(camera, dx, dy, error)

### Prototype
```c
ARV_API void arv_camera_set_binning (ArvCamera *camera, gint dx, gint dy, GError **error);
```
"""
function arv_camera_set_binning(camera, dx, dy, error)
    @ccall libaravis.arv_camera_set_binning(camera::Ptr{ArvCamera}, dx::gint, dy::gint, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_binning(camera, dx, dy, error)

### Prototype
```c
ARV_API void arv_camera_get_binning (ArvCamera *camera, gint *dx, gint *dy, GError **error);
```
"""
function arv_camera_get_binning(camera, dx, dy, error)
    @ccall libaravis.arv_camera_get_binning(camera::Ptr{ArvCamera}, dx::Ptr{gint}, dy::Ptr{gint}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_x_binning_bounds(camera, min, max, error)

### Prototype
```c
ARV_API void arv_camera_get_x_binning_bounds (ArvCamera *camera, gint *min, gint *max, GError **error);
```
"""
function arv_camera_get_x_binning_bounds(camera, min, max, error)
    @ccall libaravis.arv_camera_get_x_binning_bounds(camera::Ptr{ArvCamera}, min::Ptr{gint}, max::Ptr{gint}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_x_binning_increment(camera, error)

### Prototype
```c
ARV_API gint arv_camera_get_x_binning_increment (ArvCamera *camera, GError **error);
```
"""
function arv_camera_get_x_binning_increment(camera, error)
    @ccall libaravis.arv_camera_get_x_binning_increment(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::gint
end

"""
    arv_camera_get_y_binning_bounds(camera, min, max, error)

### Prototype
```c
ARV_API void arv_camera_get_y_binning_bounds (ArvCamera *camera, gint *min, gint *max, GError **error);
```
"""
function arv_camera_get_y_binning_bounds(camera, min, max, error)
    @ccall libaravis.arv_camera_get_y_binning_bounds(camera::Ptr{ArvCamera}, min::Ptr{gint}, max::Ptr{gint}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_y_binning_increment(camera, error)

### Prototype
```c
ARV_API gint arv_camera_get_y_binning_increment (ArvCamera *camera, GError **error);
```
"""
function arv_camera_get_y_binning_increment(camera, error)
    @ccall libaravis.arv_camera_get_y_binning_increment(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::gint
end

"""
    arv_camera_is_binning_available(camera, error)

### Prototype
```c
ARV_API gboolean arv_camera_is_binning_available (ArvCamera *camera, GError **error);
```
"""
function arv_camera_is_binning_available(camera, error)
    @ccall libaravis.arv_camera_is_binning_available(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_camera_set_pixel_format(camera, format, error)

### Prototype
```c
ARV_API void arv_camera_set_pixel_format (ArvCamera *camera, ArvPixelFormat format, GError **error);
```
"""
function arv_camera_set_pixel_format(camera, format, error)
    @ccall libaravis.arv_camera_set_pixel_format(camera::Ptr{ArvCamera}, format::ArvPixelFormat, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_set_pixel_format_from_string(camera, format, error)

### Prototype
```c
ARV_API void arv_camera_set_pixel_format_from_string (ArvCamera *camera, const char * format, GError **error);
```
"""
function arv_camera_set_pixel_format_from_string(camera, format, error)
    @ccall libaravis.arv_camera_set_pixel_format_from_string(camera::Ptr{ArvCamera}, format::Cstring, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_pixel_format(camera, error)

### Prototype
```c
ARV_API ArvPixelFormat arv_camera_get_pixel_format (ArvCamera *camera, GError **error);
```
"""
function arv_camera_get_pixel_format(camera, error)
    @ccall libaravis.arv_camera_get_pixel_format(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::ArvPixelFormat
end

"""
    arv_camera_get_pixel_format_as_string(camera, error)

### Prototype
```c
ARV_API const char * arv_camera_get_pixel_format_as_string (ArvCamera *camera, GError **error);
```
"""
function arv_camera_get_pixel_format_as_string(camera, error)
    @ccall libaravis.arv_camera_get_pixel_format_as_string(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::Cstring
end

"""
    arv_camera_dup_available_pixel_formats(camera, n_pixel_formats, error)

### Prototype
```c
ARV_API gint64 * arv_camera_dup_available_pixel_formats (ArvCamera *camera, guint *n_pixel_formats, GError **error);
```
"""
function arv_camera_dup_available_pixel_formats(camera, n_pixel_formats, error)
    @ccall libaravis.arv_camera_dup_available_pixel_formats(camera::Ptr{ArvCamera}, n_pixel_formats::Ptr{guint}, error::Ptr{Ptr{GError}})::Ptr{gint64}
end

"""
    arv_camera_dup_available_pixel_formats_as_strings(camera, n_pixel_formats, error)

### Prototype
```c
ARV_API const char ** arv_camera_dup_available_pixel_formats_as_strings (ArvCamera *camera, guint *n_pixel_formats, GError **error);
```
"""
function arv_camera_dup_available_pixel_formats_as_strings(camera, n_pixel_formats, error)
    @ccall libaravis.arv_camera_dup_available_pixel_formats_as_strings(camera::Ptr{ArvCamera}, n_pixel_formats::Ptr{guint}, error::Ptr{Ptr{GError}})::Ptr{Cstring}
end

"""
    arv_camera_dup_available_pixel_formats_as_display_names(camera, n_pixel_formats, error)

### Prototype
```c
ARV_API const char ** arv_camera_dup_available_pixel_formats_as_display_names (ArvCamera *camera, guint *n_pixel_formats, GError **error);
```
"""
function arv_camera_dup_available_pixel_formats_as_display_names(camera, n_pixel_formats, error)
    @ccall libaravis.arv_camera_dup_available_pixel_formats_as_display_names(camera::Ptr{ArvCamera}, n_pixel_formats::Ptr{guint}, error::Ptr{Ptr{GError}})::Ptr{Cstring}
end

"""
    arv_camera_start_acquisition(camera, error)

### Prototype
```c
ARV_API void arv_camera_start_acquisition (ArvCamera *camera, GError **error);
```
"""
function arv_camera_start_acquisition(camera, error)
    @ccall libaravis.arv_camera_start_acquisition(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_stop_acquisition(camera, error)

### Prototype
```c
ARV_API void arv_camera_stop_acquisition (ArvCamera *camera, GError **error);
```
"""
function arv_camera_stop_acquisition(camera, error)
    @ccall libaravis.arv_camera_stop_acquisition(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_abort_acquisition(camera, error)

### Prototype
```c
ARV_API void arv_camera_abort_acquisition (ArvCamera *camera, GError **error);
```
"""
function arv_camera_abort_acquisition(camera, error)
    @ccall libaravis.arv_camera_abort_acquisition(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_acquisition(camera, timeout, error)

### Prototype
```c
ARV_API ArvBuffer * arv_camera_acquisition (ArvCamera *camera, guint64 timeout, GError **error);
```
"""
function arv_camera_acquisition(camera, timeout, error)
    @ccall libaravis.arv_camera_acquisition(camera::Ptr{ArvCamera}, timeout::guint64, error::Ptr{Ptr{GError}})::Ptr{ArvBuffer}
end

"""
    arv_camera_set_acquisition_mode(camera, value, error)

### Prototype
```c
ARV_API void arv_camera_set_acquisition_mode (ArvCamera *camera, ArvAcquisitionMode value, GError **error);
```
"""
function arv_camera_set_acquisition_mode(camera, value, error)
    @ccall libaravis.arv_camera_set_acquisition_mode(camera::Ptr{ArvCamera}, value::ArvAcquisitionMode, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_acquisition_mode(camera, error)

### Prototype
```c
ARV_API ArvAcquisitionMode arv_camera_get_acquisition_mode (ArvCamera *camera, GError **error);
```
"""
function arv_camera_get_acquisition_mode(camera, error)
    @ccall libaravis.arv_camera_get_acquisition_mode(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::ArvAcquisitionMode
end

"""
    arv_camera_set_frame_count(camera, frame_count, error)

### Prototype
```c
ARV_API void arv_camera_set_frame_count (ArvCamera *camera, gint64 frame_count, GError **error);
```
"""
function arv_camera_set_frame_count(camera, frame_count, error)
    @ccall libaravis.arv_camera_set_frame_count(camera::Ptr{ArvCamera}, frame_count::gint64, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_frame_count(camera, error)

### Prototype
```c
ARV_API gint64 arv_camera_get_frame_count (ArvCamera *camera, GError **error);
```
"""
function arv_camera_get_frame_count(camera, error)
    @ccall libaravis.arv_camera_get_frame_count(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::gint64
end

"""
    arv_camera_get_frame_count_bounds(camera, min, max, error)

### Prototype
```c
ARV_API void arv_camera_get_frame_count_bounds (ArvCamera *camera, gint64 *min, gint64 *max, GError **error);
```
"""
function arv_camera_get_frame_count_bounds(camera, min, max, error)
    @ccall libaravis.arv_camera_get_frame_count_bounds(camera::Ptr{ArvCamera}, min::Ptr{gint64}, max::Ptr{gint64}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_frame_rate_enable(camera, error)

### Prototype
```c
ARV_API gboolean arv_camera_get_frame_rate_enable (ArvCamera *camera, GError **error);
```
"""
function arv_camera_get_frame_rate_enable(camera, error)
    @ccall libaravis.arv_camera_get_frame_rate_enable(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_camera_set_frame_rate_enable(camera, enable, error)

### Prototype
```c
ARV_API void arv_camera_set_frame_rate_enable (ArvCamera *camera, gboolean enable, GError **error);
```
"""
function arv_camera_set_frame_rate_enable(camera, enable, error)
    @ccall libaravis.arv_camera_set_frame_rate_enable(camera::Ptr{ArvCamera}, enable::gboolean, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_is_frame_rate_available(camera, error)

### Prototype
```c
ARV_API gboolean arv_camera_is_frame_rate_available (ArvCamera *camera, GError **error);
```
"""
function arv_camera_is_frame_rate_available(camera, error)
    @ccall libaravis.arv_camera_is_frame_rate_available(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_camera_set_frame_rate(camera, frame_rate, error)

### Prototype
```c
ARV_API void arv_camera_set_frame_rate (ArvCamera *camera, double frame_rate, GError **error);
```
"""
function arv_camera_set_frame_rate(camera, frame_rate, error)
    @ccall libaravis.arv_camera_set_frame_rate(camera::Ptr{ArvCamera}, frame_rate::Cdouble, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_frame_rate(camera, error)

### Prototype
```c
ARV_API double arv_camera_get_frame_rate (ArvCamera *camera, GError **error);
```
"""
function arv_camera_get_frame_rate(camera, error)
    @ccall libaravis.arv_camera_get_frame_rate(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::Cdouble
end

"""
    arv_camera_get_frame_rate_bounds(camera, min, max, error)

### Prototype
```c
ARV_API void arv_camera_get_frame_rate_bounds (ArvCamera *camera, double *min, double *max, GError **error);
```
"""
function arv_camera_get_frame_rate_bounds(camera, min, max, error)
    @ccall libaravis.arv_camera_get_frame_rate_bounds(camera::Ptr{ArvCamera}, min::Ptr{Cdouble}, max::Ptr{Cdouble}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_set_trigger(camera, source, error)

### Prototype
```c
ARV_API void arv_camera_set_trigger (ArvCamera *camera, const char *source, GError **error);
```
"""
function arv_camera_set_trigger(camera, source, error)
    @ccall libaravis.arv_camera_set_trigger(camera::Ptr{ArvCamera}, source::Cstring, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_set_trigger_source(camera, source, error)

### Prototype
```c
ARV_API void arv_camera_set_trigger_source (ArvCamera *camera, const char *source, GError **error);
```
"""
function arv_camera_set_trigger_source(camera, source, error)
    @ccall libaravis.arv_camera_set_trigger_source(camera::Ptr{ArvCamera}, source::Cstring, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_trigger_source(camera, error)

### Prototype
```c
ARV_API const char * arv_camera_get_trigger_source (ArvCamera *camera, GError **error);
```
"""
function arv_camera_get_trigger_source(camera, error)
    @ccall libaravis.arv_camera_get_trigger_source(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::Cstring
end

"""
    arv_camera_dup_available_trigger_sources(camera, n_sources, error)

### Prototype
```c
ARV_API const char ** arv_camera_dup_available_trigger_sources(ArvCamera *camera, guint *n_sources, GError **error);
```
"""
function arv_camera_dup_available_trigger_sources(camera, n_sources, error)
    @ccall libaravis.arv_camera_dup_available_trigger_sources(camera::Ptr{ArvCamera}, n_sources::Ptr{guint}, error::Ptr{Ptr{GError}})::Ptr{Cstring}
end

"""
    arv_camera_dup_available_triggers(camera, n_triggers, error)

### Prototype
```c
ARV_API const char ** arv_camera_dup_available_triggers (ArvCamera *camera, guint *n_triggers, GError **error);
```
"""
function arv_camera_dup_available_triggers(camera, n_triggers, error)
    @ccall libaravis.arv_camera_dup_available_triggers(camera::Ptr{ArvCamera}, n_triggers::Ptr{guint}, error::Ptr{Ptr{GError}})::Ptr{Cstring}
end

"""
    arv_camera_clear_triggers(camera, error)

### Prototype
```c
ARV_API void arv_camera_clear_triggers (ArvCamera *camera, GError **error);
```
"""
function arv_camera_clear_triggers(camera, error)
    @ccall libaravis.arv_camera_clear_triggers(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_is_software_trigger_supported(camera, error)

### Prototype
```c
ARV_API gboolean arv_camera_is_software_trigger_supported(ArvCamera *camera, GError **error);
```
"""
function arv_camera_is_software_trigger_supported(camera, error)
    @ccall libaravis.arv_camera_is_software_trigger_supported(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_camera_software_trigger(camera, error)

### Prototype
```c
ARV_API void arv_camera_software_trigger (ArvCamera *camera, GError **error);
```
"""
function arv_camera_software_trigger(camera, error)
    @ccall libaravis.arv_camera_software_trigger(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_is_exposure_time_available(camera, error)

### Prototype
```c
ARV_API gboolean arv_camera_is_exposure_time_available (ArvCamera *camera, GError **error);
```
"""
function arv_camera_is_exposure_time_available(camera, error)
    @ccall libaravis.arv_camera_is_exposure_time_available(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_camera_is_exposure_auto_available(camera, error)

### Prototype
```c
ARV_API gboolean arv_camera_is_exposure_auto_available (ArvCamera *camera, GError **error);
```
"""
function arv_camera_is_exposure_auto_available(camera, error)
    @ccall libaravis.arv_camera_is_exposure_auto_available(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_camera_set_exposure_time(camera, exposure_time_us, error)

### Prototype
```c
ARV_API void arv_camera_set_exposure_time (ArvCamera *camera, double exposure_time_us, GError **error);
```
"""
function arv_camera_set_exposure_time(camera, exposure_time_us, error)
    @ccall libaravis.arv_camera_set_exposure_time(camera::Ptr{ArvCamera}, exposure_time_us::Cdouble, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_exposure_time(camera, error)

### Prototype
```c
ARV_API double arv_camera_get_exposure_time (ArvCamera *camera, GError **error);
```
"""
function arv_camera_get_exposure_time(camera, error)
    @ccall libaravis.arv_camera_get_exposure_time(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::Cdouble
end

"""
    arv_camera_get_exposure_time_bounds(camera, min, max, error)

### Prototype
```c
ARV_API void arv_camera_get_exposure_time_bounds (ArvCamera *camera, double *min, double *max, GError **error);
```
"""
function arv_camera_get_exposure_time_bounds(camera, min, max, error)
    @ccall libaravis.arv_camera_get_exposure_time_bounds(camera::Ptr{ArvCamera}, min::Ptr{Cdouble}, max::Ptr{Cdouble}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_set_exposure_time_auto(camera, auto_mode, error)

### Prototype
```c
ARV_API void arv_camera_set_exposure_time_auto (ArvCamera *camera, ArvAuto auto_mode, GError **error);
```
"""
function arv_camera_set_exposure_time_auto(camera, auto_mode, error)
    @ccall libaravis.arv_camera_set_exposure_time_auto(camera::Ptr{ArvCamera}, auto_mode::ArvAuto, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_exposure_time_auto(camera, error)

### Prototype
```c
ARV_API ArvAuto arv_camera_get_exposure_time_auto (ArvCamera *camera, GError **error);
```
"""
function arv_camera_get_exposure_time_auto(camera, error)
    @ccall libaravis.arv_camera_get_exposure_time_auto(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::ArvAuto
end

"""
    arv_camera_get_exposure_time_representation(camera)

### Prototype
```c
ARV_API ArvGcRepresentation arv_camera_get_exposure_time_representation (ArvCamera *camera);
```
"""
function arv_camera_get_exposure_time_representation(camera)
    @ccall libaravis.arv_camera_get_exposure_time_representation(camera::Ptr{ArvCamera})::ArvGcRepresentation
end

"""
    arv_camera_set_exposure_mode(camera, mode, error)

### Prototype
```c
ARV_API void arv_camera_set_exposure_mode (ArvCamera *camera, ArvExposureMode mode, GError **error);
```
"""
function arv_camera_set_exposure_mode(camera, mode, error)
    @ccall libaravis.arv_camera_set_exposure_mode(camera::Ptr{ArvCamera}, mode::ArvExposureMode, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_is_gain_available(camera, error)

### Prototype
```c
ARV_API gboolean arv_camera_is_gain_available (ArvCamera *camera, GError **error);
```
"""
function arv_camera_is_gain_available(camera, error)
    @ccall libaravis.arv_camera_is_gain_available(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_camera_is_gain_auto_available(camera, error)

### Prototype
```c
ARV_API gboolean arv_camera_is_gain_auto_available (ArvCamera *camera, GError **error);
```
"""
function arv_camera_is_gain_auto_available(camera, error)
    @ccall libaravis.arv_camera_is_gain_auto_available(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_camera_select_gain(camera, selector, error)

### Prototype
```c
ARV_API void arv_camera_select_gain (ArvCamera *camera, const char *selector, GError **error);
```
"""
function arv_camera_select_gain(camera, selector, error)
    @ccall libaravis.arv_camera_select_gain(camera::Ptr{ArvCamera}, selector::Cstring, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_dup_available_gains(camera, n_selectors, error)

### Prototype
```c
ARV_API const char ** arv_camera_dup_available_gains (ArvCamera *camera, guint *n_selectors, GError **error);
```
"""
function arv_camera_dup_available_gains(camera, n_selectors, error)
    @ccall libaravis.arv_camera_dup_available_gains(camera::Ptr{ArvCamera}, n_selectors::Ptr{guint}, error::Ptr{Ptr{GError}})::Ptr{Cstring}
end

"""
    arv_camera_set_gain(camera, gain, error)

### Prototype
```c
ARV_API void arv_camera_set_gain (ArvCamera *camera, double gain, GError **error);
```
"""
function arv_camera_set_gain(camera, gain, error)
    @ccall libaravis.arv_camera_set_gain(camera::Ptr{ArvCamera}, gain::Cdouble, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_gain(camera, error)

### Prototype
```c
ARV_API double arv_camera_get_gain (ArvCamera *camera, GError **error);
```
"""
function arv_camera_get_gain(camera, error)
    @ccall libaravis.arv_camera_get_gain(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::Cdouble
end

"""
    arv_camera_get_gain_bounds(camera, min, max, error)

### Prototype
```c
ARV_API void arv_camera_get_gain_bounds (ArvCamera *camera, double *min, double *max, GError **error);
```
"""
function arv_camera_get_gain_bounds(camera, min, max, error)
    @ccall libaravis.arv_camera_get_gain_bounds(camera::Ptr{ArvCamera}, min::Ptr{Cdouble}, max::Ptr{Cdouble}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_set_gain_auto(camera, auto_mode, error)

### Prototype
```c
ARV_API void arv_camera_set_gain_auto (ArvCamera *camera, ArvAuto auto_mode, GError **error);
```
"""
function arv_camera_set_gain_auto(camera, auto_mode, error)
    @ccall libaravis.arv_camera_set_gain_auto(camera::Ptr{ArvCamera}, auto_mode::ArvAuto, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_gain_auto(camera, error)

### Prototype
```c
ARV_API ArvAuto arv_camera_get_gain_auto (ArvCamera *camera, GError **error);
```
"""
function arv_camera_get_gain_auto(camera, error)
    @ccall libaravis.arv_camera_get_gain_auto(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::ArvAuto
end

"""
    arv_camera_get_gain_representation(camera)

### Prototype
```c
ARV_API ArvGcRepresentation arv_camera_get_gain_representation (ArvCamera *camera);
```
"""
function arv_camera_get_gain_representation(camera)
    @ccall libaravis.arv_camera_get_gain_representation(camera::Ptr{ArvCamera})::ArvGcRepresentation
end

"""
    arv_camera_is_black_level_available(camera, error)

### Prototype
```c
ARV_API gboolean arv_camera_is_black_level_available (ArvCamera *camera, GError **error);
```
"""
function arv_camera_is_black_level_available(camera, error)
    @ccall libaravis.arv_camera_is_black_level_available(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_camera_is_black_level_auto_available(camera, error)

### Prototype
```c
ARV_API gboolean arv_camera_is_black_level_auto_available(ArvCamera *camera, GError **error);
```
"""
function arv_camera_is_black_level_auto_available(camera, error)
    @ccall libaravis.arv_camera_is_black_level_auto_available(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_camera_select_black_level(camera, selector, error)

### Prototype
```c
ARV_API void arv_camera_select_black_level (ArvCamera *camera, const char *selector, GError **error);
```
"""
function arv_camera_select_black_level(camera, selector, error)
    @ccall libaravis.arv_camera_select_black_level(camera::Ptr{ArvCamera}, selector::Cstring, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_dup_available_black_levels(camera, n_selectors, error)

### Prototype
```c
ARV_API const char ** arv_camera_dup_available_black_levels (ArvCamera *camera, guint *n_selectors, GError **error);
```
"""
function arv_camera_dup_available_black_levels(camera, n_selectors, error)
    @ccall libaravis.arv_camera_dup_available_black_levels(camera::Ptr{ArvCamera}, n_selectors::Ptr{guint}, error::Ptr{Ptr{GError}})::Ptr{Cstring}
end

"""
    arv_camera_set_black_level(camera, blacklevel, error)

### Prototype
```c
ARV_API void arv_camera_set_black_level (ArvCamera *camera, double blacklevel, GError **error);
```
"""
function arv_camera_set_black_level(camera, blacklevel, error)
    @ccall libaravis.arv_camera_set_black_level(camera::Ptr{ArvCamera}, blacklevel::Cdouble, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_black_level(camera, error)

### Prototype
```c
ARV_API double arv_camera_get_black_level (ArvCamera *camera, GError **error);
```
"""
function arv_camera_get_black_level(camera, error)
    @ccall libaravis.arv_camera_get_black_level(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::Cdouble
end

"""
    arv_camera_get_black_level_bounds(camera, min, max, error)

### Prototype
```c
ARV_API void arv_camera_get_black_level_bounds (ArvCamera *camera, double *min, double *max, GError **error);
```
"""
function arv_camera_get_black_level_bounds(camera, min, max, error)
    @ccall libaravis.arv_camera_get_black_level_bounds(camera::Ptr{ArvCamera}, min::Ptr{Cdouble}, max::Ptr{Cdouble}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_set_black_level_auto(camera, auto_mode, error)

### Prototype
```c
ARV_API void arv_camera_set_black_level_auto (ArvCamera *camera, ArvAuto auto_mode, GError **error);
```
"""
function arv_camera_set_black_level_auto(camera, auto_mode, error)
    @ccall libaravis.arv_camera_set_black_level_auto(camera::Ptr{ArvCamera}, auto_mode::ArvAuto, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_black_level_auto(camera, error)

### Prototype
```c
ARV_API ArvAuto arv_camera_get_black_level_auto (ArvCamera *camera, GError **error);
```
"""
function arv_camera_get_black_level_auto(camera, error)
    @ccall libaravis.arv_camera_get_black_level_auto(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::ArvAuto
end

"""
    arv_camera_is_component_available(camera, error)

### Prototype
```c
ARV_API gboolean arv_camera_is_component_available (ArvCamera *camera, GError **error);
```
"""
function arv_camera_is_component_available(camera, error)
    @ccall libaravis.arv_camera_is_component_available(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_camera_dup_available_components(camera, n_components, error)

### Prototype
```c
ARV_API const char ** arv_camera_dup_available_components (ArvCamera *camera, guint *n_components, GError **error);
```
"""
function arv_camera_dup_available_components(camera, n_components, error)
    @ccall libaravis.arv_camera_dup_available_components(camera::Ptr{ArvCamera}, n_components::Ptr{guint}, error::Ptr{Ptr{GError}})::Ptr{Cstring}
end

"""
    arv_camera_select_and_enable_component(camera, component, disable_others, error)

### Prototype
```c
ARV_API void arv_camera_select_and_enable_component (ArvCamera *camera, const char *component, gboolean disable_others, GError **error);
```
"""
function arv_camera_select_and_enable_component(camera, component, disable_others, error)
    @ccall libaravis.arv_camera_select_and_enable_component(camera::Ptr{ArvCamera}, component::Cstring, disable_others::gboolean, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_select_component(camera, component, flags, component_id, error)

### Prototype
```c
ARV_API gboolean arv_camera_select_component (ArvCamera *camera, const char *component, ArvComponentSelectionFlags flags, guint *component_id, GError **error);
```
"""
function arv_camera_select_component(camera, component, flags, component_id, error)
    @ccall libaravis.arv_camera_select_component(camera::Ptr{ArvCamera}, component::Cstring, flags::ArvComponentSelectionFlags, component_id::Ptr{guint}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_camera_get_payload(camera, error)

### Prototype
```c
ARV_API guint arv_camera_get_payload (ArvCamera *camera, GError **error);
```
"""
function arv_camera_get_payload(camera, error)
    @ccall libaravis.arv_camera_get_payload(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::guint
end

"""
    arv_camera_execute_command(camera, feature, error)

### Prototype
```c
ARV_API void arv_camera_execute_command (ArvCamera *camera, const char *feature, GError **error);
```
"""
function arv_camera_execute_command(camera, feature, error)
    @ccall libaravis.arv_camera_execute_command(camera::Ptr{ArvCamera}, feature::Cstring, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_set_boolean(camera, feature, value, error)

### Prototype
```c
ARV_API void arv_camera_set_boolean (ArvCamera *camera, const char *feature, gboolean value, GError **error);
```
"""
function arv_camera_set_boolean(camera, feature, value, error)
    @ccall libaravis.arv_camera_set_boolean(camera::Ptr{ArvCamera}, feature::Cstring, value::gboolean, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_boolean(camera, feature, error)

### Prototype
```c
ARV_API gboolean arv_camera_get_boolean (ArvCamera *camera, const char *feature, GError **error);
```
"""
function arv_camera_get_boolean(camera, feature, error)
    @ccall libaravis.arv_camera_get_boolean(camera::Ptr{ArvCamera}, feature::Cstring, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_camera_get_boolean_gi(camera, feature, value, error)

### Prototype
```c
ARV_API void arv_camera_get_boolean_gi (ArvCamera *camera, const char *feature, gboolean *value, GError **error);
```
"""
function arv_camera_get_boolean_gi(camera, feature, value, error)
    @ccall libaravis.arv_camera_get_boolean_gi(camera::Ptr{ArvCamera}, feature::Cstring, value::Ptr{gboolean}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_set_string(camera, feature, value, error)

### Prototype
```c
ARV_API void arv_camera_set_string (ArvCamera *camera, const char *feature, const char *value, GError **error);
```
"""
function arv_camera_set_string(camera, feature, value, error)
    @ccall libaravis.arv_camera_set_string(camera::Ptr{ArvCamera}, feature::Cstring, value::Cstring, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_string(camera, feature, error)

### Prototype
```c
ARV_API const char * arv_camera_get_string (ArvCamera *camera, const char *feature, GError **error);
```
"""
function arv_camera_get_string(camera, feature, error)
    @ccall libaravis.arv_camera_get_string(camera::Ptr{ArvCamera}, feature::Cstring, error::Ptr{Ptr{GError}})::Cstring
end

"""
    arv_camera_set_integer(camera, feature, value, error)

### Prototype
```c
ARV_API void arv_camera_set_integer (ArvCamera *camera, const char *feature, gint64 value, GError **error);
```
"""
function arv_camera_set_integer(camera, feature, value, error)
    @ccall libaravis.arv_camera_set_integer(camera::Ptr{ArvCamera}, feature::Cstring, value::gint64, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_integer(camera, feature, error)

### Prototype
```c
ARV_API gint64 arv_camera_get_integer (ArvCamera *camera, const char *feature, GError **error);
```
"""
function arv_camera_get_integer(camera, feature, error)
    @ccall libaravis.arv_camera_get_integer(camera::Ptr{ArvCamera}, feature::Cstring, error::Ptr{Ptr{GError}})::gint64
end

"""
    arv_camera_get_integer_bounds(camera, feature, min, max, error)

### Prototype
```c
ARV_API void arv_camera_get_integer_bounds (ArvCamera *camera, const char *feature, gint64 *min, gint64 *max, GError **error);
```
"""
function arv_camera_get_integer_bounds(camera, feature, min, max, error)
    @ccall libaravis.arv_camera_get_integer_bounds(camera::Ptr{ArvCamera}, feature::Cstring, min::Ptr{gint64}, max::Ptr{gint64}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_integer_increment(camera, feature, error)

### Prototype
```c
ARV_API gint64 arv_camera_get_integer_increment (ArvCamera *camera, const char *feature, GError **error);
```
"""
function arv_camera_get_integer_increment(camera, feature, error)
    @ccall libaravis.arv_camera_get_integer_increment(camera::Ptr{ArvCamera}, feature::Cstring, error::Ptr{Ptr{GError}})::gint64
end

"""
    arv_camera_set_float(camera, feature, value, error)

### Prototype
```c
ARV_API void arv_camera_set_float (ArvCamera *camera, const char *feature, double value, GError **error);
```
"""
function arv_camera_set_float(camera, feature, value, error)
    @ccall libaravis.arv_camera_set_float(camera::Ptr{ArvCamera}, feature::Cstring, value::Cdouble, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_float(camera, feature, error)

### Prototype
```c
ARV_API double arv_camera_get_float (ArvCamera *camera, const char *feature, GError **error);
```
"""
function arv_camera_get_float(camera, feature, error)
    @ccall libaravis.arv_camera_get_float(camera::Ptr{ArvCamera}, feature::Cstring, error::Ptr{Ptr{GError}})::Cdouble
end

"""
    arv_camera_get_float_bounds(camera, feature, min, max, error)

### Prototype
```c
ARV_API void arv_camera_get_float_bounds (ArvCamera *camera, const char *feature, double *min, double *max, GError **error);
```
"""
function arv_camera_get_float_bounds(camera, feature, min, max, error)
    @ccall libaravis.arv_camera_get_float_bounds(camera::Ptr{ArvCamera}, feature::Cstring, min::Ptr{Cdouble}, max::Ptr{Cdouble}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_float_increment(camera, feature, error)

### Prototype
```c
ARV_API double arv_camera_get_float_increment (ArvCamera *camera, const char *feature, GError **error);
```
"""
function arv_camera_get_float_increment(camera, feature, error)
    @ccall libaravis.arv_camera_get_float_increment(camera::Ptr{ArvCamera}, feature::Cstring, error::Ptr{Ptr{GError}})::Cdouble
end

"""
    arv_camera_set_register(camera, feature, length, value, error)

### Prototype
```c
ARV_API void arv_camera_set_register (ArvCamera *camera, const char *feature, guint64 length, void* value, GError **error);
```
"""
function arv_camera_set_register(camera, feature, length, value, error)
    @ccall libaravis.arv_camera_set_register(camera::Ptr{ArvCamera}, feature::Cstring, length::guint64, value::Ptr{Cvoid}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_dup_register(camera, feature, length, error)

### Prototype
```c
ARV_API void * arv_camera_dup_register (ArvCamera *camera, const char *feature, guint64 *length, GError **error);
```
"""
function arv_camera_dup_register(camera, feature, length, error)
    @ccall libaravis.arv_camera_dup_register(camera::Ptr{ArvCamera}, feature::Cstring, length::Ptr{guint64}, error::Ptr{Ptr{GError}})::Ptr{Cvoid}
end

"""
    arv_camera_dup_available_enumerations(camera, feature, n_values, error)

### Prototype
```c
ARV_API gint64 * arv_camera_dup_available_enumerations (ArvCamera *camera, const char *feature, guint *n_values, GError **error);
```
"""
function arv_camera_dup_available_enumerations(camera, feature, n_values, error)
    @ccall libaravis.arv_camera_dup_available_enumerations(camera::Ptr{ArvCamera}, feature::Cstring, n_values::Ptr{guint}, error::Ptr{Ptr{GError}})::Ptr{gint64}
end

"""
    arv_camera_dup_available_enumerations_as_strings(camera, feature, n_values, error)

### Prototype
```c
ARV_API const char ** arv_camera_dup_available_enumerations_as_strings (ArvCamera *camera, const char *feature, guint *n_values, GError **error);
```
"""
function arv_camera_dup_available_enumerations_as_strings(camera, feature, n_values, error)
    @ccall libaravis.arv_camera_dup_available_enumerations_as_strings(camera::Ptr{ArvCamera}, feature::Cstring, n_values::Ptr{guint}, error::Ptr{Ptr{GError}})::Ptr{Cstring}
end

"""
    arv_camera_dup_available_enumerations_as_display_names(camera, feature, n_values, error)

### Prototype
```c
ARV_API const char ** arv_camera_dup_available_enumerations_as_display_names (ArvCamera *camera, const char *feature, guint *n_values, GError **error);
```
"""
function arv_camera_dup_available_enumerations_as_display_names(camera, feature, n_values, error)
    @ccall libaravis.arv_camera_dup_available_enumerations_as_display_names(camera::Ptr{ArvCamera}, feature::Cstring, n_values::Ptr{guint}, error::Ptr{Ptr{GError}})::Ptr{Cstring}
end

"""
    arv_camera_is_enumeration_entry_available(camera, feature, entry, error)

### Prototype
```c
ARV_API gboolean arv_camera_is_enumeration_entry_available (ArvCamera *camera, const char *feature, const char *entry, GError **error);
```
"""
function arv_camera_is_enumeration_entry_available(camera, feature, entry, error)
    @ccall libaravis.arv_camera_is_enumeration_entry_available(camera::Ptr{ArvCamera}, feature::Cstring, entry::Cstring, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_camera_is_feature_available(camera, feature, error)

### Prototype
```c
ARV_API gboolean arv_camera_is_feature_available (ArvCamera *camera, const char *feature, GError **error);
```
"""
function arv_camera_is_feature_available(camera, feature, error)
    @ccall libaravis.arv_camera_is_feature_available(camera::Ptr{ArvCamera}, feature::Cstring, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_camera_is_feature_implemented(camera, feature, error)

### Prototype
```c
ARV_API gboolean arv_camera_is_feature_implemented (ArvCamera *camera, const char *feature, GError **error);
```
"""
function arv_camera_is_feature_implemented(camera, feature, error)
    @ccall libaravis.arv_camera_is_feature_implemented(camera::Ptr{ArvCamera}, feature::Cstring, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_camera_get_feature_representation(camera, feature)

### Prototype
```c
ARV_API ArvGcRepresentation arv_camera_get_feature_representation (ArvCamera *camera, const char *feature);
```
"""
function arv_camera_get_feature_representation(camera, feature)
    @ccall libaravis.arv_camera_get_feature_representation(camera::Ptr{ArvCamera}, feature::Cstring)::ArvGcRepresentation
end

"""
    arv_camera_set_register_cache_policy(camera, policy)

### Prototype
```c
ARV_API void arv_camera_set_register_cache_policy (ArvCamera *camera, ArvRegisterCachePolicy policy);
```
"""
function arv_camera_set_register_cache_policy(camera, policy)
    @ccall libaravis.arv_camera_set_register_cache_policy(camera::Ptr{ArvCamera}, policy::ArvRegisterCachePolicy)::Cvoid
end

"""
    arv_camera_set_range_check_policy(camera, policy)

### Prototype
```c
ARV_API void arv_camera_set_range_check_policy (ArvCamera *camera, ArvRangeCheckPolicy policy);
```
"""
function arv_camera_set_range_check_policy(camera, policy)
    @ccall libaravis.arv_camera_set_range_check_policy(camera::Ptr{ArvCamera}, policy::ArvRangeCheckPolicy)::Cvoid
end

"""
    arv_camera_set_access_check_policy(camera, policy)

### Prototype
```c
ARV_API void arv_camera_set_access_check_policy (ArvCamera *camera, ArvAccessCheckPolicy policy);
```
"""
function arv_camera_set_access_check_policy(camera, policy)
    @ccall libaravis.arv_camera_set_access_check_policy(camera::Ptr{ArvCamera}, policy::ArvAccessCheckPolicy)::Cvoid
end

"""
    arv_camera_is_gv_device(camera)

### Prototype
```c
ARV_API gboolean arv_camera_is_gv_device (ArvCamera *camera);
```
"""
function arv_camera_is_gv_device(camera)
    @ccall libaravis.arv_camera_is_gv_device(camera::Ptr{ArvCamera})::gboolean
end

"""
    arv_camera_gv_get_n_network_interfaces(camera, error)

### Prototype
```c
ARV_API gint arv_camera_gv_get_n_network_interfaces (ArvCamera *camera, GError **error);
```
"""
function arv_camera_gv_get_n_network_interfaces(camera, error)
    @ccall libaravis.arv_camera_gv_get_n_network_interfaces(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::gint
end

"""
    arv_camera_gv_get_n_stream_channels(camera, error)

### Prototype
```c
ARV_API gint arv_camera_gv_get_n_stream_channels (ArvCamera *camera, GError **error);
```
"""
function arv_camera_gv_get_n_stream_channels(camera, error)
    @ccall libaravis.arv_camera_gv_get_n_stream_channels(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::gint
end

"""
    arv_camera_gv_select_stream_channel(camera, channel_id, error)

### Prototype
```c
ARV_API void arv_camera_gv_select_stream_channel (ArvCamera *camera, gint channel_id, GError **error);
```
"""
function arv_camera_gv_select_stream_channel(camera, channel_id, error)
    @ccall libaravis.arv_camera_gv_select_stream_channel(camera::Ptr{ArvCamera}, channel_id::gint, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_gv_get_current_stream_channel(camera, error)

### Prototype
```c
ARV_API int arv_camera_gv_get_current_stream_channel (ArvCamera *camera, GError **error);
```
"""
function arv_camera_gv_get_current_stream_channel(camera, error)
    @ccall libaravis.arv_camera_gv_get_current_stream_channel(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::Cint
end

"""
    arv_camera_gv_is_multipart_supported(camera, error)

### Prototype
```c
ARV_API gboolean arv_camera_gv_is_multipart_supported (ArvCamera *camera, GError **error);
```
"""
function arv_camera_gv_is_multipart_supported(camera, error)
    @ccall libaravis.arv_camera_gv_is_multipart_supported(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_camera_gv_set_multipart(camera, enable, error)

### Prototype
```c
ARV_API void arv_camera_gv_set_multipart (ArvCamera *camera, gboolean enable, GError **error);
```
"""
function arv_camera_gv_set_multipart(camera, enable, error)
    @ccall libaravis.arv_camera_gv_set_multipart(camera::Ptr{ArvCamera}, enable::gboolean, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_gv_get_multipart(camera, error)

### Prototype
```c
ARV_API gboolean arv_camera_gv_get_multipart (ArvCamera *camera, GError **error);
```
"""
function arv_camera_gv_get_multipart(camera, error)
    @ccall libaravis.arv_camera_gv_get_multipart(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_camera_gv_set_packet_delay(camera, delay_ns, error)

### Prototype
```c
ARV_API void arv_camera_gv_set_packet_delay (ArvCamera *camera, gint64 delay_ns, GError **error);
```
"""
function arv_camera_gv_set_packet_delay(camera, delay_ns, error)
    @ccall libaravis.arv_camera_gv_set_packet_delay(camera::Ptr{ArvCamera}, delay_ns::gint64, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_gv_get_packet_delay(camera, error)

### Prototype
```c
ARV_API gint64 arv_camera_gv_get_packet_delay (ArvCamera *camera, GError **error);
```
"""
function arv_camera_gv_get_packet_delay(camera, error)
    @ccall libaravis.arv_camera_gv_get_packet_delay(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::gint64
end

"""
    arv_camera_gv_set_packet_size(camera, packet_size, error)

### Prototype
```c
ARV_API void arv_camera_gv_set_packet_size (ArvCamera *camera, gint packet_size, GError **error);
```
"""
function arv_camera_gv_set_packet_size(camera, packet_size, error)
    @ccall libaravis.arv_camera_gv_set_packet_size(camera::Ptr{ArvCamera}, packet_size::gint, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_gv_get_packet_size(camera, error)

### Prototype
```c
ARV_API guint arv_camera_gv_get_packet_size (ArvCamera *camera, GError **error);
```
"""
function arv_camera_gv_get_packet_size(camera, error)
    @ccall libaravis.arv_camera_gv_get_packet_size(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::guint
end

"""
    arv_camera_gv_auto_packet_size(camera, error)

### Prototype
```c
ARV_API guint arv_camera_gv_auto_packet_size (ArvCamera *camera, GError **error);
```
"""
function arv_camera_gv_auto_packet_size(camera, error)
    @ccall libaravis.arv_camera_gv_auto_packet_size(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::guint
end

"""
    arv_camera_gv_set_packet_size_adjustment(camera, adjustment)

### Prototype
```c
ARV_API void arv_camera_gv_set_packet_size_adjustment (ArvCamera *camera, ArvGvPacketSizeAdjustment adjustment);
```
"""
function arv_camera_gv_set_packet_size_adjustment(camera, adjustment)
    @ccall libaravis.arv_camera_gv_set_packet_size_adjustment(camera::Ptr{ArvCamera}, adjustment::ArvGvPacketSizeAdjustment)::Cvoid
end

"""
    arv_camera_gv_set_stream_options(camera, options)

### Prototype
```c
ARV_API void arv_camera_gv_set_stream_options (ArvCamera *camera, ArvGvStreamOption options);
```
"""
function arv_camera_gv_set_stream_options(camera, options)
    @ccall libaravis.arv_camera_gv_set_stream_options(camera::Ptr{ArvCamera}, options::ArvGvStreamOption)::Cvoid
end

"""
    arv_camera_gv_get_persistent_ip(camera, ip, mask, gateway, error)

### Prototype
```c
ARV_API void arv_camera_gv_get_persistent_ip (ArvCamera *camera, GInetAddress **ip, GInetAddressMask **mask, GInetAddress **gateway, GError **error);
```
"""
function arv_camera_gv_get_persistent_ip(camera, ip, mask, gateway, error)
    @ccall libaravis.arv_camera_gv_get_persistent_ip(camera::Ptr{ArvCamera}, ip::Ptr{Ptr{GInetAddress}}, mask::Ptr{Ptr{GInetAddressMask}}, gateway::Ptr{Ptr{GInetAddress}}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_gv_set_persistent_ip_from_string(camera, ip, mask, gateway, error)

### Prototype
```c
ARV_API void arv_camera_gv_set_persistent_ip_from_string (ArvCamera *camera, const char *ip, const char *mask, const char *gateway, GError **error);
```
"""
function arv_camera_gv_set_persistent_ip_from_string(camera, ip, mask, gateway, error)
    @ccall libaravis.arv_camera_gv_set_persistent_ip_from_string(camera::Ptr{ArvCamera}, ip::Cstring, mask::Cstring, gateway::Cstring, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_gv_set_persistent_ip(camera, ip, mask, gateway, error)

### Prototype
```c
ARV_API void arv_camera_gv_set_persistent_ip (ArvCamera *camera, GInetAddress *ip, GInetAddressMask *mask, GInetAddress *gateway, GError **error);
```
"""
function arv_camera_gv_set_persistent_ip(camera, ip, mask, gateway, error)
    @ccall libaravis.arv_camera_gv_set_persistent_ip(camera::Ptr{ArvCamera}, ip::Ptr{GInetAddress}, mask::Ptr{GInetAddressMask}, gateway::Ptr{GInetAddress}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_gv_get_ip_configuration_mode(camera, error)

### Prototype
```c
ARV_API ArvGvIpConfigurationMode arv_camera_gv_get_ip_configuration_mode (ArvCamera *camera, GError **error);
```
"""
function arv_camera_gv_get_ip_configuration_mode(camera, error)
    @ccall libaravis.arv_camera_gv_get_ip_configuration_mode(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::ArvGvIpConfigurationMode
end

"""
    arv_camera_gv_set_ip_configuration_mode(camera, mode, error)

### Prototype
```c
ARV_API void arv_camera_gv_set_ip_configuration_mode (ArvCamera *camera, ArvGvIpConfigurationMode mode, GError **error);
```
"""
function arv_camera_gv_set_ip_configuration_mode(camera, mode, error)
    @ccall libaravis.arv_camera_gv_set_ip_configuration_mode(camera::Ptr{ArvCamera}, mode::ArvGvIpConfigurationMode, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_is_uv_device(camera)

### Prototype
```c
ARV_API gboolean arv_camera_is_uv_device (ArvCamera *camera);
```
"""
function arv_camera_is_uv_device(camera)
    @ccall libaravis.arv_camera_is_uv_device(camera::Ptr{ArvCamera})::gboolean
end

"""
    arv_camera_uv_is_bandwidth_control_available(camera, error)

### Prototype
```c
ARV_API gboolean arv_camera_uv_is_bandwidth_control_available (ArvCamera *camera, GError **error);
```
"""
function arv_camera_uv_is_bandwidth_control_available(camera, error)
    @ccall libaravis.arv_camera_uv_is_bandwidth_control_available(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_camera_uv_set_bandwidth(camera, bandwidth, error)

### Prototype
```c
ARV_API void arv_camera_uv_set_bandwidth (ArvCamera *camera, guint bandwidth, GError **error);
```
"""
function arv_camera_uv_set_bandwidth(camera, bandwidth, error)
    @ccall libaravis.arv_camera_uv_set_bandwidth(camera::Ptr{ArvCamera}, bandwidth::guint, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_uv_get_bandwidth(camera, error)

### Prototype
```c
ARV_API guint arv_camera_uv_get_bandwidth (ArvCamera *camera, GError **error);
```
"""
function arv_camera_uv_get_bandwidth(camera, error)
    @ccall libaravis.arv_camera_uv_get_bandwidth(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::guint
end

"""
    arv_camera_uv_get_bandwidth_bounds(camera, min, max, error)

### Prototype
```c
ARV_API void arv_camera_uv_get_bandwidth_bounds (ArvCamera *camera, guint *min, guint *max, GError **error);
```
"""
function arv_camera_uv_get_bandwidth_bounds(camera, min, max, error)
    @ccall libaravis.arv_camera_uv_get_bandwidth_bounds(camera::Ptr{ArvCamera}, min::Ptr{guint}, max::Ptr{guint}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_uv_set_usb_mode(camera, usb_mode)

### Prototype
```c
ARV_API void arv_camera_uv_set_usb_mode (ArvCamera *camera, ArvUvUsbMode usb_mode);
```
"""
function arv_camera_uv_set_usb_mode(camera, usb_mode)
    @ccall libaravis.arv_camera_uv_set_usb_mode(camera::Ptr{ArvCamera}, usb_mode::ArvUvUsbMode)::Cvoid
end

"""
    arv_camera_are_chunks_available(camera, error)

### Prototype
```c
ARV_API gboolean arv_camera_are_chunks_available (ArvCamera *camera, GError **error);
```
"""
function arv_camera_are_chunks_available(camera, error)
    @ccall libaravis.arv_camera_are_chunks_available(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_camera_set_chunk_mode(camera, is_active, error)

### Prototype
```c
ARV_API void arv_camera_set_chunk_mode (ArvCamera *camera, gboolean is_active, GError **error);
```
"""
function arv_camera_set_chunk_mode(camera, is_active, error)
    @ccall libaravis.arv_camera_set_chunk_mode(camera::Ptr{ArvCamera}, is_active::gboolean, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_chunk_mode(camera, error)

### Prototype
```c
ARV_API gboolean arv_camera_get_chunk_mode (ArvCamera *camera, GError **error);
```
"""
function arv_camera_get_chunk_mode(camera, error)
    @ccall libaravis.arv_camera_get_chunk_mode(camera::Ptr{ArvCamera}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_camera_set_chunk_state(camera, chunk, is_enabled, error)

### Prototype
```c
ARV_API void arv_camera_set_chunk_state (ArvCamera *camera, const char *chunk, gboolean is_enabled, GError **error);
```
"""
function arv_camera_set_chunk_state(camera, chunk, is_enabled, error)
    @ccall libaravis.arv_camera_set_chunk_state(camera::Ptr{ArvCamera}, chunk::Cstring, is_enabled::gboolean, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_get_chunk_state(camera, chunk, error)

### Prototype
```c
ARV_API gboolean arv_camera_get_chunk_state (ArvCamera *camera, const char *chunk, GError **error);
```
"""
function arv_camera_get_chunk_state(camera, chunk, error)
    @ccall libaravis.arv_camera_get_chunk_state(camera::Ptr{ArvCamera}, chunk::Cstring, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_camera_set_chunks(camera, chunk_list, error)

### Prototype
```c
ARV_API void arv_camera_set_chunks (ArvCamera *camera, const char *chunk_list, GError **error);
```
"""
function arv_camera_set_chunks(camera, chunk_list, error)
    @ccall libaravis.arv_camera_set_chunks(camera::Ptr{ArvCamera}, chunk_list::Cstring, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_camera_create_chunk_parser(camera)

### Prototype
```c
ARV_API ArvChunkParser * arv_camera_create_chunk_parser (ArvCamera *camera);
```
"""
function arv_camera_create_chunk_parser(camera)
    @ccall libaravis.arv_camera_create_chunk_parser(camera::Ptr{ArvCamera})::Ptr{ArvChunkParser}
end

"""
    arv_debug_enable(category_selection)

### Prototype
```c
ARV_API gboolean arv_debug_enable (const char *category_selection);
```
"""
function arv_debug_enable(category_selection)
    @ccall libaravis.arv_debug_enable(category_selection::Cstring)::gboolean
end

struct _ArvDomCharacterDataClass
    parent_class::ArvDomNodeClass
end

const ArvDomCharacterDataClass = _ArvDomCharacterDataClass

const ArvDomCharacterData_autoptr = Ptr{ArvDomCharacterData}

const ArvDomCharacterData_listautoptr = Ptr{GList}

const ArvDomCharacterData_slistautoptr = Ptr{GSList}

const ArvDomCharacterData_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvDomCharacterData(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomCharacterData, arv_dom_character_data, ARV, DOM_CHARACTER_DATA, ArvDomNode);
```
"""
function glib_autoptr_clear_ArvDomCharacterData(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvDomCharacterData(_ptr::Ptr{ArvDomCharacterData})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvDomCharacterData(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomCharacterData, arv_dom_character_data, ARV, DOM_CHARACTER_DATA, ArvDomNode);
```
"""
function glib_autoptr_cleanup_ArvDomCharacterData(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvDomCharacterData(_ptr::Ptr{Ptr{ArvDomCharacterData}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvDomCharacterData(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomCharacterData, arv_dom_character_data, ARV, DOM_CHARACTER_DATA, ArvDomNode);
```
"""
function glib_autoptr_destroy_ArvDomCharacterData(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvDomCharacterData(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvDomCharacterData(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomCharacterData, arv_dom_character_data, ARV, DOM_CHARACTER_DATA, ArvDomNode);
```
"""
function glib_listautoptr_cleanup_ArvDomCharacterData(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvDomCharacterData(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvDomCharacterData(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomCharacterData, arv_dom_character_data, ARV, DOM_CHARACTER_DATA, ArvDomNode);
```
"""
function glib_slistautoptr_cleanup_ArvDomCharacterData(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvDomCharacterData(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvDomCharacterData(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomCharacterData, arv_dom_character_data, ARV, DOM_CHARACTER_DATA, ArvDomNode);
```
"""
function glib_queueautoptr_cleanup_ArvDomCharacterData(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvDomCharacterData(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvDomCharacterDataClass_autoptr = Ptr{ArvDomCharacterDataClass}

const ArvDomCharacterDataClass_listautoptr = Ptr{GList}

const ArvDomCharacterDataClass_slistautoptr = Ptr{GSList}

const ArvDomCharacterDataClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvDomCharacterDataClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomCharacterData, arv_dom_character_data, ARV, DOM_CHARACTER_DATA, ArvDomNode);
```
"""
function glib_autoptr_clear_ArvDomCharacterDataClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvDomCharacterDataClass(_ptr::Ptr{ArvDomCharacterDataClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvDomCharacterDataClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomCharacterData, arv_dom_character_data, ARV, DOM_CHARACTER_DATA, ArvDomNode);
```
"""
function glib_autoptr_cleanup_ArvDomCharacterDataClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvDomCharacterDataClass(_ptr::Ptr{Ptr{ArvDomCharacterDataClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvDomCharacterDataClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomCharacterData, arv_dom_character_data, ARV, DOM_CHARACTER_DATA, ArvDomNode);
```
"""
function glib_autoptr_destroy_ArvDomCharacterDataClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvDomCharacterDataClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvDomCharacterDataClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomCharacterData, arv_dom_character_data, ARV, DOM_CHARACTER_DATA, ArvDomNode);
```
"""
function glib_listautoptr_cleanup_ArvDomCharacterDataClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvDomCharacterDataClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvDomCharacterDataClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomCharacterData, arv_dom_character_data, ARV, DOM_CHARACTER_DATA, ArvDomNode);
```
"""
function glib_slistautoptr_cleanup_ArvDomCharacterDataClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvDomCharacterDataClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvDomCharacterDataClass(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomCharacterData, arv_dom_character_data, ARV, DOM_CHARACTER_DATA, ArvDomNode);
```
"""
function glib_queueautoptr_cleanup_ArvDomCharacterDataClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvDomCharacterDataClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_DOM_CHARACTER_DATA(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomCharacterData, arv_dom_character_data, ARV, DOM_CHARACTER_DATA, ArvDomNode);
```
"""
function ARV_DOM_CHARACTER_DATA(ptr)
    @ccall libaravis.ARV_DOM_CHARACTER_DATA(ptr::gpointer)::Ptr{ArvDomCharacterData}
end

"""
    ARV_DOM_CHARACTER_DATA_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomCharacterData, arv_dom_character_data, ARV, DOM_CHARACTER_DATA, ArvDomNode);
```
"""
function ARV_DOM_CHARACTER_DATA_CLASS(ptr)
    @ccall libaravis.ARV_DOM_CHARACTER_DATA_CLASS(ptr::gpointer)::Ptr{ArvDomCharacterDataClass}
end

"""
    ARV_IS_DOM_CHARACTER_DATA(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomCharacterData, arv_dom_character_data, ARV, DOM_CHARACTER_DATA, ArvDomNode);
```
"""
function ARV_IS_DOM_CHARACTER_DATA(ptr)
    @ccall libaravis.ARV_IS_DOM_CHARACTER_DATA(ptr::gpointer)::gboolean
end

"""
    ARV_IS_DOM_CHARACTER_DATA_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomCharacterData, arv_dom_character_data, ARV, DOM_CHARACTER_DATA, ArvDomNode);
```
"""
function ARV_IS_DOM_CHARACTER_DATA_CLASS(ptr)
    @ccall libaravis.ARV_IS_DOM_CHARACTER_DATA_CLASS(ptr::gpointer)::gboolean
end

"""
    ARV_DOM_CHARACTER_DATA_GET_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomCharacterData, arv_dom_character_data, ARV, DOM_CHARACTER_DATA, ArvDomNode);
```
"""
function ARV_DOM_CHARACTER_DATA_GET_CLASS(ptr)
    @ccall libaravis.ARV_DOM_CHARACTER_DATA_GET_CLASS(ptr::gpointer)::Ptr{ArvDomCharacterDataClass}
end

"""
    arv_dom_character_data_get_data(self)

### Prototype
```c
ARV_API const char * arv_dom_character_data_get_data (ArvDomCharacterData *self);
```
"""
function arv_dom_character_data_get_data(self)
    @ccall libaravis.arv_dom_character_data_get_data(self::Ptr{ArvDomCharacterData})::Cstring
end

"""
    arv_dom_character_data_set_data(self, value)

### Prototype
```c
ARV_API void arv_dom_character_data_set_data (ArvDomCharacterData *self, const char *value);
```
"""
function arv_dom_character_data_set_data(self, value)
    @ccall libaravis.arv_dom_character_data_set_data(self::Ptr{ArvDomCharacterData}, value::Cstring)::Cvoid
end

struct _ArvDomDocumentFragmentClass
    parent_class::ArvDomNodeClass
end

const ArvDomDocumentFragmentClass = _ArvDomDocumentFragmentClass

const ArvDomDocumentFragment_autoptr = Ptr{ArvDomDocumentFragment}

const ArvDomDocumentFragment_listautoptr = Ptr{GList}

const ArvDomDocumentFragment_slistautoptr = Ptr{GSList}

const ArvDomDocumentFragment_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvDomDocumentFragment(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocumentFragment, arv_dom_document_fragment, ARV, DOM_DOCUMENT_FRAGMENT, ArvDomNode);
```
"""
function glib_autoptr_clear_ArvDomDocumentFragment(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvDomDocumentFragment(_ptr::Ptr{ArvDomDocumentFragment})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvDomDocumentFragment(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocumentFragment, arv_dom_document_fragment, ARV, DOM_DOCUMENT_FRAGMENT, ArvDomNode);
```
"""
function glib_autoptr_cleanup_ArvDomDocumentFragment(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvDomDocumentFragment(_ptr::Ptr{Ptr{ArvDomDocumentFragment}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvDomDocumentFragment(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocumentFragment, arv_dom_document_fragment, ARV, DOM_DOCUMENT_FRAGMENT, ArvDomNode);
```
"""
function glib_autoptr_destroy_ArvDomDocumentFragment(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvDomDocumentFragment(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvDomDocumentFragment(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocumentFragment, arv_dom_document_fragment, ARV, DOM_DOCUMENT_FRAGMENT, ArvDomNode);
```
"""
function glib_listautoptr_cleanup_ArvDomDocumentFragment(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvDomDocumentFragment(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvDomDocumentFragment(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocumentFragment, arv_dom_document_fragment, ARV, DOM_DOCUMENT_FRAGMENT, ArvDomNode);
```
"""
function glib_slistautoptr_cleanup_ArvDomDocumentFragment(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvDomDocumentFragment(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvDomDocumentFragment(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocumentFragment, arv_dom_document_fragment, ARV, DOM_DOCUMENT_FRAGMENT, ArvDomNode);
```
"""
function glib_queueautoptr_cleanup_ArvDomDocumentFragment(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvDomDocumentFragment(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvDomDocumentFragmentClass_autoptr = Ptr{ArvDomDocumentFragmentClass}

const ArvDomDocumentFragmentClass_listautoptr = Ptr{GList}

const ArvDomDocumentFragmentClass_slistautoptr = Ptr{GSList}

const ArvDomDocumentFragmentClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvDomDocumentFragmentClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocumentFragment, arv_dom_document_fragment, ARV, DOM_DOCUMENT_FRAGMENT, ArvDomNode);
```
"""
function glib_autoptr_clear_ArvDomDocumentFragmentClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvDomDocumentFragmentClass(_ptr::Ptr{ArvDomDocumentFragmentClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvDomDocumentFragmentClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocumentFragment, arv_dom_document_fragment, ARV, DOM_DOCUMENT_FRAGMENT, ArvDomNode);
```
"""
function glib_autoptr_cleanup_ArvDomDocumentFragmentClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvDomDocumentFragmentClass(_ptr::Ptr{Ptr{ArvDomDocumentFragmentClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvDomDocumentFragmentClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocumentFragment, arv_dom_document_fragment, ARV, DOM_DOCUMENT_FRAGMENT, ArvDomNode);
```
"""
function glib_autoptr_destroy_ArvDomDocumentFragmentClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvDomDocumentFragmentClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvDomDocumentFragmentClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocumentFragment, arv_dom_document_fragment, ARV, DOM_DOCUMENT_FRAGMENT, ArvDomNode);
```
"""
function glib_listautoptr_cleanup_ArvDomDocumentFragmentClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvDomDocumentFragmentClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvDomDocumentFragmentClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocumentFragment, arv_dom_document_fragment, ARV, DOM_DOCUMENT_FRAGMENT, ArvDomNode);
```
"""
function glib_slistautoptr_cleanup_ArvDomDocumentFragmentClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvDomDocumentFragmentClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvDomDocumentFragmentClass(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocumentFragment, arv_dom_document_fragment, ARV, DOM_DOCUMENT_FRAGMENT, ArvDomNode);
```
"""
function glib_queueautoptr_cleanup_ArvDomDocumentFragmentClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvDomDocumentFragmentClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_DOM_DOCUMENT_FRAGMENT(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocumentFragment, arv_dom_document_fragment, ARV, DOM_DOCUMENT_FRAGMENT, ArvDomNode);
```
"""
function ARV_DOM_DOCUMENT_FRAGMENT(ptr)
    @ccall libaravis.ARV_DOM_DOCUMENT_FRAGMENT(ptr::gpointer)::Ptr{ArvDomDocumentFragment}
end

"""
    ARV_DOM_DOCUMENT_FRAGMENT_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocumentFragment, arv_dom_document_fragment, ARV, DOM_DOCUMENT_FRAGMENT, ArvDomNode);
```
"""
function ARV_DOM_DOCUMENT_FRAGMENT_CLASS(ptr)
    @ccall libaravis.ARV_DOM_DOCUMENT_FRAGMENT_CLASS(ptr::gpointer)::Ptr{ArvDomDocumentFragmentClass}
end

"""
    ARV_IS_DOM_DOCUMENT_FRAGMENT(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocumentFragment, arv_dom_document_fragment, ARV, DOM_DOCUMENT_FRAGMENT, ArvDomNode);
```
"""
function ARV_IS_DOM_DOCUMENT_FRAGMENT(ptr)
    @ccall libaravis.ARV_IS_DOM_DOCUMENT_FRAGMENT(ptr::gpointer)::gboolean
end

"""
    ARV_IS_DOM_DOCUMENT_FRAGMENT_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocumentFragment, arv_dom_document_fragment, ARV, DOM_DOCUMENT_FRAGMENT, ArvDomNode);
```
"""
function ARV_IS_DOM_DOCUMENT_FRAGMENT_CLASS(ptr)
    @ccall libaravis.ARV_IS_DOM_DOCUMENT_FRAGMENT_CLASS(ptr::gpointer)::gboolean
end

"""
    ARV_DOM_DOCUMENT_FRAGMENT_GET_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomDocumentFragment, arv_dom_document_fragment, ARV, DOM_DOCUMENT_FRAGMENT, ArvDomNode);
```
"""
function ARV_DOM_DOCUMENT_FRAGMENT_GET_CLASS(ptr)
    @ccall libaravis.ARV_DOM_DOCUMENT_FRAGMENT_GET_CLASS(ptr::gpointer)::Ptr{ArvDomDocumentFragmentClass}
end

"""
    arv_dom_document_fragment_new()

### Prototype
```c
ARV_API ArvDomDocumentFragment * arv_dom_document_fragment_new (void);
```
"""
function arv_dom_document_fragment_new()
    @ccall libaravis.arv_dom_document_fragment_new()::Ptr{ArvDomDocumentFragment}
end

struct _ArvDomElementClass
    parent_class::ArvDomNodeClass
    get_attribute::Ptr{Cvoid}
    set_attribute::Ptr{Cvoid}
end

const ArvDomElementClass = _ArvDomElementClass

const ArvDomElement_autoptr = Ptr{ArvDomElement}

const ArvDomElement_listautoptr = Ptr{GList}

const ArvDomElement_slistautoptr = Ptr{GSList}

const ArvDomElement_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvDomElement(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomElement, arv_dom_element, ARV, DOM_ELEMENT, ArvDomNode);
```
"""
function glib_autoptr_clear_ArvDomElement(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvDomElement(_ptr::Ptr{ArvDomElement})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvDomElement(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomElement, arv_dom_element, ARV, DOM_ELEMENT, ArvDomNode);
```
"""
function glib_autoptr_cleanup_ArvDomElement(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvDomElement(_ptr::Ptr{Ptr{ArvDomElement}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvDomElement(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomElement, arv_dom_element, ARV, DOM_ELEMENT, ArvDomNode);
```
"""
function glib_autoptr_destroy_ArvDomElement(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvDomElement(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvDomElement(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomElement, arv_dom_element, ARV, DOM_ELEMENT, ArvDomNode);
```
"""
function glib_listautoptr_cleanup_ArvDomElement(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvDomElement(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvDomElement(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomElement, arv_dom_element, ARV, DOM_ELEMENT, ArvDomNode);
```
"""
function glib_slistautoptr_cleanup_ArvDomElement(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvDomElement(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvDomElement(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomElement, arv_dom_element, ARV, DOM_ELEMENT, ArvDomNode);
```
"""
function glib_queueautoptr_cleanup_ArvDomElement(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvDomElement(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvDomElementClass_autoptr = Ptr{ArvDomElementClass}

const ArvDomElementClass_listautoptr = Ptr{GList}

const ArvDomElementClass_slistautoptr = Ptr{GSList}

const ArvDomElementClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvDomElementClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomElement, arv_dom_element, ARV, DOM_ELEMENT, ArvDomNode);
```
"""
function glib_autoptr_clear_ArvDomElementClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvDomElementClass(_ptr::Ptr{ArvDomElementClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvDomElementClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomElement, arv_dom_element, ARV, DOM_ELEMENT, ArvDomNode);
```
"""
function glib_autoptr_cleanup_ArvDomElementClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvDomElementClass(_ptr::Ptr{Ptr{ArvDomElementClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvDomElementClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomElement, arv_dom_element, ARV, DOM_ELEMENT, ArvDomNode);
```
"""
function glib_autoptr_destroy_ArvDomElementClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvDomElementClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvDomElementClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomElement, arv_dom_element, ARV, DOM_ELEMENT, ArvDomNode);
```
"""
function glib_listautoptr_cleanup_ArvDomElementClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvDomElementClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvDomElementClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomElement, arv_dom_element, ARV, DOM_ELEMENT, ArvDomNode);
```
"""
function glib_slistautoptr_cleanup_ArvDomElementClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvDomElementClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvDomElementClass(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomElement, arv_dom_element, ARV, DOM_ELEMENT, ArvDomNode);
```
"""
function glib_queueautoptr_cleanup_ArvDomElementClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvDomElementClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_DOM_ELEMENT(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomElement, arv_dom_element, ARV, DOM_ELEMENT, ArvDomNode);
```
"""
function ARV_DOM_ELEMENT(ptr)
    @ccall libaravis.ARV_DOM_ELEMENT(ptr::gpointer)::Ptr{ArvDomElement}
end

"""
    ARV_DOM_ELEMENT_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomElement, arv_dom_element, ARV, DOM_ELEMENT, ArvDomNode);
```
"""
function ARV_DOM_ELEMENT_CLASS(ptr)
    @ccall libaravis.ARV_DOM_ELEMENT_CLASS(ptr::gpointer)::Ptr{ArvDomElementClass}
end

"""
    ARV_IS_DOM_ELEMENT(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomElement, arv_dom_element, ARV, DOM_ELEMENT, ArvDomNode);
```
"""
function ARV_IS_DOM_ELEMENT(ptr)
    @ccall libaravis.ARV_IS_DOM_ELEMENT(ptr::gpointer)::gboolean
end

"""
    ARV_IS_DOM_ELEMENT_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomElement, arv_dom_element, ARV, DOM_ELEMENT, ArvDomNode);
```
"""
function ARV_IS_DOM_ELEMENT_CLASS(ptr)
    @ccall libaravis.ARV_IS_DOM_ELEMENT_CLASS(ptr::gpointer)::gboolean
end

"""
    ARV_DOM_ELEMENT_GET_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomElement, arv_dom_element, ARV, DOM_ELEMENT, ArvDomNode);
```
"""
function ARV_DOM_ELEMENT_GET_CLASS(ptr)
    @ccall libaravis.ARV_DOM_ELEMENT_GET_CLASS(ptr::gpointer)::Ptr{ArvDomElementClass}
end

"""
    arv_dom_element_get_tag_name(self)

### Prototype
```c
ARV_API const char * arv_dom_element_get_tag_name (ArvDomElement *self);
```
"""
function arv_dom_element_get_tag_name(self)
    @ccall libaravis.arv_dom_element_get_tag_name(self::Ptr{ArvDomElement})::Cstring
end

"""
    arv_dom_element_get_attribute(self, name)

### Prototype
```c
ARV_API const char* arv_dom_element_get_attribute (ArvDomElement *self, const char *name);
```
"""
function arv_dom_element_get_attribute(self, name)
    @ccall libaravis.arv_dom_element_get_attribute(self::Ptr{ArvDomElement}, name::Cstring)::Cstring
end

"""
    arv_dom_element_set_attribute(self, name, attribute_value)

### Prototype
```c
ARV_API void arv_dom_element_set_attribute (ArvDomElement *self, const char *name, const char *attribute_value);
```
"""
function arv_dom_element_set_attribute(self, name, attribute_value)
    @ccall libaravis.arv_dom_element_set_attribute(self::Ptr{ArvDomElement}, name::Cstring, attribute_value::Cstring)::Cvoid
end

# typedef ArvDomDocument * ( * ArvDomDocumentCreateFunction ) ( void )
const ArvDomDocumentCreateFunction = Ptr{Cvoid}

"""
    arv_dom_implementation_create_document(namespace_uri, qualified_name)

### Prototype
```c
ARV_API ArvDomDocument * arv_dom_implementation_create_document (const char *namespace_uri, const char *qualified_name);
```
"""
function arv_dom_implementation_create_document(namespace_uri, qualified_name)
    @ccall libaravis.arv_dom_implementation_create_document(namespace_uri::Cstring, qualified_name::Cstring)::Ptr{ArvDomDocument}
end

"""
    arv_dom_implementation_add_document_type(qualified_name, document_type)

### Prototype
```c
ARV_API void arv_dom_implementation_add_document_type (const char *qualified_name, GType document_type);
```
"""
function arv_dom_implementation_add_document_type(qualified_name, document_type)
    @ccall libaravis.arv_dom_implementation_add_document_type(qualified_name::Cstring, document_type::GType)::Cvoid
end

"""
    arv_dom_implementation_cleanup()

### Prototype
```c
ARV_API void arv_dom_implementation_cleanup (void);
```
"""
function arv_dom_implementation_cleanup()
    @ccall libaravis.arv_dom_implementation_cleanup()::Cvoid
end

struct _ArvDomNamedNodeMapClass
    parent_class::GObjectClass
    get::Ptr{Cvoid}
    set::Ptr{Cvoid}
    remove::Ptr{Cvoid}
    get_item::Ptr{Cvoid}
    get_length::Ptr{Cvoid}
end

const ArvDomNamedNodeMapClass = _ArvDomNamedNodeMapClass

const ArvDomNamedNodeMap_autoptr = Ptr{ArvDomNamedNodeMap}

const ArvDomNamedNodeMap_listautoptr = Ptr{GList}

const ArvDomNamedNodeMap_slistautoptr = Ptr{GSList}

const ArvDomNamedNodeMap_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvDomNamedNodeMap(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNamedNodeMap, arv_dom_named_node_map, ARV, DOM_NAMED_NODE_MAP, GObject);
```
"""
function glib_autoptr_clear_ArvDomNamedNodeMap(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvDomNamedNodeMap(_ptr::Ptr{ArvDomNamedNodeMap})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvDomNamedNodeMap(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNamedNodeMap, arv_dom_named_node_map, ARV, DOM_NAMED_NODE_MAP, GObject);
```
"""
function glib_autoptr_cleanup_ArvDomNamedNodeMap(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvDomNamedNodeMap(_ptr::Ptr{Ptr{ArvDomNamedNodeMap}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvDomNamedNodeMap(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNamedNodeMap, arv_dom_named_node_map, ARV, DOM_NAMED_NODE_MAP, GObject);
```
"""
function glib_autoptr_destroy_ArvDomNamedNodeMap(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvDomNamedNodeMap(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvDomNamedNodeMap(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNamedNodeMap, arv_dom_named_node_map, ARV, DOM_NAMED_NODE_MAP, GObject);
```
"""
function glib_listautoptr_cleanup_ArvDomNamedNodeMap(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvDomNamedNodeMap(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvDomNamedNodeMap(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNamedNodeMap, arv_dom_named_node_map, ARV, DOM_NAMED_NODE_MAP, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvDomNamedNodeMap(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvDomNamedNodeMap(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvDomNamedNodeMap(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNamedNodeMap, arv_dom_named_node_map, ARV, DOM_NAMED_NODE_MAP, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvDomNamedNodeMap(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvDomNamedNodeMap(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvDomNamedNodeMapClass_autoptr = Ptr{ArvDomNamedNodeMapClass}

const ArvDomNamedNodeMapClass_listautoptr = Ptr{GList}

const ArvDomNamedNodeMapClass_slistautoptr = Ptr{GSList}

const ArvDomNamedNodeMapClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvDomNamedNodeMapClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNamedNodeMap, arv_dom_named_node_map, ARV, DOM_NAMED_NODE_MAP, GObject);
```
"""
function glib_autoptr_clear_ArvDomNamedNodeMapClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvDomNamedNodeMapClass(_ptr::Ptr{ArvDomNamedNodeMapClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvDomNamedNodeMapClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNamedNodeMap, arv_dom_named_node_map, ARV, DOM_NAMED_NODE_MAP, GObject);
```
"""
function glib_autoptr_cleanup_ArvDomNamedNodeMapClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvDomNamedNodeMapClass(_ptr::Ptr{Ptr{ArvDomNamedNodeMapClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvDomNamedNodeMapClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNamedNodeMap, arv_dom_named_node_map, ARV, DOM_NAMED_NODE_MAP, GObject);
```
"""
function glib_autoptr_destroy_ArvDomNamedNodeMapClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvDomNamedNodeMapClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvDomNamedNodeMapClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNamedNodeMap, arv_dom_named_node_map, ARV, DOM_NAMED_NODE_MAP, GObject);
```
"""
function glib_listautoptr_cleanup_ArvDomNamedNodeMapClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvDomNamedNodeMapClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvDomNamedNodeMapClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNamedNodeMap, arv_dom_named_node_map, ARV, DOM_NAMED_NODE_MAP, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvDomNamedNodeMapClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvDomNamedNodeMapClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvDomNamedNodeMapClass(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNamedNodeMap, arv_dom_named_node_map, ARV, DOM_NAMED_NODE_MAP, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvDomNamedNodeMapClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvDomNamedNodeMapClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_DOM_NAMED_NODE_MAP(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNamedNodeMap, arv_dom_named_node_map, ARV, DOM_NAMED_NODE_MAP, GObject);
```
"""
function ARV_DOM_NAMED_NODE_MAP(ptr)
    @ccall libaravis.ARV_DOM_NAMED_NODE_MAP(ptr::gpointer)::Ptr{ArvDomNamedNodeMap}
end

"""
    ARV_DOM_NAMED_NODE_MAP_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNamedNodeMap, arv_dom_named_node_map, ARV, DOM_NAMED_NODE_MAP, GObject);
```
"""
function ARV_DOM_NAMED_NODE_MAP_CLASS(ptr)
    @ccall libaravis.ARV_DOM_NAMED_NODE_MAP_CLASS(ptr::gpointer)::Ptr{ArvDomNamedNodeMapClass}
end

"""
    ARV_IS_DOM_NAMED_NODE_MAP(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNamedNodeMap, arv_dom_named_node_map, ARV, DOM_NAMED_NODE_MAP, GObject);
```
"""
function ARV_IS_DOM_NAMED_NODE_MAP(ptr)
    @ccall libaravis.ARV_IS_DOM_NAMED_NODE_MAP(ptr::gpointer)::gboolean
end

"""
    ARV_IS_DOM_NAMED_NODE_MAP_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNamedNodeMap, arv_dom_named_node_map, ARV, DOM_NAMED_NODE_MAP, GObject);
```
"""
function ARV_IS_DOM_NAMED_NODE_MAP_CLASS(ptr)
    @ccall libaravis.ARV_IS_DOM_NAMED_NODE_MAP_CLASS(ptr::gpointer)::gboolean
end

"""
    ARV_DOM_NAMED_NODE_MAP_GET_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNamedNodeMap, arv_dom_named_node_map, ARV, DOM_NAMED_NODE_MAP, GObject);
```
"""
function ARV_DOM_NAMED_NODE_MAP_GET_CLASS(ptr)
    @ccall libaravis.ARV_DOM_NAMED_NODE_MAP_GET_CLASS(ptr::gpointer)::Ptr{ArvDomNamedNodeMapClass}
end

"""
    arv_dom_named_node_map_get_named_item(map, name)

### Prototype
```c
ARV_API ArvDomNode * arv_dom_named_node_map_get_named_item (ArvDomNamedNodeMap *map, const char *name);
```
"""
function arv_dom_named_node_map_get_named_item(map, name)
    @ccall libaravis.arv_dom_named_node_map_get_named_item(map::Ptr{ArvDomNamedNodeMap}, name::Cstring)::Ptr{ArvDomNode}
end

"""
    arv_dom_named_node_map_set_named_item(map, item)

### Prototype
```c
ARV_API ArvDomNode * arv_dom_named_node_map_set_named_item (ArvDomNamedNodeMap *map, ArvDomNode *item);
```
"""
function arv_dom_named_node_map_set_named_item(map, item)
    @ccall libaravis.arv_dom_named_node_map_set_named_item(map::Ptr{ArvDomNamedNodeMap}, item::Ptr{ArvDomNode})::Ptr{ArvDomNode}
end

"""
    arv_dom_named_node_map_remove_named_item(map, name)

### Prototype
```c
ARV_API ArvDomNode * arv_dom_named_node_map_remove_named_item (ArvDomNamedNodeMap *map, const char *name);
```
"""
function arv_dom_named_node_map_remove_named_item(map, name)
    @ccall libaravis.arv_dom_named_node_map_remove_named_item(map::Ptr{ArvDomNamedNodeMap}, name::Cstring)::Ptr{ArvDomNode}
end

"""
    arv_dom_named_node_map_get_item(map, index)

### Prototype
```c
ARV_API ArvDomNode * arv_dom_named_node_map_get_item (ArvDomNamedNodeMap *map, unsigned int index);
```
"""
function arv_dom_named_node_map_get_item(map, index)
    @ccall libaravis.arv_dom_named_node_map_get_item(map::Ptr{ArvDomNamedNodeMap}, index::Cuint)::Ptr{ArvDomNode}
end

"""
    arv_dom_named_node_map_get_length(map)

### Prototype
```c
ARV_API unsigned int arv_dom_named_node_map_get_length (ArvDomNamedNodeMap *map);
```
"""
function arv_dom_named_node_map_get_length(map)
    @ccall libaravis.arv_dom_named_node_map_get_length(map::Ptr{ArvDomNamedNodeMap})::Cuint
end

struct _ArvDomNodeListClass
    parent_class::GObjectClass
    get_item::Ptr{Cvoid}
    get_length::Ptr{Cvoid}
end

const ArvDomNodeListClass = _ArvDomNodeListClass

const ArvDomNodeList_autoptr = Ptr{ArvDomNodeList}

const ArvDomNodeList_listautoptr = Ptr{GList}

const ArvDomNodeList_slistautoptr = Ptr{GSList}

const ArvDomNodeList_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvDomNodeList(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNodeList, arv_dom_node_list, ARV, DOM_NODE_LIST, GObject);
```
"""
function glib_autoptr_clear_ArvDomNodeList(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvDomNodeList(_ptr::Ptr{ArvDomNodeList})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvDomNodeList(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNodeList, arv_dom_node_list, ARV, DOM_NODE_LIST, GObject);
```
"""
function glib_autoptr_cleanup_ArvDomNodeList(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvDomNodeList(_ptr::Ptr{Ptr{ArvDomNodeList}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvDomNodeList(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNodeList, arv_dom_node_list, ARV, DOM_NODE_LIST, GObject);
```
"""
function glib_autoptr_destroy_ArvDomNodeList(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvDomNodeList(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvDomNodeList(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNodeList, arv_dom_node_list, ARV, DOM_NODE_LIST, GObject);
```
"""
function glib_listautoptr_cleanup_ArvDomNodeList(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvDomNodeList(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvDomNodeList(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNodeList, arv_dom_node_list, ARV, DOM_NODE_LIST, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvDomNodeList(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvDomNodeList(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvDomNodeList(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNodeList, arv_dom_node_list, ARV, DOM_NODE_LIST, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvDomNodeList(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvDomNodeList(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvDomNodeListClass_autoptr = Ptr{ArvDomNodeListClass}

const ArvDomNodeListClass_listautoptr = Ptr{GList}

const ArvDomNodeListClass_slistautoptr = Ptr{GSList}

const ArvDomNodeListClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvDomNodeListClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNodeList, arv_dom_node_list, ARV, DOM_NODE_LIST, GObject);
```
"""
function glib_autoptr_clear_ArvDomNodeListClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvDomNodeListClass(_ptr::Ptr{ArvDomNodeListClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvDomNodeListClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNodeList, arv_dom_node_list, ARV, DOM_NODE_LIST, GObject);
```
"""
function glib_autoptr_cleanup_ArvDomNodeListClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvDomNodeListClass(_ptr::Ptr{Ptr{ArvDomNodeListClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvDomNodeListClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNodeList, arv_dom_node_list, ARV, DOM_NODE_LIST, GObject);
```
"""
function glib_autoptr_destroy_ArvDomNodeListClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvDomNodeListClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvDomNodeListClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNodeList, arv_dom_node_list, ARV, DOM_NODE_LIST, GObject);
```
"""
function glib_listautoptr_cleanup_ArvDomNodeListClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvDomNodeListClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvDomNodeListClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNodeList, arv_dom_node_list, ARV, DOM_NODE_LIST, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvDomNodeListClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvDomNodeListClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvDomNodeListClass(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNodeList, arv_dom_node_list, ARV, DOM_NODE_LIST, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvDomNodeListClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvDomNodeListClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_DOM_NODE_LIST(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNodeList, arv_dom_node_list, ARV, DOM_NODE_LIST, GObject);
```
"""
function ARV_DOM_NODE_LIST(ptr)
    @ccall libaravis.ARV_DOM_NODE_LIST(ptr::gpointer)::Ptr{ArvDomNodeList}
end

"""
    ARV_DOM_NODE_LIST_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNodeList, arv_dom_node_list, ARV, DOM_NODE_LIST, GObject);
```
"""
function ARV_DOM_NODE_LIST_CLASS(ptr)
    @ccall libaravis.ARV_DOM_NODE_LIST_CLASS(ptr::gpointer)::Ptr{ArvDomNodeListClass}
end

"""
    ARV_IS_DOM_NODE_LIST(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNodeList, arv_dom_node_list, ARV, DOM_NODE_LIST, GObject);
```
"""
function ARV_IS_DOM_NODE_LIST(ptr)
    @ccall libaravis.ARV_IS_DOM_NODE_LIST(ptr::gpointer)::gboolean
end

"""
    ARV_IS_DOM_NODE_LIST_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNodeList, arv_dom_node_list, ARV, DOM_NODE_LIST, GObject);
```
"""
function ARV_IS_DOM_NODE_LIST_CLASS(ptr)
    @ccall libaravis.ARV_IS_DOM_NODE_LIST_CLASS(ptr::gpointer)::gboolean
end

"""
    ARV_DOM_NODE_LIST_GET_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomNodeList, arv_dom_node_list, ARV, DOM_NODE_LIST, GObject);
```
"""
function ARV_DOM_NODE_LIST_GET_CLASS(ptr)
    @ccall libaravis.ARV_DOM_NODE_LIST_GET_CLASS(ptr::gpointer)::Ptr{ArvDomNodeListClass}
end

"""
    arv_dom_node_list_get_item(list, index)

### Prototype
```c
ARV_API ArvDomNode * arv_dom_node_list_get_item (ArvDomNodeList *list, unsigned int index);
```
"""
function arv_dom_node_list_get_item(list, index)
    @ccall libaravis.arv_dom_node_list_get_item(list::Ptr{ArvDomNodeList}, index::Cuint)::Ptr{ArvDomNode}
end

"""
    arv_dom_node_list_get_length(list)

### Prototype
```c
ARV_API unsigned int arv_dom_node_list_get_length (ArvDomNodeList *list);
```
"""
function arv_dom_node_list_get_length(list)
    @ccall libaravis.arv_dom_node_list_get_length(list::Ptr{ArvDomNodeList})::Cuint
end

const _ArvDomNodeChildList = Cvoid

const ArvDomNodeChildList = _ArvDomNodeChildList

struct ArvDomNodeChildListClass
    parent_class::ArvDomNodeListClass
end

const ArvDomNodeChildList_autoptr = Ptr{ArvDomNodeChildList}

const ArvDomNodeChildList_listautoptr = Ptr{GList}

const ArvDomNodeChildList_slistautoptr = Ptr{GSList}

const ArvDomNodeChildList_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvDomNodeChildList(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvDomNodeChildList, arv_dom_node_child_list, ARV, DOM_NODE_CHILD_LIST, ArvDomNodeList);
```
"""
function glib_autoptr_clear_ArvDomNodeChildList(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvDomNodeChildList(_ptr::Ptr{ArvDomNodeChildList})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvDomNodeChildList(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvDomNodeChildList, arv_dom_node_child_list, ARV, DOM_NODE_CHILD_LIST, ArvDomNodeList);
```
"""
function glib_autoptr_cleanup_ArvDomNodeChildList(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvDomNodeChildList(_ptr::Ptr{Ptr{ArvDomNodeChildList}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvDomNodeChildList(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvDomNodeChildList, arv_dom_node_child_list, ARV, DOM_NODE_CHILD_LIST, ArvDomNodeList);
```
"""
function glib_autoptr_destroy_ArvDomNodeChildList(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvDomNodeChildList(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvDomNodeChildList(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvDomNodeChildList, arv_dom_node_child_list, ARV, DOM_NODE_CHILD_LIST, ArvDomNodeList);
```
"""
function glib_listautoptr_cleanup_ArvDomNodeChildList(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvDomNodeChildList(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvDomNodeChildList(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvDomNodeChildList, arv_dom_node_child_list, ARV, DOM_NODE_CHILD_LIST, ArvDomNodeList);
```
"""
function glib_slistautoptr_cleanup_ArvDomNodeChildList(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvDomNodeChildList(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvDomNodeChildList(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvDomNodeChildList, arv_dom_node_child_list, ARV, DOM_NODE_CHILD_LIST, ArvDomNodeList);
```
"""
function glib_queueautoptr_cleanup_ArvDomNodeChildList(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvDomNodeChildList(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvDomNodeChildListClass_autoptr = Ptr{ArvDomNodeChildListClass}

const ArvDomNodeChildListClass_listautoptr = Ptr{GList}

const ArvDomNodeChildListClass_slistautoptr = Ptr{GSList}

const ArvDomNodeChildListClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvDomNodeChildListClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvDomNodeChildList, arv_dom_node_child_list, ARV, DOM_NODE_CHILD_LIST, ArvDomNodeList);
```
"""
function glib_autoptr_clear_ArvDomNodeChildListClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvDomNodeChildListClass(_ptr::Ptr{ArvDomNodeChildListClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvDomNodeChildListClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvDomNodeChildList, arv_dom_node_child_list, ARV, DOM_NODE_CHILD_LIST, ArvDomNodeList);
```
"""
function glib_autoptr_cleanup_ArvDomNodeChildListClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvDomNodeChildListClass(_ptr::Ptr{Ptr{ArvDomNodeChildListClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvDomNodeChildListClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvDomNodeChildList, arv_dom_node_child_list, ARV, DOM_NODE_CHILD_LIST, ArvDomNodeList);
```
"""
function glib_autoptr_destroy_ArvDomNodeChildListClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvDomNodeChildListClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvDomNodeChildListClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvDomNodeChildList, arv_dom_node_child_list, ARV, DOM_NODE_CHILD_LIST, ArvDomNodeList);
```
"""
function glib_listautoptr_cleanup_ArvDomNodeChildListClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvDomNodeChildListClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvDomNodeChildListClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvDomNodeChildList, arv_dom_node_child_list, ARV, DOM_NODE_CHILD_LIST, ArvDomNodeList);
```
"""
function glib_slistautoptr_cleanup_ArvDomNodeChildListClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvDomNodeChildListClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvDomNodeChildListClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvDomNodeChildList, arv_dom_node_child_list, ARV, DOM_NODE_CHILD_LIST, ArvDomNodeList);
```
"""
function glib_queueautoptr_cleanup_ArvDomNodeChildListClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvDomNodeChildListClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_DOM_NODE_CHILD_LIST(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvDomNodeChildList, arv_dom_node_child_list, ARV, DOM_NODE_CHILD_LIST, ArvDomNodeList);
```
"""
function ARV_DOM_NODE_CHILD_LIST(ptr)
    @ccall libaravis.ARV_DOM_NODE_CHILD_LIST(ptr::gpointer)::Ptr{ArvDomNodeChildList}
end

"""
    ARV_IS_DOM_NODE_CHILD_LIST(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvDomNodeChildList, arv_dom_node_child_list, ARV, DOM_NODE_CHILD_LIST, ArvDomNodeList);
```
"""
function ARV_IS_DOM_NODE_CHILD_LIST(ptr)
    @ccall libaravis.ARV_IS_DOM_NODE_CHILD_LIST(ptr::gpointer)::gboolean
end

"""
    arv_dom_node_child_list_new(parent_node)

### Prototype
```c
ARV_API ArvDomNodeList * arv_dom_node_child_list_new (ArvDomNode *parent_node);
```
"""
function arv_dom_node_child_list_new(parent_node)
    @ccall libaravis.arv_dom_node_child_list_new(parent_node::Ptr{ArvDomNode})::Ptr{ArvDomNodeList}
end

"""
    arv_dom_document_append_from_memory(document, node, buffer, size, error)

### Prototype
```c
ARV_API void arv_dom_document_append_from_memory (ArvDomDocument *document, ArvDomNode *node, const void *buffer, int size, GError **error);
```
"""
function arv_dom_document_append_from_memory(document, node, buffer, size, error)
    @ccall libaravis.arv_dom_document_append_from_memory(document::Ptr{ArvDomDocument}, node::Ptr{ArvDomNode}, buffer::Ptr{Cvoid}, size::Cint, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_dom_document_new_from_memory(buffer, size, error)

### Prototype
```c
ARV_API ArvDomDocument * arv_dom_document_new_from_memory (const void *buffer, int size, GError **error);
```
"""
function arv_dom_document_new_from_memory(buffer, size, error)
    @ccall libaravis.arv_dom_document_new_from_memory(buffer::Ptr{Cvoid}, size::Cint, error::Ptr{Ptr{GError}})::Ptr{ArvDomDocument}
end

"""
    arv_dom_document_new_from_path(path, error)

### Prototype
```c
ARV_API ArvDomDocument * arv_dom_document_new_from_path (const char *path, GError **error);
```
"""
function arv_dom_document_new_from_path(path, error)
    @ccall libaravis.arv_dom_document_new_from_path(path::Cstring, error::Ptr{Ptr{GError}})::Ptr{ArvDomDocument}
end

"""
    arv_dom_document_new_from_url(url, error)

### Prototype
```c
ARV_API ArvDomDocument * arv_dom_document_new_from_url (const char *url, GError **error);
```
"""
function arv_dom_document_new_from_url(url, error)
    @ccall libaravis.arv_dom_document_new_from_url(url::Cstring, error::Ptr{Ptr{GError}})::Ptr{ArvDomDocument}
end

struct _ArvDomTextClass
    parent_class::ArvDomCharacterDataClass
end

const ArvDomTextClass = _ArvDomTextClass

const ArvDomText_autoptr = Ptr{ArvDomText}

const ArvDomText_listautoptr = Ptr{GList}

const ArvDomText_slistautoptr = Ptr{GSList}

const ArvDomText_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvDomText(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomText, arv_dom_text, ARV, DOM_TEXT, ArvDomCharacterData);
```
"""
function glib_autoptr_clear_ArvDomText(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvDomText(_ptr::Ptr{ArvDomText})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvDomText(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomText, arv_dom_text, ARV, DOM_TEXT, ArvDomCharacterData);
```
"""
function glib_autoptr_cleanup_ArvDomText(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvDomText(_ptr::Ptr{Ptr{ArvDomText}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvDomText(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomText, arv_dom_text, ARV, DOM_TEXT, ArvDomCharacterData);
```
"""
function glib_autoptr_destroy_ArvDomText(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvDomText(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvDomText(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomText, arv_dom_text, ARV, DOM_TEXT, ArvDomCharacterData);
```
"""
function glib_listautoptr_cleanup_ArvDomText(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvDomText(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvDomText(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomText, arv_dom_text, ARV, DOM_TEXT, ArvDomCharacterData);
```
"""
function glib_slistautoptr_cleanup_ArvDomText(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvDomText(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvDomText(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomText, arv_dom_text, ARV, DOM_TEXT, ArvDomCharacterData);
```
"""
function glib_queueautoptr_cleanup_ArvDomText(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvDomText(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvDomTextClass_autoptr = Ptr{ArvDomTextClass}

const ArvDomTextClass_listautoptr = Ptr{GList}

const ArvDomTextClass_slistautoptr = Ptr{GSList}

const ArvDomTextClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvDomTextClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomText, arv_dom_text, ARV, DOM_TEXT, ArvDomCharacterData);
```
"""
function glib_autoptr_clear_ArvDomTextClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvDomTextClass(_ptr::Ptr{ArvDomTextClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvDomTextClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomText, arv_dom_text, ARV, DOM_TEXT, ArvDomCharacterData);
```
"""
function glib_autoptr_cleanup_ArvDomTextClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvDomTextClass(_ptr::Ptr{Ptr{ArvDomTextClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvDomTextClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomText, arv_dom_text, ARV, DOM_TEXT, ArvDomCharacterData);
```
"""
function glib_autoptr_destroy_ArvDomTextClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvDomTextClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvDomTextClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomText, arv_dom_text, ARV, DOM_TEXT, ArvDomCharacterData);
```
"""
function glib_listautoptr_cleanup_ArvDomTextClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvDomTextClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvDomTextClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomText, arv_dom_text, ARV, DOM_TEXT, ArvDomCharacterData);
```
"""
function glib_slistautoptr_cleanup_ArvDomTextClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvDomTextClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvDomTextClass(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomText, arv_dom_text, ARV, DOM_TEXT, ArvDomCharacterData);
```
"""
function glib_queueautoptr_cleanup_ArvDomTextClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvDomTextClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_DOM_TEXT(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomText, arv_dom_text, ARV, DOM_TEXT, ArvDomCharacterData);
```
"""
function ARV_DOM_TEXT(ptr)
    @ccall libaravis.ARV_DOM_TEXT(ptr::gpointer)::Ptr{ArvDomText}
end

"""
    ARV_DOM_TEXT_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomText, arv_dom_text, ARV, DOM_TEXT, ArvDomCharacterData);
```
"""
function ARV_DOM_TEXT_CLASS(ptr)
    @ccall libaravis.ARV_DOM_TEXT_CLASS(ptr::gpointer)::Ptr{ArvDomTextClass}
end

"""
    ARV_IS_DOM_TEXT(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomText, arv_dom_text, ARV, DOM_TEXT, ArvDomCharacterData);
```
"""
function ARV_IS_DOM_TEXT(ptr)
    @ccall libaravis.ARV_IS_DOM_TEXT(ptr::gpointer)::gboolean
end

"""
    ARV_IS_DOM_TEXT_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomText, arv_dom_text, ARV, DOM_TEXT, ArvDomCharacterData);
```
"""
function ARV_IS_DOM_TEXT_CLASS(ptr)
    @ccall libaravis.ARV_IS_DOM_TEXT_CLASS(ptr::gpointer)::gboolean
end

"""
    ARV_DOM_TEXT_GET_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvDomText, arv_dom_text, ARV, DOM_TEXT, ArvDomCharacterData);
```
"""
function ARV_DOM_TEXT_GET_CLASS(ptr)
    @ccall libaravis.ARV_DOM_TEXT_GET_CLASS(ptr::gpointer)::Ptr{ArvDomTextClass}
end

"""
    arv_dom_text_new(data)

### Prototype
```c
ARV_API ArvDomNode * arv_dom_text_new (const char *data);
```
"""
function arv_dom_text_new(data)
    @ccall libaravis.arv_dom_text_new(data::Cstring)::Ptr{ArvDomNode}
end

struct ArvEvaluatorClass
    parent_class::GObjectClass
end

const ArvEvaluator_autoptr = Ptr{ArvEvaluator}

const ArvEvaluator_listautoptr = Ptr{GList}

const ArvEvaluator_slistautoptr = Ptr{GSList}

const ArvEvaluator_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvEvaluator(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvEvaluator, arv_evaluator, ARV, EVALUATOR, GObject);
```
"""
function glib_autoptr_clear_ArvEvaluator(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvEvaluator(_ptr::Ptr{ArvEvaluator})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvEvaluator(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvEvaluator, arv_evaluator, ARV, EVALUATOR, GObject);
```
"""
function glib_autoptr_cleanup_ArvEvaluator(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvEvaluator(_ptr::Ptr{Ptr{ArvEvaluator}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvEvaluator(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvEvaluator, arv_evaluator, ARV, EVALUATOR, GObject);
```
"""
function glib_autoptr_destroy_ArvEvaluator(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvEvaluator(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvEvaluator(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvEvaluator, arv_evaluator, ARV, EVALUATOR, GObject);
```
"""
function glib_listautoptr_cleanup_ArvEvaluator(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvEvaluator(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvEvaluator(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvEvaluator, arv_evaluator, ARV, EVALUATOR, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvEvaluator(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvEvaluator(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvEvaluator(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvEvaluator, arv_evaluator, ARV, EVALUATOR, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvEvaluator(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvEvaluator(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvEvaluatorClass_autoptr = Ptr{ArvEvaluatorClass}

const ArvEvaluatorClass_listautoptr = Ptr{GList}

const ArvEvaluatorClass_slistautoptr = Ptr{GSList}

const ArvEvaluatorClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvEvaluatorClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvEvaluator, arv_evaluator, ARV, EVALUATOR, GObject);
```
"""
function glib_autoptr_clear_ArvEvaluatorClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvEvaluatorClass(_ptr::Ptr{ArvEvaluatorClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvEvaluatorClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvEvaluator, arv_evaluator, ARV, EVALUATOR, GObject);
```
"""
function glib_autoptr_cleanup_ArvEvaluatorClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvEvaluatorClass(_ptr::Ptr{Ptr{ArvEvaluatorClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvEvaluatorClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvEvaluator, arv_evaluator, ARV, EVALUATOR, GObject);
```
"""
function glib_autoptr_destroy_ArvEvaluatorClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvEvaluatorClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvEvaluatorClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvEvaluator, arv_evaluator, ARV, EVALUATOR, GObject);
```
"""
function glib_listautoptr_cleanup_ArvEvaluatorClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvEvaluatorClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvEvaluatorClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvEvaluator, arv_evaluator, ARV, EVALUATOR, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvEvaluatorClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvEvaluatorClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvEvaluatorClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvEvaluator, arv_evaluator, ARV, EVALUATOR, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvEvaluatorClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvEvaluatorClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_EVALUATOR(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvEvaluator, arv_evaluator, ARV, EVALUATOR, GObject);
```
"""
function ARV_EVALUATOR(ptr)
    @ccall libaravis.ARV_EVALUATOR(ptr::gpointer)::Ptr{ArvEvaluator}
end

"""
    ARV_IS_EVALUATOR(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvEvaluator, arv_evaluator, ARV, EVALUATOR, GObject);
```
"""
function ARV_IS_EVALUATOR(ptr)
    @ccall libaravis.ARV_IS_EVALUATOR(ptr::gpointer)::gboolean
end

"""
    arv_evaluator_new(expression)

### Prototype
```c
ARV_API ArvEvaluator * arv_evaluator_new (const char *expression);
```
"""
function arv_evaluator_new(expression)
    @ccall libaravis.arv_evaluator_new(expression::Cstring)::Ptr{ArvEvaluator}
end

"""
    arv_evaluator_set_expression(evaluator, expression)

### Prototype
```c
ARV_API void arv_evaluator_set_expression (ArvEvaluator *evaluator, const char *expression);
```
"""
function arv_evaluator_set_expression(evaluator, expression)
    @ccall libaravis.arv_evaluator_set_expression(evaluator::Ptr{ArvEvaluator}, expression::Cstring)::Cvoid
end

"""
    arv_evaluator_get_expression(evaluator)

### Prototype
```c
ARV_API const char * arv_evaluator_get_expression (ArvEvaluator *evaluator);
```
"""
function arv_evaluator_get_expression(evaluator)
    @ccall libaravis.arv_evaluator_get_expression(evaluator::Ptr{ArvEvaluator})::Cstring
end

"""
    arv_evaluator_set_sub_expression(evaluator, name, expression)

### Prototype
```c
ARV_API void arv_evaluator_set_sub_expression (ArvEvaluator *evaluator, const char *name, const char *expression);
```
"""
function arv_evaluator_set_sub_expression(evaluator, name, expression)
    @ccall libaravis.arv_evaluator_set_sub_expression(evaluator::Ptr{ArvEvaluator}, name::Cstring, expression::Cstring)::Cvoid
end

"""
    arv_evaluator_get_sub_expression(evaluator, name)

### Prototype
```c
ARV_API const char * arv_evaluator_get_sub_expression (ArvEvaluator *evaluator, const char *name);
```
"""
function arv_evaluator_get_sub_expression(evaluator, name)
    @ccall libaravis.arv_evaluator_get_sub_expression(evaluator::Ptr{ArvEvaluator}, name::Cstring)::Cstring
end

"""
    arv_evaluator_set_constant(evaluator, name, constant)

### Prototype
```c
ARV_API void arv_evaluator_set_constant (ArvEvaluator *evaluator, const char *name, const char *constant);
```
"""
function arv_evaluator_set_constant(evaluator, name, constant)
    @ccall libaravis.arv_evaluator_set_constant(evaluator::Ptr{ArvEvaluator}, name::Cstring, constant::Cstring)::Cvoid
end

"""
    arv_evaluator_get_constant(evaluator, name)

### Prototype
```c
ARV_API const char * arv_evaluator_get_constant (ArvEvaluator *evaluator, const char *name);
```
"""
function arv_evaluator_get_constant(evaluator, name)
    @ccall libaravis.arv_evaluator_get_constant(evaluator::Ptr{ArvEvaluator}, name::Cstring)::Cstring
end

"""
    arv_evaluator_evaluate_as_double(evaluator, error)

### Prototype
```c
ARV_API double arv_evaluator_evaluate_as_double (ArvEvaluator *evaluator, GError **error);
```
"""
function arv_evaluator_evaluate_as_double(evaluator, error)
    @ccall libaravis.arv_evaluator_evaluate_as_double(evaluator::Ptr{ArvEvaluator}, error::Ptr{Ptr{GError}})::Cdouble
end

"""
    arv_evaluator_evaluate_as_int64(evaluator, error)

### Prototype
```c
ARV_API gint64 arv_evaluator_evaluate_as_int64 (ArvEvaluator *evaluator, GError **error);
```
"""
function arv_evaluator_evaluate_as_int64(evaluator, error)
    @ccall libaravis.arv_evaluator_evaluate_as_int64(evaluator::Ptr{ArvEvaluator}, error::Ptr{Ptr{GError}})::gint64
end

"""
    arv_evaluator_set_double_variable(evaluator, name, v_double)

### Prototype
```c
ARV_API void arv_evaluator_set_double_variable (ArvEvaluator *evaluator, const char *name, double v_double);
```
"""
function arv_evaluator_set_double_variable(evaluator, name, v_double)
    @ccall libaravis.arv_evaluator_set_double_variable(evaluator::Ptr{ArvEvaluator}, name::Cstring, v_double::Cdouble)::Cvoid
end

"""
    arv_evaluator_set_int64_variable(evaluator, name, v_int64)

### Prototype
```c
ARV_API void arv_evaluator_set_int64_variable (ArvEvaluator *evaluator, const char *name, gint64 v_int64);
```
"""
function arv_evaluator_set_int64_variable(evaluator, name, v_int64)
    @ccall libaravis.arv_evaluator_set_int64_variable(evaluator::Ptr{ArvEvaluator}, name::Cstring, v_int64::gint64)::Cvoid
end

"""
    arv_set_fake_camera_genicam_filename(filename)

### Prototype
```c
ARV_API void arv_set_fake_camera_genicam_filename (const char *filename);
```
"""
function arv_set_fake_camera_genicam_filename(filename)
    @ccall libaravis.arv_set_fake_camera_genicam_filename(filename::Cstring)::Cvoid
end

struct ArvFakeCameraClass
    parent_class::GObjectClass
end

const ArvFakeCamera_autoptr = Ptr{ArvFakeCamera}

const ArvFakeCamera_listautoptr = Ptr{GList}

const ArvFakeCamera_slistautoptr = Ptr{GSList}

const ArvFakeCamera_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvFakeCamera(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeCamera, arv_fake_camera, ARV, FAKE_CAMERA, GObject);
```
"""
function glib_autoptr_clear_ArvFakeCamera(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvFakeCamera(_ptr::Ptr{ArvFakeCamera})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvFakeCamera(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeCamera, arv_fake_camera, ARV, FAKE_CAMERA, GObject);
```
"""
function glib_autoptr_cleanup_ArvFakeCamera(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvFakeCamera(_ptr::Ptr{Ptr{ArvFakeCamera}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvFakeCamera(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeCamera, arv_fake_camera, ARV, FAKE_CAMERA, GObject);
```
"""
function glib_autoptr_destroy_ArvFakeCamera(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvFakeCamera(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvFakeCamera(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeCamera, arv_fake_camera, ARV, FAKE_CAMERA, GObject);
```
"""
function glib_listautoptr_cleanup_ArvFakeCamera(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvFakeCamera(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvFakeCamera(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeCamera, arv_fake_camera, ARV, FAKE_CAMERA, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvFakeCamera(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvFakeCamera(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvFakeCamera(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeCamera, arv_fake_camera, ARV, FAKE_CAMERA, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvFakeCamera(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvFakeCamera(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvFakeCameraClass_autoptr = Ptr{ArvFakeCameraClass}

const ArvFakeCameraClass_listautoptr = Ptr{GList}

const ArvFakeCameraClass_slistautoptr = Ptr{GSList}

const ArvFakeCameraClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvFakeCameraClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeCamera, arv_fake_camera, ARV, FAKE_CAMERA, GObject);
```
"""
function glib_autoptr_clear_ArvFakeCameraClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvFakeCameraClass(_ptr::Ptr{ArvFakeCameraClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvFakeCameraClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeCamera, arv_fake_camera, ARV, FAKE_CAMERA, GObject);
```
"""
function glib_autoptr_cleanup_ArvFakeCameraClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvFakeCameraClass(_ptr::Ptr{Ptr{ArvFakeCameraClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvFakeCameraClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeCamera, arv_fake_camera, ARV, FAKE_CAMERA, GObject);
```
"""
function glib_autoptr_destroy_ArvFakeCameraClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvFakeCameraClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvFakeCameraClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeCamera, arv_fake_camera, ARV, FAKE_CAMERA, GObject);
```
"""
function glib_listautoptr_cleanup_ArvFakeCameraClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvFakeCameraClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvFakeCameraClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeCamera, arv_fake_camera, ARV, FAKE_CAMERA, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvFakeCameraClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvFakeCameraClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvFakeCameraClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeCamera, arv_fake_camera, ARV, FAKE_CAMERA, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvFakeCameraClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvFakeCameraClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_FAKE_CAMERA(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeCamera, arv_fake_camera, ARV, FAKE_CAMERA, GObject);
```
"""
function ARV_FAKE_CAMERA(ptr)
    @ccall libaravis.ARV_FAKE_CAMERA(ptr::gpointer)::Ptr{ArvFakeCamera}
end

"""
    ARV_IS_FAKE_CAMERA(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeCamera, arv_fake_camera, ARV, FAKE_CAMERA, GObject);
```
"""
function ARV_IS_FAKE_CAMERA(ptr)
    @ccall libaravis.ARV_IS_FAKE_CAMERA(ptr::gpointer)::gboolean
end

# typedef void ( * ArvFakeCameraFillPattern ) ( ArvBuffer * buffer , void * fill_pattern_data , guint32 exposure_time_us , guint32 gain , ArvPixelFormat pixel_format )
const ArvFakeCameraFillPattern = Ptr{Cvoid}

"""
    arv_fake_camera_new(serial_number)

### Prototype
```c
ARV_API ArvFakeCamera * arv_fake_camera_new (const char *serial_number);
```
"""
function arv_fake_camera_new(serial_number)
    @ccall libaravis.arv_fake_camera_new(serial_number::Cstring)::Ptr{ArvFakeCamera}
end

"""
    arv_fake_camera_new_full(serial_number, genicam_filename)

### Prototype
```c
ARV_API ArvFakeCamera * arv_fake_camera_new_full (const char *serial_number, const char *genicam_filename);
```
"""
function arv_fake_camera_new_full(serial_number, genicam_filename)
    @ccall libaravis.arv_fake_camera_new_full(serial_number::Cstring, genicam_filename::Cstring)::Ptr{ArvFakeCamera}
end

"""
    arv_fake_camera_read_memory(camera, address, size, buffer)

### Prototype
```c
ARV_API gboolean arv_fake_camera_read_memory (ArvFakeCamera *camera, guint32 address, guint32 size, void *buffer);
```
"""
function arv_fake_camera_read_memory(camera, address, size, buffer)
    @ccall libaravis.arv_fake_camera_read_memory(camera::Ptr{ArvFakeCamera}, address::guint32, size::guint32, buffer::Ptr{Cvoid})::gboolean
end

"""
    arv_fake_camera_write_memory(camera, address, size, buffer)

### Prototype
```c
ARV_API gboolean arv_fake_camera_write_memory (ArvFakeCamera *camera, guint32 address, guint32 size, const void *buffer);
```
"""
function arv_fake_camera_write_memory(camera, address, size, buffer)
    @ccall libaravis.arv_fake_camera_write_memory(camera::Ptr{ArvFakeCamera}, address::guint32, size::guint32, buffer::Ptr{Cvoid})::gboolean
end

"""
    arv_fake_camera_read_register(camera, address, value)

### Prototype
```c
ARV_API gboolean arv_fake_camera_read_register (ArvFakeCamera *camera, guint32 address, guint32 *value);
```
"""
function arv_fake_camera_read_register(camera, address, value)
    @ccall libaravis.arv_fake_camera_read_register(camera::Ptr{ArvFakeCamera}, address::guint32, value::Ptr{guint32})::gboolean
end

"""
    arv_fake_camera_write_register(camera, address, value)

### Prototype
```c
ARV_API gboolean arv_fake_camera_write_register (ArvFakeCamera *camera, guint32 address, guint32 value);
```
"""
function arv_fake_camera_write_register(camera, address, value)
    @ccall libaravis.arv_fake_camera_write_register(camera::Ptr{ArvFakeCamera}, address::guint32, value::guint32)::gboolean
end

"""
    arv_fake_camera_get_payload(camera)

### Prototype
```c
ARV_API size_t arv_fake_camera_get_payload (ArvFakeCamera *camera);
```
"""
function arv_fake_camera_get_payload(camera)
    @ccall libaravis.arv_fake_camera_get_payload(camera::Ptr{ArvFakeCamera})::Csize_t
end

"""
    arv_fake_camera_wait_for_next_frame(camera)

### Prototype
```c
ARV_API void arv_fake_camera_wait_for_next_frame (ArvFakeCamera *camera);
```
"""
function arv_fake_camera_wait_for_next_frame(camera)
    @ccall libaravis.arv_fake_camera_wait_for_next_frame(camera::Ptr{ArvFakeCamera})::Cvoid
end

"""
    arv_fake_camera_get_sleep_time_for_next_frame(camera, next_timestamp_us)

### Prototype
```c
ARV_API guint64 arv_fake_camera_get_sleep_time_for_next_frame (ArvFakeCamera *camera, guint64 *next_timestamp_us);
```
"""
function arv_fake_camera_get_sleep_time_for_next_frame(camera, next_timestamp_us)
    @ccall libaravis.arv_fake_camera_get_sleep_time_for_next_frame(camera::Ptr{ArvFakeCamera}, next_timestamp_us::Ptr{guint64})::guint64
end

"""
    arv_fake_camera_fill_buffer(camera, buffer, packet_size)

### Prototype
```c
ARV_API void arv_fake_camera_fill_buffer (ArvFakeCamera *camera, ArvBuffer *buffer, guint32 *packet_size);
```
"""
function arv_fake_camera_fill_buffer(camera, buffer, packet_size)
    @ccall libaravis.arv_fake_camera_fill_buffer(camera::Ptr{ArvFakeCamera}, buffer::Ptr{ArvBuffer}, packet_size::Ptr{guint32})::Cvoid
end

"""
    arv_fake_camera_get_acquisition_status(camera)

### Prototype
```c
ARV_API guint32 arv_fake_camera_get_acquisition_status (ArvFakeCamera *camera);
```
"""
function arv_fake_camera_get_acquisition_status(camera)
    @ccall libaravis.arv_fake_camera_get_acquisition_status(camera::Ptr{ArvFakeCamera})::guint32
end

"""
    arv_fake_camera_get_stream_address(camera)

### Prototype
```c
ARV_API GSocketAddress * arv_fake_camera_get_stream_address (ArvFakeCamera *camera);
```
"""
function arv_fake_camera_get_stream_address(camera)
    @ccall libaravis.arv_fake_camera_get_stream_address(camera::Ptr{ArvFakeCamera})::Ptr{GSocketAddress}
end

"""
    arv_fake_camera_set_inet_address(camera, address)

### Prototype
```c
ARV_API void arv_fake_camera_set_inet_address (ArvFakeCamera *camera, GInetAddress *address);
```
"""
function arv_fake_camera_set_inet_address(camera, address)
    @ccall libaravis.arv_fake_camera_set_inet_address(camera::Ptr{ArvFakeCamera}, address::Ptr{GInetAddress})::Cvoid
end

"""
    arv_fake_camera_get_control_channel_privilege(camera)

### Prototype
```c
ARV_API guint32 arv_fake_camera_get_control_channel_privilege (ArvFakeCamera *camera);
```
"""
function arv_fake_camera_get_control_channel_privilege(camera)
    @ccall libaravis.arv_fake_camera_get_control_channel_privilege(camera::Ptr{ArvFakeCamera})::guint32
end

"""
    arv_fake_camera_set_control_channel_privilege(camera, privilege)

### Prototype
```c
ARV_API void arv_fake_camera_set_control_channel_privilege (ArvFakeCamera *camera, guint32 privilege);
```
"""
function arv_fake_camera_set_control_channel_privilege(camera, privilege)
    @ccall libaravis.arv_fake_camera_set_control_channel_privilege(camera::Ptr{ArvFakeCamera}, privilege::guint32)::Cvoid
end

"""
    arv_fake_camera_get_heartbeat_timeout(camera)

### Prototype
```c
ARV_API guint32 arv_fake_camera_get_heartbeat_timeout (ArvFakeCamera *camera);
```
"""
function arv_fake_camera_get_heartbeat_timeout(camera)
    @ccall libaravis.arv_fake_camera_get_heartbeat_timeout(camera::Ptr{ArvFakeCamera})::guint32
end

"""
    arv_fake_camera_set_fill_pattern(camera, fill_pattern_callback, fill_pattern_data)

### Prototype
```c
ARV_API void arv_fake_camera_set_fill_pattern (ArvFakeCamera *camera, ArvFakeCameraFillPattern fill_pattern_callback, void *fill_pattern_data);
```
"""
function arv_fake_camera_set_fill_pattern(camera, fill_pattern_callback, fill_pattern_data)
    @ccall libaravis.arv_fake_camera_set_fill_pattern(camera::Ptr{ArvFakeCamera}, fill_pattern_callback::ArvFakeCameraFillPattern, fill_pattern_data::Ptr{Cvoid})::Cvoid
end

"""
    arv_fake_camera_set_trigger_frequency(camera, frequency)

### Prototype
```c
ARV_API void arv_fake_camera_set_trigger_frequency (ArvFakeCamera *camera, double frequency);
```
"""
function arv_fake_camera_set_trigger_frequency(camera, frequency)
    @ccall libaravis.arv_fake_camera_set_trigger_frequency(camera::Ptr{ArvFakeCamera}, frequency::Cdouble)::Cvoid
end

"""
    arv_fake_camera_is_in_free_running_mode(camera)

### Prototype
```c
ARV_API gboolean arv_fake_camera_is_in_free_running_mode (ArvFakeCamera *camera);
```
"""
function arv_fake_camera_is_in_free_running_mode(camera)
    @ccall libaravis.arv_fake_camera_is_in_free_running_mode(camera::Ptr{ArvFakeCamera})::gboolean
end

"""
    arv_fake_camera_is_in_software_trigger_mode(camera)

### Prototype
```c
ARV_API gboolean arv_fake_camera_is_in_software_trigger_mode (ArvFakeCamera *camera);
```
"""
function arv_fake_camera_is_in_software_trigger_mode(camera)
    @ccall libaravis.arv_fake_camera_is_in_software_trigger_mode(camera::Ptr{ArvFakeCamera})::gboolean
end

"""
    arv_fake_camera_check_and_acknowledge_software_trigger(camera)

### Prototype
```c
ARV_API gboolean arv_fake_camera_check_and_acknowledge_software_trigger (ArvFakeCamera *camera);
```
"""
function arv_fake_camera_check_and_acknowledge_software_trigger(camera)
    @ccall libaravis.arv_fake_camera_check_and_acknowledge_software_trigger(camera::Ptr{ArvFakeCamera})::gboolean
end

"""
    arv_fake_camera_get_genicam_xml(camera, size)

### Prototype
```c
ARV_API const char * arv_fake_camera_get_genicam_xml (ArvFakeCamera *camera, size_t *size);
```
"""
function arv_fake_camera_get_genicam_xml(camera, size)
    @ccall libaravis.arv_fake_camera_get_genicam_xml(camera::Ptr{ArvFakeCamera}, size::Ptr{Csize_t})::Cstring
end

"""
    arv_fake_camera_get_genicam_xml_url(camera)

### Prototype
```c
ARV_API const char * arv_fake_camera_get_genicam_xml_url (ArvFakeCamera *camera);
```
"""
function arv_fake_camera_get_genicam_xml_url(camera)
    @ccall libaravis.arv_fake_camera_get_genicam_xml_url(camera::Ptr{ArvFakeCamera})::Cstring
end

const _ArvFakeDevice = Cvoid

const ArvFakeDevice = _ArvFakeDevice

struct ArvFakeDeviceClass
    parent_class::ArvDeviceClass
end

const ArvFakeDevice_autoptr = Ptr{ArvFakeDevice}

const ArvFakeDevice_listautoptr = Ptr{GList}

const ArvFakeDevice_slistautoptr = Ptr{GSList}

const ArvFakeDevice_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvFakeDevice(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeDevice, arv_fake_device, ARV, FAKE_DEVICE, ArvDevice);
```
"""
function glib_autoptr_clear_ArvFakeDevice(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvFakeDevice(_ptr::Ptr{ArvFakeDevice})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvFakeDevice(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeDevice, arv_fake_device, ARV, FAKE_DEVICE, ArvDevice);
```
"""
function glib_autoptr_cleanup_ArvFakeDevice(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvFakeDevice(_ptr::Ptr{Ptr{ArvFakeDevice}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvFakeDevice(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeDevice, arv_fake_device, ARV, FAKE_DEVICE, ArvDevice);
```
"""
function glib_autoptr_destroy_ArvFakeDevice(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvFakeDevice(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvFakeDevice(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeDevice, arv_fake_device, ARV, FAKE_DEVICE, ArvDevice);
```
"""
function glib_listautoptr_cleanup_ArvFakeDevice(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvFakeDevice(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvFakeDevice(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeDevice, arv_fake_device, ARV, FAKE_DEVICE, ArvDevice);
```
"""
function glib_slistautoptr_cleanup_ArvFakeDevice(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvFakeDevice(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvFakeDevice(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeDevice, arv_fake_device, ARV, FAKE_DEVICE, ArvDevice);
```
"""
function glib_queueautoptr_cleanup_ArvFakeDevice(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvFakeDevice(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvFakeDeviceClass_autoptr = Ptr{ArvFakeDeviceClass}

const ArvFakeDeviceClass_listautoptr = Ptr{GList}

const ArvFakeDeviceClass_slistautoptr = Ptr{GSList}

const ArvFakeDeviceClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvFakeDeviceClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeDevice, arv_fake_device, ARV, FAKE_DEVICE, ArvDevice);
```
"""
function glib_autoptr_clear_ArvFakeDeviceClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvFakeDeviceClass(_ptr::Ptr{ArvFakeDeviceClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvFakeDeviceClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeDevice, arv_fake_device, ARV, FAKE_DEVICE, ArvDevice);
```
"""
function glib_autoptr_cleanup_ArvFakeDeviceClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvFakeDeviceClass(_ptr::Ptr{Ptr{ArvFakeDeviceClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvFakeDeviceClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeDevice, arv_fake_device, ARV, FAKE_DEVICE, ArvDevice);
```
"""
function glib_autoptr_destroy_ArvFakeDeviceClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvFakeDeviceClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvFakeDeviceClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeDevice, arv_fake_device, ARV, FAKE_DEVICE, ArvDevice);
```
"""
function glib_listautoptr_cleanup_ArvFakeDeviceClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvFakeDeviceClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvFakeDeviceClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeDevice, arv_fake_device, ARV, FAKE_DEVICE, ArvDevice);
```
"""
function glib_slistautoptr_cleanup_ArvFakeDeviceClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvFakeDeviceClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvFakeDeviceClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeDevice, arv_fake_device, ARV, FAKE_DEVICE, ArvDevice);
```
"""
function glib_queueautoptr_cleanup_ArvFakeDeviceClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvFakeDeviceClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_FAKE_DEVICE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeDevice, arv_fake_device, ARV, FAKE_DEVICE, ArvDevice);
```
"""
function ARV_FAKE_DEVICE(ptr)
    @ccall libaravis.ARV_FAKE_DEVICE(ptr::gpointer)::Ptr{ArvFakeDevice}
end

"""
    ARV_IS_FAKE_DEVICE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeDevice, arv_fake_device, ARV, FAKE_DEVICE, ArvDevice);
```
"""
function ARV_IS_FAKE_DEVICE(ptr)
    @ccall libaravis.ARV_IS_FAKE_DEVICE(ptr::gpointer)::gboolean
end

"""
    arv_fake_device_new(serial_number, error)

### Prototype
```c
ARV_API ArvDevice * arv_fake_device_new (const char *serial_number, GError **error);
```
"""
function arv_fake_device_new(serial_number, error)
    @ccall libaravis.arv_fake_device_new(serial_number::Cstring, error::Ptr{Ptr{GError}})::Ptr{ArvDevice}
end

"""
    arv_fake_device_get_fake_camera(device)

### Prototype
```c
ARV_API ArvFakeCamera * arv_fake_device_get_fake_camera (ArvFakeDevice *device);
```
"""
function arv_fake_device_get_fake_camera(device)
    @ccall libaravis.arv_fake_device_get_fake_camera(device::Ptr{ArvFakeDevice})::Ptr{ArvFakeCamera}
end

struct _ArvInterfaceClass
    parent_class::GObjectClass
    update_device_list::Ptr{Cvoid}
    open_device::Ptr{Cvoid}
    protocol::Cstring
end

const ArvInterfaceClass = _ArvInterfaceClass

const ArvInterface_autoptr = Ptr{ArvInterface}

const ArvInterface_listautoptr = Ptr{GList}

const ArvInterface_slistautoptr = Ptr{GSList}

const ArvInterface_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvInterface(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvInterface, arv_interface, ARV, INTERFACE, GObject);
```
"""
function glib_autoptr_clear_ArvInterface(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvInterface(_ptr::Ptr{ArvInterface})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvInterface(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvInterface, arv_interface, ARV, INTERFACE, GObject);
```
"""
function glib_autoptr_cleanup_ArvInterface(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvInterface(_ptr::Ptr{Ptr{ArvInterface}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvInterface(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvInterface, arv_interface, ARV, INTERFACE, GObject);
```
"""
function glib_autoptr_destroy_ArvInterface(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvInterface(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvInterface(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvInterface, arv_interface, ARV, INTERFACE, GObject);
```
"""
function glib_listautoptr_cleanup_ArvInterface(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvInterface(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvInterface(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvInterface, arv_interface, ARV, INTERFACE, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvInterface(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvInterface(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvInterface(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvInterface, arv_interface, ARV, INTERFACE, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvInterface(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvInterface(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvInterfaceClass_autoptr = Ptr{ArvInterfaceClass}

const ArvInterfaceClass_listautoptr = Ptr{GList}

const ArvInterfaceClass_slistautoptr = Ptr{GSList}

const ArvInterfaceClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvInterfaceClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvInterface, arv_interface, ARV, INTERFACE, GObject);
```
"""
function glib_autoptr_clear_ArvInterfaceClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvInterfaceClass(_ptr::Ptr{ArvInterfaceClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvInterfaceClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvInterface, arv_interface, ARV, INTERFACE, GObject);
```
"""
function glib_autoptr_cleanup_ArvInterfaceClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvInterfaceClass(_ptr::Ptr{Ptr{ArvInterfaceClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvInterfaceClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvInterface, arv_interface, ARV, INTERFACE, GObject);
```
"""
function glib_autoptr_destroy_ArvInterfaceClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvInterfaceClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvInterfaceClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvInterface, arv_interface, ARV, INTERFACE, GObject);
```
"""
function glib_listautoptr_cleanup_ArvInterfaceClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvInterfaceClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvInterfaceClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvInterface, arv_interface, ARV, INTERFACE, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvInterfaceClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvInterfaceClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvInterfaceClass(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvInterface, arv_interface, ARV, INTERFACE, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvInterfaceClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvInterfaceClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_INTERFACE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvInterface, arv_interface, ARV, INTERFACE, GObject);
```
"""
function ARV_INTERFACE(ptr)
    @ccall libaravis.ARV_INTERFACE(ptr::gpointer)::Ptr{ArvInterface}
end

"""
    ARV_INTERFACE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvInterface, arv_interface, ARV, INTERFACE, GObject);
```
"""
function ARV_INTERFACE_CLASS(ptr)
    @ccall libaravis.ARV_INTERFACE_CLASS(ptr::gpointer)::Ptr{ArvInterfaceClass}
end

"""
    ARV_IS_INTERFACE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvInterface, arv_interface, ARV, INTERFACE, GObject);
```
"""
function ARV_IS_INTERFACE(ptr)
    @ccall libaravis.ARV_IS_INTERFACE(ptr::gpointer)::gboolean
end

"""
    ARV_IS_INTERFACE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvInterface, arv_interface, ARV, INTERFACE, GObject);
```
"""
function ARV_IS_INTERFACE_CLASS(ptr)
    @ccall libaravis.ARV_IS_INTERFACE_CLASS(ptr::gpointer)::gboolean
end

"""
    ARV_INTERFACE_GET_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvInterface, arv_interface, ARV, INTERFACE, GObject);
```
"""
function ARV_INTERFACE_GET_CLASS(ptr)
    @ccall libaravis.ARV_INTERFACE_GET_CLASS(ptr::gpointer)::Ptr{ArvInterfaceClass}
end

"""
    arv_interface_update_device_list(iface)

### Prototype
```c
ARV_API void arv_interface_update_device_list (ArvInterface *iface);
```
"""
function arv_interface_update_device_list(iface)
    @ccall libaravis.arv_interface_update_device_list(iface::Ptr{ArvInterface})::Cvoid
end

"""
    arv_interface_get_n_devices(iface)

### Prototype
```c
ARV_API unsigned int arv_interface_get_n_devices (ArvInterface *iface);
```
"""
function arv_interface_get_n_devices(iface)
    @ccall libaravis.arv_interface_get_n_devices(iface::Ptr{ArvInterface})::Cuint
end

"""
    arv_interface_get_device_id(iface, index)

### Prototype
```c
ARV_API const char * arv_interface_get_device_id (ArvInterface *iface, unsigned int index);
```
"""
function arv_interface_get_device_id(iface, index)
    @ccall libaravis.arv_interface_get_device_id(iface::Ptr{ArvInterface}, index::Cuint)::Cstring
end

"""
    arv_interface_get_device_physical_id(iface, index)

### Prototype
```c
ARV_API const char * arv_interface_get_device_physical_id (ArvInterface *iface, unsigned int index);
```
"""
function arv_interface_get_device_physical_id(iface, index)
    @ccall libaravis.arv_interface_get_device_physical_id(iface::Ptr{ArvInterface}, index::Cuint)::Cstring
end

"""
    arv_interface_get_device_address(iface, index)

### Prototype
```c
ARV_API const char * arv_interface_get_device_address (ArvInterface *iface, unsigned int index);
```
"""
function arv_interface_get_device_address(iface, index)
    @ccall libaravis.arv_interface_get_device_address(iface::Ptr{ArvInterface}, index::Cuint)::Cstring
end

"""
    arv_interface_get_device_vendor(iface, index)

### Prototype
```c
ARV_API const char * arv_interface_get_device_vendor (ArvInterface *iface, unsigned int index);
```
"""
function arv_interface_get_device_vendor(iface, index)
    @ccall libaravis.arv_interface_get_device_vendor(iface::Ptr{ArvInterface}, index::Cuint)::Cstring
end

"""
    arv_interface_get_device_manufacturer_info(iface, index)

### Prototype
```c
ARV_API const char * arv_interface_get_device_manufacturer_info (ArvInterface *iface, unsigned int index);
```
"""
function arv_interface_get_device_manufacturer_info(iface, index)
    @ccall libaravis.arv_interface_get_device_manufacturer_info(iface::Ptr{ArvInterface}, index::Cuint)::Cstring
end

"""
    arv_interface_get_device_model(iface, index)

### Prototype
```c
ARV_API const char * arv_interface_get_device_model (ArvInterface *iface, unsigned int index);
```
"""
function arv_interface_get_device_model(iface, index)
    @ccall libaravis.arv_interface_get_device_model(iface::Ptr{ArvInterface}, index::Cuint)::Cstring
end

"""
    arv_interface_get_device_serial_nbr(iface, index)

### Prototype
```c
ARV_API const char * arv_interface_get_device_serial_nbr (ArvInterface *iface, unsigned int index);
```
"""
function arv_interface_get_device_serial_nbr(iface, index)
    @ccall libaravis.arv_interface_get_device_serial_nbr(iface::Ptr{ArvInterface}, index::Cuint)::Cstring
end

"""
    arv_interface_get_device_protocol(iface, index)

### Prototype
```c
ARV_API const char * arv_interface_get_device_protocol (ArvInterface *iface, unsigned int index);
```
"""
function arv_interface_get_device_protocol(iface, index)
    @ccall libaravis.arv_interface_get_device_protocol(iface::Ptr{ArvInterface}, index::Cuint)::Cstring
end

"""
    arv_interface_open_device(iface, device_id, error)

### Prototype
```c
ARV_API ArvDevice * arv_interface_open_device (ArvInterface *iface, const char *device_id, GError **error);
```
"""
function arv_interface_open_device(iface, device_id, error)
    @ccall libaravis.arv_interface_open_device(iface::Ptr{ArvInterface}, device_id::Cstring, error::Ptr{Ptr{GError}})::Ptr{ArvDevice}
end

const _ArvFakeInterface = Cvoid

const ArvFakeInterface = _ArvFakeInterface

struct ArvFakeInterfaceClass
    parent_class::ArvInterfaceClass
end

const ArvFakeInterface_autoptr = Ptr{ArvFakeInterface}

const ArvFakeInterface_listautoptr = Ptr{GList}

const ArvFakeInterface_slistautoptr = Ptr{GSList}

const ArvFakeInterface_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvFakeInterface(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeInterface, arv_fake_interface, ARV, FAKE_INTERFACE, ArvInterface);
```
"""
function glib_autoptr_clear_ArvFakeInterface(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvFakeInterface(_ptr::Ptr{ArvFakeInterface})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvFakeInterface(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeInterface, arv_fake_interface, ARV, FAKE_INTERFACE, ArvInterface);
```
"""
function glib_autoptr_cleanup_ArvFakeInterface(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvFakeInterface(_ptr::Ptr{Ptr{ArvFakeInterface}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvFakeInterface(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeInterface, arv_fake_interface, ARV, FAKE_INTERFACE, ArvInterface);
```
"""
function glib_autoptr_destroy_ArvFakeInterface(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvFakeInterface(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvFakeInterface(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeInterface, arv_fake_interface, ARV, FAKE_INTERFACE, ArvInterface);
```
"""
function glib_listautoptr_cleanup_ArvFakeInterface(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvFakeInterface(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvFakeInterface(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeInterface, arv_fake_interface, ARV, FAKE_INTERFACE, ArvInterface);
```
"""
function glib_slistautoptr_cleanup_ArvFakeInterface(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvFakeInterface(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvFakeInterface(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeInterface, arv_fake_interface, ARV, FAKE_INTERFACE, ArvInterface);
```
"""
function glib_queueautoptr_cleanup_ArvFakeInterface(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvFakeInterface(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvFakeInterfaceClass_autoptr = Ptr{ArvFakeInterfaceClass}

const ArvFakeInterfaceClass_listautoptr = Ptr{GList}

const ArvFakeInterfaceClass_slistautoptr = Ptr{GSList}

const ArvFakeInterfaceClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvFakeInterfaceClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeInterface, arv_fake_interface, ARV, FAKE_INTERFACE, ArvInterface);
```
"""
function glib_autoptr_clear_ArvFakeInterfaceClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvFakeInterfaceClass(_ptr::Ptr{ArvFakeInterfaceClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvFakeInterfaceClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeInterface, arv_fake_interface, ARV, FAKE_INTERFACE, ArvInterface);
```
"""
function glib_autoptr_cleanup_ArvFakeInterfaceClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvFakeInterfaceClass(_ptr::Ptr{Ptr{ArvFakeInterfaceClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvFakeInterfaceClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeInterface, arv_fake_interface, ARV, FAKE_INTERFACE, ArvInterface);
```
"""
function glib_autoptr_destroy_ArvFakeInterfaceClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvFakeInterfaceClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvFakeInterfaceClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeInterface, arv_fake_interface, ARV, FAKE_INTERFACE, ArvInterface);
```
"""
function glib_listautoptr_cleanup_ArvFakeInterfaceClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvFakeInterfaceClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvFakeInterfaceClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeInterface, arv_fake_interface, ARV, FAKE_INTERFACE, ArvInterface);
```
"""
function glib_slistautoptr_cleanup_ArvFakeInterfaceClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvFakeInterfaceClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvFakeInterfaceClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeInterface, arv_fake_interface, ARV, FAKE_INTERFACE, ArvInterface);
```
"""
function glib_queueautoptr_cleanup_ArvFakeInterfaceClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvFakeInterfaceClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_FAKE_INTERFACE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeInterface, arv_fake_interface, ARV, FAKE_INTERFACE, ArvInterface);
```
"""
function ARV_FAKE_INTERFACE(ptr)
    @ccall libaravis.ARV_FAKE_INTERFACE(ptr::gpointer)::Ptr{ArvFakeInterface}
end

"""
    ARV_IS_FAKE_INTERFACE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeInterface, arv_fake_interface, ARV, FAKE_INTERFACE, ArvInterface);
```
"""
function ARV_IS_FAKE_INTERFACE(ptr)
    @ccall libaravis.ARV_IS_FAKE_INTERFACE(ptr::gpointer)::gboolean
end

"""
    arv_fake_interface_get_instance()

### Prototype
```c
ARV_API ArvInterface * arv_fake_interface_get_instance (void);
```
"""
function arv_fake_interface_get_instance()
    @ccall libaravis.arv_fake_interface_get_instance()::Ptr{ArvInterface}
end

const _ArvFakeStream = Cvoid

const ArvFakeStream = _ArvFakeStream

struct ArvFakeStreamClass
    parent_class::ArvStreamClass
end

const ArvFakeStream_autoptr = Ptr{ArvFakeStream}

const ArvFakeStream_listautoptr = Ptr{GList}

const ArvFakeStream_slistautoptr = Ptr{GSList}

const ArvFakeStream_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvFakeStream(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeStream, arv_fake_stream, ARV, FAKE_STREAM, ArvStream);
```
"""
function glib_autoptr_clear_ArvFakeStream(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvFakeStream(_ptr::Ptr{ArvFakeStream})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvFakeStream(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeStream, arv_fake_stream, ARV, FAKE_STREAM, ArvStream);
```
"""
function glib_autoptr_cleanup_ArvFakeStream(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvFakeStream(_ptr::Ptr{Ptr{ArvFakeStream}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvFakeStream(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeStream, arv_fake_stream, ARV, FAKE_STREAM, ArvStream);
```
"""
function glib_autoptr_destroy_ArvFakeStream(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvFakeStream(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvFakeStream(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeStream, arv_fake_stream, ARV, FAKE_STREAM, ArvStream);
```
"""
function glib_listautoptr_cleanup_ArvFakeStream(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvFakeStream(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvFakeStream(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeStream, arv_fake_stream, ARV, FAKE_STREAM, ArvStream);
```
"""
function glib_slistautoptr_cleanup_ArvFakeStream(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvFakeStream(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvFakeStream(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeStream, arv_fake_stream, ARV, FAKE_STREAM, ArvStream);
```
"""
function glib_queueautoptr_cleanup_ArvFakeStream(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvFakeStream(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvFakeStreamClass_autoptr = Ptr{ArvFakeStreamClass}

const ArvFakeStreamClass_listautoptr = Ptr{GList}

const ArvFakeStreamClass_slistautoptr = Ptr{GSList}

const ArvFakeStreamClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvFakeStreamClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeStream, arv_fake_stream, ARV, FAKE_STREAM, ArvStream);
```
"""
function glib_autoptr_clear_ArvFakeStreamClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvFakeStreamClass(_ptr::Ptr{ArvFakeStreamClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvFakeStreamClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeStream, arv_fake_stream, ARV, FAKE_STREAM, ArvStream);
```
"""
function glib_autoptr_cleanup_ArvFakeStreamClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvFakeStreamClass(_ptr::Ptr{Ptr{ArvFakeStreamClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvFakeStreamClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeStream, arv_fake_stream, ARV, FAKE_STREAM, ArvStream);
```
"""
function glib_autoptr_destroy_ArvFakeStreamClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvFakeStreamClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvFakeStreamClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeStream, arv_fake_stream, ARV, FAKE_STREAM, ArvStream);
```
"""
function glib_listautoptr_cleanup_ArvFakeStreamClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvFakeStreamClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvFakeStreamClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeStream, arv_fake_stream, ARV, FAKE_STREAM, ArvStream);
```
"""
function glib_slistautoptr_cleanup_ArvFakeStreamClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvFakeStreamClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvFakeStreamClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeStream, arv_fake_stream, ARV, FAKE_STREAM, ArvStream);
```
"""
function glib_queueautoptr_cleanup_ArvFakeStreamClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvFakeStreamClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_FAKE_STREAM(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeStream, arv_fake_stream, ARV, FAKE_STREAM, ArvStream);
```
"""
function ARV_FAKE_STREAM(ptr)
    @ccall libaravis.ARV_FAKE_STREAM(ptr::gpointer)::Ptr{ArvFakeStream}
end

"""
    ARV_IS_FAKE_STREAM(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvFakeStream, arv_fake_stream, ARV, FAKE_STREAM, ArvStream);
```
"""
function ARV_IS_FAKE_STREAM(ptr)
    @ccall libaravis.ARV_IS_FAKE_STREAM(ptr::gpointer)::gboolean
end

struct _ArvGcNodeClass
    parent_class::ArvDomElementClass
end

const ArvGcNodeClass = _ArvGcNodeClass

const ArvGcNode_autoptr = Ptr{ArvGcNode}

const ArvGcNode_listautoptr = Ptr{GList}

const ArvGcNode_slistautoptr = Ptr{GSList}

const ArvGcNode_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcNode, arv_gc_node, ARV, GC_NODE, ArvDomElement);
```
"""
function glib_autoptr_clear_ArvGcNode(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcNode(_ptr::Ptr{ArvGcNode})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcNode, arv_gc_node, ARV, GC_NODE, ArvDomElement);
```
"""
function glib_autoptr_cleanup_ArvGcNode(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcNode(_ptr::Ptr{Ptr{ArvGcNode}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcNode, arv_gc_node, ARV, GC_NODE, ArvDomElement);
```
"""
function glib_autoptr_destroy_ArvGcNode(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcNode(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcNode(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcNode, arv_gc_node, ARV, GC_NODE, ArvDomElement);
```
"""
function glib_listautoptr_cleanup_ArvGcNode(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcNode(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcNode(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcNode, arv_gc_node, ARV, GC_NODE, ArvDomElement);
```
"""
function glib_slistautoptr_cleanup_ArvGcNode(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcNode(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcNode(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcNode, arv_gc_node, ARV, GC_NODE, ArvDomElement);
```
"""
function glib_queueautoptr_cleanup_ArvGcNode(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcNode(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcNodeClass_autoptr = Ptr{ArvGcNodeClass}

const ArvGcNodeClass_listautoptr = Ptr{GList}

const ArvGcNodeClass_slistautoptr = Ptr{GSList}

const ArvGcNodeClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcNode, arv_gc_node, ARV, GC_NODE, ArvDomElement);
```
"""
function glib_autoptr_clear_ArvGcNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcNodeClass(_ptr::Ptr{ArvGcNodeClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcNode, arv_gc_node, ARV, GC_NODE, ArvDomElement);
```
"""
function glib_autoptr_cleanup_ArvGcNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcNodeClass(_ptr::Ptr{Ptr{ArvGcNodeClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcNode, arv_gc_node, ARV, GC_NODE, ArvDomElement);
```
"""
function glib_autoptr_destroy_ArvGcNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcNodeClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcNodeClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcNode, arv_gc_node, ARV, GC_NODE, ArvDomElement);
```
"""
function glib_listautoptr_cleanup_ArvGcNodeClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcNodeClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcNodeClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcNode, arv_gc_node, ARV, GC_NODE, ArvDomElement);
```
"""
function glib_slistautoptr_cleanup_ArvGcNodeClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcNodeClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcNodeClass(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcNode, arv_gc_node, ARV, GC_NODE, ArvDomElement);
```
"""
function glib_queueautoptr_cleanup_ArvGcNodeClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcNodeClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_NODE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcNode, arv_gc_node, ARV, GC_NODE, ArvDomElement);
```
"""
function ARV_GC_NODE(ptr)
    @ccall libaravis.ARV_GC_NODE(ptr::gpointer)::Ptr{ArvGcNode}
end

"""
    ARV_GC_NODE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcNode, arv_gc_node, ARV, GC_NODE, ArvDomElement);
```
"""
function ARV_GC_NODE_CLASS(ptr)
    @ccall libaravis.ARV_GC_NODE_CLASS(ptr::gpointer)::Ptr{ArvGcNodeClass}
end

"""
    ARV_IS_GC_NODE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcNode, arv_gc_node, ARV, GC_NODE, ArvDomElement);
```
"""
function ARV_IS_GC_NODE(ptr)
    @ccall libaravis.ARV_IS_GC_NODE(ptr::gpointer)::gboolean
end

"""
    ARV_IS_GC_NODE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcNode, arv_gc_node, ARV, GC_NODE, ArvDomElement);
```
"""
function ARV_IS_GC_NODE_CLASS(ptr)
    @ccall libaravis.ARV_IS_GC_NODE_CLASS(ptr::gpointer)::gboolean
end

"""
    ARV_GC_NODE_GET_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcNode, arv_gc_node, ARV, GC_NODE, ArvDomElement);
```
"""
function ARV_GC_NODE_GET_CLASS(ptr)
    @ccall libaravis.ARV_GC_NODE_GET_CLASS(ptr::gpointer)::Ptr{ArvGcNodeClass}
end

"""
    arv_gc_node_get_genicam(gc_node)

### Prototype
```c
ARV_API ArvGc * arv_gc_node_get_genicam (ArvGcNode *gc_node);
```
"""
function arv_gc_node_get_genicam(gc_node)
    @ccall libaravis.arv_gc_node_get_genicam(gc_node::Ptr{ArvGcNode})::Ptr{ArvGc}
end

struct _ArvGcFeatureNodeClass
    parent_class::ArvGcNodeClass
    get_linked_feature::Ptr{Cvoid}
    get_access_mode::Ptr{Cvoid}
    default_access_mode::ArvGcAccessMode
end

const ArvGcFeatureNodeClass = _ArvGcFeatureNodeClass

const ArvGcFeatureNode_autoptr = Ptr{ArvGcFeatureNode}

const ArvGcFeatureNode_listautoptr = Ptr{GList}

const ArvGcFeatureNode_slistautoptr = Ptr{GSList}

const ArvGcFeatureNode_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcFeatureNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFeatureNode, arv_gc_feature_node, ARV, GC_FEATURE_NODE, ArvGcNode);
```
"""
function glib_autoptr_clear_ArvGcFeatureNode(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcFeatureNode(_ptr::Ptr{ArvGcFeatureNode})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcFeatureNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFeatureNode, arv_gc_feature_node, ARV, GC_FEATURE_NODE, ArvGcNode);
```
"""
function glib_autoptr_cleanup_ArvGcFeatureNode(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcFeatureNode(_ptr::Ptr{Ptr{ArvGcFeatureNode}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcFeatureNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFeatureNode, arv_gc_feature_node, ARV, GC_FEATURE_NODE, ArvGcNode);
```
"""
function glib_autoptr_destroy_ArvGcFeatureNode(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcFeatureNode(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcFeatureNode(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFeatureNode, arv_gc_feature_node, ARV, GC_FEATURE_NODE, ArvGcNode);
```
"""
function glib_listautoptr_cleanup_ArvGcFeatureNode(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcFeatureNode(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcFeatureNode(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFeatureNode, arv_gc_feature_node, ARV, GC_FEATURE_NODE, ArvGcNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcFeatureNode(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcFeatureNode(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcFeatureNode(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFeatureNode, arv_gc_feature_node, ARV, GC_FEATURE_NODE, ArvGcNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcFeatureNode(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcFeatureNode(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcFeatureNodeClass_autoptr = Ptr{ArvGcFeatureNodeClass}

const ArvGcFeatureNodeClass_listautoptr = Ptr{GList}

const ArvGcFeatureNodeClass_slistautoptr = Ptr{GSList}

const ArvGcFeatureNodeClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcFeatureNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFeatureNode, arv_gc_feature_node, ARV, GC_FEATURE_NODE, ArvGcNode);
```
"""
function glib_autoptr_clear_ArvGcFeatureNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcFeatureNodeClass(_ptr::Ptr{ArvGcFeatureNodeClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcFeatureNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFeatureNode, arv_gc_feature_node, ARV, GC_FEATURE_NODE, ArvGcNode);
```
"""
function glib_autoptr_cleanup_ArvGcFeatureNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcFeatureNodeClass(_ptr::Ptr{Ptr{ArvGcFeatureNodeClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcFeatureNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFeatureNode, arv_gc_feature_node, ARV, GC_FEATURE_NODE, ArvGcNode);
```
"""
function glib_autoptr_destroy_ArvGcFeatureNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcFeatureNodeClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcFeatureNodeClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFeatureNode, arv_gc_feature_node, ARV, GC_FEATURE_NODE, ArvGcNode);
```
"""
function glib_listautoptr_cleanup_ArvGcFeatureNodeClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcFeatureNodeClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcFeatureNodeClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFeatureNode, arv_gc_feature_node, ARV, GC_FEATURE_NODE, ArvGcNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcFeatureNodeClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcFeatureNodeClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcFeatureNodeClass(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFeatureNode, arv_gc_feature_node, ARV, GC_FEATURE_NODE, ArvGcNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcFeatureNodeClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcFeatureNodeClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_FEATURE_NODE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFeatureNode, arv_gc_feature_node, ARV, GC_FEATURE_NODE, ArvGcNode);
```
"""
function ARV_GC_FEATURE_NODE(ptr)
    @ccall libaravis.ARV_GC_FEATURE_NODE(ptr::gpointer)::Ptr{ArvGcFeatureNode}
end

"""
    ARV_GC_FEATURE_NODE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFeatureNode, arv_gc_feature_node, ARV, GC_FEATURE_NODE, ArvGcNode);
```
"""
function ARV_GC_FEATURE_NODE_CLASS(ptr)
    @ccall libaravis.ARV_GC_FEATURE_NODE_CLASS(ptr::gpointer)::Ptr{ArvGcFeatureNodeClass}
end

"""
    ARV_IS_GC_FEATURE_NODE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFeatureNode, arv_gc_feature_node, ARV, GC_FEATURE_NODE, ArvGcNode);
```
"""
function ARV_IS_GC_FEATURE_NODE(ptr)
    @ccall libaravis.ARV_IS_GC_FEATURE_NODE(ptr::gpointer)::gboolean
end

"""
    ARV_IS_GC_FEATURE_NODE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFeatureNode, arv_gc_feature_node, ARV, GC_FEATURE_NODE, ArvGcNode);
```
"""
function ARV_IS_GC_FEATURE_NODE_CLASS(ptr)
    @ccall libaravis.ARV_IS_GC_FEATURE_NODE_CLASS(ptr::gpointer)::gboolean
end

"""
    ARV_GC_FEATURE_NODE_GET_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFeatureNode, arv_gc_feature_node, ARV, GC_FEATURE_NODE, ArvGcNode);
```
"""
function ARV_GC_FEATURE_NODE_GET_CLASS(ptr)
    @ccall libaravis.ARV_GC_FEATURE_NODE_GET_CLASS(ptr::gpointer)::Ptr{ArvGcFeatureNodeClass}
end

"""
    arv_gc_feature_node_get_name(gc_feature_node)

### Prototype
```c
ARV_API const char * arv_gc_feature_node_get_name (ArvGcFeatureNode *gc_feature_node);
```
"""
function arv_gc_feature_node_get_name(gc_feature_node)
    @ccall libaravis.arv_gc_feature_node_get_name(gc_feature_node::Ptr{ArvGcFeatureNode})::Cstring
end

"""
    arv_gc_feature_node_get_name_space(gc_feature_node)

### Prototype
```c
ARV_API ArvGcNameSpace arv_gc_feature_node_get_name_space (ArvGcFeatureNode *gc_feature_node);
```
"""
function arv_gc_feature_node_get_name_space(gc_feature_node)
    @ccall libaravis.arv_gc_feature_node_get_name_space(gc_feature_node::Ptr{ArvGcFeatureNode})::ArvGcNameSpace
end

"""
    arv_gc_feature_node_get_tooltip(gc_feature_node)

### Prototype
```c
ARV_API const char * arv_gc_feature_node_get_tooltip (ArvGcFeatureNode *gc_feature_node);
```
"""
function arv_gc_feature_node_get_tooltip(gc_feature_node)
    @ccall libaravis.arv_gc_feature_node_get_tooltip(gc_feature_node::Ptr{ArvGcFeatureNode})::Cstring
end

"""
    arv_gc_feature_node_get_description(gc_feature_node)

### Prototype
```c
ARV_API const char * arv_gc_feature_node_get_description (ArvGcFeatureNode *gc_feature_node);
```
"""
function arv_gc_feature_node_get_description(gc_feature_node)
    @ccall libaravis.arv_gc_feature_node_get_description(gc_feature_node::Ptr{ArvGcFeatureNode})::Cstring
end

"""
    arv_gc_feature_node_get_display_name(gc_feature_node)

### Prototype
```c
ARV_API const char * arv_gc_feature_node_get_display_name (ArvGcFeatureNode *gc_feature_node);
```
"""
function arv_gc_feature_node_get_display_name(gc_feature_node)
    @ccall libaravis.arv_gc_feature_node_get_display_name(gc_feature_node::Ptr{ArvGcFeatureNode})::Cstring
end

"""
    arv_gc_feature_node_get_visibility(gc_feature_node)

### Prototype
```c
ARV_API ArvGcVisibility arv_gc_feature_node_get_visibility (ArvGcFeatureNode *gc_feature_node);
```
"""
function arv_gc_feature_node_get_visibility(gc_feature_node)
    @ccall libaravis.arv_gc_feature_node_get_visibility(gc_feature_node::Ptr{ArvGcFeatureNode})::ArvGcVisibility
end

"""
    arv_gc_feature_node_is_available(gc_feature_node, error)

### Prototype
```c
ARV_API gboolean arv_gc_feature_node_is_available (ArvGcFeatureNode *gc_feature_node, GError **error);
```
"""
function arv_gc_feature_node_is_available(gc_feature_node, error)
    @ccall libaravis.arv_gc_feature_node_is_available(gc_feature_node::Ptr{ArvGcFeatureNode}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_gc_feature_node_is_implemented(gc_feature_node, error)

### Prototype
```c
ARV_API gboolean arv_gc_feature_node_is_implemented (ArvGcFeatureNode *gc_feature_node, GError **error);
```
"""
function arv_gc_feature_node_is_implemented(gc_feature_node, error)
    @ccall libaravis.arv_gc_feature_node_is_implemented(gc_feature_node::Ptr{ArvGcFeatureNode}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_gc_feature_node_is_locked(gc_feature_node, error)

### Prototype
```c
ARV_API gboolean arv_gc_feature_node_is_locked (ArvGcFeatureNode *gc_feature_node, GError **error);
```
"""
function arv_gc_feature_node_is_locked(gc_feature_node, error)
    @ccall libaravis.arv_gc_feature_node_is_locked(gc_feature_node::Ptr{ArvGcFeatureNode}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_gc_feature_node_get_imposed_access_mode(gc_feature_node)

### Prototype
```c
ARV_API ArvGcAccessMode arv_gc_feature_node_get_imposed_access_mode (ArvGcFeatureNode *gc_feature_node);
```
"""
function arv_gc_feature_node_get_imposed_access_mode(gc_feature_node)
    @ccall libaravis.arv_gc_feature_node_get_imposed_access_mode(gc_feature_node::Ptr{ArvGcFeatureNode})::ArvGcAccessMode
end

"""
    arv_gc_feature_node_get_actual_access_mode(gc_feature_node)

### Prototype
```c
ARV_API ArvGcAccessMode arv_gc_feature_node_get_actual_access_mode (ArvGcFeatureNode *gc_feature_node);
```
"""
function arv_gc_feature_node_get_actual_access_mode(gc_feature_node)
    @ccall libaravis.arv_gc_feature_node_get_actual_access_mode(gc_feature_node::Ptr{ArvGcFeatureNode})::ArvGcAccessMode
end

"""
    arv_gc_feature_node_set_value_from_string(gc_feature_node, string, error)

### Prototype
```c
ARV_API void arv_gc_feature_node_set_value_from_string (ArvGcFeatureNode *gc_feature_node, const char *string, GError **error);
```
"""
function arv_gc_feature_node_set_value_from_string(gc_feature_node, string, error)
    @ccall libaravis.arv_gc_feature_node_set_value_from_string(gc_feature_node::Ptr{ArvGcFeatureNode}, string::Cstring, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_gc_feature_node_get_value_as_string(gc_feature_node, error)

### Prototype
```c
ARV_API const char * arv_gc_feature_node_get_value_as_string (ArvGcFeatureNode *gc_feature_node, GError **error);
```
"""
function arv_gc_feature_node_get_value_as_string(gc_feature_node, error)
    @ccall libaravis.arv_gc_feature_node_get_value_as_string(gc_feature_node::Ptr{ArvGcFeatureNode}, error::Ptr{Ptr{GError}})::Cstring
end

@cenum ArvGcPropertyNodeType::UInt32 begin
    ARV_GC_PROPERTY_NODE_TYPE_UNKNOWN = 0
    ARV_GC_PROPERTY_NODE_TYPE_VALUE = 1
    ARV_GC_PROPERTY_NODE_TYPE_ADDRESS = 2
    ARV_GC_PROPERTY_NODE_TYPE_DESCRIPTION = 3
    ARV_GC_PROPERTY_NODE_TYPE_VISIBILITY = 4
    ARV_GC_PROPERTY_NODE_TYPE_TOOLTIP = 5
    ARV_GC_PROPERTY_NODE_TYPE_DISPLAY_NAME = 6
    ARV_GC_PROPERTY_NODE_TYPE_MINIMUM = 7
    ARV_GC_PROPERTY_NODE_TYPE_MAXIMUM = 8
    ARV_GC_PROPERTY_NODE_TYPE_SLOPE = 9
    ARV_GC_PROPERTY_NODE_TYPE_INCREMENT = 10
    ARV_GC_PROPERTY_NODE_TYPE_IS_LINEAR = 11
    ARV_GC_PROPERTY_NODE_TYPE_REPRESENTATION = 12
    ARV_GC_PROPERTY_NODE_TYPE_DISPLAY_NOTATION = 13
    ARV_GC_PROPERTY_NODE_TYPE_DISPLAY_PRECISION = 14
    ARV_GC_PROPERTY_NODE_TYPE_UNIT = 15
    ARV_GC_PROPERTY_NODE_TYPE_ON_VALUE = 16
    ARV_GC_PROPERTY_NODE_TYPE_OFF_VALUE = 17
    ARV_GC_PROPERTY_NODE_TYPE_LENGTH = 18
    ARV_GC_PROPERTY_NODE_TYPE_FORMULA = 19
    ARV_GC_PROPERTY_NODE_TYPE_FORMULA_TO = 20
    ARV_GC_PROPERTY_NODE_TYPE_FORMULA_FROM = 21
    ARV_GC_PROPERTY_NODE_TYPE_EXPRESSION = 22
    ARV_GC_PROPERTY_NODE_TYPE_CONSTANT = 23
    ARV_GC_PROPERTY_NODE_TYPE_ACCESS_MODE = 24
    ARV_GC_PROPERTY_NODE_TYPE_IMPOSED_ACCESS_MODE = 25
    ARV_GC_PROPERTY_NODE_TYPE_CACHABLE = 26
    ARV_GC_PROPERTY_NODE_TYPE_POLLING_TIME = 27
    ARV_GC_PROPERTY_NODE_TYPE_ENDIANNESS = 28
    ARV_GC_PROPERTY_NODE_TYPE_SIGN = 29
    ARV_GC_PROPERTY_NODE_TYPE_LSB = 30
    ARV_GC_PROPERTY_NODE_TYPE_MSB = 31
    ARV_GC_PROPERTY_NODE_TYPE_BIT = 32
    ARV_GC_PROPERTY_NODE_TYPE_COMMAND_VALUE = 33
    ARV_GC_PROPERTY_NODE_TYPE_CHUNK_ID = 34
    ARV_GC_PROPERTY_NODE_TYPE_EVENT_ID = 35
    ARV_GC_PROPERTY_NODE_TYPE_VALUE_INDEXED = 36
    ARV_GC_PROPERTY_NODE_TYPE_VALUE_DEFAULT = 37
    ARV_GC_PROPERTY_NODE_TYPE_STREAMABLE = 38
    ARV_GC_PROPERTY_NODE_TYPE_IS_DEPRECATED = 39
    ARV_GC_PROPERTY_NODE_TYPE_P_UNKNONW = 1000
    ARV_GC_PROPERTY_NODE_TYPE_P_FEATURE = 1001
    ARV_GC_PROPERTY_NODE_TYPE_P_VALUE = 1002
    ARV_GC_PROPERTY_NODE_TYPE_P_ADDRESS = 1003
    ARV_GC_PROPERTY_NODE_TYPE_P_IS_IMPLEMENTED = 1004
    ARV_GC_PROPERTY_NODE_TYPE_P_IS_LOCKED = 1005
    ARV_GC_PROPERTY_NODE_TYPE_P_IS_AVAILABLE = 1006
    ARV_GC_PROPERTY_NODE_TYPE_P_SELECTED = 1007
    ARV_GC_PROPERTY_NODE_TYPE_P_MINIMUM = 1008
    ARV_GC_PROPERTY_NODE_TYPE_P_MAXIMUM = 1009
    ARV_GC_PROPERTY_NODE_TYPE_P_INCREMENT = 1010
    ARV_GC_PROPERTY_NODE_TYPE_P_INDEX = 1011
    ARV_GC_PROPERTY_NODE_TYPE_P_LENGTH = 1012
    ARV_GC_PROPERTY_NODE_TYPE_P_PORT = 1013
    ARV_GC_PROPERTY_NODE_TYPE_P_VARIABLE = 1014
    ARV_GC_PROPERTY_NODE_TYPE_P_INVALIDATOR = 1015
    ARV_GC_PROPERTY_NODE_TYPE_P_COMMAND_VALUE = 1016
    ARV_GC_PROPERTY_NODE_TYPE_P_VALUE_INDEXED = 1017
    ARV_GC_PROPERTY_NODE_TYPE_P_VALUE_DEFAULT = 1018
    ARV_GC_PROPERTY_NODE_TYPE_P_ALIAS = 1019
    ARV_GC_PROPERTY_NODE_TYPE_P_CAST_ALIAS = 1020
end

struct _ArvGcPropertyNodeClass
    parent_class::ArvGcNodeClass
end

const ArvGcPropertyNodeClass = _ArvGcPropertyNodeClass

const ArvGcPropertyNode_autoptr = Ptr{ArvGcPropertyNode}

const ArvGcPropertyNode_listautoptr = Ptr{GList}

const ArvGcPropertyNode_slistautoptr = Ptr{GSList}

const ArvGcPropertyNode_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcPropertyNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcPropertyNode, arv_gc_property_node, ARV, GC_PROPERTY_NODE, ArvGcNode);
```
"""
function glib_autoptr_clear_ArvGcPropertyNode(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcPropertyNode(_ptr::Ptr{ArvGcPropertyNode})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcPropertyNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcPropertyNode, arv_gc_property_node, ARV, GC_PROPERTY_NODE, ArvGcNode);
```
"""
function glib_autoptr_cleanup_ArvGcPropertyNode(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcPropertyNode(_ptr::Ptr{Ptr{ArvGcPropertyNode}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcPropertyNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcPropertyNode, arv_gc_property_node, ARV, GC_PROPERTY_NODE, ArvGcNode);
```
"""
function glib_autoptr_destroy_ArvGcPropertyNode(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcPropertyNode(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcPropertyNode(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcPropertyNode, arv_gc_property_node, ARV, GC_PROPERTY_NODE, ArvGcNode);
```
"""
function glib_listautoptr_cleanup_ArvGcPropertyNode(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcPropertyNode(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcPropertyNode(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcPropertyNode, arv_gc_property_node, ARV, GC_PROPERTY_NODE, ArvGcNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcPropertyNode(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcPropertyNode(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcPropertyNode(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcPropertyNode, arv_gc_property_node, ARV, GC_PROPERTY_NODE, ArvGcNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcPropertyNode(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcPropertyNode(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcPropertyNodeClass_autoptr = Ptr{ArvGcPropertyNodeClass}

const ArvGcPropertyNodeClass_listautoptr = Ptr{GList}

const ArvGcPropertyNodeClass_slistautoptr = Ptr{GSList}

const ArvGcPropertyNodeClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcPropertyNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcPropertyNode, arv_gc_property_node, ARV, GC_PROPERTY_NODE, ArvGcNode);
```
"""
function glib_autoptr_clear_ArvGcPropertyNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcPropertyNodeClass(_ptr::Ptr{ArvGcPropertyNodeClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcPropertyNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcPropertyNode, arv_gc_property_node, ARV, GC_PROPERTY_NODE, ArvGcNode);
```
"""
function glib_autoptr_cleanup_ArvGcPropertyNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcPropertyNodeClass(_ptr::Ptr{Ptr{ArvGcPropertyNodeClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcPropertyNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcPropertyNode, arv_gc_property_node, ARV, GC_PROPERTY_NODE, ArvGcNode);
```
"""
function glib_autoptr_destroy_ArvGcPropertyNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcPropertyNodeClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcPropertyNodeClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcPropertyNode, arv_gc_property_node, ARV, GC_PROPERTY_NODE, ArvGcNode);
```
"""
function glib_listautoptr_cleanup_ArvGcPropertyNodeClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcPropertyNodeClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcPropertyNodeClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcPropertyNode, arv_gc_property_node, ARV, GC_PROPERTY_NODE, ArvGcNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcPropertyNodeClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcPropertyNodeClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcPropertyNodeClass(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcPropertyNode, arv_gc_property_node, ARV, GC_PROPERTY_NODE, ArvGcNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcPropertyNodeClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcPropertyNodeClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_PROPERTY_NODE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcPropertyNode, arv_gc_property_node, ARV, GC_PROPERTY_NODE, ArvGcNode);
```
"""
function ARV_GC_PROPERTY_NODE(ptr)
    @ccall libaravis.ARV_GC_PROPERTY_NODE(ptr::gpointer)::Ptr{ArvGcPropertyNode}
end

"""
    ARV_GC_PROPERTY_NODE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcPropertyNode, arv_gc_property_node, ARV, GC_PROPERTY_NODE, ArvGcNode);
```
"""
function ARV_GC_PROPERTY_NODE_CLASS(ptr)
    @ccall libaravis.ARV_GC_PROPERTY_NODE_CLASS(ptr::gpointer)::Ptr{ArvGcPropertyNodeClass}
end

"""
    ARV_IS_GC_PROPERTY_NODE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcPropertyNode, arv_gc_property_node, ARV, GC_PROPERTY_NODE, ArvGcNode);
```
"""
function ARV_IS_GC_PROPERTY_NODE(ptr)
    @ccall libaravis.ARV_IS_GC_PROPERTY_NODE(ptr::gpointer)::gboolean
end

"""
    ARV_IS_GC_PROPERTY_NODE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcPropertyNode, arv_gc_property_node, ARV, GC_PROPERTY_NODE, ArvGcNode);
```
"""
function ARV_IS_GC_PROPERTY_NODE_CLASS(ptr)
    @ccall libaravis.ARV_IS_GC_PROPERTY_NODE_CLASS(ptr::gpointer)::gboolean
end

"""
    ARV_GC_PROPERTY_NODE_GET_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcPropertyNode, arv_gc_property_node, ARV, GC_PROPERTY_NODE, ArvGcNode);
```
"""
function ARV_GC_PROPERTY_NODE_GET_CLASS(ptr)
    @ccall libaravis.ARV_GC_PROPERTY_NODE_GET_CLASS(ptr::gpointer)::Ptr{ArvGcPropertyNodeClass}
end

"""
    arv_gc_property_node_new_p_feature()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_p_feature (void);
```
"""
function arv_gc_property_node_new_p_feature()
    @ccall libaravis.arv_gc_property_node_new_p_feature()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_value()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_value (void);
```
"""
function arv_gc_property_node_new_value()
    @ccall libaravis.arv_gc_property_node_new_value()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_p_value()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_p_value (void);
```
"""
function arv_gc_property_node_new_p_value()
    @ccall libaravis.arv_gc_property_node_new_p_value()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_address()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_address (void);
```
"""
function arv_gc_property_node_new_address()
    @ccall libaravis.arv_gc_property_node_new_address()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_p_address()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_p_address (void);
```
"""
function arv_gc_property_node_new_p_address()
    @ccall libaravis.arv_gc_property_node_new_p_address()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_description()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_description (void);
```
"""
function arv_gc_property_node_new_description()
    @ccall libaravis.arv_gc_property_node_new_description()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_visibility()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_visibility (void);
```
"""
function arv_gc_property_node_new_visibility()
    @ccall libaravis.arv_gc_property_node_new_visibility()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_tooltip()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_tooltip (void);
```
"""
function arv_gc_property_node_new_tooltip()
    @ccall libaravis.arv_gc_property_node_new_tooltip()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_display_name()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_display_name (void);
```
"""
function arv_gc_property_node_new_display_name()
    @ccall libaravis.arv_gc_property_node_new_display_name()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_minimum()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_minimum (void);
```
"""
function arv_gc_property_node_new_minimum()
    @ccall libaravis.arv_gc_property_node_new_minimum()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_p_minimum()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_p_minimum (void);
```
"""
function arv_gc_property_node_new_p_minimum()
    @ccall libaravis.arv_gc_property_node_new_p_minimum()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_maximum()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_maximum (void);
```
"""
function arv_gc_property_node_new_maximum()
    @ccall libaravis.arv_gc_property_node_new_maximum()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_p_maximum()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_p_maximum (void);
```
"""
function arv_gc_property_node_new_p_maximum()
    @ccall libaravis.arv_gc_property_node_new_p_maximum()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_slope()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_slope (void);
```
"""
function arv_gc_property_node_new_slope()
    @ccall libaravis.arv_gc_property_node_new_slope()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_increment()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_increment (void);
```
"""
function arv_gc_property_node_new_increment()
    @ccall libaravis.arv_gc_property_node_new_increment()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_p_increment()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_p_increment (void);
```
"""
function arv_gc_property_node_new_p_increment()
    @ccall libaravis.arv_gc_property_node_new_p_increment()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_is_linear()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_is_linear (void);
```
"""
function arv_gc_property_node_new_is_linear()
    @ccall libaravis.arv_gc_property_node_new_is_linear()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_representation()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_representation (void);
```
"""
function arv_gc_property_node_new_representation()
    @ccall libaravis.arv_gc_property_node_new_representation()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_display_notation()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_display_notation (void);
```
"""
function arv_gc_property_node_new_display_notation()
    @ccall libaravis.arv_gc_property_node_new_display_notation()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_display_precision()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_display_precision (void);
```
"""
function arv_gc_property_node_new_display_precision()
    @ccall libaravis.arv_gc_property_node_new_display_precision()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_unit()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_unit (void);
```
"""
function arv_gc_property_node_new_unit()
    @ccall libaravis.arv_gc_property_node_new_unit()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_on_value()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_on_value (void);
```
"""
function arv_gc_property_node_new_on_value()
    @ccall libaravis.arv_gc_property_node_new_on_value()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_off_value()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_off_value (void);
```
"""
function arv_gc_property_node_new_off_value()
    @ccall libaravis.arv_gc_property_node_new_off_value()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_p_is_implemented()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_p_is_implemented (void);
```
"""
function arv_gc_property_node_new_p_is_implemented()
    @ccall libaravis.arv_gc_property_node_new_p_is_implemented()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_p_is_available()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_p_is_available (void);
```
"""
function arv_gc_property_node_new_p_is_available()
    @ccall libaravis.arv_gc_property_node_new_p_is_available()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_p_is_locked()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_p_is_locked (void);
```
"""
function arv_gc_property_node_new_p_is_locked()
    @ccall libaravis.arv_gc_property_node_new_p_is_locked()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_p_selected()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_p_selected (void);
```
"""
function arv_gc_property_node_new_p_selected()
    @ccall libaravis.arv_gc_property_node_new_p_selected()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_length()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_length (void);
```
"""
function arv_gc_property_node_new_length()
    @ccall libaravis.arv_gc_property_node_new_length()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_p_length()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_p_length (void);
```
"""
function arv_gc_property_node_new_p_length()
    @ccall libaravis.arv_gc_property_node_new_p_length()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_p_port()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_p_port (void);
```
"""
function arv_gc_property_node_new_p_port()
    @ccall libaravis.arv_gc_property_node_new_p_port()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_p_variable()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_p_variable (void);
```
"""
function arv_gc_property_node_new_p_variable()
    @ccall libaravis.arv_gc_property_node_new_p_variable()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_formula()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_formula (void);
```
"""
function arv_gc_property_node_new_formula()
    @ccall libaravis.arv_gc_property_node_new_formula()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_formula_to()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_formula_to (void);
```
"""
function arv_gc_property_node_new_formula_to()
    @ccall libaravis.arv_gc_property_node_new_formula_to()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_formula_from()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_formula_from (void);
```
"""
function arv_gc_property_node_new_formula_from()
    @ccall libaravis.arv_gc_property_node_new_formula_from()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_expression()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_expression (void);
```
"""
function arv_gc_property_node_new_expression()
    @ccall libaravis.arv_gc_property_node_new_expression()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_constant()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_constant (void);
```
"""
function arv_gc_property_node_new_constant()
    @ccall libaravis.arv_gc_property_node_new_constant()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_access_mode()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_access_mode (void);
```
"""
function arv_gc_property_node_new_access_mode()
    @ccall libaravis.arv_gc_property_node_new_access_mode()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_imposed_access_mode()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_imposed_access_mode (void);
```
"""
function arv_gc_property_node_new_imposed_access_mode()
    @ccall libaravis.arv_gc_property_node_new_imposed_access_mode()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_cachable()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_cachable (void);
```
"""
function arv_gc_property_node_new_cachable()
    @ccall libaravis.arv_gc_property_node_new_cachable()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_polling_time()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_polling_time (void);
```
"""
function arv_gc_property_node_new_polling_time()
    @ccall libaravis.arv_gc_property_node_new_polling_time()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_endianness()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_endianness (void);
```
"""
function arv_gc_property_node_new_endianness()
    @ccall libaravis.arv_gc_property_node_new_endianness()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_sign()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_sign (void);
```
"""
function arv_gc_property_node_new_sign()
    @ccall libaravis.arv_gc_property_node_new_sign()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_lsb()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_lsb (void);
```
"""
function arv_gc_property_node_new_lsb()
    @ccall libaravis.arv_gc_property_node_new_lsb()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_msb()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_msb (void);
```
"""
function arv_gc_property_node_new_msb()
    @ccall libaravis.arv_gc_property_node_new_msb()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_bit()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_bit (void);
```
"""
function arv_gc_property_node_new_bit()
    @ccall libaravis.arv_gc_property_node_new_bit()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_command_value()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_command_value (void);
```
"""
function arv_gc_property_node_new_command_value()
    @ccall libaravis.arv_gc_property_node_new_command_value()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_p_command_value()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_p_command_value (void);
```
"""
function arv_gc_property_node_new_p_command_value()
    @ccall libaravis.arv_gc_property_node_new_p_command_value()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_chunk_id()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_chunk_id (void);
```
"""
function arv_gc_property_node_new_chunk_id()
    @ccall libaravis.arv_gc_property_node_new_chunk_id()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_event_id()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_event_id (void);
```
"""
function arv_gc_property_node_new_event_id()
    @ccall libaravis.arv_gc_property_node_new_event_id()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_value_default()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_value_default (void);
```
"""
function arv_gc_property_node_new_value_default()
    @ccall libaravis.arv_gc_property_node_new_value_default()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_p_value_default()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_p_value_default (void);
```
"""
function arv_gc_property_node_new_p_value_default()
    @ccall libaravis.arv_gc_property_node_new_p_value_default()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_streamable()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_streamable (void);
```
"""
function arv_gc_property_node_new_streamable()
    @ccall libaravis.arv_gc_property_node_new_streamable()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_is_deprecated()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_is_deprecated (void);
```
"""
function arv_gc_property_node_new_is_deprecated()
    @ccall libaravis.arv_gc_property_node_new_is_deprecated()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_p_alias()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_p_alias (void);
```
"""
function arv_gc_property_node_new_p_alias()
    @ccall libaravis.arv_gc_property_node_new_p_alias()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_new_p_cast_alias()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_new_p_cast_alias (void);
```
"""
function arv_gc_property_node_new_p_cast_alias()
    @ccall libaravis.arv_gc_property_node_new_p_cast_alias()::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_get_name(node)

### Prototype
```c
ARV_API const char * arv_gc_property_node_get_name (ArvGcPropertyNode *node);
```
"""
function arv_gc_property_node_get_name(node)
    @ccall libaravis.arv_gc_property_node_get_name(node::Ptr{ArvGcPropertyNode})::Cstring
end

"""
    arv_gc_property_node_get_string(node, error)

### Prototype
```c
ARV_API const char * arv_gc_property_node_get_string (ArvGcPropertyNode *node, GError **error);
```
"""
function arv_gc_property_node_get_string(node, error)
    @ccall libaravis.arv_gc_property_node_get_string(node::Ptr{ArvGcPropertyNode}, error::Ptr{Ptr{GError}})::Cstring
end

"""
    arv_gc_property_node_set_string(node, string, error)

### Prototype
```c
ARV_API void arv_gc_property_node_set_string (ArvGcPropertyNode *node, const char *string, GError **error);
```
"""
function arv_gc_property_node_set_string(node, string, error)
    @ccall libaravis.arv_gc_property_node_set_string(node::Ptr{ArvGcPropertyNode}, string::Cstring, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_gc_property_node_get_int64(node, error)

### Prototype
```c
ARV_API gint64 arv_gc_property_node_get_int64 (ArvGcPropertyNode *node, GError **error);
```
"""
function arv_gc_property_node_get_int64(node, error)
    @ccall libaravis.arv_gc_property_node_get_int64(node::Ptr{ArvGcPropertyNode}, error::Ptr{Ptr{GError}})::gint64
end

"""
    arv_gc_property_node_set_int64(node, v_int64, error)

### Prototype
```c
ARV_API void arv_gc_property_node_set_int64 (ArvGcPropertyNode *node, gint64 v_int64, GError **error);
```
"""
function arv_gc_property_node_set_int64(node, v_int64, error)
    @ccall libaravis.arv_gc_property_node_set_int64(node::Ptr{ArvGcPropertyNode}, v_int64::gint64, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_gc_property_node_get_double(node, error)

### Prototype
```c
ARV_API double arv_gc_property_node_get_double (ArvGcPropertyNode *node, GError **error);
```
"""
function arv_gc_property_node_get_double(node, error)
    @ccall libaravis.arv_gc_property_node_get_double(node::Ptr{ArvGcPropertyNode}, error::Ptr{Ptr{GError}})::Cdouble
end

"""
    arv_gc_property_node_set_double(node, v_double, error)

### Prototype
```c
ARV_API void arv_gc_property_node_set_double (ArvGcPropertyNode *node, double v_double, GError **error);
```
"""
function arv_gc_property_node_set_double(node, v_double, error)
    @ccall libaravis.arv_gc_property_node_set_double(node::Ptr{ArvGcPropertyNode}, v_double::Cdouble, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_gc_property_node_get_endianness(self, default_value)

### Prototype
```c
ARV_API guint arv_gc_property_node_get_endianness (ArvGcPropertyNode *self, guint default_value);
```
"""
function arv_gc_property_node_get_endianness(self, default_value)
    @ccall libaravis.arv_gc_property_node_get_endianness(self::Ptr{ArvGcPropertyNode}, default_value::guint)::guint
end

"""
    arv_gc_property_node_get_sign(self, default_value)

### Prototype
```c
ARV_API ArvGcSignedness arv_gc_property_node_get_sign (ArvGcPropertyNode *self, ArvGcSignedness default_value);
```
"""
function arv_gc_property_node_get_sign(self, default_value)
    @ccall libaravis.arv_gc_property_node_get_sign(self::Ptr{ArvGcPropertyNode}, default_value::ArvGcSignedness)::ArvGcSignedness
end

"""
    arv_gc_property_node_get_lsb(self, default_value)

### Prototype
```c
ARV_API guint arv_gc_property_node_get_lsb (ArvGcPropertyNode *self, guint default_value);
```
"""
function arv_gc_property_node_get_lsb(self, default_value)
    @ccall libaravis.arv_gc_property_node_get_lsb(self::Ptr{ArvGcPropertyNode}, default_value::guint)::guint
end

"""
    arv_gc_property_node_get_msb(self, default_value)

### Prototype
```c
ARV_API guint arv_gc_property_node_get_msb (ArvGcPropertyNode *self, guint default_value);
```
"""
function arv_gc_property_node_get_msb(self, default_value)
    @ccall libaravis.arv_gc_property_node_get_msb(self::Ptr{ArvGcPropertyNode}, default_value::guint)::guint
end

"""
    arv_gc_property_node_get_cachable(self, default_value)

### Prototype
```c
ARV_API ArvGcCachable arv_gc_property_node_get_cachable (ArvGcPropertyNode *self, ArvGcCachable default_value);
```
"""
function arv_gc_property_node_get_cachable(self, default_value)
    @ccall libaravis.arv_gc_property_node_get_cachable(self::Ptr{ArvGcPropertyNode}, default_value::ArvGcCachable)::ArvGcCachable
end

"""
    arv_gc_property_node_get_access_mode(self, default_value)

### Prototype
```c
ARV_API ArvGcAccessMode arv_gc_property_node_get_access_mode (ArvGcPropertyNode *self, ArvGcAccessMode default_value);
```
"""
function arv_gc_property_node_get_access_mode(self, default_value)
    @ccall libaravis.arv_gc_property_node_get_access_mode(self::Ptr{ArvGcPropertyNode}, default_value::ArvGcAccessMode)::ArvGcAccessMode
end

"""
    arv_gc_property_node_get_visibility(self, default_value)

### Prototype
```c
ARV_API ArvGcVisibility arv_gc_property_node_get_visibility (ArvGcPropertyNode *self, ArvGcVisibility default_value);
```
"""
function arv_gc_property_node_get_visibility(self, default_value)
    @ccall libaravis.arv_gc_property_node_get_visibility(self::Ptr{ArvGcPropertyNode}, default_value::ArvGcVisibility)::ArvGcVisibility
end

"""
    arv_gc_property_node_get_representation(self, default_value)

### Prototype
```c
ARV_API ArvGcRepresentation arv_gc_property_node_get_representation (ArvGcPropertyNode *self, ArvGcRepresentation default_value);
```
"""
function arv_gc_property_node_get_representation(self, default_value)
    @ccall libaravis.arv_gc_property_node_get_representation(self::Ptr{ArvGcPropertyNode}, default_value::ArvGcRepresentation)::ArvGcRepresentation
end

"""
    arv_gc_property_node_get_display_notation(self, default_value)

### Prototype
```c
ARV_API ArvGcDisplayNotation arv_gc_property_node_get_display_notation (ArvGcPropertyNode *self, ArvGcDisplayNotation default_value);
```
"""
function arv_gc_property_node_get_display_notation(self, default_value)
    @ccall libaravis.arv_gc_property_node_get_display_notation(self::Ptr{ArvGcPropertyNode}, default_value::ArvGcDisplayNotation)::ArvGcDisplayNotation
end

"""
    arv_gc_property_node_get_display_precision(self, default_value)

### Prototype
```c
ARV_API gint64 arv_gc_property_node_get_display_precision (ArvGcPropertyNode *self, gint64 default_value);
```
"""
function arv_gc_property_node_get_display_precision(self, default_value)
    @ccall libaravis.arv_gc_property_node_get_display_precision(self::Ptr{ArvGcPropertyNode}, default_value::gint64)::gint64
end

"""
    arv_gc_property_node_get_streamable(self, default_value)

### Prototype
```c
ARV_API ArvGcStreamable arv_gc_property_node_get_streamable (ArvGcPropertyNode *self, ArvGcStreamable default_value);
```
"""
function arv_gc_property_node_get_streamable(self, default_value)
    @ccall libaravis.arv_gc_property_node_get_streamable(self::Ptr{ArvGcPropertyNode}, default_value::ArvGcStreamable)::ArvGcStreamable
end

"""
    arv_gc_property_node_get_linked_node(node)

### Prototype
```c
ARV_API ArvGcNode * arv_gc_property_node_get_linked_node (ArvGcPropertyNode *node);
```
"""
function arv_gc_property_node_get_linked_node(node)
    @ccall libaravis.arv_gc_property_node_get_linked_node(node::Ptr{ArvGcPropertyNode})::Ptr{ArvGcNode}
end

"""
    arv_gc_property_node_get_node_type(node)

### Prototype
```c
ARV_API ArvGcPropertyNodeType arv_gc_property_node_get_node_type (ArvGcPropertyNode *node);
```
"""
function arv_gc_property_node_get_node_type(node)
    @ccall libaravis.arv_gc_property_node_get_node_type(node::Ptr{ArvGcPropertyNode})::ArvGcPropertyNodeType
end

struct ArvGcBooleanClass
    parent_class::ArvGcFeatureNodeClass
end

const ArvGcBoolean_autoptr = Ptr{ArvGcBoolean}

const ArvGcBoolean_listautoptr = Ptr{GList}

const ArvGcBoolean_slistautoptr = Ptr{GSList}

const ArvGcBoolean_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcBoolean(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcBoolean, arv_gc_boolean, ARV, GC_BOOLEAN, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcBoolean(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcBoolean(_ptr::Ptr{ArvGcBoolean})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcBoolean(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcBoolean, arv_gc_boolean, ARV, GC_BOOLEAN, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcBoolean(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcBoolean(_ptr::Ptr{Ptr{ArvGcBoolean}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcBoolean(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcBoolean, arv_gc_boolean, ARV, GC_BOOLEAN, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcBoolean(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcBoolean(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcBoolean(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcBoolean, arv_gc_boolean, ARV, GC_BOOLEAN, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcBoolean(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcBoolean(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcBoolean(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcBoolean, arv_gc_boolean, ARV, GC_BOOLEAN, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcBoolean(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcBoolean(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcBoolean(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcBoolean, arv_gc_boolean, ARV, GC_BOOLEAN, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcBoolean(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcBoolean(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcBooleanClass_autoptr = Ptr{ArvGcBooleanClass}

const ArvGcBooleanClass_listautoptr = Ptr{GList}

const ArvGcBooleanClass_slistautoptr = Ptr{GSList}

const ArvGcBooleanClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcBooleanClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcBoolean, arv_gc_boolean, ARV, GC_BOOLEAN, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcBooleanClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcBooleanClass(_ptr::Ptr{ArvGcBooleanClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcBooleanClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcBoolean, arv_gc_boolean, ARV, GC_BOOLEAN, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcBooleanClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcBooleanClass(_ptr::Ptr{Ptr{ArvGcBooleanClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcBooleanClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcBoolean, arv_gc_boolean, ARV, GC_BOOLEAN, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcBooleanClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcBooleanClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcBooleanClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcBoolean, arv_gc_boolean, ARV, GC_BOOLEAN, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcBooleanClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcBooleanClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcBooleanClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcBoolean, arv_gc_boolean, ARV, GC_BOOLEAN, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcBooleanClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcBooleanClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcBooleanClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcBoolean, arv_gc_boolean, ARV, GC_BOOLEAN, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcBooleanClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcBooleanClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_BOOLEAN(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcBoolean, arv_gc_boolean, ARV, GC_BOOLEAN, ArvGcFeatureNode);
```
"""
function ARV_GC_BOOLEAN(ptr)
    @ccall libaravis.ARV_GC_BOOLEAN(ptr::gpointer)::Ptr{ArvGcBoolean}
end

"""
    ARV_IS_GC_BOOLEAN(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcBoolean, arv_gc_boolean, ARV, GC_BOOLEAN, ArvGcFeatureNode);
```
"""
function ARV_IS_GC_BOOLEAN(ptr)
    @ccall libaravis.ARV_IS_GC_BOOLEAN(ptr::gpointer)::gboolean
end

"""
    arv_gc_boolean_new()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_boolean_new (void);
```
"""
function arv_gc_boolean_new()
    @ccall libaravis.arv_gc_boolean_new()::Ptr{ArvGcNode}
end

"""
    arv_gc_boolean_get_value(gc_boolean, error)

### Prototype
```c
ARV_API gboolean arv_gc_boolean_get_value (ArvGcBoolean *gc_boolean, GError **error);
```
"""
function arv_gc_boolean_get_value(gc_boolean, error)
    @ccall libaravis.arv_gc_boolean_get_value(gc_boolean::Ptr{ArvGcBoolean}, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_gc_boolean_get_value_gi(gc_boolean, value, error)

### Prototype
```c
ARV_API void arv_gc_boolean_get_value_gi (ArvGcBoolean *gc_boolean, gboolean *value, GError **error);
```
"""
function arv_gc_boolean_get_value_gi(gc_boolean, value, error)
    @ccall libaravis.arv_gc_boolean_get_value_gi(gc_boolean::Ptr{ArvGcBoolean}, value::Ptr{gboolean}, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_gc_boolean_set_value(gc_boolean, v_boolean, error)

### Prototype
```c
ARV_API void arv_gc_boolean_set_value (ArvGcBoolean *gc_boolean, gboolean v_boolean, GError **error);
```
"""
function arv_gc_boolean_set_value(gc_boolean, v_boolean, error)
    @ccall libaravis.arv_gc_boolean_set_value(gc_boolean::Ptr{ArvGcBoolean}, v_boolean::gboolean, error::Ptr{Ptr{GError}})::Cvoid
end

struct ArvGcCategoryClass
    parent_class::ArvGcFeatureNodeClass
end

const ArvGcCategory_autoptr = Ptr{ArvGcCategory}

const ArvGcCategory_listautoptr = Ptr{GList}

const ArvGcCategory_slistautoptr = Ptr{GSList}

const ArvGcCategory_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcCategory(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcCategory, arv_gc_category, ARV, GC_CATEGORY, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcCategory(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcCategory(_ptr::Ptr{ArvGcCategory})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcCategory(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcCategory, arv_gc_category, ARV, GC_CATEGORY, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcCategory(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcCategory(_ptr::Ptr{Ptr{ArvGcCategory}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcCategory(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcCategory, arv_gc_category, ARV, GC_CATEGORY, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcCategory(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcCategory(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcCategory(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcCategory, arv_gc_category, ARV, GC_CATEGORY, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcCategory(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcCategory(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcCategory(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcCategory, arv_gc_category, ARV, GC_CATEGORY, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcCategory(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcCategory(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcCategory(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcCategory, arv_gc_category, ARV, GC_CATEGORY, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcCategory(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcCategory(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcCategoryClass_autoptr = Ptr{ArvGcCategoryClass}

const ArvGcCategoryClass_listautoptr = Ptr{GList}

const ArvGcCategoryClass_slistautoptr = Ptr{GSList}

const ArvGcCategoryClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcCategoryClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcCategory, arv_gc_category, ARV, GC_CATEGORY, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcCategoryClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcCategoryClass(_ptr::Ptr{ArvGcCategoryClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcCategoryClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcCategory, arv_gc_category, ARV, GC_CATEGORY, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcCategoryClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcCategoryClass(_ptr::Ptr{Ptr{ArvGcCategoryClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcCategoryClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcCategory, arv_gc_category, ARV, GC_CATEGORY, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcCategoryClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcCategoryClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcCategoryClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcCategory, arv_gc_category, ARV, GC_CATEGORY, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcCategoryClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcCategoryClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcCategoryClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcCategory, arv_gc_category, ARV, GC_CATEGORY, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcCategoryClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcCategoryClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcCategoryClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcCategory, arv_gc_category, ARV, GC_CATEGORY, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcCategoryClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcCategoryClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_CATEGORY(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcCategory, arv_gc_category, ARV, GC_CATEGORY, ArvGcFeatureNode);
```
"""
function ARV_GC_CATEGORY(ptr)
    @ccall libaravis.ARV_GC_CATEGORY(ptr::gpointer)::Ptr{ArvGcCategory}
end

"""
    ARV_IS_GC_CATEGORY(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcCategory, arv_gc_category, ARV, GC_CATEGORY, ArvGcFeatureNode);
```
"""
function ARV_IS_GC_CATEGORY(ptr)
    @ccall libaravis.ARV_IS_GC_CATEGORY(ptr::gpointer)::gboolean
end

"""
    arv_gc_category_new()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_category_new (void);
```
"""
function arv_gc_category_new()
    @ccall libaravis.arv_gc_category_new()::Ptr{ArvGcNode}
end

"""
    arv_gc_category_get_features(category)

### Prototype
```c
ARV_API const GSList * arv_gc_category_get_features (ArvGcCategory *category);
```
"""
function arv_gc_category_get_features(category)
    @ccall libaravis.arv_gc_category_get_features(category::Ptr{ArvGcCategory})::Ptr{GSList}
end

struct ArvGcCommandClass
    parent_class::ArvGcFeatureNodeClass
end

const ArvGcCommand_autoptr = Ptr{ArvGcCommand}

const ArvGcCommand_listautoptr = Ptr{GList}

const ArvGcCommand_slistautoptr = Ptr{GSList}

const ArvGcCommand_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcCommand(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcCommand, arv_gc_command, ARV, GC_COMMAND, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcCommand(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcCommand(_ptr::Ptr{ArvGcCommand})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcCommand(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcCommand, arv_gc_command, ARV, GC_COMMAND, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcCommand(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcCommand(_ptr::Ptr{Ptr{ArvGcCommand}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcCommand(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcCommand, arv_gc_command, ARV, GC_COMMAND, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcCommand(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcCommand(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcCommand(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcCommand, arv_gc_command, ARV, GC_COMMAND, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcCommand(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcCommand(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcCommand(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcCommand, arv_gc_command, ARV, GC_COMMAND, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcCommand(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcCommand(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcCommand(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcCommand, arv_gc_command, ARV, GC_COMMAND, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcCommand(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcCommand(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcCommandClass_autoptr = Ptr{ArvGcCommandClass}

const ArvGcCommandClass_listautoptr = Ptr{GList}

const ArvGcCommandClass_slistautoptr = Ptr{GSList}

const ArvGcCommandClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcCommandClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcCommand, arv_gc_command, ARV, GC_COMMAND, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcCommandClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcCommandClass(_ptr::Ptr{ArvGcCommandClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcCommandClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcCommand, arv_gc_command, ARV, GC_COMMAND, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcCommandClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcCommandClass(_ptr::Ptr{Ptr{ArvGcCommandClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcCommandClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcCommand, arv_gc_command, ARV, GC_COMMAND, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcCommandClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcCommandClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcCommandClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcCommand, arv_gc_command, ARV, GC_COMMAND, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcCommandClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcCommandClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcCommandClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcCommand, arv_gc_command, ARV, GC_COMMAND, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcCommandClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcCommandClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcCommandClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcCommand, arv_gc_command, ARV, GC_COMMAND, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcCommandClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcCommandClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_COMMAND(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcCommand, arv_gc_command, ARV, GC_COMMAND, ArvGcFeatureNode);
```
"""
function ARV_GC_COMMAND(ptr)
    @ccall libaravis.ARV_GC_COMMAND(ptr::gpointer)::Ptr{ArvGcCommand}
end

"""
    ARV_IS_GC_COMMAND(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcCommand, arv_gc_command, ARV, GC_COMMAND, ArvGcFeatureNode);
```
"""
function ARV_IS_GC_COMMAND(ptr)
    @ccall libaravis.ARV_IS_GC_COMMAND(ptr::gpointer)::gboolean
end

"""
    arv_gc_command_new()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_command_new (void);
```
"""
function arv_gc_command_new()
    @ccall libaravis.arv_gc_command_new()::Ptr{ArvGcNode}
end

"""
    arv_gc_command_execute(gc_command, error)

### Prototype
```c
ARV_API void arv_gc_command_execute (ArvGcCommand *gc_command, GError **error);
```
"""
function arv_gc_command_execute(gc_command, error)
    @ccall libaravis.arv_gc_command_execute(gc_command::Ptr{ArvGcCommand}, error::Ptr{Ptr{GError}})::Cvoid
end

struct _ArvGcConverterClass
    parent_class::ArvGcFeatureNodeClass
end

const ArvGcConverterClass = _ArvGcConverterClass

const ArvGcConverter_autoptr = Ptr{ArvGcConverter}

const ArvGcConverter_listautoptr = Ptr{GList}

const ArvGcConverter_slistautoptr = Ptr{GSList}

const ArvGcConverter_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcConverter(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcConverter, arv_gc_converter, ARV, GC_CONVERTER, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcConverter(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcConverter(_ptr::Ptr{ArvGcConverter})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcConverter(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcConverter, arv_gc_converter, ARV, GC_CONVERTER, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcConverter(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcConverter(_ptr::Ptr{Ptr{ArvGcConverter}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcConverter(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcConverter, arv_gc_converter, ARV, GC_CONVERTER, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcConverter(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcConverter(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcConverter(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcConverter, arv_gc_converter, ARV, GC_CONVERTER, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcConverter(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcConverter(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcConverter(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcConverter, arv_gc_converter, ARV, GC_CONVERTER, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcConverter(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcConverter(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcConverter(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcConverter, arv_gc_converter, ARV, GC_CONVERTER, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcConverter(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcConverter(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcConverterClass_autoptr = Ptr{ArvGcConverterClass}

const ArvGcConverterClass_listautoptr = Ptr{GList}

const ArvGcConverterClass_slistautoptr = Ptr{GSList}

const ArvGcConverterClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcConverterClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcConverter, arv_gc_converter, ARV, GC_CONVERTER, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcConverterClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcConverterClass(_ptr::Ptr{ArvGcConverterClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcConverterClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcConverter, arv_gc_converter, ARV, GC_CONVERTER, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcConverterClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcConverterClass(_ptr::Ptr{Ptr{ArvGcConverterClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcConverterClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcConverter, arv_gc_converter, ARV, GC_CONVERTER, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcConverterClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcConverterClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcConverterClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcConverter, arv_gc_converter, ARV, GC_CONVERTER, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcConverterClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcConverterClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcConverterClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcConverter, arv_gc_converter, ARV, GC_CONVERTER, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcConverterClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcConverterClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcConverterClass(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcConverter, arv_gc_converter, ARV, GC_CONVERTER, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcConverterClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcConverterClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_CONVERTER(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcConverter, arv_gc_converter, ARV, GC_CONVERTER, ArvGcFeatureNode);
```
"""
function ARV_GC_CONVERTER(ptr)
    @ccall libaravis.ARV_GC_CONVERTER(ptr::gpointer)::Ptr{ArvGcConverter}
end

"""
    ARV_GC_CONVERTER_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcConverter, arv_gc_converter, ARV, GC_CONVERTER, ArvGcFeatureNode);
```
"""
function ARV_GC_CONVERTER_CLASS(ptr)
    @ccall libaravis.ARV_GC_CONVERTER_CLASS(ptr::gpointer)::Ptr{ArvGcConverterClass}
end

"""
    ARV_IS_GC_CONVERTER(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcConverter, arv_gc_converter, ARV, GC_CONVERTER, ArvGcFeatureNode);
```
"""
function ARV_IS_GC_CONVERTER(ptr)
    @ccall libaravis.ARV_IS_GC_CONVERTER(ptr::gpointer)::gboolean
end

"""
    ARV_IS_GC_CONVERTER_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcConverter, arv_gc_converter, ARV, GC_CONVERTER, ArvGcFeatureNode);
```
"""
function ARV_IS_GC_CONVERTER_CLASS(ptr)
    @ccall libaravis.ARV_IS_GC_CONVERTER_CLASS(ptr::gpointer)::gboolean
end

"""
    ARV_GC_CONVERTER_GET_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcConverter, arv_gc_converter, ARV, GC_CONVERTER, ArvGcFeatureNode);
```
"""
function ARV_GC_CONVERTER_GET_CLASS(ptr)
    @ccall libaravis.ARV_GC_CONVERTER_GET_CLASS(ptr::gpointer)::Ptr{ArvGcConverterClass}
end

struct ArvGcConverterNodeClass
    parent_class::ArvGcConverterClass
end

const ArvGcConverterNode_autoptr = Ptr{ArvGcConverterNode}

const ArvGcConverterNode_listautoptr = Ptr{GList}

const ArvGcConverterNode_slistautoptr = Ptr{GSList}

const ArvGcConverterNode_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcConverterNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcConverterNode, arv_gc_converter_node, ARV, GC_CONVERTER_NODE, ArvGcConverter);
```
"""
function glib_autoptr_clear_ArvGcConverterNode(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcConverterNode(_ptr::Ptr{ArvGcConverterNode})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcConverterNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcConverterNode, arv_gc_converter_node, ARV, GC_CONVERTER_NODE, ArvGcConverter);
```
"""
function glib_autoptr_cleanup_ArvGcConverterNode(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcConverterNode(_ptr::Ptr{Ptr{ArvGcConverterNode}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcConverterNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcConverterNode, arv_gc_converter_node, ARV, GC_CONVERTER_NODE, ArvGcConverter);
```
"""
function glib_autoptr_destroy_ArvGcConverterNode(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcConverterNode(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcConverterNode(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcConverterNode, arv_gc_converter_node, ARV, GC_CONVERTER_NODE, ArvGcConverter);
```
"""
function glib_listautoptr_cleanup_ArvGcConverterNode(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcConverterNode(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcConverterNode(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcConverterNode, arv_gc_converter_node, ARV, GC_CONVERTER_NODE, ArvGcConverter);
```
"""
function glib_slistautoptr_cleanup_ArvGcConverterNode(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcConverterNode(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcConverterNode(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcConverterNode, arv_gc_converter_node, ARV, GC_CONVERTER_NODE, ArvGcConverter);
```
"""
function glib_queueautoptr_cleanup_ArvGcConverterNode(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcConverterNode(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcConverterNodeClass_autoptr = Ptr{ArvGcConverterNodeClass}

const ArvGcConverterNodeClass_listautoptr = Ptr{GList}

const ArvGcConverterNodeClass_slistautoptr = Ptr{GSList}

const ArvGcConverterNodeClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcConverterNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcConverterNode, arv_gc_converter_node, ARV, GC_CONVERTER_NODE, ArvGcConverter);
```
"""
function glib_autoptr_clear_ArvGcConverterNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcConverterNodeClass(_ptr::Ptr{ArvGcConverterNodeClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcConverterNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcConverterNode, arv_gc_converter_node, ARV, GC_CONVERTER_NODE, ArvGcConverter);
```
"""
function glib_autoptr_cleanup_ArvGcConverterNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcConverterNodeClass(_ptr::Ptr{Ptr{ArvGcConverterNodeClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcConverterNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcConverterNode, arv_gc_converter_node, ARV, GC_CONVERTER_NODE, ArvGcConverter);
```
"""
function glib_autoptr_destroy_ArvGcConverterNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcConverterNodeClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcConverterNodeClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcConverterNode, arv_gc_converter_node, ARV, GC_CONVERTER_NODE, ArvGcConverter);
```
"""
function glib_listautoptr_cleanup_ArvGcConverterNodeClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcConverterNodeClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcConverterNodeClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcConverterNode, arv_gc_converter_node, ARV, GC_CONVERTER_NODE, ArvGcConverter);
```
"""
function glib_slistautoptr_cleanup_ArvGcConverterNodeClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcConverterNodeClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcConverterNodeClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcConverterNode, arv_gc_converter_node, ARV, GC_CONVERTER_NODE, ArvGcConverter);
```
"""
function glib_queueautoptr_cleanup_ArvGcConverterNodeClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcConverterNodeClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_CONVERTER_NODE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcConverterNode, arv_gc_converter_node, ARV, GC_CONVERTER_NODE, ArvGcConverter);
```
"""
function ARV_GC_CONVERTER_NODE(ptr)
    @ccall libaravis.ARV_GC_CONVERTER_NODE(ptr::gpointer)::Ptr{ArvGcConverterNode}
end

"""
    ARV_IS_GC_CONVERTER_NODE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcConverterNode, arv_gc_converter_node, ARV, GC_CONVERTER_NODE, ArvGcConverter);
```
"""
function ARV_IS_GC_CONVERTER_NODE(ptr)
    @ccall libaravis.ARV_IS_GC_CONVERTER_NODE(ptr::gpointer)::gboolean
end

"""
    arv_gc_converter_node_new()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_converter_node_new (void);
```
"""
function arv_gc_converter_node_new()
    @ccall libaravis.arv_gc_converter_node_new()::Ptr{ArvGcNode}
end

struct ArvGcEnumEntryClass
    parent_class::ArvGcFeatureNodeClass
end

const ArvGcEnumEntry_autoptr = Ptr{ArvGcEnumEntry}

const ArvGcEnumEntry_listautoptr = Ptr{GList}

const ArvGcEnumEntry_slistautoptr = Ptr{GSList}

const ArvGcEnumEntry_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcEnumEntry(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcEnumEntry, arv_gc_enum_entry, ARV, GC_ENUM_ENTRY, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcEnumEntry(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcEnumEntry(_ptr::Ptr{ArvGcEnumEntry})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcEnumEntry(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcEnumEntry, arv_gc_enum_entry, ARV, GC_ENUM_ENTRY, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcEnumEntry(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcEnumEntry(_ptr::Ptr{Ptr{ArvGcEnumEntry}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcEnumEntry(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcEnumEntry, arv_gc_enum_entry, ARV, GC_ENUM_ENTRY, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcEnumEntry(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcEnumEntry(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcEnumEntry(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcEnumEntry, arv_gc_enum_entry, ARV, GC_ENUM_ENTRY, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcEnumEntry(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcEnumEntry(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcEnumEntry(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcEnumEntry, arv_gc_enum_entry, ARV, GC_ENUM_ENTRY, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcEnumEntry(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcEnumEntry(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcEnumEntry(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcEnumEntry, arv_gc_enum_entry, ARV, GC_ENUM_ENTRY, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcEnumEntry(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcEnumEntry(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcEnumEntryClass_autoptr = Ptr{ArvGcEnumEntryClass}

const ArvGcEnumEntryClass_listautoptr = Ptr{GList}

const ArvGcEnumEntryClass_slistautoptr = Ptr{GSList}

const ArvGcEnumEntryClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcEnumEntryClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcEnumEntry, arv_gc_enum_entry, ARV, GC_ENUM_ENTRY, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcEnumEntryClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcEnumEntryClass(_ptr::Ptr{ArvGcEnumEntryClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcEnumEntryClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcEnumEntry, arv_gc_enum_entry, ARV, GC_ENUM_ENTRY, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcEnumEntryClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcEnumEntryClass(_ptr::Ptr{Ptr{ArvGcEnumEntryClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcEnumEntryClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcEnumEntry, arv_gc_enum_entry, ARV, GC_ENUM_ENTRY, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcEnumEntryClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcEnumEntryClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcEnumEntryClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcEnumEntry, arv_gc_enum_entry, ARV, GC_ENUM_ENTRY, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcEnumEntryClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcEnumEntryClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcEnumEntryClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcEnumEntry, arv_gc_enum_entry, ARV, GC_ENUM_ENTRY, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcEnumEntryClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcEnumEntryClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcEnumEntryClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcEnumEntry, arv_gc_enum_entry, ARV, GC_ENUM_ENTRY, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcEnumEntryClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcEnumEntryClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_ENUM_ENTRY(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcEnumEntry, arv_gc_enum_entry, ARV, GC_ENUM_ENTRY, ArvGcFeatureNode);
```
"""
function ARV_GC_ENUM_ENTRY(ptr)
    @ccall libaravis.ARV_GC_ENUM_ENTRY(ptr::gpointer)::Ptr{ArvGcEnumEntry}
end

"""
    ARV_IS_GC_ENUM_ENTRY(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcEnumEntry, arv_gc_enum_entry, ARV, GC_ENUM_ENTRY, ArvGcFeatureNode);
```
"""
function ARV_IS_GC_ENUM_ENTRY(ptr)
    @ccall libaravis.ARV_IS_GC_ENUM_ENTRY(ptr::gpointer)::gboolean
end

"""
    arv_gc_enum_entry_new()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_enum_entry_new (void);
```
"""
function arv_gc_enum_entry_new()
    @ccall libaravis.arv_gc_enum_entry_new()::Ptr{ArvGcNode}
end

"""
    arv_gc_enum_entry_get_value(entry, error)

### Prototype
```c
ARV_API gint64 arv_gc_enum_entry_get_value (ArvGcEnumEntry *entry, GError **error);
```
"""
function arv_gc_enum_entry_get_value(entry, error)
    @ccall libaravis.arv_gc_enum_entry_get_value(entry::Ptr{ArvGcEnumEntry}, error::Ptr{Ptr{GError}})::gint64
end

struct ArvGcEnumerationClass
    parent_class::ArvGcFeatureNodeClass
end

const ArvGcEnumeration_autoptr = Ptr{ArvGcEnumeration}

const ArvGcEnumeration_listautoptr = Ptr{GList}

const ArvGcEnumeration_slistautoptr = Ptr{GSList}

const ArvGcEnumeration_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcEnumeration(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcEnumeration, arv_gc_enumeration, ARV, GC_ENUMERATION, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcEnumeration(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcEnumeration(_ptr::Ptr{ArvGcEnumeration})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcEnumeration(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcEnumeration, arv_gc_enumeration, ARV, GC_ENUMERATION, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcEnumeration(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcEnumeration(_ptr::Ptr{Ptr{ArvGcEnumeration}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcEnumeration(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcEnumeration, arv_gc_enumeration, ARV, GC_ENUMERATION, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcEnumeration(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcEnumeration(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcEnumeration(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcEnumeration, arv_gc_enumeration, ARV, GC_ENUMERATION, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcEnumeration(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcEnumeration(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcEnumeration(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcEnumeration, arv_gc_enumeration, ARV, GC_ENUMERATION, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcEnumeration(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcEnumeration(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcEnumeration(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcEnumeration, arv_gc_enumeration, ARV, GC_ENUMERATION, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcEnumeration(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcEnumeration(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcEnumerationClass_autoptr = Ptr{ArvGcEnumerationClass}

const ArvGcEnumerationClass_listautoptr = Ptr{GList}

const ArvGcEnumerationClass_slistautoptr = Ptr{GSList}

const ArvGcEnumerationClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcEnumerationClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcEnumeration, arv_gc_enumeration, ARV, GC_ENUMERATION, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcEnumerationClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcEnumerationClass(_ptr::Ptr{ArvGcEnumerationClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcEnumerationClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcEnumeration, arv_gc_enumeration, ARV, GC_ENUMERATION, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcEnumerationClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcEnumerationClass(_ptr::Ptr{Ptr{ArvGcEnumerationClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcEnumerationClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcEnumeration, arv_gc_enumeration, ARV, GC_ENUMERATION, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcEnumerationClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcEnumerationClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcEnumerationClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcEnumeration, arv_gc_enumeration, ARV, GC_ENUMERATION, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcEnumerationClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcEnumerationClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcEnumerationClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcEnumeration, arv_gc_enumeration, ARV, GC_ENUMERATION, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcEnumerationClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcEnumerationClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcEnumerationClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcEnumeration, arv_gc_enumeration, ARV, GC_ENUMERATION, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcEnumerationClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcEnumerationClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_ENUMERATION(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcEnumeration, arv_gc_enumeration, ARV, GC_ENUMERATION, ArvGcFeatureNode);
```
"""
function ARV_GC_ENUMERATION(ptr)
    @ccall libaravis.ARV_GC_ENUMERATION(ptr::gpointer)::Ptr{ArvGcEnumeration}
end

"""
    ARV_IS_GC_ENUMERATION(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcEnumeration, arv_gc_enumeration, ARV, GC_ENUMERATION, ArvGcFeatureNode);
```
"""
function ARV_IS_GC_ENUMERATION(ptr)
    @ccall libaravis.ARV_IS_GC_ENUMERATION(ptr::gpointer)::gboolean
end

"""
    arv_gc_enumeration_new()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_enumeration_new (void);
```
"""
function arv_gc_enumeration_new()
    @ccall libaravis.arv_gc_enumeration_new()::Ptr{ArvGcNode}
end

"""
    arv_gc_enumeration_get_entries(enumeration)

### Prototype
```c
ARV_API const GSList * arv_gc_enumeration_get_entries (ArvGcEnumeration *enumeration);
```
"""
function arv_gc_enumeration_get_entries(enumeration)
    @ccall libaravis.arv_gc_enumeration_get_entries(enumeration::Ptr{ArvGcEnumeration})::Ptr{GSList}
end

"""
    arv_gc_enumeration_get_string_value(enumeration, error)

### Prototype
```c
ARV_API const char * arv_gc_enumeration_get_string_value (ArvGcEnumeration *enumeration, GError **error);
```
"""
function arv_gc_enumeration_get_string_value(enumeration, error)
    @ccall libaravis.arv_gc_enumeration_get_string_value(enumeration::Ptr{ArvGcEnumeration}, error::Ptr{Ptr{GError}})::Cstring
end

"""
    arv_gc_enumeration_set_string_value(enumeration, value, error)

### Prototype
```c
ARV_API gboolean arv_gc_enumeration_set_string_value (ArvGcEnumeration *enumeration, const char *value, GError **error);
```
"""
function arv_gc_enumeration_set_string_value(enumeration, value, error)
    @ccall libaravis.arv_gc_enumeration_set_string_value(enumeration::Ptr{ArvGcEnumeration}, value::Cstring, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_gc_enumeration_get_int_value(enumeration, error)

### Prototype
```c
ARV_API gint64 arv_gc_enumeration_get_int_value (ArvGcEnumeration *enumeration, GError **error);
```
"""
function arv_gc_enumeration_get_int_value(enumeration, error)
    @ccall libaravis.arv_gc_enumeration_get_int_value(enumeration::Ptr{ArvGcEnumeration}, error::Ptr{Ptr{GError}})::gint64
end

"""
    arv_gc_enumeration_set_int_value(enumeration, value, error)

### Prototype
```c
ARV_API gboolean arv_gc_enumeration_set_int_value (ArvGcEnumeration *enumeration, gint64 value, GError **error);
```
"""
function arv_gc_enumeration_set_int_value(enumeration, value, error)
    @ccall libaravis.arv_gc_enumeration_set_int_value(enumeration::Ptr{ArvGcEnumeration}, value::gint64, error::Ptr{Ptr{GError}})::gboolean
end

"""
    arv_gc_enumeration_dup_available_int_values(enumeration, n_values, error)

### Prototype
```c
ARV_API gint64 * arv_gc_enumeration_dup_available_int_values (ArvGcEnumeration *enumeration, guint *n_values, GError **error);
```
"""
function arv_gc_enumeration_dup_available_int_values(enumeration, n_values, error)
    @ccall libaravis.arv_gc_enumeration_dup_available_int_values(enumeration::Ptr{ArvGcEnumeration}, n_values::Ptr{guint}, error::Ptr{Ptr{GError}})::Ptr{gint64}
end

"""
    arv_gc_enumeration_dup_available_string_values(enumeration, n_values, error)

### Prototype
```c
ARV_API const char ** arv_gc_enumeration_dup_available_string_values (ArvGcEnumeration *enumeration, guint *n_values, GError **error);
```
"""
function arv_gc_enumeration_dup_available_string_values(enumeration, n_values, error)
    @ccall libaravis.arv_gc_enumeration_dup_available_string_values(enumeration::Ptr{ArvGcEnumeration}, n_values::Ptr{guint}, error::Ptr{Ptr{GError}})::Ptr{Cstring}
end

"""
    arv_gc_enumeration_dup_available_display_names(enumeration, n_values, error)

### Prototype
```c
ARV_API const char ** arv_gc_enumeration_dup_available_display_names (ArvGcEnumeration *enumeration, guint *n_values, GError **error);
```
"""
function arv_gc_enumeration_dup_available_display_names(enumeration, n_values, error)
    @ccall libaravis.arv_gc_enumeration_dup_available_display_names(enumeration::Ptr{ArvGcEnumeration}, n_values::Ptr{guint}, error::Ptr{Ptr{GError}})::Ptr{Cstring}
end

struct _ArvGcFloatInterface
    parent::GTypeInterface
    get_value::Ptr{Cvoid}
    set_value::Ptr{Cvoid}
    get_min::Ptr{Cvoid}
    get_max::Ptr{Cvoid}
    get_inc::Ptr{Cvoid}
    get_representation::Ptr{Cvoid}
    get_display_notation::Ptr{Cvoid}
    get_display_precision::Ptr{Cvoid}
    get_unit::Ptr{Cvoid}
    impose_min::Ptr{Cvoid}
    impose_max::Ptr{Cvoid}
end

const ArvGcFloatInterface = _ArvGcFloatInterface

const ArvGcFloat_autoptr = Ptr{ArvGcFloat}

const ArvGcFloat_listautoptr = Ptr{GList}

const ArvGcFloat_slistautoptr = Ptr{GSList}

const ArvGcFloat_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcFloat(_ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcFloat, arv_gc_float, ARV, GC_FLOAT, GObject);
```
"""
function glib_autoptr_clear_ArvGcFloat(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcFloat(_ptr::Ptr{ArvGcFloat})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcFloat(_ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcFloat, arv_gc_float, ARV, GC_FLOAT, GObject);
```
"""
function glib_autoptr_cleanup_ArvGcFloat(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcFloat(_ptr::Ptr{Ptr{ArvGcFloat}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcFloat(_ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcFloat, arv_gc_float, ARV, GC_FLOAT, GObject);
```
"""
function glib_autoptr_destroy_ArvGcFloat(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcFloat(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcFloat(_l)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcFloat, arv_gc_float, ARV, GC_FLOAT, GObject);
```
"""
function glib_listautoptr_cleanup_ArvGcFloat(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcFloat(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcFloat(_l)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcFloat, arv_gc_float, ARV, GC_FLOAT, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvGcFloat(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcFloat(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcFloat(_q)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcFloat, arv_gc_float, ARV, GC_FLOAT, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvGcFloat(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcFloat(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_FLOAT(ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcFloat, arv_gc_float, ARV, GC_FLOAT, GObject);
```
"""
function ARV_GC_FLOAT(ptr)
    @ccall libaravis.ARV_GC_FLOAT(ptr::gpointer)::Ptr{ArvGcFloat}
end

"""
    ARV_IS_GC_FLOAT(ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcFloat, arv_gc_float, ARV, GC_FLOAT, GObject);
```
"""
function ARV_IS_GC_FLOAT(ptr)
    @ccall libaravis.ARV_IS_GC_FLOAT(ptr::gpointer)::gboolean
end

"""
    ARV_GC_FLOAT_GET_IFACE(ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcFloat, arv_gc_float, ARV, GC_FLOAT, GObject);
```
"""
function ARV_GC_FLOAT_GET_IFACE(ptr)
    @ccall libaravis.ARV_GC_FLOAT_GET_IFACE(ptr::gpointer)::Ptr{ArvGcFloatInterface}
end

"""
    arv_gc_float_get_value(gc_float, error)

### Prototype
```c
ARV_API double arv_gc_float_get_value (ArvGcFloat *gc_float, GError **error);
```
"""
function arv_gc_float_get_value(gc_float, error)
    @ccall libaravis.arv_gc_float_get_value(gc_float::Ptr{ArvGcFloat}, error::Ptr{Ptr{GError}})::Cdouble
end

"""
    arv_gc_float_set_value(gc_float, value, error)

### Prototype
```c
ARV_API void arv_gc_float_set_value (ArvGcFloat *gc_float, double value, GError **error);
```
"""
function arv_gc_float_set_value(gc_float, value, error)
    @ccall libaravis.arv_gc_float_set_value(gc_float::Ptr{ArvGcFloat}, value::Cdouble, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_gc_float_get_min(gc_float, error)

### Prototype
```c
ARV_API double arv_gc_float_get_min (ArvGcFloat *gc_float, GError **error);
```
"""
function arv_gc_float_get_min(gc_float, error)
    @ccall libaravis.arv_gc_float_get_min(gc_float::Ptr{ArvGcFloat}, error::Ptr{Ptr{GError}})::Cdouble
end

"""
    arv_gc_float_get_max(gc_float, error)

### Prototype
```c
ARV_API double arv_gc_float_get_max (ArvGcFloat *gc_float, GError **error);
```
"""
function arv_gc_float_get_max(gc_float, error)
    @ccall libaravis.arv_gc_float_get_max(gc_float::Ptr{ArvGcFloat}, error::Ptr{Ptr{GError}})::Cdouble
end

"""
    arv_gc_float_get_inc(gc_float, error)

### Prototype
```c
ARV_API double arv_gc_float_get_inc (ArvGcFloat *gc_float, GError **error);
```
"""
function arv_gc_float_get_inc(gc_float, error)
    @ccall libaravis.arv_gc_float_get_inc(gc_float::Ptr{ArvGcFloat}, error::Ptr{Ptr{GError}})::Cdouble
end

"""
    arv_gc_float_get_representation(gc_float)

### Prototype
```c
ARV_API ArvGcRepresentation arv_gc_float_get_representation (ArvGcFloat *gc_float);
```
"""
function arv_gc_float_get_representation(gc_float)
    @ccall libaravis.arv_gc_float_get_representation(gc_float::Ptr{ArvGcFloat})::ArvGcRepresentation
end

"""
    arv_gc_float_get_unit(gc_float)

### Prototype
```c
ARV_API const char * arv_gc_float_get_unit (ArvGcFloat *gc_float);
```
"""
function arv_gc_float_get_unit(gc_float)
    @ccall libaravis.arv_gc_float_get_unit(gc_float::Ptr{ArvGcFloat})::Cstring
end

"""
    arv_gc_float_get_display_notation(gc_float)

### Prototype
```c
ARV_API ArvGcDisplayNotation arv_gc_float_get_display_notation (ArvGcFloat *gc_float);
```
"""
function arv_gc_float_get_display_notation(gc_float)
    @ccall libaravis.arv_gc_float_get_display_notation(gc_float::Ptr{ArvGcFloat})::ArvGcDisplayNotation
end

"""
    arv_gc_float_get_display_precision(gc_float)

### Prototype
```c
ARV_API gint64 arv_gc_float_get_display_precision (ArvGcFloat *gc_float);
```
"""
function arv_gc_float_get_display_precision(gc_float)
    @ccall libaravis.arv_gc_float_get_display_precision(gc_float::Ptr{ArvGcFloat})::gint64
end

"""
    arv_gc_float_impose_min(gc_float, minimum, error)

### Prototype
```c
ARV_API void arv_gc_float_impose_min (ArvGcFloat *gc_float, double minimum, GError **error);
```
"""
function arv_gc_float_impose_min(gc_float, minimum, error)
    @ccall libaravis.arv_gc_float_impose_min(gc_float::Ptr{ArvGcFloat}, minimum::Cdouble, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_gc_float_impose_max(gc_float, maximum, error)

### Prototype
```c
ARV_API void arv_gc_float_impose_max (ArvGcFloat *gc_float, double maximum, GError **error);
```
"""
function arv_gc_float_impose_max(gc_float, maximum, error)
    @ccall libaravis.arv_gc_float_impose_max(gc_float::Ptr{ArvGcFloat}, maximum::Cdouble, error::Ptr{Ptr{GError}})::Cvoid
end

struct ArvGcFloatNodeClass
    parent_class::ArvGcFeatureNodeClass
end

const ArvGcFloatNode_autoptr = Ptr{ArvGcFloatNode}

const ArvGcFloatNode_listautoptr = Ptr{GList}

const ArvGcFloatNode_slistautoptr = Ptr{GSList}

const ArvGcFloatNode_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcFloatNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcFloatNode, arv_gc_float_node, ARV, GC_FLOAT_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcFloatNode(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcFloatNode(_ptr::Ptr{ArvGcFloatNode})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcFloatNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcFloatNode, arv_gc_float_node, ARV, GC_FLOAT_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcFloatNode(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcFloatNode(_ptr::Ptr{Ptr{ArvGcFloatNode}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcFloatNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcFloatNode, arv_gc_float_node, ARV, GC_FLOAT_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcFloatNode(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcFloatNode(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcFloatNode(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcFloatNode, arv_gc_float_node, ARV, GC_FLOAT_NODE, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcFloatNode(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcFloatNode(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcFloatNode(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcFloatNode, arv_gc_float_node, ARV, GC_FLOAT_NODE, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcFloatNode(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcFloatNode(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcFloatNode(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcFloatNode, arv_gc_float_node, ARV, GC_FLOAT_NODE, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcFloatNode(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcFloatNode(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcFloatNodeClass_autoptr = Ptr{ArvGcFloatNodeClass}

const ArvGcFloatNodeClass_listautoptr = Ptr{GList}

const ArvGcFloatNodeClass_slistautoptr = Ptr{GSList}

const ArvGcFloatNodeClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcFloatNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcFloatNode, arv_gc_float_node, ARV, GC_FLOAT_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcFloatNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcFloatNodeClass(_ptr::Ptr{ArvGcFloatNodeClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcFloatNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcFloatNode, arv_gc_float_node, ARV, GC_FLOAT_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcFloatNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcFloatNodeClass(_ptr::Ptr{Ptr{ArvGcFloatNodeClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcFloatNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcFloatNode, arv_gc_float_node, ARV, GC_FLOAT_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcFloatNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcFloatNodeClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcFloatNodeClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcFloatNode, arv_gc_float_node, ARV, GC_FLOAT_NODE, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcFloatNodeClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcFloatNodeClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcFloatNodeClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcFloatNode, arv_gc_float_node, ARV, GC_FLOAT_NODE, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcFloatNodeClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcFloatNodeClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcFloatNodeClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcFloatNode, arv_gc_float_node, ARV, GC_FLOAT_NODE, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcFloatNodeClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcFloatNodeClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_FLOAT_NODE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcFloatNode, arv_gc_float_node, ARV, GC_FLOAT_NODE, ArvGcFeatureNode);
```
"""
function ARV_GC_FLOAT_NODE(ptr)
    @ccall libaravis.ARV_GC_FLOAT_NODE(ptr::gpointer)::Ptr{ArvGcFloatNode}
end

"""
    ARV_IS_GC_FLOAT_NODE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcFloatNode, arv_gc_float_node, ARV, GC_FLOAT_NODE, ArvGcFeatureNode);
```
"""
function ARV_IS_GC_FLOAT_NODE(ptr)
    @ccall libaravis.ARV_IS_GC_FLOAT_NODE(ptr::gpointer)::gboolean
end

"""
    arv_gc_float_node_new()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_float_node_new (void);
```
"""
function arv_gc_float_node_new()
    @ccall libaravis.arv_gc_float_node_new()::Ptr{ArvGcNode}
end

struct _ArvGcRegisterNodeClass
    parent_class::ArvGcFeatureNodeClass
    default_cachable::ArvGcCachable
end

const ArvGcRegisterNodeClass = _ArvGcRegisterNodeClass

const ArvGcRegisterNode_autoptr = Ptr{ArvGcRegisterNode}

const ArvGcRegisterNode_listautoptr = Ptr{GList}

const ArvGcRegisterNode_slistautoptr = Ptr{GSList}

const ArvGcRegisterNode_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcRegisterNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcRegisterNode, arv_gc_register_node, ARV, GC_REGISTER_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcRegisterNode(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcRegisterNode(_ptr::Ptr{ArvGcRegisterNode})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcRegisterNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcRegisterNode, arv_gc_register_node, ARV, GC_REGISTER_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcRegisterNode(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcRegisterNode(_ptr::Ptr{Ptr{ArvGcRegisterNode}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcRegisterNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcRegisterNode, arv_gc_register_node, ARV, GC_REGISTER_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcRegisterNode(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcRegisterNode(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcRegisterNode(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcRegisterNode, arv_gc_register_node, ARV, GC_REGISTER_NODE, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcRegisterNode(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcRegisterNode(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcRegisterNode(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcRegisterNode, arv_gc_register_node, ARV, GC_REGISTER_NODE, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcRegisterNode(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcRegisterNode(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcRegisterNode(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcRegisterNode, arv_gc_register_node, ARV, GC_REGISTER_NODE, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcRegisterNode(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcRegisterNode(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcRegisterNodeClass_autoptr = Ptr{ArvGcRegisterNodeClass}

const ArvGcRegisterNodeClass_listautoptr = Ptr{GList}

const ArvGcRegisterNodeClass_slistautoptr = Ptr{GSList}

const ArvGcRegisterNodeClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcRegisterNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcRegisterNode, arv_gc_register_node, ARV, GC_REGISTER_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcRegisterNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcRegisterNodeClass(_ptr::Ptr{ArvGcRegisterNodeClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcRegisterNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcRegisterNode, arv_gc_register_node, ARV, GC_REGISTER_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcRegisterNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcRegisterNodeClass(_ptr::Ptr{Ptr{ArvGcRegisterNodeClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcRegisterNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcRegisterNode, arv_gc_register_node, ARV, GC_REGISTER_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcRegisterNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcRegisterNodeClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcRegisterNodeClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcRegisterNode, arv_gc_register_node, ARV, GC_REGISTER_NODE, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcRegisterNodeClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcRegisterNodeClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcRegisterNodeClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcRegisterNode, arv_gc_register_node, ARV, GC_REGISTER_NODE, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcRegisterNodeClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcRegisterNodeClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcRegisterNodeClass(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcRegisterNode, arv_gc_register_node, ARV, GC_REGISTER_NODE, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcRegisterNodeClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcRegisterNodeClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_REGISTER_NODE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcRegisterNode, arv_gc_register_node, ARV, GC_REGISTER_NODE, ArvGcFeatureNode);
```
"""
function ARV_GC_REGISTER_NODE(ptr)
    @ccall libaravis.ARV_GC_REGISTER_NODE(ptr::gpointer)::Ptr{ArvGcRegisterNode}
end

"""
    ARV_GC_REGISTER_NODE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcRegisterNode, arv_gc_register_node, ARV, GC_REGISTER_NODE, ArvGcFeatureNode);
```
"""
function ARV_GC_REGISTER_NODE_CLASS(ptr)
    @ccall libaravis.ARV_GC_REGISTER_NODE_CLASS(ptr::gpointer)::Ptr{ArvGcRegisterNodeClass}
end

"""
    ARV_IS_GC_REGISTER_NODE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcRegisterNode, arv_gc_register_node, ARV, GC_REGISTER_NODE, ArvGcFeatureNode);
```
"""
function ARV_IS_GC_REGISTER_NODE(ptr)
    @ccall libaravis.ARV_IS_GC_REGISTER_NODE(ptr::gpointer)::gboolean
end

"""
    ARV_IS_GC_REGISTER_NODE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcRegisterNode, arv_gc_register_node, ARV, GC_REGISTER_NODE, ArvGcFeatureNode);
```
"""
function ARV_IS_GC_REGISTER_NODE_CLASS(ptr)
    @ccall libaravis.ARV_IS_GC_REGISTER_NODE_CLASS(ptr::gpointer)::gboolean
end

"""
    ARV_GC_REGISTER_NODE_GET_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcRegisterNode, arv_gc_register_node, ARV, GC_REGISTER_NODE, ArvGcFeatureNode);
```
"""
function ARV_GC_REGISTER_NODE_GET_CLASS(ptr)
    @ccall libaravis.ARV_GC_REGISTER_NODE_GET_CLASS(ptr::gpointer)::Ptr{ArvGcRegisterNodeClass}
end

"""
    arv_gc_register_node_new()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_register_node_new (void);
```
"""
function arv_gc_register_node_new()
    @ccall libaravis.arv_gc_register_node_new()::Ptr{ArvGcNode}
end

struct _ArvGcFloatRegNode
    parent_instance::ArvGcRegisterNode
end

const ArvGcFloatRegNode = _ArvGcFloatRegNode

struct _ArvGcFloatRegNodeClass
    parent_class::ArvGcRegisterNodeClass
end

const ArvGcFloatRegNodeClass = _ArvGcFloatRegNodeClass

const ArvGcFloatRegNode_autoptr = Ptr{ArvGcFloatRegNode}

const ArvGcFloatRegNode_listautoptr = Ptr{GList}

const ArvGcFloatRegNode_slistautoptr = Ptr{GSList}

const ArvGcFloatRegNode_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcFloatRegNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFloatRegNode, arv_gc_float_reg_node, ARV, GC_FLOAT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_clear_ArvGcFloatRegNode(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcFloatRegNode(_ptr::Ptr{ArvGcFloatRegNode})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcFloatRegNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFloatRegNode, arv_gc_float_reg_node, ARV, GC_FLOAT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_cleanup_ArvGcFloatRegNode(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcFloatRegNode(_ptr::Ptr{Ptr{ArvGcFloatRegNode}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcFloatRegNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFloatRegNode, arv_gc_float_reg_node, ARV, GC_FLOAT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_destroy_ArvGcFloatRegNode(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcFloatRegNode(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcFloatRegNode(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFloatRegNode, arv_gc_float_reg_node, ARV, GC_FLOAT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_listautoptr_cleanup_ArvGcFloatRegNode(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcFloatRegNode(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcFloatRegNode(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFloatRegNode, arv_gc_float_reg_node, ARV, GC_FLOAT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcFloatRegNode(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcFloatRegNode(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcFloatRegNode(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFloatRegNode, arv_gc_float_reg_node, ARV, GC_FLOAT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcFloatRegNode(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcFloatRegNode(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcFloatRegNodeClass_autoptr = Ptr{ArvGcFloatRegNodeClass}

const ArvGcFloatRegNodeClass_listautoptr = Ptr{GList}

const ArvGcFloatRegNodeClass_slistautoptr = Ptr{GSList}

const ArvGcFloatRegNodeClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcFloatRegNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFloatRegNode, arv_gc_float_reg_node, ARV, GC_FLOAT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_clear_ArvGcFloatRegNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcFloatRegNodeClass(_ptr::Ptr{ArvGcFloatRegNodeClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcFloatRegNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFloatRegNode, arv_gc_float_reg_node, ARV, GC_FLOAT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_cleanup_ArvGcFloatRegNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcFloatRegNodeClass(_ptr::Ptr{Ptr{ArvGcFloatRegNodeClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcFloatRegNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFloatRegNode, arv_gc_float_reg_node, ARV, GC_FLOAT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_destroy_ArvGcFloatRegNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcFloatRegNodeClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcFloatRegNodeClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFloatRegNode, arv_gc_float_reg_node, ARV, GC_FLOAT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_listautoptr_cleanup_ArvGcFloatRegNodeClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcFloatRegNodeClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcFloatRegNodeClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFloatRegNode, arv_gc_float_reg_node, ARV, GC_FLOAT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcFloatRegNodeClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcFloatRegNodeClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcFloatRegNodeClass(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFloatRegNode, arv_gc_float_reg_node, ARV, GC_FLOAT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcFloatRegNodeClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcFloatRegNodeClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_FLOAT_REG_NODE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFloatRegNode, arv_gc_float_reg_node, ARV, GC_FLOAT_REG_NODE, ArvGcRegisterNode);
```
"""
function ARV_GC_FLOAT_REG_NODE(ptr)
    @ccall libaravis.ARV_GC_FLOAT_REG_NODE(ptr::gpointer)::Ptr{ArvGcFloatRegNode}
end

"""
    ARV_GC_FLOAT_REG_NODE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFloatRegNode, arv_gc_float_reg_node, ARV, GC_FLOAT_REG_NODE, ArvGcRegisterNode);
```
"""
function ARV_GC_FLOAT_REG_NODE_CLASS(ptr)
    @ccall libaravis.ARV_GC_FLOAT_REG_NODE_CLASS(ptr::gpointer)::Ptr{ArvGcFloatRegNodeClass}
end

"""
    ARV_IS_GC_FLOAT_REG_NODE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFloatRegNode, arv_gc_float_reg_node, ARV, GC_FLOAT_REG_NODE, ArvGcRegisterNode);
```
"""
function ARV_IS_GC_FLOAT_REG_NODE(ptr)
    @ccall libaravis.ARV_IS_GC_FLOAT_REG_NODE(ptr::gpointer)::gboolean
end

"""
    ARV_IS_GC_FLOAT_REG_NODE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFloatRegNode, arv_gc_float_reg_node, ARV, GC_FLOAT_REG_NODE, ArvGcRegisterNode);
```
"""
function ARV_IS_GC_FLOAT_REG_NODE_CLASS(ptr)
    @ccall libaravis.ARV_IS_GC_FLOAT_REG_NODE_CLASS(ptr::gpointer)::gboolean
end

"""
    ARV_GC_FLOAT_REG_NODE_GET_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcFloatRegNode, arv_gc_float_reg_node, ARV, GC_FLOAT_REG_NODE, ArvGcRegisterNode);
```
"""
function ARV_GC_FLOAT_REG_NODE_GET_CLASS(ptr)
    @ccall libaravis.ARV_GC_FLOAT_REG_NODE_GET_CLASS(ptr::gpointer)::Ptr{ArvGcFloatRegNodeClass}
end

"""
    arv_gc_float_reg_node_new()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_float_reg_node_new (void);
```
"""
function arv_gc_float_reg_node_new()
    @ccall libaravis.arv_gc_float_reg_node_new()::Ptr{ArvGcNode}
end

struct ArvGcGroupNodeClass
    parent_class::ArvGcFeatureNodeClass
end

const ArvGcGroupNode_autoptr = Ptr{ArvGcGroupNode}

const ArvGcGroupNode_listautoptr = Ptr{GList}

const ArvGcGroupNode_slistautoptr = Ptr{GSList}

const ArvGcGroupNode_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcGroupNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcGroupNode, arv_gc_group_node, ARV, GC_GROUP_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcGroupNode(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcGroupNode(_ptr::Ptr{ArvGcGroupNode})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcGroupNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcGroupNode, arv_gc_group_node, ARV, GC_GROUP_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcGroupNode(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcGroupNode(_ptr::Ptr{Ptr{ArvGcGroupNode}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcGroupNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcGroupNode, arv_gc_group_node, ARV, GC_GROUP_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcGroupNode(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcGroupNode(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcGroupNode(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcGroupNode, arv_gc_group_node, ARV, GC_GROUP_NODE, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcGroupNode(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcGroupNode(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcGroupNode(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcGroupNode, arv_gc_group_node, ARV, GC_GROUP_NODE, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcGroupNode(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcGroupNode(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcGroupNode(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcGroupNode, arv_gc_group_node, ARV, GC_GROUP_NODE, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcGroupNode(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcGroupNode(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcGroupNodeClass_autoptr = Ptr{ArvGcGroupNodeClass}

const ArvGcGroupNodeClass_listautoptr = Ptr{GList}

const ArvGcGroupNodeClass_slistautoptr = Ptr{GSList}

const ArvGcGroupNodeClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcGroupNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcGroupNode, arv_gc_group_node, ARV, GC_GROUP_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcGroupNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcGroupNodeClass(_ptr::Ptr{ArvGcGroupNodeClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcGroupNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcGroupNode, arv_gc_group_node, ARV, GC_GROUP_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcGroupNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcGroupNodeClass(_ptr::Ptr{Ptr{ArvGcGroupNodeClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcGroupNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcGroupNode, arv_gc_group_node, ARV, GC_GROUP_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcGroupNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcGroupNodeClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcGroupNodeClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcGroupNode, arv_gc_group_node, ARV, GC_GROUP_NODE, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcGroupNodeClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcGroupNodeClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcGroupNodeClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcGroupNode, arv_gc_group_node, ARV, GC_GROUP_NODE, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcGroupNodeClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcGroupNodeClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcGroupNodeClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcGroupNode, arv_gc_group_node, ARV, GC_GROUP_NODE, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcGroupNodeClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcGroupNodeClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_GROUP_NODE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcGroupNode, arv_gc_group_node, ARV, GC_GROUP_NODE, ArvGcFeatureNode);
```
"""
function ARV_GC_GROUP_NODE(ptr)
    @ccall libaravis.ARV_GC_GROUP_NODE(ptr::gpointer)::Ptr{ArvGcGroupNode}
end

"""
    ARV_IS_GC_GROUP_NODE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcGroupNode, arv_gc_group_node, ARV, GC_GROUP_NODE, ArvGcFeatureNode);
```
"""
function ARV_IS_GC_GROUP_NODE(ptr)
    @ccall libaravis.ARV_IS_GC_GROUP_NODE(ptr::gpointer)::gboolean
end

"""
    arv_gc_group_node_new()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_group_node_new (void);
```
"""
function arv_gc_group_node_new()
    @ccall libaravis.arv_gc_group_node_new()::Ptr{ArvGcNode}
end

struct ArvGcIndexNodeClass
    parent_class::ArvGcPropertyNodeClass
end

const ArvGcIndexNode_autoptr = Ptr{ArvGcIndexNode}

const ArvGcIndexNode_listautoptr = Ptr{GList}

const ArvGcIndexNode_slistautoptr = Ptr{GSList}

const ArvGcIndexNode_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcIndexNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIndexNode, arv_gc_index_node, ARV, GC_INDEX_NODE, ArvGcPropertyNode);
```
"""
function glib_autoptr_clear_ArvGcIndexNode(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcIndexNode(_ptr::Ptr{ArvGcIndexNode})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcIndexNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIndexNode, arv_gc_index_node, ARV, GC_INDEX_NODE, ArvGcPropertyNode);
```
"""
function glib_autoptr_cleanup_ArvGcIndexNode(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcIndexNode(_ptr::Ptr{Ptr{ArvGcIndexNode}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcIndexNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIndexNode, arv_gc_index_node, ARV, GC_INDEX_NODE, ArvGcPropertyNode);
```
"""
function glib_autoptr_destroy_ArvGcIndexNode(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcIndexNode(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcIndexNode(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIndexNode, arv_gc_index_node, ARV, GC_INDEX_NODE, ArvGcPropertyNode);
```
"""
function glib_listautoptr_cleanup_ArvGcIndexNode(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcIndexNode(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcIndexNode(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIndexNode, arv_gc_index_node, ARV, GC_INDEX_NODE, ArvGcPropertyNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcIndexNode(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcIndexNode(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcIndexNode(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIndexNode, arv_gc_index_node, ARV, GC_INDEX_NODE, ArvGcPropertyNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcIndexNode(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcIndexNode(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcIndexNodeClass_autoptr = Ptr{ArvGcIndexNodeClass}

const ArvGcIndexNodeClass_listautoptr = Ptr{GList}

const ArvGcIndexNodeClass_slistautoptr = Ptr{GSList}

const ArvGcIndexNodeClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcIndexNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIndexNode, arv_gc_index_node, ARV, GC_INDEX_NODE, ArvGcPropertyNode);
```
"""
function glib_autoptr_clear_ArvGcIndexNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcIndexNodeClass(_ptr::Ptr{ArvGcIndexNodeClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcIndexNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIndexNode, arv_gc_index_node, ARV, GC_INDEX_NODE, ArvGcPropertyNode);
```
"""
function glib_autoptr_cleanup_ArvGcIndexNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcIndexNodeClass(_ptr::Ptr{Ptr{ArvGcIndexNodeClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcIndexNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIndexNode, arv_gc_index_node, ARV, GC_INDEX_NODE, ArvGcPropertyNode);
```
"""
function glib_autoptr_destroy_ArvGcIndexNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcIndexNodeClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcIndexNodeClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIndexNode, arv_gc_index_node, ARV, GC_INDEX_NODE, ArvGcPropertyNode);
```
"""
function glib_listautoptr_cleanup_ArvGcIndexNodeClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcIndexNodeClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcIndexNodeClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIndexNode, arv_gc_index_node, ARV, GC_INDEX_NODE, ArvGcPropertyNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcIndexNodeClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcIndexNodeClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcIndexNodeClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIndexNode, arv_gc_index_node, ARV, GC_INDEX_NODE, ArvGcPropertyNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcIndexNodeClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcIndexNodeClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_INDEX_NODE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIndexNode, arv_gc_index_node, ARV, GC_INDEX_NODE, ArvGcPropertyNode);
```
"""
function ARV_GC_INDEX_NODE(ptr)
    @ccall libaravis.ARV_GC_INDEX_NODE(ptr::gpointer)::Ptr{ArvGcIndexNode}
end

"""
    ARV_IS_GC_INDEX_NODE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIndexNode, arv_gc_index_node, ARV, GC_INDEX_NODE, ArvGcPropertyNode);
```
"""
function ARV_IS_GC_INDEX_NODE(ptr)
    @ccall libaravis.ARV_IS_GC_INDEX_NODE(ptr::gpointer)::gboolean
end

"""
    arv_gc_index_node_new()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_index_node_new (void);
```
"""
function arv_gc_index_node_new()
    @ccall libaravis.arv_gc_index_node_new()::Ptr{ArvGcNode}
end

"""
    arv_gc_index_node_get_index(index_node, default_offset, error)

### Prototype
```c
ARV_API gint64 arv_gc_index_node_get_index (ArvGcIndexNode *index_node, gint64 default_offset, GError **error);
```
"""
function arv_gc_index_node_get_index(index_node, default_offset, error)
    @ccall libaravis.arv_gc_index_node_get_index(index_node::Ptr{ArvGcIndexNode}, default_offset::gint64, error::Ptr{Ptr{GError}})::gint64
end

struct ArvGcIntConverterNodeClass
    parent_class::ArvGcConverterClass
end

const ArvGcIntConverterNode_autoptr = Ptr{ArvGcIntConverterNode}

const ArvGcIntConverterNode_listautoptr = Ptr{GList}

const ArvGcIntConverterNode_slistautoptr = Ptr{GSList}

const ArvGcIntConverterNode_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcIntConverterNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIntConverterNode, arv_gc_int_converter_node, ARV, GC_INT_CONVERTER_NODE, ArvGcConverter);
```
"""
function glib_autoptr_clear_ArvGcIntConverterNode(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcIntConverterNode(_ptr::Ptr{ArvGcIntConverterNode})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcIntConverterNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIntConverterNode, arv_gc_int_converter_node, ARV, GC_INT_CONVERTER_NODE, ArvGcConverter);
```
"""
function glib_autoptr_cleanup_ArvGcIntConverterNode(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcIntConverterNode(_ptr::Ptr{Ptr{ArvGcIntConverterNode}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcIntConverterNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIntConverterNode, arv_gc_int_converter_node, ARV, GC_INT_CONVERTER_NODE, ArvGcConverter);
```
"""
function glib_autoptr_destroy_ArvGcIntConverterNode(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcIntConverterNode(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcIntConverterNode(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIntConverterNode, arv_gc_int_converter_node, ARV, GC_INT_CONVERTER_NODE, ArvGcConverter);
```
"""
function glib_listautoptr_cleanup_ArvGcIntConverterNode(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcIntConverterNode(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcIntConverterNode(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIntConverterNode, arv_gc_int_converter_node, ARV, GC_INT_CONVERTER_NODE, ArvGcConverter);
```
"""
function glib_slistautoptr_cleanup_ArvGcIntConverterNode(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcIntConverterNode(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcIntConverterNode(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIntConverterNode, arv_gc_int_converter_node, ARV, GC_INT_CONVERTER_NODE, ArvGcConverter);
```
"""
function glib_queueautoptr_cleanup_ArvGcIntConverterNode(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcIntConverterNode(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcIntConverterNodeClass_autoptr = Ptr{ArvGcIntConverterNodeClass}

const ArvGcIntConverterNodeClass_listautoptr = Ptr{GList}

const ArvGcIntConverterNodeClass_slistautoptr = Ptr{GSList}

const ArvGcIntConverterNodeClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcIntConverterNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIntConverterNode, arv_gc_int_converter_node, ARV, GC_INT_CONVERTER_NODE, ArvGcConverter);
```
"""
function glib_autoptr_clear_ArvGcIntConverterNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcIntConverterNodeClass(_ptr::Ptr{ArvGcIntConverterNodeClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcIntConverterNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIntConverterNode, arv_gc_int_converter_node, ARV, GC_INT_CONVERTER_NODE, ArvGcConverter);
```
"""
function glib_autoptr_cleanup_ArvGcIntConverterNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcIntConverterNodeClass(_ptr::Ptr{Ptr{ArvGcIntConverterNodeClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcIntConverterNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIntConverterNode, arv_gc_int_converter_node, ARV, GC_INT_CONVERTER_NODE, ArvGcConverter);
```
"""
function glib_autoptr_destroy_ArvGcIntConverterNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcIntConverterNodeClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcIntConverterNodeClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIntConverterNode, arv_gc_int_converter_node, ARV, GC_INT_CONVERTER_NODE, ArvGcConverter);
```
"""
function glib_listautoptr_cleanup_ArvGcIntConverterNodeClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcIntConverterNodeClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcIntConverterNodeClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIntConverterNode, arv_gc_int_converter_node, ARV, GC_INT_CONVERTER_NODE, ArvGcConverter);
```
"""
function glib_slistautoptr_cleanup_ArvGcIntConverterNodeClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcIntConverterNodeClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcIntConverterNodeClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIntConverterNode, arv_gc_int_converter_node, ARV, GC_INT_CONVERTER_NODE, ArvGcConverter);
```
"""
function glib_queueautoptr_cleanup_ArvGcIntConverterNodeClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcIntConverterNodeClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_INT_CONVERTER_NODE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIntConverterNode, arv_gc_int_converter_node, ARV, GC_INT_CONVERTER_NODE, ArvGcConverter);
```
"""
function ARV_GC_INT_CONVERTER_NODE(ptr)
    @ccall libaravis.ARV_GC_INT_CONVERTER_NODE(ptr::gpointer)::Ptr{ArvGcIntConverterNode}
end

"""
    ARV_IS_GC_INT_CONVERTER_NODE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIntConverterNode, arv_gc_int_converter_node, ARV, GC_INT_CONVERTER_NODE, ArvGcConverter);
```
"""
function ARV_IS_GC_INT_CONVERTER_NODE(ptr)
    @ccall libaravis.ARV_IS_GC_INT_CONVERTER_NODE(ptr::gpointer)::gboolean
end

"""
    arv_gc_int_converter_node_new()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_int_converter_node_new (void);
```
"""
function arv_gc_int_converter_node_new()
    @ccall libaravis.arv_gc_int_converter_node_new()::Ptr{ArvGcNode}
end

struct _ArvGcIntegerInterface
    parent::GTypeInterface
    get_value::Ptr{Cvoid}
    set_value::Ptr{Cvoid}
    get_min::Ptr{Cvoid}
    get_max::Ptr{Cvoid}
    get_inc::Ptr{Cvoid}
    get_representation::Ptr{Cvoid}
    get_unit::Ptr{Cvoid}
    impose_min::Ptr{Cvoid}
    impose_max::Ptr{Cvoid}
end

const ArvGcIntegerInterface = _ArvGcIntegerInterface

const ArvGcInteger_autoptr = Ptr{ArvGcInteger}

const ArvGcInteger_listautoptr = Ptr{GList}

const ArvGcInteger_slistautoptr = Ptr{GSList}

const ArvGcInteger_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcInteger(_ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcInteger, arv_gc_integer, ARV, GC_INTEGER, GObject);
```
"""
function glib_autoptr_clear_ArvGcInteger(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcInteger(_ptr::Ptr{ArvGcInteger})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcInteger(_ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcInteger, arv_gc_integer, ARV, GC_INTEGER, GObject);
```
"""
function glib_autoptr_cleanup_ArvGcInteger(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcInteger(_ptr::Ptr{Ptr{ArvGcInteger}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcInteger(_ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcInteger, arv_gc_integer, ARV, GC_INTEGER, GObject);
```
"""
function glib_autoptr_destroy_ArvGcInteger(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcInteger(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcInteger(_l)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcInteger, arv_gc_integer, ARV, GC_INTEGER, GObject);
```
"""
function glib_listautoptr_cleanup_ArvGcInteger(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcInteger(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcInteger(_l)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcInteger, arv_gc_integer, ARV, GC_INTEGER, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvGcInteger(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcInteger(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcInteger(_q)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcInteger, arv_gc_integer, ARV, GC_INTEGER, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvGcInteger(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcInteger(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_INTEGER(ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcInteger, arv_gc_integer, ARV, GC_INTEGER, GObject);
```
"""
function ARV_GC_INTEGER(ptr)
    @ccall libaravis.ARV_GC_INTEGER(ptr::gpointer)::Ptr{ArvGcInteger}
end

"""
    ARV_IS_GC_INTEGER(ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcInteger, arv_gc_integer, ARV, GC_INTEGER, GObject);
```
"""
function ARV_IS_GC_INTEGER(ptr)
    @ccall libaravis.ARV_IS_GC_INTEGER(ptr::gpointer)::gboolean
end

"""
    ARV_GC_INTEGER_GET_IFACE(ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcInteger, arv_gc_integer, ARV, GC_INTEGER, GObject);
```
"""
function ARV_GC_INTEGER_GET_IFACE(ptr)
    @ccall libaravis.ARV_GC_INTEGER_GET_IFACE(ptr::gpointer)::Ptr{ArvGcIntegerInterface}
end

"""
    arv_gc_integer_get_value(gc_integer, error)

### Prototype
```c
ARV_API gint64 arv_gc_integer_get_value (ArvGcInteger *gc_integer, GError **error);
```
"""
function arv_gc_integer_get_value(gc_integer, error)
    @ccall libaravis.arv_gc_integer_get_value(gc_integer::Ptr{ArvGcInteger}, error::Ptr{Ptr{GError}})::gint64
end

"""
    arv_gc_integer_set_value(gc_integer, value, error)

### Prototype
```c
ARV_API void arv_gc_integer_set_value (ArvGcInteger *gc_integer, gint64 value, GError **error);
```
"""
function arv_gc_integer_set_value(gc_integer, value, error)
    @ccall libaravis.arv_gc_integer_set_value(gc_integer::Ptr{ArvGcInteger}, value::gint64, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_gc_integer_get_min(gc_integer, error)

### Prototype
```c
ARV_API gint64 arv_gc_integer_get_min (ArvGcInteger *gc_integer, GError **error);
```
"""
function arv_gc_integer_get_min(gc_integer, error)
    @ccall libaravis.arv_gc_integer_get_min(gc_integer::Ptr{ArvGcInteger}, error::Ptr{Ptr{GError}})::gint64
end

"""
    arv_gc_integer_get_max(gc_integer, error)

### Prototype
```c
ARV_API gint64 arv_gc_integer_get_max (ArvGcInteger *gc_integer, GError **error);
```
"""
function arv_gc_integer_get_max(gc_integer, error)
    @ccall libaravis.arv_gc_integer_get_max(gc_integer::Ptr{ArvGcInteger}, error::Ptr{Ptr{GError}})::gint64
end

"""
    arv_gc_integer_get_inc(gc_integer, error)

### Prototype
```c
ARV_API gint64 arv_gc_integer_get_inc (ArvGcInteger *gc_integer, GError **error);
```
"""
function arv_gc_integer_get_inc(gc_integer, error)
    @ccall libaravis.arv_gc_integer_get_inc(gc_integer::Ptr{ArvGcInteger}, error::Ptr{Ptr{GError}})::gint64
end

"""
    arv_gc_integer_get_representation(gc_integer)

### Prototype
```c
ARV_API ArvGcRepresentation arv_gc_integer_get_representation (ArvGcInteger *gc_integer);
```
"""
function arv_gc_integer_get_representation(gc_integer)
    @ccall libaravis.arv_gc_integer_get_representation(gc_integer::Ptr{ArvGcInteger})::ArvGcRepresentation
end

"""
    arv_gc_integer_get_unit(gc_integer)

### Prototype
```c
ARV_API const char * arv_gc_integer_get_unit (ArvGcInteger *gc_integer);
```
"""
function arv_gc_integer_get_unit(gc_integer)
    @ccall libaravis.arv_gc_integer_get_unit(gc_integer::Ptr{ArvGcInteger})::Cstring
end

"""
    arv_gc_integer_impose_min(gc_integer, minimum, error)

### Prototype
```c
ARV_API void arv_gc_integer_impose_min (ArvGcInteger *gc_integer, gint64 minimum, GError **error);
```
"""
function arv_gc_integer_impose_min(gc_integer, minimum, error)
    @ccall libaravis.arv_gc_integer_impose_min(gc_integer::Ptr{ArvGcInteger}, minimum::gint64, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_gc_integer_impose_max(gc_integer, maximum, error)

### Prototype
```c
ARV_API void arv_gc_integer_impose_max (ArvGcInteger *gc_integer, gint64 maximum, GError **error);
```
"""
function arv_gc_integer_impose_max(gc_integer, maximum, error)
    @ccall libaravis.arv_gc_integer_impose_max(gc_integer::Ptr{ArvGcInteger}, maximum::gint64, error::Ptr{Ptr{GError}})::Cvoid
end

struct ArvGcIntegerNodeClass
    parent_class::ArvGcFeatureNodeClass
end

const ArvGcIntegerNode_autoptr = Ptr{ArvGcIntegerNode}

const ArvGcIntegerNode_listautoptr = Ptr{GList}

const ArvGcIntegerNode_slistautoptr = Ptr{GSList}

const ArvGcIntegerNode_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcIntegerNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIntegerNode, arv_gc_integer_node, ARV, GC_INTEGER_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcIntegerNode(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcIntegerNode(_ptr::Ptr{ArvGcIntegerNode})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcIntegerNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIntegerNode, arv_gc_integer_node, ARV, GC_INTEGER_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcIntegerNode(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcIntegerNode(_ptr::Ptr{Ptr{ArvGcIntegerNode}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcIntegerNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIntegerNode, arv_gc_integer_node, ARV, GC_INTEGER_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcIntegerNode(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcIntegerNode(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcIntegerNode(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIntegerNode, arv_gc_integer_node, ARV, GC_INTEGER_NODE, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcIntegerNode(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcIntegerNode(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcIntegerNode(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIntegerNode, arv_gc_integer_node, ARV, GC_INTEGER_NODE, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcIntegerNode(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcIntegerNode(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcIntegerNode(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIntegerNode, arv_gc_integer_node, ARV, GC_INTEGER_NODE, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcIntegerNode(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcIntegerNode(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcIntegerNodeClass_autoptr = Ptr{ArvGcIntegerNodeClass}

const ArvGcIntegerNodeClass_listautoptr = Ptr{GList}

const ArvGcIntegerNodeClass_slistautoptr = Ptr{GSList}

const ArvGcIntegerNodeClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcIntegerNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIntegerNode, arv_gc_integer_node, ARV, GC_INTEGER_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcIntegerNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcIntegerNodeClass(_ptr::Ptr{ArvGcIntegerNodeClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcIntegerNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIntegerNode, arv_gc_integer_node, ARV, GC_INTEGER_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcIntegerNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcIntegerNodeClass(_ptr::Ptr{Ptr{ArvGcIntegerNodeClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcIntegerNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIntegerNode, arv_gc_integer_node, ARV, GC_INTEGER_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcIntegerNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcIntegerNodeClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcIntegerNodeClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIntegerNode, arv_gc_integer_node, ARV, GC_INTEGER_NODE, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcIntegerNodeClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcIntegerNodeClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcIntegerNodeClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIntegerNode, arv_gc_integer_node, ARV, GC_INTEGER_NODE, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcIntegerNodeClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcIntegerNodeClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcIntegerNodeClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIntegerNode, arv_gc_integer_node, ARV, GC_INTEGER_NODE, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcIntegerNodeClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcIntegerNodeClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_INTEGER_NODE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIntegerNode, arv_gc_integer_node, ARV, GC_INTEGER_NODE, ArvGcFeatureNode);
```
"""
function ARV_GC_INTEGER_NODE(ptr)
    @ccall libaravis.ARV_GC_INTEGER_NODE(ptr::gpointer)::Ptr{ArvGcIntegerNode}
end

"""
    ARV_IS_GC_INTEGER_NODE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcIntegerNode, arv_gc_integer_node, ARV, GC_INTEGER_NODE, ArvGcFeatureNode);
```
"""
function ARV_IS_GC_INTEGER_NODE(ptr)
    @ccall libaravis.ARV_IS_GC_INTEGER_NODE(ptr::gpointer)::gboolean
end

"""
    arv_gc_integer_node_new()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_integer_node_new (void);
```
"""
function arv_gc_integer_node_new()
    @ccall libaravis.arv_gc_integer_node_new()::Ptr{ArvGcNode}
end

struct _ArvGcIntRegNode
    parent_instance::ArvGcRegisterNode
end

const ArvGcIntRegNode = _ArvGcIntRegNode

struct _ArvGcIntRegNodeClass
    parent_class::ArvGcRegisterNodeClass
end

const ArvGcIntRegNodeClass = _ArvGcIntRegNodeClass

const ArvGcIntRegNode_autoptr = Ptr{ArvGcIntRegNode}

const ArvGcIntRegNode_listautoptr = Ptr{GList}

const ArvGcIntRegNode_slistautoptr = Ptr{GSList}

const ArvGcIntRegNode_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcIntRegNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntRegNode, arv_gc_int_reg_node, ARV, GC_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_clear_ArvGcIntRegNode(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcIntRegNode(_ptr::Ptr{ArvGcIntRegNode})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcIntRegNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntRegNode, arv_gc_int_reg_node, ARV, GC_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_cleanup_ArvGcIntRegNode(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcIntRegNode(_ptr::Ptr{Ptr{ArvGcIntRegNode}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcIntRegNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntRegNode, arv_gc_int_reg_node, ARV, GC_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_destroy_ArvGcIntRegNode(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcIntRegNode(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcIntRegNode(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntRegNode, arv_gc_int_reg_node, ARV, GC_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_listautoptr_cleanup_ArvGcIntRegNode(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcIntRegNode(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcIntRegNode(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntRegNode, arv_gc_int_reg_node, ARV, GC_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcIntRegNode(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcIntRegNode(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcIntRegNode(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntRegNode, arv_gc_int_reg_node, ARV, GC_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcIntRegNode(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcIntRegNode(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcIntRegNodeClass_autoptr = Ptr{ArvGcIntRegNodeClass}

const ArvGcIntRegNodeClass_listautoptr = Ptr{GList}

const ArvGcIntRegNodeClass_slistautoptr = Ptr{GSList}

const ArvGcIntRegNodeClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcIntRegNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntRegNode, arv_gc_int_reg_node, ARV, GC_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_clear_ArvGcIntRegNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcIntRegNodeClass(_ptr::Ptr{ArvGcIntRegNodeClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcIntRegNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntRegNode, arv_gc_int_reg_node, ARV, GC_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_cleanup_ArvGcIntRegNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcIntRegNodeClass(_ptr::Ptr{Ptr{ArvGcIntRegNodeClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcIntRegNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntRegNode, arv_gc_int_reg_node, ARV, GC_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_destroy_ArvGcIntRegNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcIntRegNodeClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcIntRegNodeClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntRegNode, arv_gc_int_reg_node, ARV, GC_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_listautoptr_cleanup_ArvGcIntRegNodeClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcIntRegNodeClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcIntRegNodeClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntRegNode, arv_gc_int_reg_node, ARV, GC_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcIntRegNodeClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcIntRegNodeClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcIntRegNodeClass(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntRegNode, arv_gc_int_reg_node, ARV, GC_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcIntRegNodeClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcIntRegNodeClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_INT_REG_NODE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntRegNode, arv_gc_int_reg_node, ARV, GC_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function ARV_GC_INT_REG_NODE(ptr)
    @ccall libaravis.ARV_GC_INT_REG_NODE(ptr::gpointer)::Ptr{ArvGcIntRegNode}
end

"""
    ARV_GC_INT_REG_NODE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntRegNode, arv_gc_int_reg_node, ARV, GC_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function ARV_GC_INT_REG_NODE_CLASS(ptr)
    @ccall libaravis.ARV_GC_INT_REG_NODE_CLASS(ptr::gpointer)::Ptr{ArvGcIntRegNodeClass}
end

"""
    ARV_IS_GC_INT_REG_NODE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntRegNode, arv_gc_int_reg_node, ARV, GC_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function ARV_IS_GC_INT_REG_NODE(ptr)
    @ccall libaravis.ARV_IS_GC_INT_REG_NODE(ptr::gpointer)::gboolean
end

"""
    ARV_IS_GC_INT_REG_NODE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntRegNode, arv_gc_int_reg_node, ARV, GC_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function ARV_IS_GC_INT_REG_NODE_CLASS(ptr)
    @ccall libaravis.ARV_IS_GC_INT_REG_NODE_CLASS(ptr::gpointer)::gboolean
end

"""
    ARV_GC_INT_REG_NODE_GET_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntRegNode, arv_gc_int_reg_node, ARV, GC_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function ARV_GC_INT_REG_NODE_GET_CLASS(ptr)
    @ccall libaravis.ARV_GC_INT_REG_NODE_GET_CLASS(ptr::gpointer)::Ptr{ArvGcIntRegNodeClass}
end

"""
    arv_gc_int_reg_node_new()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_int_reg_node_new (void);
```
"""
function arv_gc_int_reg_node_new()
    @ccall libaravis.arv_gc_int_reg_node_new()::Ptr{ArvGcNode}
end

struct _ArvGcSwissKnifeClass
    parent_class::ArvGcFeatureNodeClass
end

const ArvGcSwissKnifeClass = _ArvGcSwissKnifeClass

const ArvGcSwissKnife_autoptr = Ptr{ArvGcSwissKnife}

const ArvGcSwissKnife_listautoptr = Ptr{GList}

const ArvGcSwissKnife_slistautoptr = Ptr{GSList}

const ArvGcSwissKnife_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcSwissKnife(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnife, arv_gc_swiss_knife, ARV, GC_SWISS_KNIFE, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcSwissKnife(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcSwissKnife(_ptr::Ptr{ArvGcSwissKnife})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcSwissKnife(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnife, arv_gc_swiss_knife, ARV, GC_SWISS_KNIFE, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcSwissKnife(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcSwissKnife(_ptr::Ptr{Ptr{ArvGcSwissKnife}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcSwissKnife(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnife, arv_gc_swiss_knife, ARV, GC_SWISS_KNIFE, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcSwissKnife(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcSwissKnife(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcSwissKnife(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnife, arv_gc_swiss_knife, ARV, GC_SWISS_KNIFE, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcSwissKnife(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcSwissKnife(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcSwissKnife(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnife, arv_gc_swiss_knife, ARV, GC_SWISS_KNIFE, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcSwissKnife(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcSwissKnife(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcSwissKnife(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnife, arv_gc_swiss_knife, ARV, GC_SWISS_KNIFE, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcSwissKnife(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcSwissKnife(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcSwissKnifeClass_autoptr = Ptr{ArvGcSwissKnifeClass}

const ArvGcSwissKnifeClass_listautoptr = Ptr{GList}

const ArvGcSwissKnifeClass_slistautoptr = Ptr{GSList}

const ArvGcSwissKnifeClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcSwissKnifeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnife, arv_gc_swiss_knife, ARV, GC_SWISS_KNIFE, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcSwissKnifeClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcSwissKnifeClass(_ptr::Ptr{ArvGcSwissKnifeClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcSwissKnifeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnife, arv_gc_swiss_knife, ARV, GC_SWISS_KNIFE, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcSwissKnifeClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcSwissKnifeClass(_ptr::Ptr{Ptr{ArvGcSwissKnifeClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcSwissKnifeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnife, arv_gc_swiss_knife, ARV, GC_SWISS_KNIFE, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcSwissKnifeClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcSwissKnifeClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcSwissKnifeClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnife, arv_gc_swiss_knife, ARV, GC_SWISS_KNIFE, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcSwissKnifeClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcSwissKnifeClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcSwissKnifeClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnife, arv_gc_swiss_knife, ARV, GC_SWISS_KNIFE, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcSwissKnifeClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcSwissKnifeClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcSwissKnifeClass(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnife, arv_gc_swiss_knife, ARV, GC_SWISS_KNIFE, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcSwissKnifeClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcSwissKnifeClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_SWISS_KNIFE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnife, arv_gc_swiss_knife, ARV, GC_SWISS_KNIFE, ArvGcFeatureNode);
```
"""
function ARV_GC_SWISS_KNIFE(ptr)
    @ccall libaravis.ARV_GC_SWISS_KNIFE(ptr::gpointer)::Ptr{ArvGcSwissKnife}
end

"""
    ARV_GC_SWISS_KNIFE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnife, arv_gc_swiss_knife, ARV, GC_SWISS_KNIFE, ArvGcFeatureNode);
```
"""
function ARV_GC_SWISS_KNIFE_CLASS(ptr)
    @ccall libaravis.ARV_GC_SWISS_KNIFE_CLASS(ptr::gpointer)::Ptr{ArvGcSwissKnifeClass}
end

"""
    ARV_IS_GC_SWISS_KNIFE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnife, arv_gc_swiss_knife, ARV, GC_SWISS_KNIFE, ArvGcFeatureNode);
```
"""
function ARV_IS_GC_SWISS_KNIFE(ptr)
    @ccall libaravis.ARV_IS_GC_SWISS_KNIFE(ptr::gpointer)::gboolean
end

"""
    ARV_IS_GC_SWISS_KNIFE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnife, arv_gc_swiss_knife, ARV, GC_SWISS_KNIFE, ArvGcFeatureNode);
```
"""
function ARV_IS_GC_SWISS_KNIFE_CLASS(ptr)
    @ccall libaravis.ARV_IS_GC_SWISS_KNIFE_CLASS(ptr::gpointer)::gboolean
end

"""
    ARV_GC_SWISS_KNIFE_GET_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnife, arv_gc_swiss_knife, ARV, GC_SWISS_KNIFE, ArvGcFeatureNode);
```
"""
function ARV_GC_SWISS_KNIFE_GET_CLASS(ptr)
    @ccall libaravis.ARV_GC_SWISS_KNIFE_GET_CLASS(ptr::gpointer)::Ptr{ArvGcSwissKnifeClass}
end

struct _ArvGcIntSwissKnifeNode
    parent_instance::ArvGcSwissKnife
end

const ArvGcIntSwissKnifeNode = _ArvGcIntSwissKnifeNode

struct _ArvGcIntSwissKnifeNodeClass
    parent_class::ArvGcSwissKnifeClass
end

const ArvGcIntSwissKnifeNodeClass = _ArvGcIntSwissKnifeNodeClass

const ArvGcIntSwissKnifeNode_autoptr = Ptr{ArvGcIntSwissKnifeNode}

const ArvGcIntSwissKnifeNode_listautoptr = Ptr{GList}

const ArvGcIntSwissKnifeNode_slistautoptr = Ptr{GSList}

const ArvGcIntSwissKnifeNode_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcIntSwissKnifeNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntSwissKnifeNode, arv_gc_int_swiss_knife_node, ARV, GC_INT_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function glib_autoptr_clear_ArvGcIntSwissKnifeNode(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcIntSwissKnifeNode(_ptr::Ptr{ArvGcIntSwissKnifeNode})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcIntSwissKnifeNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntSwissKnifeNode, arv_gc_int_swiss_knife_node, ARV, GC_INT_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function glib_autoptr_cleanup_ArvGcIntSwissKnifeNode(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcIntSwissKnifeNode(_ptr::Ptr{Ptr{ArvGcIntSwissKnifeNode}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcIntSwissKnifeNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntSwissKnifeNode, arv_gc_int_swiss_knife_node, ARV, GC_INT_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function glib_autoptr_destroy_ArvGcIntSwissKnifeNode(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcIntSwissKnifeNode(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcIntSwissKnifeNode(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntSwissKnifeNode, arv_gc_int_swiss_knife_node, ARV, GC_INT_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function glib_listautoptr_cleanup_ArvGcIntSwissKnifeNode(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcIntSwissKnifeNode(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcIntSwissKnifeNode(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntSwissKnifeNode, arv_gc_int_swiss_knife_node, ARV, GC_INT_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function glib_slistautoptr_cleanup_ArvGcIntSwissKnifeNode(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcIntSwissKnifeNode(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcIntSwissKnifeNode(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntSwissKnifeNode, arv_gc_int_swiss_knife_node, ARV, GC_INT_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function glib_queueautoptr_cleanup_ArvGcIntSwissKnifeNode(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcIntSwissKnifeNode(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcIntSwissKnifeNodeClass_autoptr = Ptr{ArvGcIntSwissKnifeNodeClass}

const ArvGcIntSwissKnifeNodeClass_listautoptr = Ptr{GList}

const ArvGcIntSwissKnifeNodeClass_slistautoptr = Ptr{GSList}

const ArvGcIntSwissKnifeNodeClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcIntSwissKnifeNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntSwissKnifeNode, arv_gc_int_swiss_knife_node, ARV, GC_INT_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function glib_autoptr_clear_ArvGcIntSwissKnifeNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcIntSwissKnifeNodeClass(_ptr::Ptr{ArvGcIntSwissKnifeNodeClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcIntSwissKnifeNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntSwissKnifeNode, arv_gc_int_swiss_knife_node, ARV, GC_INT_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function glib_autoptr_cleanup_ArvGcIntSwissKnifeNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcIntSwissKnifeNodeClass(_ptr::Ptr{Ptr{ArvGcIntSwissKnifeNodeClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcIntSwissKnifeNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntSwissKnifeNode, arv_gc_int_swiss_knife_node, ARV, GC_INT_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function glib_autoptr_destroy_ArvGcIntSwissKnifeNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcIntSwissKnifeNodeClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcIntSwissKnifeNodeClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntSwissKnifeNode, arv_gc_int_swiss_knife_node, ARV, GC_INT_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function glib_listautoptr_cleanup_ArvGcIntSwissKnifeNodeClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcIntSwissKnifeNodeClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcIntSwissKnifeNodeClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntSwissKnifeNode, arv_gc_int_swiss_knife_node, ARV, GC_INT_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function glib_slistautoptr_cleanup_ArvGcIntSwissKnifeNodeClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcIntSwissKnifeNodeClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcIntSwissKnifeNodeClass(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntSwissKnifeNode, arv_gc_int_swiss_knife_node, ARV, GC_INT_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function glib_queueautoptr_cleanup_ArvGcIntSwissKnifeNodeClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcIntSwissKnifeNodeClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_INT_SWISS_KNIFE_NODE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntSwissKnifeNode, arv_gc_int_swiss_knife_node, ARV, GC_INT_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function ARV_GC_INT_SWISS_KNIFE_NODE(ptr)
    @ccall libaravis.ARV_GC_INT_SWISS_KNIFE_NODE(ptr::gpointer)::Ptr{ArvGcIntSwissKnifeNode}
end

"""
    ARV_GC_INT_SWISS_KNIFE_NODE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntSwissKnifeNode, arv_gc_int_swiss_knife_node, ARV, GC_INT_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function ARV_GC_INT_SWISS_KNIFE_NODE_CLASS(ptr)
    @ccall libaravis.ARV_GC_INT_SWISS_KNIFE_NODE_CLASS(ptr::gpointer)::Ptr{ArvGcIntSwissKnifeNodeClass}
end

"""
    ARV_IS_GC_INT_SWISS_KNIFE_NODE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntSwissKnifeNode, arv_gc_int_swiss_knife_node, ARV, GC_INT_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function ARV_IS_GC_INT_SWISS_KNIFE_NODE(ptr)
    @ccall libaravis.ARV_IS_GC_INT_SWISS_KNIFE_NODE(ptr::gpointer)::gboolean
end

"""
    ARV_IS_GC_INT_SWISS_KNIFE_NODE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntSwissKnifeNode, arv_gc_int_swiss_knife_node, ARV, GC_INT_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function ARV_IS_GC_INT_SWISS_KNIFE_NODE_CLASS(ptr)
    @ccall libaravis.ARV_IS_GC_INT_SWISS_KNIFE_NODE_CLASS(ptr::gpointer)::gboolean
end

"""
    ARV_GC_INT_SWISS_KNIFE_NODE_GET_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcIntSwissKnifeNode, arv_gc_int_swiss_knife_node, ARV, GC_INT_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function ARV_GC_INT_SWISS_KNIFE_NODE_GET_CLASS(ptr)
    @ccall libaravis.ARV_GC_INT_SWISS_KNIFE_NODE_GET_CLASS(ptr::gpointer)::Ptr{ArvGcIntSwissKnifeNodeClass}
end

"""
    arv_gc_int_swiss_knife_node_new()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_int_swiss_knife_node_new (void);
```
"""
function arv_gc_int_swiss_knife_node_new()
    @ccall libaravis.arv_gc_int_swiss_knife_node_new()::Ptr{ArvGcNode}
end

struct ArvGcInvalidatorNodeClass
    parent_class::ArvGcPropertyNodeClass
end

const ArvGcInvalidatorNode_autoptr = Ptr{ArvGcInvalidatorNode}

const ArvGcInvalidatorNode_listautoptr = Ptr{GList}

const ArvGcInvalidatorNode_slistautoptr = Ptr{GSList}

const ArvGcInvalidatorNode_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcInvalidatorNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcInvalidatorNode, arv_gc_invalidator_node, ARV, GC_INVALIDATOR_NODE, ArvGcPropertyNode);
```
"""
function glib_autoptr_clear_ArvGcInvalidatorNode(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcInvalidatorNode(_ptr::Ptr{ArvGcInvalidatorNode})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcInvalidatorNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcInvalidatorNode, arv_gc_invalidator_node, ARV, GC_INVALIDATOR_NODE, ArvGcPropertyNode);
```
"""
function glib_autoptr_cleanup_ArvGcInvalidatorNode(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcInvalidatorNode(_ptr::Ptr{Ptr{ArvGcInvalidatorNode}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcInvalidatorNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcInvalidatorNode, arv_gc_invalidator_node, ARV, GC_INVALIDATOR_NODE, ArvGcPropertyNode);
```
"""
function glib_autoptr_destroy_ArvGcInvalidatorNode(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcInvalidatorNode(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcInvalidatorNode(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcInvalidatorNode, arv_gc_invalidator_node, ARV, GC_INVALIDATOR_NODE, ArvGcPropertyNode);
```
"""
function glib_listautoptr_cleanup_ArvGcInvalidatorNode(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcInvalidatorNode(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcInvalidatorNode(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcInvalidatorNode, arv_gc_invalidator_node, ARV, GC_INVALIDATOR_NODE, ArvGcPropertyNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcInvalidatorNode(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcInvalidatorNode(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcInvalidatorNode(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcInvalidatorNode, arv_gc_invalidator_node, ARV, GC_INVALIDATOR_NODE, ArvGcPropertyNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcInvalidatorNode(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcInvalidatorNode(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcInvalidatorNodeClass_autoptr = Ptr{ArvGcInvalidatorNodeClass}

const ArvGcInvalidatorNodeClass_listautoptr = Ptr{GList}

const ArvGcInvalidatorNodeClass_slistautoptr = Ptr{GSList}

const ArvGcInvalidatorNodeClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcInvalidatorNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcInvalidatorNode, arv_gc_invalidator_node, ARV, GC_INVALIDATOR_NODE, ArvGcPropertyNode);
```
"""
function glib_autoptr_clear_ArvGcInvalidatorNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcInvalidatorNodeClass(_ptr::Ptr{ArvGcInvalidatorNodeClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcInvalidatorNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcInvalidatorNode, arv_gc_invalidator_node, ARV, GC_INVALIDATOR_NODE, ArvGcPropertyNode);
```
"""
function glib_autoptr_cleanup_ArvGcInvalidatorNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcInvalidatorNodeClass(_ptr::Ptr{Ptr{ArvGcInvalidatorNodeClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcInvalidatorNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcInvalidatorNode, arv_gc_invalidator_node, ARV, GC_INVALIDATOR_NODE, ArvGcPropertyNode);
```
"""
function glib_autoptr_destroy_ArvGcInvalidatorNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcInvalidatorNodeClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcInvalidatorNodeClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcInvalidatorNode, arv_gc_invalidator_node, ARV, GC_INVALIDATOR_NODE, ArvGcPropertyNode);
```
"""
function glib_listautoptr_cleanup_ArvGcInvalidatorNodeClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcInvalidatorNodeClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcInvalidatorNodeClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcInvalidatorNode, arv_gc_invalidator_node, ARV, GC_INVALIDATOR_NODE, ArvGcPropertyNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcInvalidatorNodeClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcInvalidatorNodeClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcInvalidatorNodeClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcInvalidatorNode, arv_gc_invalidator_node, ARV, GC_INVALIDATOR_NODE, ArvGcPropertyNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcInvalidatorNodeClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcInvalidatorNodeClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_INVALIDATOR_NODE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcInvalidatorNode, arv_gc_invalidator_node, ARV, GC_INVALIDATOR_NODE, ArvGcPropertyNode);
```
"""
function ARV_GC_INVALIDATOR_NODE(ptr)
    @ccall libaravis.ARV_GC_INVALIDATOR_NODE(ptr::gpointer)::Ptr{ArvGcInvalidatorNode}
end

"""
    ARV_IS_GC_INVALIDATOR_NODE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcInvalidatorNode, arv_gc_invalidator_node, ARV, GC_INVALIDATOR_NODE, ArvGcPropertyNode);
```
"""
function ARV_IS_GC_INVALIDATOR_NODE(ptr)
    @ccall libaravis.ARV_IS_GC_INVALIDATOR_NODE(ptr::gpointer)::gboolean
end

"""
    arv_gc_invalidator_node_new()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_invalidator_node_new (void);
```
"""
function arv_gc_invalidator_node_new()
    @ccall libaravis.arv_gc_invalidator_node_new()::Ptr{ArvGcNode}
end

"""
    arv_gc_invalidator_has_changed(self)

### Prototype
```c
ARV_API gboolean arv_gc_invalidator_has_changed (ArvGcInvalidatorNode *self);
```
"""
function arv_gc_invalidator_has_changed(self)
    @ccall libaravis.arv_gc_invalidator_has_changed(self::Ptr{ArvGcInvalidatorNode})::gboolean
end

struct _ArvGcMaskedIntRegNode
    parent_instance::ArvGcRegisterNode
end

const ArvGcMaskedIntRegNode = _ArvGcMaskedIntRegNode

struct _ArvGcMaskedIntRegNodeClass
    parent_class::ArvGcRegisterNodeClass
end

const ArvGcMaskedIntRegNodeClass = _ArvGcMaskedIntRegNodeClass

const ArvGcMaskedIntRegNode_autoptr = Ptr{ArvGcMaskedIntRegNode}

const ArvGcMaskedIntRegNode_listautoptr = Ptr{GList}

const ArvGcMaskedIntRegNode_slistautoptr = Ptr{GSList}

const ArvGcMaskedIntRegNode_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcMaskedIntRegNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcMaskedIntRegNode, arv_gc_masked_int_reg_node, ARV, GC_MASKED_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_clear_ArvGcMaskedIntRegNode(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcMaskedIntRegNode(_ptr::Ptr{ArvGcMaskedIntRegNode})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcMaskedIntRegNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcMaskedIntRegNode, arv_gc_masked_int_reg_node, ARV, GC_MASKED_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_cleanup_ArvGcMaskedIntRegNode(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcMaskedIntRegNode(_ptr::Ptr{Ptr{ArvGcMaskedIntRegNode}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcMaskedIntRegNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcMaskedIntRegNode, arv_gc_masked_int_reg_node, ARV, GC_MASKED_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_destroy_ArvGcMaskedIntRegNode(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcMaskedIntRegNode(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcMaskedIntRegNode(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcMaskedIntRegNode, arv_gc_masked_int_reg_node, ARV, GC_MASKED_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_listautoptr_cleanup_ArvGcMaskedIntRegNode(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcMaskedIntRegNode(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcMaskedIntRegNode(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcMaskedIntRegNode, arv_gc_masked_int_reg_node, ARV, GC_MASKED_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcMaskedIntRegNode(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcMaskedIntRegNode(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcMaskedIntRegNode(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcMaskedIntRegNode, arv_gc_masked_int_reg_node, ARV, GC_MASKED_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcMaskedIntRegNode(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcMaskedIntRegNode(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcMaskedIntRegNodeClass_autoptr = Ptr{ArvGcMaskedIntRegNodeClass}

const ArvGcMaskedIntRegNodeClass_listautoptr = Ptr{GList}

const ArvGcMaskedIntRegNodeClass_slistautoptr = Ptr{GSList}

const ArvGcMaskedIntRegNodeClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcMaskedIntRegNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcMaskedIntRegNode, arv_gc_masked_int_reg_node, ARV, GC_MASKED_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_clear_ArvGcMaskedIntRegNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcMaskedIntRegNodeClass(_ptr::Ptr{ArvGcMaskedIntRegNodeClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcMaskedIntRegNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcMaskedIntRegNode, arv_gc_masked_int_reg_node, ARV, GC_MASKED_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_cleanup_ArvGcMaskedIntRegNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcMaskedIntRegNodeClass(_ptr::Ptr{Ptr{ArvGcMaskedIntRegNodeClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcMaskedIntRegNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcMaskedIntRegNode, arv_gc_masked_int_reg_node, ARV, GC_MASKED_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_destroy_ArvGcMaskedIntRegNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcMaskedIntRegNodeClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcMaskedIntRegNodeClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcMaskedIntRegNode, arv_gc_masked_int_reg_node, ARV, GC_MASKED_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_listautoptr_cleanup_ArvGcMaskedIntRegNodeClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcMaskedIntRegNodeClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcMaskedIntRegNodeClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcMaskedIntRegNode, arv_gc_masked_int_reg_node, ARV, GC_MASKED_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcMaskedIntRegNodeClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcMaskedIntRegNodeClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcMaskedIntRegNodeClass(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcMaskedIntRegNode, arv_gc_masked_int_reg_node, ARV, GC_MASKED_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcMaskedIntRegNodeClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcMaskedIntRegNodeClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_MASKED_INT_REG_NODE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcMaskedIntRegNode, arv_gc_masked_int_reg_node, ARV, GC_MASKED_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function ARV_GC_MASKED_INT_REG_NODE(ptr)
    @ccall libaravis.ARV_GC_MASKED_INT_REG_NODE(ptr::gpointer)::Ptr{ArvGcMaskedIntRegNode}
end

"""
    ARV_GC_MASKED_INT_REG_NODE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcMaskedIntRegNode, arv_gc_masked_int_reg_node, ARV, GC_MASKED_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function ARV_GC_MASKED_INT_REG_NODE_CLASS(ptr)
    @ccall libaravis.ARV_GC_MASKED_INT_REG_NODE_CLASS(ptr::gpointer)::Ptr{ArvGcMaskedIntRegNodeClass}
end

"""
    ARV_IS_GC_MASKED_INT_REG_NODE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcMaskedIntRegNode, arv_gc_masked_int_reg_node, ARV, GC_MASKED_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function ARV_IS_GC_MASKED_INT_REG_NODE(ptr)
    @ccall libaravis.ARV_IS_GC_MASKED_INT_REG_NODE(ptr::gpointer)::gboolean
end

"""
    ARV_IS_GC_MASKED_INT_REG_NODE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcMaskedIntRegNode, arv_gc_masked_int_reg_node, ARV, GC_MASKED_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function ARV_IS_GC_MASKED_INT_REG_NODE_CLASS(ptr)
    @ccall libaravis.ARV_IS_GC_MASKED_INT_REG_NODE_CLASS(ptr::gpointer)::gboolean
end

"""
    ARV_GC_MASKED_INT_REG_NODE_GET_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcMaskedIntRegNode, arv_gc_masked_int_reg_node, ARV, GC_MASKED_INT_REG_NODE, ArvGcRegisterNode);
```
"""
function ARV_GC_MASKED_INT_REG_NODE_GET_CLASS(ptr)
    @ccall libaravis.ARV_GC_MASKED_INT_REG_NODE_GET_CLASS(ptr::gpointer)::Ptr{ArvGcMaskedIntRegNodeClass}
end

"""
    arv_gc_masked_int_reg_node_new()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_masked_int_reg_node_new (void);
```
"""
function arv_gc_masked_int_reg_node_new()
    @ccall libaravis.arv_gc_masked_int_reg_node_new()::Ptr{ArvGcNode}
end

struct ArvGcPortClass
    parent_class::ArvGcFeatureNodeClass
end

const ArvGcPort_autoptr = Ptr{ArvGcPort}

const ArvGcPort_listautoptr = Ptr{GList}

const ArvGcPort_slistautoptr = Ptr{GSList}

const ArvGcPort_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcPort(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcPort, arv_gc_port, ARV, GC_PORT, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcPort(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcPort(_ptr::Ptr{ArvGcPort})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcPort(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcPort, arv_gc_port, ARV, GC_PORT, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcPort(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcPort(_ptr::Ptr{Ptr{ArvGcPort}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcPort(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcPort, arv_gc_port, ARV, GC_PORT, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcPort(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcPort(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcPort(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcPort, arv_gc_port, ARV, GC_PORT, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcPort(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcPort(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcPort(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcPort, arv_gc_port, ARV, GC_PORT, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcPort(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcPort(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcPort(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcPort, arv_gc_port, ARV, GC_PORT, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcPort(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcPort(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcPortClass_autoptr = Ptr{ArvGcPortClass}

const ArvGcPortClass_listautoptr = Ptr{GList}

const ArvGcPortClass_slistautoptr = Ptr{GSList}

const ArvGcPortClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcPortClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcPort, arv_gc_port, ARV, GC_PORT, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcPortClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcPortClass(_ptr::Ptr{ArvGcPortClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcPortClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcPort, arv_gc_port, ARV, GC_PORT, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcPortClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcPortClass(_ptr::Ptr{Ptr{ArvGcPortClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcPortClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcPort, arv_gc_port, ARV, GC_PORT, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcPortClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcPortClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcPortClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcPort, arv_gc_port, ARV, GC_PORT, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcPortClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcPortClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcPortClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcPort, arv_gc_port, ARV, GC_PORT, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcPortClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcPortClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcPortClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcPort, arv_gc_port, ARV, GC_PORT, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcPortClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcPortClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_PORT(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcPort, arv_gc_port, ARV, GC_PORT, ArvGcFeatureNode);
```
"""
function ARV_GC_PORT(ptr)
    @ccall libaravis.ARV_GC_PORT(ptr::gpointer)::Ptr{ArvGcPort}
end

"""
    ARV_IS_GC_PORT(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcPort, arv_gc_port, ARV, GC_PORT, ArvGcFeatureNode);
```
"""
function ARV_IS_GC_PORT(ptr)
    @ccall libaravis.ARV_IS_GC_PORT(ptr::gpointer)::gboolean
end

"""
    arv_gc_port_new()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_port_new (void);
```
"""
function arv_gc_port_new()
    @ccall libaravis.arv_gc_port_new()::Ptr{ArvGcNode}
end

"""
    arv_gc_port_read(port, buffer, address, length, error)

### Prototype
```c
ARV_API void arv_gc_port_read (ArvGcPort *port, void *buffer, guint64 address, guint64 length, GError **error);
```
"""
function arv_gc_port_read(port, buffer, address, length, error)
    @ccall libaravis.arv_gc_port_read(port::Ptr{ArvGcPort}, buffer::Ptr{Cvoid}, address::guint64, length::guint64, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_gc_port_write(port, buffer, address, length, error)

### Prototype
```c
ARV_API void arv_gc_port_write (ArvGcPort *port, void *buffer, guint64 address, guint64 length, GError **error);
```
"""
function arv_gc_port_write(port, buffer, address, length, error)
    @ccall libaravis.arv_gc_port_write(port::Ptr{ArvGcPort}, buffer::Ptr{Cvoid}, address::guint64, length::guint64, error::Ptr{Ptr{GError}})::Cvoid
end

struct ArvGcRegisterDescriptionNodeClass
    parent_class::ArvGcFeatureNodeClass
end

const ArvGcRegisterDescriptionNode_autoptr = Ptr{ArvGcRegisterDescriptionNode}

const ArvGcRegisterDescriptionNode_listautoptr = Ptr{GList}

const ArvGcRegisterDescriptionNode_slistautoptr = Ptr{GSList}

const ArvGcRegisterDescriptionNode_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcRegisterDescriptionNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcRegisterDescriptionNode, arv_gc_register_description_node, ARV, GC_REGISTER_DESCRIPTION_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcRegisterDescriptionNode(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcRegisterDescriptionNode(_ptr::Ptr{ArvGcRegisterDescriptionNode})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcRegisterDescriptionNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcRegisterDescriptionNode, arv_gc_register_description_node, ARV, GC_REGISTER_DESCRIPTION_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcRegisterDescriptionNode(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcRegisterDescriptionNode(_ptr::Ptr{Ptr{ArvGcRegisterDescriptionNode}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcRegisterDescriptionNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcRegisterDescriptionNode, arv_gc_register_description_node, ARV, GC_REGISTER_DESCRIPTION_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcRegisterDescriptionNode(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcRegisterDescriptionNode(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcRegisterDescriptionNode(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcRegisterDescriptionNode, arv_gc_register_description_node, ARV, GC_REGISTER_DESCRIPTION_NODE, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcRegisterDescriptionNode(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcRegisterDescriptionNode(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcRegisterDescriptionNode(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcRegisterDescriptionNode, arv_gc_register_description_node, ARV, GC_REGISTER_DESCRIPTION_NODE, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcRegisterDescriptionNode(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcRegisterDescriptionNode(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcRegisterDescriptionNode(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcRegisterDescriptionNode, arv_gc_register_description_node, ARV, GC_REGISTER_DESCRIPTION_NODE, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcRegisterDescriptionNode(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcRegisterDescriptionNode(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcRegisterDescriptionNodeClass_autoptr = Ptr{ArvGcRegisterDescriptionNodeClass}

const ArvGcRegisterDescriptionNodeClass_listautoptr = Ptr{GList}

const ArvGcRegisterDescriptionNodeClass_slistautoptr = Ptr{GSList}

const ArvGcRegisterDescriptionNodeClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcRegisterDescriptionNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcRegisterDescriptionNode, arv_gc_register_description_node, ARV, GC_REGISTER_DESCRIPTION_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcRegisterDescriptionNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcRegisterDescriptionNodeClass(_ptr::Ptr{ArvGcRegisterDescriptionNodeClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcRegisterDescriptionNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcRegisterDescriptionNode, arv_gc_register_description_node, ARV, GC_REGISTER_DESCRIPTION_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcRegisterDescriptionNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcRegisterDescriptionNodeClass(_ptr::Ptr{Ptr{ArvGcRegisterDescriptionNodeClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcRegisterDescriptionNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcRegisterDescriptionNode, arv_gc_register_description_node, ARV, GC_REGISTER_DESCRIPTION_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcRegisterDescriptionNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcRegisterDescriptionNodeClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcRegisterDescriptionNodeClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcRegisterDescriptionNode, arv_gc_register_description_node, ARV, GC_REGISTER_DESCRIPTION_NODE, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcRegisterDescriptionNodeClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcRegisterDescriptionNodeClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcRegisterDescriptionNodeClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcRegisterDescriptionNode, arv_gc_register_description_node, ARV, GC_REGISTER_DESCRIPTION_NODE, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcRegisterDescriptionNodeClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcRegisterDescriptionNodeClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcRegisterDescriptionNodeClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcRegisterDescriptionNode, arv_gc_register_description_node, ARV, GC_REGISTER_DESCRIPTION_NODE, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcRegisterDescriptionNodeClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcRegisterDescriptionNodeClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_REGISTER_DESCRIPTION_NODE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcRegisterDescriptionNode, arv_gc_register_description_node, ARV, GC_REGISTER_DESCRIPTION_NODE, ArvGcFeatureNode);
```
"""
function ARV_GC_REGISTER_DESCRIPTION_NODE(ptr)
    @ccall libaravis.ARV_GC_REGISTER_DESCRIPTION_NODE(ptr::gpointer)::Ptr{ArvGcRegisterDescriptionNode}
end

"""
    ARV_IS_GC_REGISTER_DESCRIPTION_NODE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcRegisterDescriptionNode, arv_gc_register_description_node, ARV, GC_REGISTER_DESCRIPTION_NODE, ArvGcFeatureNode);
```
"""
function ARV_IS_GC_REGISTER_DESCRIPTION_NODE(ptr)
    @ccall libaravis.ARV_IS_GC_REGISTER_DESCRIPTION_NODE(ptr::gpointer)::gboolean
end

"""
    arv_gc_register_description_node_new()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_register_description_node_new (void);
```
"""
function arv_gc_register_description_node_new()
    @ccall libaravis.arv_gc_register_description_node_new()::Ptr{ArvGcNode}
end

"""
    arv_gc_register_description_node_compare_schema_version(node, major, minor, subminor)

### Prototype
```c
ARV_API int arv_gc_register_description_node_compare_schema_version (ArvGcRegisterDescriptionNode *node, guint major, guint minor, guint subminor);
```
"""
function arv_gc_register_description_node_compare_schema_version(node, major, minor, subminor)
    @ccall libaravis.arv_gc_register_description_node_compare_schema_version(node::Ptr{ArvGcRegisterDescriptionNode}, major::guint, minor::guint, subminor::guint)::Cint
end

"""
    arv_gc_register_description_node_check_schema_version(node, required_major, required_minor, required_subminor)

### Prototype
```c
ARV_API gboolean arv_gc_register_description_node_check_schema_version (ArvGcRegisterDescriptionNode *node, guint required_major, guint required_minor, guint required_subminor);
```
"""
function arv_gc_register_description_node_check_schema_version(node, required_major, required_minor, required_subminor)
    @ccall libaravis.arv_gc_register_description_node_check_schema_version(node::Ptr{ArvGcRegisterDescriptionNode}, required_major::guint, required_minor::guint, required_subminor::guint)::gboolean
end

"""
    arv_gc_register_description_node_get_model_name(node)

### Prototype
```c
ARV_API char * arv_gc_register_description_node_get_model_name (ArvGcRegisterDescriptionNode* node);
```
"""
function arv_gc_register_description_node_get_model_name(node)
    @ccall libaravis.arv_gc_register_description_node_get_model_name(node::Ptr{ArvGcRegisterDescriptionNode})::Cstring
end

"""
    arv_gc_register_description_node_get_vendor_name(node)

### Prototype
```c
ARV_API char * arv_gc_register_description_node_get_vendor_name (ArvGcRegisterDescriptionNode* node);
```
"""
function arv_gc_register_description_node_get_vendor_name(node)
    @ccall libaravis.arv_gc_register_description_node_get_vendor_name(node::Ptr{ArvGcRegisterDescriptionNode})::Cstring
end

"""
    arv_gc_register_description_node_get_major_version(node)

### Prototype
```c
ARV_API guint arv_gc_register_description_node_get_major_version (ArvGcRegisterDescriptionNode* node);
```
"""
function arv_gc_register_description_node_get_major_version(node)
    @ccall libaravis.arv_gc_register_description_node_get_major_version(node::Ptr{ArvGcRegisterDescriptionNode})::guint
end

"""
    arv_gc_register_description_node_get_minor_version(node)

### Prototype
```c
ARV_API guint arv_gc_register_description_node_get_minor_version (ArvGcRegisterDescriptionNode* node);
```
"""
function arv_gc_register_description_node_get_minor_version(node)
    @ccall libaravis.arv_gc_register_description_node_get_minor_version(node::Ptr{ArvGcRegisterDescriptionNode})::guint
end

"""
    arv_gc_register_description_node_get_subminor_version(node)

### Prototype
```c
ARV_API guint arv_gc_register_description_node_get_subminor_version (ArvGcRegisterDescriptionNode* node);
```
"""
function arv_gc_register_description_node_get_subminor_version(node)
    @ccall libaravis.arv_gc_register_description_node_get_subminor_version(node::Ptr{ArvGcRegisterDescriptionNode})::guint
end

"""
    arv_gc_register_description_node_get_schema_major_version(node)

### Prototype
```c
ARV_API guint arv_gc_register_description_node_get_schema_major_version (ArvGcRegisterDescriptionNode* node);
```
"""
function arv_gc_register_description_node_get_schema_major_version(node)
    @ccall libaravis.arv_gc_register_description_node_get_schema_major_version(node::Ptr{ArvGcRegisterDescriptionNode})::guint
end

"""
    arv_gc_register_description_node_get_schema_minor_version(node)

### Prototype
```c
ARV_API guint arv_gc_register_description_node_get_schema_minor_version (ArvGcRegisterDescriptionNode* node);
```
"""
function arv_gc_register_description_node_get_schema_minor_version(node)
    @ccall libaravis.arv_gc_register_description_node_get_schema_minor_version(node::Ptr{ArvGcRegisterDescriptionNode})::guint
end

"""
    arv_gc_register_description_node_get_schema_subminor_version(node)

### Prototype
```c
ARV_API guint arv_gc_register_description_node_get_schema_subminor_version (ArvGcRegisterDescriptionNode* node);
```
"""
function arv_gc_register_description_node_get_schema_subminor_version(node)
    @ccall libaravis.arv_gc_register_description_node_get_schema_subminor_version(node::Ptr{ArvGcRegisterDescriptionNode})::guint
end

struct _ArvGcRegisterInterface
    parent::GTypeInterface
    get::Ptr{Cvoid}
    set::Ptr{Cvoid}
    get_address::Ptr{Cvoid}
    get_length::Ptr{Cvoid}
end

const ArvGcRegisterInterface = _ArvGcRegisterInterface

const ArvGcRegister_autoptr = Ptr{ArvGcRegister}

const ArvGcRegister_listautoptr = Ptr{GList}

const ArvGcRegister_slistautoptr = Ptr{GSList}

const ArvGcRegister_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcRegister(_ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcRegister, arv_gc_register, ARV, GC_REGISTER, GObject);
```
"""
function glib_autoptr_clear_ArvGcRegister(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcRegister(_ptr::Ptr{ArvGcRegister})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcRegister(_ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcRegister, arv_gc_register, ARV, GC_REGISTER, GObject);
```
"""
function glib_autoptr_cleanup_ArvGcRegister(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcRegister(_ptr::Ptr{Ptr{ArvGcRegister}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcRegister(_ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcRegister, arv_gc_register, ARV, GC_REGISTER, GObject);
```
"""
function glib_autoptr_destroy_ArvGcRegister(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcRegister(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcRegister(_l)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcRegister, arv_gc_register, ARV, GC_REGISTER, GObject);
```
"""
function glib_listautoptr_cleanup_ArvGcRegister(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcRegister(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcRegister(_l)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcRegister, arv_gc_register, ARV, GC_REGISTER, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvGcRegister(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcRegister(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcRegister(_q)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcRegister, arv_gc_register, ARV, GC_REGISTER, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvGcRegister(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcRegister(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_REGISTER(ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcRegister, arv_gc_register, ARV, GC_REGISTER, GObject);
```
"""
function ARV_GC_REGISTER(ptr)
    @ccall libaravis.ARV_GC_REGISTER(ptr::gpointer)::Ptr{ArvGcRegister}
end

"""
    ARV_IS_GC_REGISTER(ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcRegister, arv_gc_register, ARV, GC_REGISTER, GObject);
```
"""
function ARV_IS_GC_REGISTER(ptr)
    @ccall libaravis.ARV_IS_GC_REGISTER(ptr::gpointer)::gboolean
end

"""
    ARV_GC_REGISTER_GET_IFACE(ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcRegister, arv_gc_register, ARV, GC_REGISTER, GObject);
```
"""
function ARV_GC_REGISTER_GET_IFACE(ptr)
    @ccall libaravis.ARV_GC_REGISTER_GET_IFACE(ptr::gpointer)::Ptr{ArvGcRegisterInterface}
end

"""
    arv_gc_register_get(gc_register, buffer, length, error)

### Prototype
```c
ARV_API void arv_gc_register_get (ArvGcRegister *gc_register, void *buffer, guint64 length, GError **error);
```
"""
function arv_gc_register_get(gc_register, buffer, length, error)
    @ccall libaravis.arv_gc_register_get(gc_register::Ptr{ArvGcRegister}, buffer::Ptr{Cvoid}, length::guint64, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_gc_register_set(gc_register, buffer, length, error)

### Prototype
```c
ARV_API void arv_gc_register_set (ArvGcRegister *gc_register, const void *buffer, guint64 length, GError **error);
```
"""
function arv_gc_register_set(gc_register, buffer, length, error)
    @ccall libaravis.arv_gc_register_set(gc_register::Ptr{ArvGcRegister}, buffer::Ptr{Cvoid}, length::guint64, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_gc_register_get_address(gc_register, error)

### Prototype
```c
ARV_API guint64 arv_gc_register_get_address (ArvGcRegister *gc_register, GError **error);
```
"""
function arv_gc_register_get_address(gc_register, error)
    @ccall libaravis.arv_gc_register_get_address(gc_register::Ptr{ArvGcRegister}, error::Ptr{Ptr{GError}})::guint64
end

"""
    arv_gc_register_get_length(gc_register, error)

### Prototype
```c
ARV_API guint64 arv_gc_register_get_length (ArvGcRegister *gc_register, GError **error);
```
"""
function arv_gc_register_get_length(gc_register, error)
    @ccall libaravis.arv_gc_register_get_length(gc_register::Ptr{ArvGcRegister}, error::Ptr{Ptr{GError}})::guint64
end

"""
    arv_gc_register_dup(gc_register, length, error)

### Prototype
```c
ARV_API void * arv_gc_register_dup (ArvGcRegister *gc_register, guint64 *length, GError **error);
```
"""
function arv_gc_register_dup(gc_register, length, error)
    @ccall libaravis.arv_gc_register_dup(gc_register::Ptr{ArvGcRegister}, length::Ptr{guint64}, error::Ptr{Ptr{GError}})::Ptr{Cvoid}
end

struct _ArvGcSelectorInterface
    parent::GTypeInterface
    get_selected_features::Ptr{Cvoid}
end

const ArvGcSelectorInterface = _ArvGcSelectorInterface

const ArvGcSelector_autoptr = Ptr{ArvGcSelector}

const ArvGcSelector_listautoptr = Ptr{GList}

const ArvGcSelector_slistautoptr = Ptr{GSList}

const ArvGcSelector_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcSelector(_ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcSelector, arv_gc_selector, ARV, GC_SELECTOR, GObject);
```
"""
function glib_autoptr_clear_ArvGcSelector(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcSelector(_ptr::Ptr{ArvGcSelector})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcSelector(_ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcSelector, arv_gc_selector, ARV, GC_SELECTOR, GObject);
```
"""
function glib_autoptr_cleanup_ArvGcSelector(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcSelector(_ptr::Ptr{Ptr{ArvGcSelector}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcSelector(_ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcSelector, arv_gc_selector, ARV, GC_SELECTOR, GObject);
```
"""
function glib_autoptr_destroy_ArvGcSelector(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcSelector(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcSelector(_l)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcSelector, arv_gc_selector, ARV, GC_SELECTOR, GObject);
```
"""
function glib_listautoptr_cleanup_ArvGcSelector(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcSelector(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcSelector(_l)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcSelector, arv_gc_selector, ARV, GC_SELECTOR, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvGcSelector(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcSelector(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcSelector(_q)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcSelector, arv_gc_selector, ARV, GC_SELECTOR, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvGcSelector(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcSelector(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_SELECTOR(ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcSelector, arv_gc_selector, ARV, GC_SELECTOR, GObject);
```
"""
function ARV_GC_SELECTOR(ptr)
    @ccall libaravis.ARV_GC_SELECTOR(ptr::gpointer)::Ptr{ArvGcSelector}
end

"""
    ARV_IS_GC_SELECTOR(ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcSelector, arv_gc_selector, ARV, GC_SELECTOR, GObject);
```
"""
function ARV_IS_GC_SELECTOR(ptr)
    @ccall libaravis.ARV_IS_GC_SELECTOR(ptr::gpointer)::gboolean
end

"""
    ARV_GC_SELECTOR_GET_IFACE(ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcSelector, arv_gc_selector, ARV, GC_SELECTOR, GObject);
```
"""
function ARV_GC_SELECTOR_GET_IFACE(ptr)
    @ccall libaravis.ARV_GC_SELECTOR_GET_IFACE(ptr::gpointer)::Ptr{ArvGcSelectorInterface}
end

"""
    arv_gc_selector_is_selector(gc_selector)

### Prototype
```c
ARV_API gboolean arv_gc_selector_is_selector (ArvGcSelector *gc_selector);
```
"""
function arv_gc_selector_is_selector(gc_selector)
    @ccall libaravis.arv_gc_selector_is_selector(gc_selector::Ptr{ArvGcSelector})::gboolean
end

"""
    arv_gc_selector_get_selected_features(gc_selector)

### Prototype
```c
ARV_API const GSList * arv_gc_selector_get_selected_features (ArvGcSelector *gc_selector);
```
"""
function arv_gc_selector_get_selected_features(gc_selector)
    @ccall libaravis.arv_gc_selector_get_selected_features(gc_selector::Ptr{ArvGcSelector})::Ptr{GSList}
end

struct _ArvGcStringInterface
    parent::GTypeInterface
    get_value::Ptr{Cvoid}
    set_value::Ptr{Cvoid}
    get_max_length::Ptr{Cvoid}
end

const ArvGcStringInterface = _ArvGcStringInterface

const ArvGcString_autoptr = Ptr{ArvGcString}

const ArvGcString_listautoptr = Ptr{GList}

const ArvGcString_slistautoptr = Ptr{GSList}

const ArvGcString_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcString(_ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcString, arv_gc_string, ARV, GC_STRING, GObject);
```
"""
function glib_autoptr_clear_ArvGcString(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcString(_ptr::Ptr{ArvGcString})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcString(_ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcString, arv_gc_string, ARV, GC_STRING, GObject);
```
"""
function glib_autoptr_cleanup_ArvGcString(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcString(_ptr::Ptr{Ptr{ArvGcString}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcString(_ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcString, arv_gc_string, ARV, GC_STRING, GObject);
```
"""
function glib_autoptr_destroy_ArvGcString(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcString(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcString(_l)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcString, arv_gc_string, ARV, GC_STRING, GObject);
```
"""
function glib_listautoptr_cleanup_ArvGcString(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcString(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcString(_l)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcString, arv_gc_string, ARV, GC_STRING, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvGcString(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcString(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcString(_q)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcString, arv_gc_string, ARV, GC_STRING, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvGcString(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcString(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_STRING(ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcString, arv_gc_string, ARV, GC_STRING, GObject);
```
"""
function ARV_GC_STRING(ptr)
    @ccall libaravis.ARV_GC_STRING(ptr::gpointer)::Ptr{ArvGcString}
end

"""
    ARV_IS_GC_STRING(ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcString, arv_gc_string, ARV, GC_STRING, GObject);
```
"""
function ARV_IS_GC_STRING(ptr)
    @ccall libaravis.ARV_IS_GC_STRING(ptr::gpointer)::gboolean
end

"""
    ARV_GC_STRING_GET_IFACE(ptr)

### Prototype
```c
G_DECLARE_INTERFACE (ArvGcString, arv_gc_string, ARV, GC_STRING, GObject);
```
"""
function ARV_GC_STRING_GET_IFACE(ptr)
    @ccall libaravis.ARV_GC_STRING_GET_IFACE(ptr::gpointer)::Ptr{ArvGcStringInterface}
end

"""
    arv_gc_string_get_value(gc_string, error)

### Prototype
```c
ARV_API const char * arv_gc_string_get_value (ArvGcString *gc_string, GError **error);
```
"""
function arv_gc_string_get_value(gc_string, error)
    @ccall libaravis.arv_gc_string_get_value(gc_string::Ptr{ArvGcString}, error::Ptr{Ptr{GError}})::Cstring
end

"""
    arv_gc_string_set_value(gc_string, value, error)

### Prototype
```c
ARV_API void arv_gc_string_set_value (ArvGcString *gc_string, const char *value, GError **error);
```
"""
function arv_gc_string_set_value(gc_string, value, error)
    @ccall libaravis.arv_gc_string_set_value(gc_string::Ptr{ArvGcString}, value::Cstring, error::Ptr{Ptr{GError}})::Cvoid
end

"""
    arv_gc_string_get_max_length(gc_string, error)

### Prototype
```c
ARV_API gint64 arv_gc_string_get_max_length (ArvGcString *gc_string, GError **error);
```
"""
function arv_gc_string_get_max_length(gc_string, error)
    @ccall libaravis.arv_gc_string_get_max_length(gc_string::Ptr{ArvGcString}, error::Ptr{Ptr{GError}})::gint64
end

const _ArvGcStringNode = Cvoid

const ArvGcStringNode = _ArvGcStringNode

struct ArvGcStringNodeClass
    parent_class::ArvGcFeatureNodeClass
end

const ArvGcStringNode_autoptr = Ptr{ArvGcStringNode}

const ArvGcStringNode_listautoptr = Ptr{GList}

const ArvGcStringNode_slistautoptr = Ptr{GSList}

const ArvGcStringNode_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcStringNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcStringNode, arv_gc_string_node, ARV, GC_STRING_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcStringNode(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcStringNode(_ptr::Ptr{ArvGcStringNode})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcStringNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcStringNode, arv_gc_string_node, ARV, GC_STRING_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcStringNode(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcStringNode(_ptr::Ptr{Ptr{ArvGcStringNode}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcStringNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcStringNode, arv_gc_string_node, ARV, GC_STRING_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcStringNode(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcStringNode(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcStringNode(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcStringNode, arv_gc_string_node, ARV, GC_STRING_NODE, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcStringNode(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcStringNode(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcStringNode(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcStringNode, arv_gc_string_node, ARV, GC_STRING_NODE, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcStringNode(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcStringNode(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcStringNode(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcStringNode, arv_gc_string_node, ARV, GC_STRING_NODE, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcStringNode(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcStringNode(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcStringNodeClass_autoptr = Ptr{ArvGcStringNodeClass}

const ArvGcStringNodeClass_listautoptr = Ptr{GList}

const ArvGcStringNodeClass_slistautoptr = Ptr{GSList}

const ArvGcStringNodeClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcStringNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcStringNode, arv_gc_string_node, ARV, GC_STRING_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcStringNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcStringNodeClass(_ptr::Ptr{ArvGcStringNodeClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcStringNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcStringNode, arv_gc_string_node, ARV, GC_STRING_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcStringNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcStringNodeClass(_ptr::Ptr{Ptr{ArvGcStringNodeClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcStringNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcStringNode, arv_gc_string_node, ARV, GC_STRING_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcStringNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcStringNodeClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcStringNodeClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcStringNode, arv_gc_string_node, ARV, GC_STRING_NODE, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcStringNodeClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcStringNodeClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcStringNodeClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcStringNode, arv_gc_string_node, ARV, GC_STRING_NODE, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcStringNodeClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcStringNodeClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcStringNodeClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcStringNode, arv_gc_string_node, ARV, GC_STRING_NODE, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcStringNodeClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcStringNodeClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_STRING_NODE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcStringNode, arv_gc_string_node, ARV, GC_STRING_NODE, ArvGcFeatureNode);
```
"""
function ARV_GC_STRING_NODE(ptr)
    @ccall libaravis.ARV_GC_STRING_NODE(ptr::gpointer)::Ptr{ArvGcStringNode}
end

"""
    ARV_IS_GC_STRING_NODE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcStringNode, arv_gc_string_node, ARV, GC_STRING_NODE, ArvGcFeatureNode);
```
"""
function ARV_IS_GC_STRING_NODE(ptr)
    @ccall libaravis.ARV_IS_GC_STRING_NODE(ptr::gpointer)::gboolean
end

"""
    arv_gc_string_node_new()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_string_node_new (void);
```
"""
function arv_gc_string_node_new()
    @ccall libaravis.arv_gc_string_node_new()::Ptr{ArvGcNode}
end

struct _ArvGcStringRegNode
    parent_instance::ArvGcRegisterNode
end

const ArvGcStringRegNode = _ArvGcStringRegNode

struct _ArvGcStringRegNodeClass
    parent_class::ArvGcRegisterNodeClass
end

const ArvGcStringRegNodeClass = _ArvGcStringRegNodeClass

const ArvGcStringRegNode_autoptr = Ptr{ArvGcStringRegNode}

const ArvGcStringRegNode_listautoptr = Ptr{GList}

const ArvGcStringRegNode_slistautoptr = Ptr{GSList}

const ArvGcStringRegNode_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcStringRegNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStringRegNode, arv_gc_string_reg_node, ARV, GC_STRING_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_clear_ArvGcStringRegNode(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcStringRegNode(_ptr::Ptr{ArvGcStringRegNode})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcStringRegNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStringRegNode, arv_gc_string_reg_node, ARV, GC_STRING_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_cleanup_ArvGcStringRegNode(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcStringRegNode(_ptr::Ptr{Ptr{ArvGcStringRegNode}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcStringRegNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStringRegNode, arv_gc_string_reg_node, ARV, GC_STRING_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_destroy_ArvGcStringRegNode(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcStringRegNode(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcStringRegNode(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStringRegNode, arv_gc_string_reg_node, ARV, GC_STRING_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_listautoptr_cleanup_ArvGcStringRegNode(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcStringRegNode(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcStringRegNode(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStringRegNode, arv_gc_string_reg_node, ARV, GC_STRING_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcStringRegNode(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcStringRegNode(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcStringRegNode(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStringRegNode, arv_gc_string_reg_node, ARV, GC_STRING_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcStringRegNode(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcStringRegNode(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcStringRegNodeClass_autoptr = Ptr{ArvGcStringRegNodeClass}

const ArvGcStringRegNodeClass_listautoptr = Ptr{GList}

const ArvGcStringRegNodeClass_slistautoptr = Ptr{GSList}

const ArvGcStringRegNodeClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcStringRegNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStringRegNode, arv_gc_string_reg_node, ARV, GC_STRING_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_clear_ArvGcStringRegNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcStringRegNodeClass(_ptr::Ptr{ArvGcStringRegNodeClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcStringRegNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStringRegNode, arv_gc_string_reg_node, ARV, GC_STRING_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_cleanup_ArvGcStringRegNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcStringRegNodeClass(_ptr::Ptr{Ptr{ArvGcStringRegNodeClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcStringRegNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStringRegNode, arv_gc_string_reg_node, ARV, GC_STRING_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_destroy_ArvGcStringRegNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcStringRegNodeClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcStringRegNodeClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStringRegNode, arv_gc_string_reg_node, ARV, GC_STRING_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_listautoptr_cleanup_ArvGcStringRegNodeClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcStringRegNodeClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcStringRegNodeClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStringRegNode, arv_gc_string_reg_node, ARV, GC_STRING_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcStringRegNodeClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcStringRegNodeClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcStringRegNodeClass(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStringRegNode, arv_gc_string_reg_node, ARV, GC_STRING_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcStringRegNodeClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcStringRegNodeClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_STRING_REG_NODE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStringRegNode, arv_gc_string_reg_node, ARV, GC_STRING_REG_NODE, ArvGcRegisterNode);
```
"""
function ARV_GC_STRING_REG_NODE(ptr)
    @ccall libaravis.ARV_GC_STRING_REG_NODE(ptr::gpointer)::Ptr{ArvGcStringRegNode}
end

"""
    ARV_GC_STRING_REG_NODE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStringRegNode, arv_gc_string_reg_node, ARV, GC_STRING_REG_NODE, ArvGcRegisterNode);
```
"""
function ARV_GC_STRING_REG_NODE_CLASS(ptr)
    @ccall libaravis.ARV_GC_STRING_REG_NODE_CLASS(ptr::gpointer)::Ptr{ArvGcStringRegNodeClass}
end

"""
    ARV_IS_GC_STRING_REG_NODE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStringRegNode, arv_gc_string_reg_node, ARV, GC_STRING_REG_NODE, ArvGcRegisterNode);
```
"""
function ARV_IS_GC_STRING_REG_NODE(ptr)
    @ccall libaravis.ARV_IS_GC_STRING_REG_NODE(ptr::gpointer)::gboolean
end

"""
    ARV_IS_GC_STRING_REG_NODE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStringRegNode, arv_gc_string_reg_node, ARV, GC_STRING_REG_NODE, ArvGcRegisterNode);
```
"""
function ARV_IS_GC_STRING_REG_NODE_CLASS(ptr)
    @ccall libaravis.ARV_IS_GC_STRING_REG_NODE_CLASS(ptr::gpointer)::gboolean
end

"""
    ARV_GC_STRING_REG_NODE_GET_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStringRegNode, arv_gc_string_reg_node, ARV, GC_STRING_REG_NODE, ArvGcRegisterNode);
```
"""
function ARV_GC_STRING_REG_NODE_GET_CLASS(ptr)
    @ccall libaravis.ARV_GC_STRING_REG_NODE_GET_CLASS(ptr::gpointer)::Ptr{ArvGcStringRegNodeClass}
end

"""
    arv_gc_string_reg_node_new()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_string_reg_node_new (void);
```
"""
function arv_gc_string_reg_node_new()
    @ccall libaravis.arv_gc_string_reg_node_new()::Ptr{ArvGcNode}
end

struct _ArvGcStructRegNode
    parent_instance::ArvGcRegisterNode
end

const ArvGcStructRegNode = _ArvGcStructRegNode

struct _ArvGcStructRegNodeClass
    parent_class::ArvGcRegisterNodeClass
end

const ArvGcStructRegNodeClass = _ArvGcStructRegNodeClass

const ArvGcStructRegNode_autoptr = Ptr{ArvGcStructRegNode}

const ArvGcStructRegNode_listautoptr = Ptr{GList}

const ArvGcStructRegNode_slistautoptr = Ptr{GSList}

const ArvGcStructRegNode_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcStructRegNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStructRegNode, arv_gc_struct_reg_node, ARV, GC_STRUCT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_clear_ArvGcStructRegNode(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcStructRegNode(_ptr::Ptr{ArvGcStructRegNode})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcStructRegNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStructRegNode, arv_gc_struct_reg_node, ARV, GC_STRUCT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_cleanup_ArvGcStructRegNode(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcStructRegNode(_ptr::Ptr{Ptr{ArvGcStructRegNode}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcStructRegNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStructRegNode, arv_gc_struct_reg_node, ARV, GC_STRUCT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_destroy_ArvGcStructRegNode(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcStructRegNode(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcStructRegNode(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStructRegNode, arv_gc_struct_reg_node, ARV, GC_STRUCT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_listautoptr_cleanup_ArvGcStructRegNode(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcStructRegNode(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcStructRegNode(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStructRegNode, arv_gc_struct_reg_node, ARV, GC_STRUCT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcStructRegNode(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcStructRegNode(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcStructRegNode(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStructRegNode, arv_gc_struct_reg_node, ARV, GC_STRUCT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcStructRegNode(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcStructRegNode(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcStructRegNodeClass_autoptr = Ptr{ArvGcStructRegNodeClass}

const ArvGcStructRegNodeClass_listautoptr = Ptr{GList}

const ArvGcStructRegNodeClass_slistautoptr = Ptr{GSList}

const ArvGcStructRegNodeClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcStructRegNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStructRegNode, arv_gc_struct_reg_node, ARV, GC_STRUCT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_clear_ArvGcStructRegNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcStructRegNodeClass(_ptr::Ptr{ArvGcStructRegNodeClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcStructRegNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStructRegNode, arv_gc_struct_reg_node, ARV, GC_STRUCT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_cleanup_ArvGcStructRegNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcStructRegNodeClass(_ptr::Ptr{Ptr{ArvGcStructRegNodeClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcStructRegNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStructRegNode, arv_gc_struct_reg_node, ARV, GC_STRUCT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_autoptr_destroy_ArvGcStructRegNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcStructRegNodeClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcStructRegNodeClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStructRegNode, arv_gc_struct_reg_node, ARV, GC_STRUCT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_listautoptr_cleanup_ArvGcStructRegNodeClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcStructRegNodeClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcStructRegNodeClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStructRegNode, arv_gc_struct_reg_node, ARV, GC_STRUCT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcStructRegNodeClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcStructRegNodeClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcStructRegNodeClass(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStructRegNode, arv_gc_struct_reg_node, ARV, GC_STRUCT_REG_NODE, ArvGcRegisterNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcStructRegNodeClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcStructRegNodeClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_STRUCT_REG_NODE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStructRegNode, arv_gc_struct_reg_node, ARV, GC_STRUCT_REG_NODE, ArvGcRegisterNode);
```
"""
function ARV_GC_STRUCT_REG_NODE(ptr)
    @ccall libaravis.ARV_GC_STRUCT_REG_NODE(ptr::gpointer)::Ptr{ArvGcStructRegNode}
end

"""
    ARV_GC_STRUCT_REG_NODE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStructRegNode, arv_gc_struct_reg_node, ARV, GC_STRUCT_REG_NODE, ArvGcRegisterNode);
```
"""
function ARV_GC_STRUCT_REG_NODE_CLASS(ptr)
    @ccall libaravis.ARV_GC_STRUCT_REG_NODE_CLASS(ptr::gpointer)::Ptr{ArvGcStructRegNodeClass}
end

"""
    ARV_IS_GC_STRUCT_REG_NODE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStructRegNode, arv_gc_struct_reg_node, ARV, GC_STRUCT_REG_NODE, ArvGcRegisterNode);
```
"""
function ARV_IS_GC_STRUCT_REG_NODE(ptr)
    @ccall libaravis.ARV_IS_GC_STRUCT_REG_NODE(ptr::gpointer)::gboolean
end

"""
    ARV_IS_GC_STRUCT_REG_NODE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStructRegNode, arv_gc_struct_reg_node, ARV, GC_STRUCT_REG_NODE, ArvGcRegisterNode);
```
"""
function ARV_IS_GC_STRUCT_REG_NODE_CLASS(ptr)
    @ccall libaravis.ARV_IS_GC_STRUCT_REG_NODE_CLASS(ptr::gpointer)::gboolean
end

"""
    ARV_GC_STRUCT_REG_NODE_GET_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcStructRegNode, arv_gc_struct_reg_node, ARV, GC_STRUCT_REG_NODE, ArvGcRegisterNode);
```
"""
function ARV_GC_STRUCT_REG_NODE_GET_CLASS(ptr)
    @ccall libaravis.ARV_GC_STRUCT_REG_NODE_GET_CLASS(ptr::gpointer)::Ptr{ArvGcStructRegNodeClass}
end

"""
    arv_gc_struct_reg_node_new()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_struct_reg_node_new (void);
```
"""
function arv_gc_struct_reg_node_new()
    @ccall libaravis.arv_gc_struct_reg_node_new()::Ptr{ArvGcNode}
end

struct ArvGcStructEntryNodeClass
    parent_class::ArvGcFeatureNodeClass
end

const ArvGcStructEntryNode_autoptr = Ptr{ArvGcStructEntryNode}

const ArvGcStructEntryNode_listautoptr = Ptr{GList}

const ArvGcStructEntryNode_slistautoptr = Ptr{GSList}

const ArvGcStructEntryNode_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcStructEntryNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcStructEntryNode, arv_gc_struct_entry_node, ARV, GC_STRUCT_ENTRY_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcStructEntryNode(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcStructEntryNode(_ptr::Ptr{ArvGcStructEntryNode})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcStructEntryNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcStructEntryNode, arv_gc_struct_entry_node, ARV, GC_STRUCT_ENTRY_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcStructEntryNode(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcStructEntryNode(_ptr::Ptr{Ptr{ArvGcStructEntryNode}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcStructEntryNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcStructEntryNode, arv_gc_struct_entry_node, ARV, GC_STRUCT_ENTRY_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcStructEntryNode(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcStructEntryNode(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcStructEntryNode(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcStructEntryNode, arv_gc_struct_entry_node, ARV, GC_STRUCT_ENTRY_NODE, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcStructEntryNode(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcStructEntryNode(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcStructEntryNode(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcStructEntryNode, arv_gc_struct_entry_node, ARV, GC_STRUCT_ENTRY_NODE, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcStructEntryNode(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcStructEntryNode(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcStructEntryNode(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcStructEntryNode, arv_gc_struct_entry_node, ARV, GC_STRUCT_ENTRY_NODE, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcStructEntryNode(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcStructEntryNode(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcStructEntryNodeClass_autoptr = Ptr{ArvGcStructEntryNodeClass}

const ArvGcStructEntryNodeClass_listautoptr = Ptr{GList}

const ArvGcStructEntryNodeClass_slistautoptr = Ptr{GSList}

const ArvGcStructEntryNodeClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcStructEntryNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcStructEntryNode, arv_gc_struct_entry_node, ARV, GC_STRUCT_ENTRY_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_clear_ArvGcStructEntryNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcStructEntryNodeClass(_ptr::Ptr{ArvGcStructEntryNodeClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcStructEntryNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcStructEntryNode, arv_gc_struct_entry_node, ARV, GC_STRUCT_ENTRY_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_cleanup_ArvGcStructEntryNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcStructEntryNodeClass(_ptr::Ptr{Ptr{ArvGcStructEntryNodeClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcStructEntryNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcStructEntryNode, arv_gc_struct_entry_node, ARV, GC_STRUCT_ENTRY_NODE, ArvGcFeatureNode);
```
"""
function glib_autoptr_destroy_ArvGcStructEntryNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcStructEntryNodeClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcStructEntryNodeClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcStructEntryNode, arv_gc_struct_entry_node, ARV, GC_STRUCT_ENTRY_NODE, ArvGcFeatureNode);
```
"""
function glib_listautoptr_cleanup_ArvGcStructEntryNodeClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcStructEntryNodeClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcStructEntryNodeClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcStructEntryNode, arv_gc_struct_entry_node, ARV, GC_STRUCT_ENTRY_NODE, ArvGcFeatureNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcStructEntryNodeClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcStructEntryNodeClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcStructEntryNodeClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcStructEntryNode, arv_gc_struct_entry_node, ARV, GC_STRUCT_ENTRY_NODE, ArvGcFeatureNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcStructEntryNodeClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcStructEntryNodeClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_STRUCT_ENTRY_NODE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcStructEntryNode, arv_gc_struct_entry_node, ARV, GC_STRUCT_ENTRY_NODE, ArvGcFeatureNode);
```
"""
function ARV_GC_STRUCT_ENTRY_NODE(ptr)
    @ccall libaravis.ARV_GC_STRUCT_ENTRY_NODE(ptr::gpointer)::Ptr{ArvGcStructEntryNode}
end

"""
    ARV_IS_GC_STRUCT_ENTRY_NODE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcStructEntryNode, arv_gc_struct_entry_node, ARV, GC_STRUCT_ENTRY_NODE, ArvGcFeatureNode);
```
"""
function ARV_IS_GC_STRUCT_ENTRY_NODE(ptr)
    @ccall libaravis.ARV_IS_GC_STRUCT_ENTRY_NODE(ptr::gpointer)::gboolean
end

"""
    arv_gc_struct_entry_node_new()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_struct_entry_node_new (void);
```
"""
function arv_gc_struct_entry_node_new()
    @ccall libaravis.arv_gc_struct_entry_node_new()::Ptr{ArvGcNode}
end

struct _ArvGcSwissKnifeNode
    parent_instance::ArvGcSwissKnife
end

const ArvGcSwissKnifeNode = _ArvGcSwissKnifeNode

struct _ArvGcSwissKnifeNodeClass
    parent_class::ArvGcSwissKnifeClass
end

const ArvGcSwissKnifeNodeClass = _ArvGcSwissKnifeNodeClass

const ArvGcSwissKnifeNode_autoptr = Ptr{ArvGcSwissKnifeNode}

const ArvGcSwissKnifeNode_listautoptr = Ptr{GList}

const ArvGcSwissKnifeNode_slistautoptr = Ptr{GSList}

const ArvGcSwissKnifeNode_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcSwissKnifeNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnifeNode, arv_gc_swiss_knife_node, ARV, GC_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function glib_autoptr_clear_ArvGcSwissKnifeNode(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcSwissKnifeNode(_ptr::Ptr{ArvGcSwissKnifeNode})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcSwissKnifeNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnifeNode, arv_gc_swiss_knife_node, ARV, GC_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function glib_autoptr_cleanup_ArvGcSwissKnifeNode(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcSwissKnifeNode(_ptr::Ptr{Ptr{ArvGcSwissKnifeNode}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcSwissKnifeNode(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnifeNode, arv_gc_swiss_knife_node, ARV, GC_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function glib_autoptr_destroy_ArvGcSwissKnifeNode(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcSwissKnifeNode(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcSwissKnifeNode(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnifeNode, arv_gc_swiss_knife_node, ARV, GC_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function glib_listautoptr_cleanup_ArvGcSwissKnifeNode(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcSwissKnifeNode(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcSwissKnifeNode(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnifeNode, arv_gc_swiss_knife_node, ARV, GC_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function glib_slistautoptr_cleanup_ArvGcSwissKnifeNode(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcSwissKnifeNode(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcSwissKnifeNode(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnifeNode, arv_gc_swiss_knife_node, ARV, GC_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function glib_queueautoptr_cleanup_ArvGcSwissKnifeNode(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcSwissKnifeNode(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcSwissKnifeNodeClass_autoptr = Ptr{ArvGcSwissKnifeNodeClass}

const ArvGcSwissKnifeNodeClass_listautoptr = Ptr{GList}

const ArvGcSwissKnifeNodeClass_slistautoptr = Ptr{GSList}

const ArvGcSwissKnifeNodeClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcSwissKnifeNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnifeNode, arv_gc_swiss_knife_node, ARV, GC_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function glib_autoptr_clear_ArvGcSwissKnifeNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcSwissKnifeNodeClass(_ptr::Ptr{ArvGcSwissKnifeNodeClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcSwissKnifeNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnifeNode, arv_gc_swiss_knife_node, ARV, GC_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function glib_autoptr_cleanup_ArvGcSwissKnifeNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcSwissKnifeNodeClass(_ptr::Ptr{Ptr{ArvGcSwissKnifeNodeClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcSwissKnifeNodeClass(_ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnifeNode, arv_gc_swiss_knife_node, ARV, GC_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function glib_autoptr_destroy_ArvGcSwissKnifeNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcSwissKnifeNodeClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcSwissKnifeNodeClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnifeNode, arv_gc_swiss_knife_node, ARV, GC_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function glib_listautoptr_cleanup_ArvGcSwissKnifeNodeClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcSwissKnifeNodeClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcSwissKnifeNodeClass(_l)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnifeNode, arv_gc_swiss_knife_node, ARV, GC_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function glib_slistautoptr_cleanup_ArvGcSwissKnifeNodeClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcSwissKnifeNodeClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcSwissKnifeNodeClass(_q)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnifeNode, arv_gc_swiss_knife_node, ARV, GC_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function glib_queueautoptr_cleanup_ArvGcSwissKnifeNodeClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcSwissKnifeNodeClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_SWISS_KNIFE_NODE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnifeNode, arv_gc_swiss_knife_node, ARV, GC_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function ARV_GC_SWISS_KNIFE_NODE(ptr)
    @ccall libaravis.ARV_GC_SWISS_KNIFE_NODE(ptr::gpointer)::Ptr{ArvGcSwissKnifeNode}
end

"""
    ARV_GC_SWISS_KNIFE_NODE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnifeNode, arv_gc_swiss_knife_node, ARV, GC_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function ARV_GC_SWISS_KNIFE_NODE_CLASS(ptr)
    @ccall libaravis.ARV_GC_SWISS_KNIFE_NODE_CLASS(ptr::gpointer)::Ptr{ArvGcSwissKnifeNodeClass}
end

"""
    ARV_IS_GC_SWISS_KNIFE_NODE(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnifeNode, arv_gc_swiss_knife_node, ARV, GC_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function ARV_IS_GC_SWISS_KNIFE_NODE(ptr)
    @ccall libaravis.ARV_IS_GC_SWISS_KNIFE_NODE(ptr::gpointer)::gboolean
end

"""
    ARV_IS_GC_SWISS_KNIFE_NODE_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnifeNode, arv_gc_swiss_knife_node, ARV, GC_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function ARV_IS_GC_SWISS_KNIFE_NODE_CLASS(ptr)
    @ccall libaravis.ARV_IS_GC_SWISS_KNIFE_NODE_CLASS(ptr::gpointer)::gboolean
end

"""
    ARV_GC_SWISS_KNIFE_NODE_GET_CLASS(ptr)

### Prototype
```c
G_DECLARE_DERIVABLE_TYPE (ArvGcSwissKnifeNode, arv_gc_swiss_knife_node, ARV, GC_SWISS_KNIFE_NODE, ArvGcSwissKnife);
```
"""
function ARV_GC_SWISS_KNIFE_NODE_GET_CLASS(ptr)
    @ccall libaravis.ARV_GC_SWISS_KNIFE_NODE_GET_CLASS(ptr::gpointer)::Ptr{ArvGcSwissKnifeNodeClass}
end

"""
    arv_gc_swiss_knife_node_new()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_swiss_knife_node_new (void);
```
"""
function arv_gc_swiss_knife_node_new()
    @ccall libaravis.arv_gc_swiss_knife_node_new()::Ptr{ArvGcNode}
end

struct ArvGcValueIndexedNodeClass
    parent_class::ArvGcPropertyNodeClass
end

const ArvGcValueIndexedNode_autoptr = Ptr{ArvGcValueIndexedNode}

const ArvGcValueIndexedNode_listautoptr = Ptr{GList}

const ArvGcValueIndexedNode_slistautoptr = Ptr{GSList}

const ArvGcValueIndexedNode_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcValueIndexedNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcValueIndexedNode, arv_gc_value_indexed_node, ARV, GC_VALUE_INDEXED_NODE, ArvGcPropertyNode);
```
"""
function glib_autoptr_clear_ArvGcValueIndexedNode(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcValueIndexedNode(_ptr::Ptr{ArvGcValueIndexedNode})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcValueIndexedNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcValueIndexedNode, arv_gc_value_indexed_node, ARV, GC_VALUE_INDEXED_NODE, ArvGcPropertyNode);
```
"""
function glib_autoptr_cleanup_ArvGcValueIndexedNode(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcValueIndexedNode(_ptr::Ptr{Ptr{ArvGcValueIndexedNode}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcValueIndexedNode(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcValueIndexedNode, arv_gc_value_indexed_node, ARV, GC_VALUE_INDEXED_NODE, ArvGcPropertyNode);
```
"""
function glib_autoptr_destroy_ArvGcValueIndexedNode(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcValueIndexedNode(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcValueIndexedNode(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcValueIndexedNode, arv_gc_value_indexed_node, ARV, GC_VALUE_INDEXED_NODE, ArvGcPropertyNode);
```
"""
function glib_listautoptr_cleanup_ArvGcValueIndexedNode(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcValueIndexedNode(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcValueIndexedNode(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcValueIndexedNode, arv_gc_value_indexed_node, ARV, GC_VALUE_INDEXED_NODE, ArvGcPropertyNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcValueIndexedNode(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcValueIndexedNode(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcValueIndexedNode(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcValueIndexedNode, arv_gc_value_indexed_node, ARV, GC_VALUE_INDEXED_NODE, ArvGcPropertyNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcValueIndexedNode(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcValueIndexedNode(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGcValueIndexedNodeClass_autoptr = Ptr{ArvGcValueIndexedNodeClass}

const ArvGcValueIndexedNodeClass_listautoptr = Ptr{GList}

const ArvGcValueIndexedNodeClass_slistautoptr = Ptr{GSList}

const ArvGcValueIndexedNodeClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGcValueIndexedNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcValueIndexedNode, arv_gc_value_indexed_node, ARV, GC_VALUE_INDEXED_NODE, ArvGcPropertyNode);
```
"""
function glib_autoptr_clear_ArvGcValueIndexedNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGcValueIndexedNodeClass(_ptr::Ptr{ArvGcValueIndexedNodeClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGcValueIndexedNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcValueIndexedNode, arv_gc_value_indexed_node, ARV, GC_VALUE_INDEXED_NODE, ArvGcPropertyNode);
```
"""
function glib_autoptr_cleanup_ArvGcValueIndexedNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGcValueIndexedNodeClass(_ptr::Ptr{Ptr{ArvGcValueIndexedNodeClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGcValueIndexedNodeClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcValueIndexedNode, arv_gc_value_indexed_node, ARV, GC_VALUE_INDEXED_NODE, ArvGcPropertyNode);
```
"""
function glib_autoptr_destroy_ArvGcValueIndexedNodeClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGcValueIndexedNodeClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGcValueIndexedNodeClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcValueIndexedNode, arv_gc_value_indexed_node, ARV, GC_VALUE_INDEXED_NODE, ArvGcPropertyNode);
```
"""
function glib_listautoptr_cleanup_ArvGcValueIndexedNodeClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGcValueIndexedNodeClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGcValueIndexedNodeClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcValueIndexedNode, arv_gc_value_indexed_node, ARV, GC_VALUE_INDEXED_NODE, ArvGcPropertyNode);
```
"""
function glib_slistautoptr_cleanup_ArvGcValueIndexedNodeClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGcValueIndexedNodeClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGcValueIndexedNodeClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcValueIndexedNode, arv_gc_value_indexed_node, ARV, GC_VALUE_INDEXED_NODE, ArvGcPropertyNode);
```
"""
function glib_queueautoptr_cleanup_ArvGcValueIndexedNodeClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGcValueIndexedNodeClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GC_VALUE_INDEXED_NODE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcValueIndexedNode, arv_gc_value_indexed_node, ARV, GC_VALUE_INDEXED_NODE, ArvGcPropertyNode);
```
"""
function ARV_GC_VALUE_INDEXED_NODE(ptr)
    @ccall libaravis.ARV_GC_VALUE_INDEXED_NODE(ptr::gpointer)::Ptr{ArvGcValueIndexedNode}
end

"""
    ARV_IS_GC_VALUE_INDEXED_NODE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGcValueIndexedNode, arv_gc_value_indexed_node, ARV, GC_VALUE_INDEXED_NODE, ArvGcPropertyNode);
```
"""
function ARV_IS_GC_VALUE_INDEXED_NODE(ptr)
    @ccall libaravis.ARV_IS_GC_VALUE_INDEXED_NODE(ptr::gpointer)::gboolean
end

"""
    arv_gc_value_indexed_node_new()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_value_indexed_node_new (void);
```
"""
function arv_gc_value_indexed_node_new()
    @ccall libaravis.arv_gc_value_indexed_node_new()::Ptr{ArvGcNode}
end

"""
    arv_gc_p_value_indexed_node_new()

### Prototype
```c
ARV_API ArvGcNode * arv_gc_p_value_indexed_node_new (void);
```
"""
function arv_gc_p_value_indexed_node_new()
    @ccall libaravis.arv_gc_p_value_indexed_node_new()::Ptr{ArvGcNode}
end

"""
    arv_gc_value_indexed_node_get_index(value_indexed_node)

### Prototype
```c
ARV_API gint64 arv_gc_value_indexed_node_get_index (ArvGcValueIndexedNode *value_indexed_node);
```
"""
function arv_gc_value_indexed_node_get_index(value_indexed_node)
    @ccall libaravis.arv_gc_value_indexed_node_get_index(value_indexed_node::Ptr{ArvGcValueIndexedNode})::gint64
end

struct ArvGvFakeCameraClass
    parent_class::GObjectClass
end

const ArvGvFakeCamera_autoptr = Ptr{ArvGvFakeCamera}

const ArvGvFakeCamera_listautoptr = Ptr{GList}

const ArvGvFakeCamera_slistautoptr = Ptr{GSList}

const ArvGvFakeCamera_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGvFakeCamera(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvFakeCamera, arv_gv_fake_camera, ARV, GV_FAKE_CAMERA, GObject);
```
"""
function glib_autoptr_clear_ArvGvFakeCamera(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGvFakeCamera(_ptr::Ptr{ArvGvFakeCamera})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGvFakeCamera(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvFakeCamera, arv_gv_fake_camera, ARV, GV_FAKE_CAMERA, GObject);
```
"""
function glib_autoptr_cleanup_ArvGvFakeCamera(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGvFakeCamera(_ptr::Ptr{Ptr{ArvGvFakeCamera}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGvFakeCamera(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvFakeCamera, arv_gv_fake_camera, ARV, GV_FAKE_CAMERA, GObject);
```
"""
function glib_autoptr_destroy_ArvGvFakeCamera(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGvFakeCamera(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGvFakeCamera(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvFakeCamera, arv_gv_fake_camera, ARV, GV_FAKE_CAMERA, GObject);
```
"""
function glib_listautoptr_cleanup_ArvGvFakeCamera(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGvFakeCamera(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGvFakeCamera(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvFakeCamera, arv_gv_fake_camera, ARV, GV_FAKE_CAMERA, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvGvFakeCamera(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGvFakeCamera(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGvFakeCamera(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvFakeCamera, arv_gv_fake_camera, ARV, GV_FAKE_CAMERA, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvGvFakeCamera(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGvFakeCamera(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGvFakeCameraClass_autoptr = Ptr{ArvGvFakeCameraClass}

const ArvGvFakeCameraClass_listautoptr = Ptr{GList}

const ArvGvFakeCameraClass_slistautoptr = Ptr{GSList}

const ArvGvFakeCameraClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGvFakeCameraClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvFakeCamera, arv_gv_fake_camera, ARV, GV_FAKE_CAMERA, GObject);
```
"""
function glib_autoptr_clear_ArvGvFakeCameraClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGvFakeCameraClass(_ptr::Ptr{ArvGvFakeCameraClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGvFakeCameraClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvFakeCamera, arv_gv_fake_camera, ARV, GV_FAKE_CAMERA, GObject);
```
"""
function glib_autoptr_cleanup_ArvGvFakeCameraClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGvFakeCameraClass(_ptr::Ptr{Ptr{ArvGvFakeCameraClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGvFakeCameraClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvFakeCamera, arv_gv_fake_camera, ARV, GV_FAKE_CAMERA, GObject);
```
"""
function glib_autoptr_destroy_ArvGvFakeCameraClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGvFakeCameraClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGvFakeCameraClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvFakeCamera, arv_gv_fake_camera, ARV, GV_FAKE_CAMERA, GObject);
```
"""
function glib_listautoptr_cleanup_ArvGvFakeCameraClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGvFakeCameraClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGvFakeCameraClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvFakeCamera, arv_gv_fake_camera, ARV, GV_FAKE_CAMERA, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvGvFakeCameraClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGvFakeCameraClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGvFakeCameraClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvFakeCamera, arv_gv_fake_camera, ARV, GV_FAKE_CAMERA, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvGvFakeCameraClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGvFakeCameraClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GV_FAKE_CAMERA(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvFakeCamera, arv_gv_fake_camera, ARV, GV_FAKE_CAMERA, GObject);
```
"""
function ARV_GV_FAKE_CAMERA(ptr)
    @ccall libaravis.ARV_GV_FAKE_CAMERA(ptr::gpointer)::Ptr{ArvGvFakeCamera}
end

"""
    ARV_IS_GV_FAKE_CAMERA(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvFakeCamera, arv_gv_fake_camera, ARV, GV_FAKE_CAMERA, GObject);
```
"""
function ARV_IS_GV_FAKE_CAMERA(ptr)
    @ccall libaravis.ARV_IS_GV_FAKE_CAMERA(ptr::gpointer)::gboolean
end

"""
    arv_gv_fake_camera_new(interface_name, serial_number)

### Prototype
```c
ARV_API ArvGvFakeCamera * arv_gv_fake_camera_new (const char *interface_name, const char *serial_number);
```
"""
function arv_gv_fake_camera_new(interface_name, serial_number)
    @ccall libaravis.arv_gv_fake_camera_new(interface_name::Cstring, serial_number::Cstring)::Ptr{ArvGvFakeCamera}
end

"""
    arv_gv_fake_camera_new_full(interface_name, serial_number, genicam_filename)

### Prototype
```c
ARV_API ArvGvFakeCamera * arv_gv_fake_camera_new_full (const char *interface_name, const char *serial_number, const char *genicam_filename);
```
"""
function arv_gv_fake_camera_new_full(interface_name, serial_number, genicam_filename)
    @ccall libaravis.arv_gv_fake_camera_new_full(interface_name::Cstring, serial_number::Cstring, genicam_filename::Cstring)::Ptr{ArvGvFakeCamera}
end

"""
    arv_gv_fake_camera_is_running(gv_fake_camera)

### Prototype
```c
ARV_API gboolean arv_gv_fake_camera_is_running (ArvGvFakeCamera *gv_fake_camera);
```
"""
function arv_gv_fake_camera_is_running(gv_fake_camera)
    @ccall libaravis.arv_gv_fake_camera_is_running(gv_fake_camera::Ptr{ArvGvFakeCamera})::gboolean
end

"""
    arv_gv_fake_camera_get_fake_camera(gv_fake_camera)

### Prototype
```c
ARV_API ArvFakeCamera * arv_gv_fake_camera_get_fake_camera (ArvGvFakeCamera *gv_fake_camera);
```
"""
function arv_gv_fake_camera_get_fake_camera(gv_fake_camera)
    @ccall libaravis.arv_gv_fake_camera_get_fake_camera(gv_fake_camera::Ptr{ArvGvFakeCamera})::Ptr{ArvFakeCamera}
end

"""
    ArvGvInterfaceFlags

[`ArvGvInterfaceFlags`](@ref): \\_GV\\_INTERFACE\\_FLAGS\\_ALLOW\\_BROADCAST\\_DISCOVERY\\_ACK: allow gv devices to broadcast the discovery acknowledge packet

Since: 0.8.23
"""
@cenum ArvGvInterfaceFlags::UInt32 begin
    ARV_GV_INTERFACE_FLAGS_ALLOW_BROADCAST_DISCOVERY_ACK = 1
end

struct ArvGvInterfaceClass
    parent_class::ArvInterfaceClass
end

const ArvGvInterface_autoptr = Ptr{ArvGvInterface}

const ArvGvInterface_listautoptr = Ptr{GList}

const ArvGvInterface_slistautoptr = Ptr{GSList}

const ArvGvInterface_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGvInterface(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvInterface, arv_gv_interface, ARV, GV_INTERFACE, ArvInterface);
```
"""
function glib_autoptr_clear_ArvGvInterface(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGvInterface(_ptr::Ptr{ArvGvInterface})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGvInterface(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvInterface, arv_gv_interface, ARV, GV_INTERFACE, ArvInterface);
```
"""
function glib_autoptr_cleanup_ArvGvInterface(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGvInterface(_ptr::Ptr{Ptr{ArvGvInterface}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGvInterface(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvInterface, arv_gv_interface, ARV, GV_INTERFACE, ArvInterface);
```
"""
function glib_autoptr_destroy_ArvGvInterface(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGvInterface(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGvInterface(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvInterface, arv_gv_interface, ARV, GV_INTERFACE, ArvInterface);
```
"""
function glib_listautoptr_cleanup_ArvGvInterface(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGvInterface(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGvInterface(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvInterface, arv_gv_interface, ARV, GV_INTERFACE, ArvInterface);
```
"""
function glib_slistautoptr_cleanup_ArvGvInterface(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGvInterface(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGvInterface(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvInterface, arv_gv_interface, ARV, GV_INTERFACE, ArvInterface);
```
"""
function glib_queueautoptr_cleanup_ArvGvInterface(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGvInterface(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvGvInterfaceClass_autoptr = Ptr{ArvGvInterfaceClass}

const ArvGvInterfaceClass_listautoptr = Ptr{GList}

const ArvGvInterfaceClass_slistautoptr = Ptr{GSList}

const ArvGvInterfaceClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvGvInterfaceClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvInterface, arv_gv_interface, ARV, GV_INTERFACE, ArvInterface);
```
"""
function glib_autoptr_clear_ArvGvInterfaceClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvGvInterfaceClass(_ptr::Ptr{ArvGvInterfaceClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvGvInterfaceClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvInterface, arv_gv_interface, ARV, GV_INTERFACE, ArvInterface);
```
"""
function glib_autoptr_cleanup_ArvGvInterfaceClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvGvInterfaceClass(_ptr::Ptr{Ptr{ArvGvInterfaceClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvGvInterfaceClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvInterface, arv_gv_interface, ARV, GV_INTERFACE, ArvInterface);
```
"""
function glib_autoptr_destroy_ArvGvInterfaceClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvGvInterfaceClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvGvInterfaceClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvInterface, arv_gv_interface, ARV, GV_INTERFACE, ArvInterface);
```
"""
function glib_listautoptr_cleanup_ArvGvInterfaceClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvGvInterfaceClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvGvInterfaceClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvInterface, arv_gv_interface, ARV, GV_INTERFACE, ArvInterface);
```
"""
function glib_slistautoptr_cleanup_ArvGvInterfaceClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvGvInterfaceClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvGvInterfaceClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvInterface, arv_gv_interface, ARV, GV_INTERFACE, ArvInterface);
```
"""
function glib_queueautoptr_cleanup_ArvGvInterfaceClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvGvInterfaceClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_GV_INTERFACE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvInterface, arv_gv_interface, ARV, GV_INTERFACE, ArvInterface);
```
"""
function ARV_GV_INTERFACE(ptr)
    @ccall libaravis.ARV_GV_INTERFACE(ptr::gpointer)::Ptr{ArvGvInterface}
end

"""
    ARV_IS_GV_INTERFACE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvGvInterface, arv_gv_interface, ARV, GV_INTERFACE, ArvInterface);
```
"""
function ARV_IS_GV_INTERFACE(ptr)
    @ccall libaravis.ARV_IS_GV_INTERFACE(ptr::gpointer)::gboolean
end

"""
    arv_gv_interface_get_instance()

### Prototype
```c
ARV_API ArvInterface * arv_gv_interface_get_instance (void);
```
"""
function arv_gv_interface_get_instance()
    @ccall libaravis.arv_gv_interface_get_instance()::Ptr{ArvInterface}
end

"""
    arv_gv_interface_set_discovery_interface_name(discovery_interface)

### Prototype
```c
ARV_API void arv_gv_interface_set_discovery_interface_name (const char *discovery_interface);
```
"""
function arv_gv_interface_set_discovery_interface_name(discovery_interface)
    @ccall libaravis.arv_gv_interface_set_discovery_interface_name(discovery_interface::Cstring)::Cvoid
end

"""
    arv_gv_interface_dup_discovery_interface_name()

### Prototype
```c
ARV_API char * arv_gv_interface_dup_discovery_interface_name (void);
```
"""
function arv_gv_interface_dup_discovery_interface_name()
    @ccall libaravis.arv_gv_interface_dup_discovery_interface_name()::Cstring
end

"""
    arv_get_major_version()

### Prototype
```c
ARV_API guint arv_get_major_version (void);
```
"""
function arv_get_major_version()
    @ccall libaravis.arv_get_major_version()::guint
end

"""
    arv_get_minor_version()

### Prototype
```c
ARV_API guint arv_get_minor_version (void);
```
"""
function arv_get_minor_version()
    @ccall libaravis.arv_get_minor_version()::guint
end

"""
    arv_get_micro_version()

### Prototype
```c
ARV_API guint arv_get_micro_version (void);
```
"""
function arv_get_micro_version()
    @ccall libaravis.arv_get_micro_version()::guint
end

"""
    arv_pixel_format_to_gst_caps_string(pixel_format)

### Prototype
```c
ARV_API const char * arv_pixel_format_to_gst_caps_string (ArvPixelFormat pixel_format);
```
"""
function arv_pixel_format_to_gst_caps_string(pixel_format)
    @ccall libaravis.arv_pixel_format_to_gst_caps_string(pixel_format::ArvPixelFormat)::Cstring
end

"""
    arv_pixel_format_to_gst_caps_string_full(pixel_format, vendor_name, model_name)

### Prototype
```c
ARV_API const char * arv_pixel_format_to_gst_caps_string_full (ArvPixelFormat pixel_format, const char *vendor_name, const char *model_name);
```
"""
function arv_pixel_format_to_gst_caps_string_full(pixel_format, vendor_name, model_name)
    @ccall libaravis.arv_pixel_format_to_gst_caps_string_full(pixel_format::ArvPixelFormat, vendor_name::Cstring, model_name::Cstring)::Cstring
end

"""
    arv_pixel_format_from_gst_caps(name, format, bpp, depth)

### Prototype
```c
ARV_API ArvPixelFormat arv_pixel_format_from_gst_caps (const char *name, const char *format, int bpp, int depth);
```
"""
function arv_pixel_format_from_gst_caps(name, format, bpp, depth)
    @ccall libaravis.arv_pixel_format_from_gst_caps(name::Cstring, format::Cstring, bpp::Cint, depth::Cint)::ArvPixelFormat
end

"""
    arv_pixel_format_to_gst_0_10_caps_string(pixel_format)

### Prototype
```c
ARV_API const char * arv_pixel_format_to_gst_0_10_caps_string (ArvPixelFormat pixel_format);
```
"""
function arv_pixel_format_to_gst_0_10_caps_string(pixel_format)
    @ccall libaravis.arv_pixel_format_to_gst_0_10_caps_string(pixel_format::ArvPixelFormat)::Cstring
end

"""
    arv_pixel_format_from_gst_0_10_caps(name, bpp, depth, fourcc)

### Prototype
```c
ARV_API ArvPixelFormat arv_pixel_format_from_gst_0_10_caps (const char *name, int bpp, int depth, guint32 fourcc);
```
"""
function arv_pixel_format_from_gst_0_10_caps(name, bpp, depth, fourcc)
    @ccall libaravis.arv_pixel_format_from_gst_0_10_caps(name::Cstring, bpp::Cint, depth::Cint, fourcc::guint32)::ArvPixelFormat
end

"""
    arv_make_thread_realtime(priority)

### Prototype
```c
ARV_API gboolean arv_make_thread_realtime (int priority);
```
"""
function arv_make_thread_realtime(priority)
    @ccall libaravis.arv_make_thread_realtime(priority::Cint)::gboolean
end

"""
    arv_make_thread_high_priority(nice_level)

### Prototype
```c
ARV_API gboolean arv_make_thread_high_priority (int nice_level);
```
"""
function arv_make_thread_high_priority(nice_level)
    @ccall libaravis.arv_make_thread_high_priority(nice_level::Cint)::gboolean
end

"""
    arv_str_strip(str, illegal_chars, replacement_char)

### Prototype
```c
ARV_API char * arv_str_strip (char *str, const char *illegal_chars, char replacement_char);
```
"""
function arv_str_strip(str, illegal_chars, replacement_char)
    @ccall libaravis.arv_str_strip(str::Cstring, illegal_chars::Cstring, replacement_char::Cchar)::Cstring
end

"""
    arv_str_is_uri(str)

### Prototype
```c
ARV_API gboolean arv_str_is_uri (const char *str);
```
"""
function arv_str_is_uri(str)
    @ccall libaravis.arv_str_is_uri(str::Cstring)::gboolean
end

"""
    arv_str_to_uri(str)

### Prototype
```c
ARV_API char * arv_str_to_uri (const char *str);
```
"""
function arv_str_to_uri(str)
    @ccall libaravis.arv_str_to_uri(str::Cstring)::Cstring
end

"""
    arv_str_parse_double(str, x)

### Prototype
```c
ARV_API gboolean arv_str_parse_double (char **str, double *x);
```
"""
function arv_str_parse_double(str, x)
    @ccall libaravis.arv_str_parse_double(str::Ptr{Cstring}, x::Ptr{Cdouble})::gboolean
end

"""
    arv_str_parse_double_list(str, n_values, values)

### Prototype
```c
ARV_API unsigned int arv_str_parse_double_list (char **str, unsigned int n_values, double *values);
```
"""
function arv_str_parse_double_list(str, n_values, values)
    @ccall libaravis.arv_str_parse_double_list(str::Ptr{Cstring}, n_values::Cuint, values::Ptr{Cdouble})::Cuint
end

"""
    arv_str_skip_spaces(str)

### Prototype
```c
static inline void arv_str_skip_spaces (char **str);
```
"""
function arv_str_skip_spaces(str)
    @ccall libaravis.arv_str_skip_spaces(str::Ptr{Cstring})::Cvoid
end

"""
    arv_str_skip_char(str, c)

### Prototype
```c
static inline void arv_str_skip_char (char **str, char c);
```
"""
function arv_str_skip_char(str, c)
    @ccall libaravis.arv_str_skip_char(str::Ptr{Cstring}, c::Cchar)::Cvoid
end

"""
    arv_str_skip_comma_and_spaces(str)

### Prototype
```c
static inline void arv_str_skip_comma_and_spaces (char **str);
```
"""
function arv_str_skip_comma_and_spaces(str)
    @ccall libaravis.arv_str_skip_comma_and_spaces(str::Ptr{Cstring})::Cvoid
end

"""
    arv_str_skip_semicolon_and_spaces(str)

### Prototype
```c
static inline void arv_str_skip_semicolon_and_spaces (char **str);
```
"""
function arv_str_skip_semicolon_and_spaces(str)
    @ccall libaravis.arv_str_skip_semicolon_and_spaces(str::Ptr{Cstring})::Cvoid
end

"""
    arv_str_skip_colon_and_spaces(str)

### Prototype
```c
static inline void arv_str_skip_colon_and_spaces (char **str);
```
"""
function arv_str_skip_colon_and_spaces(str)
    @ccall libaravis.arv_str_skip_colon_and_spaces(str::Ptr{Cstring})::Cvoid
end

"""
    arv_g_string_append_hex_dump(string, data, size)

### Prototype
```c
ARV_API void arv_g_string_append_hex_dump (GString *string, const void *data, size_t size);
```
"""
function arv_g_string_append_hex_dump(string, data, size)
    @ccall libaravis.arv_g_string_append_hex_dump(string::Ptr{GString}, data::Ptr{Cvoid}, size::Csize_t)::Cvoid
end

"""
    arv_get_n_interfaces()

### Prototype
```c
ARV_API unsigned int arv_get_n_interfaces (void);
```
"""
function arv_get_n_interfaces()
    @ccall libaravis.arv_get_n_interfaces()::Cuint
end

"""
    arv_get_interface_id(index)

### Prototype
```c
ARV_API const char * arv_get_interface_id (unsigned int index);
```
"""
function arv_get_interface_id(index)
    @ccall libaravis.arv_get_interface_id(index::Cuint)::Cstring
end

"""
    arv_enable_interface(interface_id)

### Prototype
```c
ARV_API void arv_enable_interface (const char *interface_id);
```
"""
function arv_enable_interface(interface_id)
    @ccall libaravis.arv_enable_interface(interface_id::Cstring)::Cvoid
end

"""
    arv_select_interface(interface_id)

### Prototype
```c
ARV_API void arv_select_interface (const char *interface_id);
```
"""
function arv_select_interface(interface_id)
    @ccall libaravis.arv_select_interface(interface_id::Cstring)::Cvoid
end

"""
    arv_disable_interface(interface_id)

### Prototype
```c
ARV_API void arv_disable_interface (const char *interface_id);
```
"""
function arv_disable_interface(interface_id)
    @ccall libaravis.arv_disable_interface(interface_id::Cstring)::Cvoid
end

"""
    arv_set_interface_flags(interface_id, flags)

### Prototype
```c
ARV_API void arv_set_interface_flags (const char *interface_id, int flags);
```
"""
function arv_set_interface_flags(interface_id, flags)
    @ccall libaravis.arv_set_interface_flags(interface_id::Cstring, flags::Cint)::Cvoid
end

"""
    arv_update_device_list()

### Prototype
```c
ARV_API void arv_update_device_list (void);
```
"""
function arv_update_device_list()
    @ccall libaravis.arv_update_device_list()::Cvoid
end

"""
    arv_get_n_devices()

### Prototype
```c
ARV_API unsigned int arv_get_n_devices (void);
```
"""
function arv_get_n_devices()
    @ccall libaravis.arv_get_n_devices()::Cuint
end

"""
    arv_get_device_id(index)

### Prototype
```c
ARV_API const char * arv_get_device_id (unsigned int index);
```
"""
function arv_get_device_id(index)
    @ccall libaravis.arv_get_device_id(index::Cuint)::Cstring
end

"""
    arv_get_device_physical_id(index)

### Prototype
```c
ARV_API const char * arv_get_device_physical_id (unsigned int index);
```
"""
function arv_get_device_physical_id(index)
    @ccall libaravis.arv_get_device_physical_id(index::Cuint)::Cstring
end

"""
    arv_get_device_address(index)

### Prototype
```c
ARV_API const char * arv_get_device_address (unsigned int index);
```
"""
function arv_get_device_address(index)
    @ccall libaravis.arv_get_device_address(index::Cuint)::Cstring
end

"""
    arv_get_device_vendor(index)

### Prototype
```c
ARV_API const char * arv_get_device_vendor (unsigned int index);
```
"""
function arv_get_device_vendor(index)
    @ccall libaravis.arv_get_device_vendor(index::Cuint)::Cstring
end

"""
    arv_get_device_manufacturer_info(index)

### Prototype
```c
ARV_API const char * arv_get_device_manufacturer_info (unsigned int index);
```
"""
function arv_get_device_manufacturer_info(index)
    @ccall libaravis.arv_get_device_manufacturer_info(index::Cuint)::Cstring
end

"""
    arv_get_device_model(index)

### Prototype
```c
ARV_API const char * arv_get_device_model (unsigned int index);
```
"""
function arv_get_device_model(index)
    @ccall libaravis.arv_get_device_model(index::Cuint)::Cstring
end

"""
    arv_get_device_serial_nbr(index)

### Prototype
```c
ARV_API const char * arv_get_device_serial_nbr (unsigned int index);
```
"""
function arv_get_device_serial_nbr(index)
    @ccall libaravis.arv_get_device_serial_nbr(index::Cuint)::Cstring
end

"""
    arv_get_device_protocol(index)

### Prototype
```c
ARV_API const char * arv_get_device_protocol (unsigned int index);
```
"""
function arv_get_device_protocol(index)
    @ccall libaravis.arv_get_device_protocol(index::Cuint)::Cstring
end

"""
    arv_open_device(device_id, error)

### Prototype
```c
ARV_API ArvDevice * arv_open_device (const char *device_id, GError **error);
```
"""
function arv_open_device(device_id, error)
    @ccall libaravis.arv_open_device(device_id::Cstring, error::Ptr{Ptr{GError}})::Ptr{ArvDevice}
end

"""
    arv_shutdown()

### Prototype
```c
ARV_API void arv_shutdown (void);
```
"""
function arv_shutdown()
    @ccall libaravis.arv_shutdown()::Cvoid
end

struct ArvUvInterfaceClass
    parent_class::ArvInterfaceClass
end

const ArvUvInterface_autoptr = Ptr{ArvUvInterface}

const ArvUvInterface_listautoptr = Ptr{GList}

const ArvUvInterface_slistautoptr = Ptr{GSList}

const ArvUvInterface_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvUvInterface(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvInterface, arv_uv_interface, ARV, UV_INTERFACE, ArvInterface);
```
"""
function glib_autoptr_clear_ArvUvInterface(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvUvInterface(_ptr::Ptr{ArvUvInterface})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvUvInterface(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvInterface, arv_uv_interface, ARV, UV_INTERFACE, ArvInterface);
```
"""
function glib_autoptr_cleanup_ArvUvInterface(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvUvInterface(_ptr::Ptr{Ptr{ArvUvInterface}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvUvInterface(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvInterface, arv_uv_interface, ARV, UV_INTERFACE, ArvInterface);
```
"""
function glib_autoptr_destroy_ArvUvInterface(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvUvInterface(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvUvInterface(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvInterface, arv_uv_interface, ARV, UV_INTERFACE, ArvInterface);
```
"""
function glib_listautoptr_cleanup_ArvUvInterface(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvUvInterface(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvUvInterface(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvInterface, arv_uv_interface, ARV, UV_INTERFACE, ArvInterface);
```
"""
function glib_slistautoptr_cleanup_ArvUvInterface(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvUvInterface(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvUvInterface(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvInterface, arv_uv_interface, ARV, UV_INTERFACE, ArvInterface);
```
"""
function glib_queueautoptr_cleanup_ArvUvInterface(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvUvInterface(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvUvInterfaceClass_autoptr = Ptr{ArvUvInterfaceClass}

const ArvUvInterfaceClass_listautoptr = Ptr{GList}

const ArvUvInterfaceClass_slistautoptr = Ptr{GSList}

const ArvUvInterfaceClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvUvInterfaceClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvInterface, arv_uv_interface, ARV, UV_INTERFACE, ArvInterface);
```
"""
function glib_autoptr_clear_ArvUvInterfaceClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvUvInterfaceClass(_ptr::Ptr{ArvUvInterfaceClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvUvInterfaceClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvInterface, arv_uv_interface, ARV, UV_INTERFACE, ArvInterface);
```
"""
function glib_autoptr_cleanup_ArvUvInterfaceClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvUvInterfaceClass(_ptr::Ptr{Ptr{ArvUvInterfaceClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvUvInterfaceClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvInterface, arv_uv_interface, ARV, UV_INTERFACE, ArvInterface);
```
"""
function glib_autoptr_destroy_ArvUvInterfaceClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvUvInterfaceClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvUvInterfaceClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvInterface, arv_uv_interface, ARV, UV_INTERFACE, ArvInterface);
```
"""
function glib_listautoptr_cleanup_ArvUvInterfaceClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvUvInterfaceClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvUvInterfaceClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvInterface, arv_uv_interface, ARV, UV_INTERFACE, ArvInterface);
```
"""
function glib_slistautoptr_cleanup_ArvUvInterfaceClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvUvInterfaceClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvUvInterfaceClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvInterface, arv_uv_interface, ARV, UV_INTERFACE, ArvInterface);
```
"""
function glib_queueautoptr_cleanup_ArvUvInterfaceClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvUvInterfaceClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_UV_INTERFACE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvInterface, arv_uv_interface, ARV, UV_INTERFACE, ArvInterface);
```
"""
function ARV_UV_INTERFACE(ptr)
    @ccall libaravis.ARV_UV_INTERFACE(ptr::gpointer)::Ptr{ArvUvInterface}
end

"""
    ARV_IS_UV_INTERFACE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvInterface, arv_uv_interface, ARV, UV_INTERFACE, ArvInterface);
```
"""
function ARV_IS_UV_INTERFACE(ptr)
    @ccall libaravis.ARV_IS_UV_INTERFACE(ptr::gpointer)::gboolean
end

"""
    arv_uv_interface_get_instance()

### Prototype
```c
ARV_API ArvInterface * arv_uv_interface_get_instance (void);
```
"""
function arv_uv_interface_get_instance()
    @ccall libaravis.arv_uv_interface_get_instance()::Ptr{ArvInterface}
end

struct ArvUvDeviceClass
    parent_class::ArvDeviceClass
end

const ArvUvDevice_autoptr = Ptr{ArvUvDevice}

const ArvUvDevice_listautoptr = Ptr{GList}

const ArvUvDevice_slistautoptr = Ptr{GSList}

const ArvUvDevice_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvUvDevice(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvDevice, arv_uv_device, ARV, UV_DEVICE, ArvDevice);
```
"""
function glib_autoptr_clear_ArvUvDevice(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvUvDevice(_ptr::Ptr{ArvUvDevice})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvUvDevice(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvDevice, arv_uv_device, ARV, UV_DEVICE, ArvDevice);
```
"""
function glib_autoptr_cleanup_ArvUvDevice(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvUvDevice(_ptr::Ptr{Ptr{ArvUvDevice}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvUvDevice(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvDevice, arv_uv_device, ARV, UV_DEVICE, ArvDevice);
```
"""
function glib_autoptr_destroy_ArvUvDevice(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvUvDevice(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvUvDevice(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvDevice, arv_uv_device, ARV, UV_DEVICE, ArvDevice);
```
"""
function glib_listautoptr_cleanup_ArvUvDevice(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvUvDevice(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvUvDevice(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvDevice, arv_uv_device, ARV, UV_DEVICE, ArvDevice);
```
"""
function glib_slistautoptr_cleanup_ArvUvDevice(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvUvDevice(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvUvDevice(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvDevice, arv_uv_device, ARV, UV_DEVICE, ArvDevice);
```
"""
function glib_queueautoptr_cleanup_ArvUvDevice(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvUvDevice(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvUvDeviceClass_autoptr = Ptr{ArvUvDeviceClass}

const ArvUvDeviceClass_listautoptr = Ptr{GList}

const ArvUvDeviceClass_slistautoptr = Ptr{GSList}

const ArvUvDeviceClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvUvDeviceClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvDevice, arv_uv_device, ARV, UV_DEVICE, ArvDevice);
```
"""
function glib_autoptr_clear_ArvUvDeviceClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvUvDeviceClass(_ptr::Ptr{ArvUvDeviceClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvUvDeviceClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvDevice, arv_uv_device, ARV, UV_DEVICE, ArvDevice);
```
"""
function glib_autoptr_cleanup_ArvUvDeviceClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvUvDeviceClass(_ptr::Ptr{Ptr{ArvUvDeviceClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvUvDeviceClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvDevice, arv_uv_device, ARV, UV_DEVICE, ArvDevice);
```
"""
function glib_autoptr_destroy_ArvUvDeviceClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvUvDeviceClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvUvDeviceClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvDevice, arv_uv_device, ARV, UV_DEVICE, ArvDevice);
```
"""
function glib_listautoptr_cleanup_ArvUvDeviceClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvUvDeviceClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvUvDeviceClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvDevice, arv_uv_device, ARV, UV_DEVICE, ArvDevice);
```
"""
function glib_slistautoptr_cleanup_ArvUvDeviceClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvUvDeviceClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvUvDeviceClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvDevice, arv_uv_device, ARV, UV_DEVICE, ArvDevice);
```
"""
function glib_queueautoptr_cleanup_ArvUvDeviceClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvUvDeviceClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_UV_DEVICE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvDevice, arv_uv_device, ARV, UV_DEVICE, ArvDevice);
```
"""
function ARV_UV_DEVICE(ptr)
    @ccall libaravis.ARV_UV_DEVICE(ptr::gpointer)::Ptr{ArvUvDevice}
end

"""
    ARV_IS_UV_DEVICE(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvDevice, arv_uv_device, ARV, UV_DEVICE, ArvDevice);
```
"""
function ARV_IS_UV_DEVICE(ptr)
    @ccall libaravis.ARV_IS_UV_DEVICE(ptr::gpointer)::gboolean
end

"""
    arv_uv_device_new(vendor, product, serial_number, error)

### Prototype
```c
ARV_API ArvDevice * arv_uv_device_new (const char *vendor, const char *product, const char *serial_number, GError **error);
```
"""
function arv_uv_device_new(vendor, product, serial_number, error)
    @ccall libaravis.arv_uv_device_new(vendor::Cstring, product::Cstring, serial_number::Cstring, error::Ptr{Ptr{GError}})::Ptr{ArvDevice}
end

"""
    arv_uv_device_new_from_guid(guid, error)

### Prototype
```c
ARV_API ArvDevice * arv_uv_device_new_from_guid (const char *guid, GError **error);
```
"""
function arv_uv_device_new_from_guid(guid, error)
    @ccall libaravis.arv_uv_device_new_from_guid(guid::Cstring, error::Ptr{Ptr{GError}})::Ptr{ArvDevice}
end

"""
    arv_uv_device_set_usb_mode(uv_device, usb_mode)

### Prototype
```c
ARV_API void arv_uv_device_set_usb_mode (ArvUvDevice *uv_device, ArvUvUsbMode usb_mode);
```
"""
function arv_uv_device_set_usb_mode(uv_device, usb_mode)
    @ccall libaravis.arv_uv_device_set_usb_mode(uv_device::Ptr{ArvUvDevice}, usb_mode::ArvUvUsbMode)::Cvoid
end

struct ArvUvStreamClass
    parent_class::ArvStreamClass
end

const ArvUvStream_autoptr = Ptr{ArvUvStream}

const ArvUvStream_listautoptr = Ptr{GList}

const ArvUvStream_slistautoptr = Ptr{GSList}

const ArvUvStream_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvUvStream(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvStream, arv_uv_stream, ARV, UV_STREAM, ArvStream);
```
"""
function glib_autoptr_clear_ArvUvStream(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvUvStream(_ptr::Ptr{ArvUvStream})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvUvStream(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvStream, arv_uv_stream, ARV, UV_STREAM, ArvStream);
```
"""
function glib_autoptr_cleanup_ArvUvStream(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvUvStream(_ptr::Ptr{Ptr{ArvUvStream}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvUvStream(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvStream, arv_uv_stream, ARV, UV_STREAM, ArvStream);
```
"""
function glib_autoptr_destroy_ArvUvStream(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvUvStream(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvUvStream(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvStream, arv_uv_stream, ARV, UV_STREAM, ArvStream);
```
"""
function glib_listautoptr_cleanup_ArvUvStream(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvUvStream(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvUvStream(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvStream, arv_uv_stream, ARV, UV_STREAM, ArvStream);
```
"""
function glib_slistautoptr_cleanup_ArvUvStream(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvUvStream(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvUvStream(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvStream, arv_uv_stream, ARV, UV_STREAM, ArvStream);
```
"""
function glib_queueautoptr_cleanup_ArvUvStream(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvUvStream(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvUvStreamClass_autoptr = Ptr{ArvUvStreamClass}

const ArvUvStreamClass_listautoptr = Ptr{GList}

const ArvUvStreamClass_slistautoptr = Ptr{GSList}

const ArvUvStreamClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvUvStreamClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvStream, arv_uv_stream, ARV, UV_STREAM, ArvStream);
```
"""
function glib_autoptr_clear_ArvUvStreamClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvUvStreamClass(_ptr::Ptr{ArvUvStreamClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvUvStreamClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvStream, arv_uv_stream, ARV, UV_STREAM, ArvStream);
```
"""
function glib_autoptr_cleanup_ArvUvStreamClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvUvStreamClass(_ptr::Ptr{Ptr{ArvUvStreamClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvUvStreamClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvStream, arv_uv_stream, ARV, UV_STREAM, ArvStream);
```
"""
function glib_autoptr_destroy_ArvUvStreamClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvUvStreamClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvUvStreamClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvStream, arv_uv_stream, ARV, UV_STREAM, ArvStream);
```
"""
function glib_listautoptr_cleanup_ArvUvStreamClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvUvStreamClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvUvStreamClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvStream, arv_uv_stream, ARV, UV_STREAM, ArvStream);
```
"""
function glib_slistautoptr_cleanup_ArvUvStreamClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvUvStreamClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvUvStreamClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvStream, arv_uv_stream, ARV, UV_STREAM, ArvStream);
```
"""
function glib_queueautoptr_cleanup_ArvUvStreamClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvUvStreamClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_UV_STREAM(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvStream, arv_uv_stream, ARV, UV_STREAM, ArvStream);
```
"""
function ARV_UV_STREAM(ptr)
    @ccall libaravis.ARV_UV_STREAM(ptr::gpointer)::Ptr{ArvUvStream}
end

"""
    ARV_IS_UV_STREAM(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvUvStream, arv_uv_stream, ARV, UV_STREAM, ArvStream);
```
"""
function ARV_IS_UV_STREAM(ptr)
    @ccall libaravis.ARV_IS_UV_STREAM(ptr::gpointer)::gboolean
end

"""
    arv_zip_new(buffer, size)

### Prototype
```c
ARV_API ArvZip * arv_zip_new (const void *buffer, size_t size);
```
"""
function arv_zip_new(buffer, size)
    @ccall libaravis.arv_zip_new(buffer::Ptr{Cvoid}, size::Csize_t)::Ptr{ArvZip}
end

"""
    arv_zip_free(zip)

### Prototype
```c
ARV_API void arv_zip_free (ArvZip *zip);
```
"""
function arv_zip_free(zip)
    @ccall libaravis.arv_zip_free(zip::Ptr{ArvZip})::Cvoid
end

"""
    arv_zip_get_file(zip, name, size)

### Prototype
```c
ARV_API void * arv_zip_get_file (ArvZip *zip, const char *name, size_t *size);
```
"""
function arv_zip_get_file(zip, name, size)
    @ccall libaravis.arv_zip_get_file(zip::Ptr{ArvZip}, name::Cstring, size::Ptr{Csize_t})::Ptr{Cvoid}
end

"""
    arv_zip_get_file_list(zip)

### Prototype
```c
ARV_API const GSList * arv_zip_get_file_list (ArvZip *zip);
```
"""
function arv_zip_get_file_list(zip)
    @ccall libaravis.arv_zip_get_file_list(zip::Ptr{ArvZip})::Ptr{GSList}
end

"""
    arv_zip_file_get_name(zip_file)

### Prototype
```c
ARV_API const char * arv_zip_file_get_name (ArvZipFile *zip_file);
```
"""
function arv_zip_file_get_name(zip_file)
    @ccall libaravis.arv_zip_file_get_name(zip_file::Ptr{ArvZipFile})::Cstring
end

"""
    arv_zip_file_get_uncompressed_size(zip_file)

### Prototype
```c
ARV_API size_t arv_zip_file_get_uncompressed_size (ArvZipFile *zip_file);
```
"""
function arv_zip_file_get_uncompressed_size(zip_file)
    @ccall libaravis.arv_zip_file_get_uncompressed_size(zip_file::Ptr{ArvZipFile})::Csize_t
end

"""
    ArvXmlSchemaError

[`ArvXmlSchemaError`](@ref): \\_XML\\_SCHEMA\\_ERROR\\_INVALID\\_STRUCTURE: invalid structure
"""
@cenum ArvXmlSchemaError::UInt32 begin
    ARV_XML_SCHEMA_ERROR_INVALID_STRUCTURE = 0
end

const _ArvXmlSchema = Cvoid

const ArvXmlSchema = _ArvXmlSchema

struct ArvXmlSchemaClass
    parent_class::GObjectClass
end

const ArvXmlSchema_autoptr = Ptr{ArvXmlSchema}

const ArvXmlSchema_listautoptr = Ptr{GList}

const ArvXmlSchema_slistautoptr = Ptr{GSList}

const ArvXmlSchema_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvXmlSchema(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvXmlSchema, arv_xml_schema, ARV, XML_SCHEMA, GObject);
```
"""
function glib_autoptr_clear_ArvXmlSchema(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvXmlSchema(_ptr::Ptr{ArvXmlSchema})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvXmlSchema(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvXmlSchema, arv_xml_schema, ARV, XML_SCHEMA, GObject);
```
"""
function glib_autoptr_cleanup_ArvXmlSchema(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvXmlSchema(_ptr::Ptr{Ptr{ArvXmlSchema}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvXmlSchema(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvXmlSchema, arv_xml_schema, ARV, XML_SCHEMA, GObject);
```
"""
function glib_autoptr_destroy_ArvXmlSchema(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvXmlSchema(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvXmlSchema(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvXmlSchema, arv_xml_schema, ARV, XML_SCHEMA, GObject);
```
"""
function glib_listautoptr_cleanup_ArvXmlSchema(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvXmlSchema(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvXmlSchema(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvXmlSchema, arv_xml_schema, ARV, XML_SCHEMA, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvXmlSchema(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvXmlSchema(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvXmlSchema(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvXmlSchema, arv_xml_schema, ARV, XML_SCHEMA, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvXmlSchema(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvXmlSchema(_q::Ptr{Ptr{GQueue}})::Cvoid
end

const ArvXmlSchemaClass_autoptr = Ptr{ArvXmlSchemaClass}

const ArvXmlSchemaClass_listautoptr = Ptr{GList}

const ArvXmlSchemaClass_slistautoptr = Ptr{GSList}

const ArvXmlSchemaClass_queueautoptr = Ptr{GQueue}

"""
    glib_autoptr_clear_ArvXmlSchemaClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvXmlSchema, arv_xml_schema, ARV, XML_SCHEMA, GObject);
```
"""
function glib_autoptr_clear_ArvXmlSchemaClass(_ptr)
    @ccall libaravis.glib_autoptr_clear_ArvXmlSchemaClass(_ptr::Ptr{ArvXmlSchemaClass})::Cvoid
end

"""
    glib_autoptr_cleanup_ArvXmlSchemaClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvXmlSchema, arv_xml_schema, ARV, XML_SCHEMA, GObject);
```
"""
function glib_autoptr_cleanup_ArvXmlSchemaClass(_ptr)
    @ccall libaravis.glib_autoptr_cleanup_ArvXmlSchemaClass(_ptr::Ptr{Ptr{ArvXmlSchemaClass}})::Cvoid
end

"""
    glib_autoptr_destroy_ArvXmlSchemaClass(_ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvXmlSchema, arv_xml_schema, ARV, XML_SCHEMA, GObject);
```
"""
function glib_autoptr_destroy_ArvXmlSchemaClass(_ptr)
    @ccall libaravis.glib_autoptr_destroy_ArvXmlSchemaClass(_ptr::Ptr{Cvoid})::Cvoid
end

"""
    glib_listautoptr_cleanup_ArvXmlSchemaClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvXmlSchema, arv_xml_schema, ARV, XML_SCHEMA, GObject);
```
"""
function glib_listautoptr_cleanup_ArvXmlSchemaClass(_l)
    @ccall libaravis.glib_listautoptr_cleanup_ArvXmlSchemaClass(_l::Ptr{Ptr{GList}})::Cvoid
end

"""
    glib_slistautoptr_cleanup_ArvXmlSchemaClass(_l)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvXmlSchema, arv_xml_schema, ARV, XML_SCHEMA, GObject);
```
"""
function glib_slistautoptr_cleanup_ArvXmlSchemaClass(_l)
    @ccall libaravis.glib_slistautoptr_cleanup_ArvXmlSchemaClass(_l::Ptr{Ptr{GSList}})::Cvoid
end

"""
    glib_queueautoptr_cleanup_ArvXmlSchemaClass(_q)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvXmlSchema, arv_xml_schema, ARV, XML_SCHEMA, GObject);
```
"""
function glib_queueautoptr_cleanup_ArvXmlSchemaClass(_q)
    @ccall libaravis.glib_queueautoptr_cleanup_ArvXmlSchemaClass(_q::Ptr{Ptr{GQueue}})::Cvoid
end

"""
    ARV_XML_SCHEMA(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvXmlSchema, arv_xml_schema, ARV, XML_SCHEMA, GObject);
```
"""
function ARV_XML_SCHEMA(ptr)
    @ccall libaravis.ARV_XML_SCHEMA(ptr::gpointer)::Ptr{ArvXmlSchema}
end

"""
    ARV_IS_XML_SCHEMA(ptr)

### Prototype
```c
G_DECLARE_FINAL_TYPE (ArvXmlSchema, arv_xml_schema, ARV, XML_SCHEMA, GObject);
```
"""
function ARV_IS_XML_SCHEMA(ptr)
    @ccall libaravis.ARV_IS_XML_SCHEMA(ptr::gpointer)::gboolean
end

"""
    arv_xml_schema_new_from_memory(buffer, size)

### Prototype
```c
ARV_API ArvXmlSchema * arv_xml_schema_new_from_memory (const char *buffer, size_t size);
```
"""
function arv_xml_schema_new_from_memory(buffer, size)
    @ccall libaravis.arv_xml_schema_new_from_memory(buffer::Cstring, size::Csize_t)::Ptr{ArvXmlSchema}
end

"""
    arv_xml_schema_new_from_file(file)

### Prototype
```c
ARV_API ArvXmlSchema * arv_xml_schema_new_from_file (GFile *file);
```
"""
function arv_xml_schema_new_from_file(file)
    @ccall libaravis.arv_xml_schema_new_from_file(file::Ptr{GFile})::Ptr{ArvXmlSchema}
end

"""
    arv_xml_schema_new_from_path(path)

### Prototype
```c
ARV_API ArvXmlSchema * arv_xml_schema_new_from_path (const char *path);
```
"""
function arv_xml_schema_new_from_path(path)
    @ccall libaravis.arv_xml_schema_new_from_path(path::Cstring)::Ptr{ArvXmlSchema}
end

"""
    arv_xml_schema_validate(schema, xml, size, line, column, error)

### Prototype
```c
ARV_API gboolean arv_xml_schema_validate (ArvXmlSchema *schema, const void *xml, size_t size, int *line, int *column, GError **error);
```
"""
function arv_xml_schema_validate(schema, xml, size, line, column, error)
    @ccall libaravis.arv_xml_schema_validate(schema::Ptr{ArvXmlSchema}, xml::Ptr{Cvoid}, size::Csize_t, line::Ptr{Cint}, column::Ptr{Cint}, error::Ptr{Ptr{GError}})::gboolean
end

struct __JL_Ctag_25
    mantissa::guint
    biased_exponent::guint
    sign::guint
end
function Base.getproperty(x::Ptr{__JL_Ctag_25}, f::Symbol)
    f === :mantissa && return (Ptr{guint}(x + 0), 0, 23)
    f === :biased_exponent && return (Ptr{guint}(x + 0), 23, 8)
    f === :sign && return (Ptr{guint}(x + 0), 31, 1)
    return getfield(x, f)
end

function Base.getproperty(x::__JL_Ctag_25, f::Symbol)
    r = Ref{__JL_Ctag_25}(x)
    ptr = Base.unsafe_convert(Ptr{__JL_Ctag_25}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{__JL_Ctag_25}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end


struct __JL_Ctag_27
    mantissa_low::guint
    mantissa_high::guint
    biased_exponent::guint
    sign::guint
end
function Base.getproperty(x::Ptr{__JL_Ctag_27}, f::Symbol)
    f === :mantissa_low && return (Ptr{guint}(x + 0), 0, 32)
    f === :mantissa_high && return (Ptr{guint}(x + 4), 0, 20)
    f === :biased_exponent && return (Ptr{guint}(x + 4), 20, 11)
    f === :sign && return (Ptr{guint}(x + 4), 31, 1)
    return getfield(x, f)
end

function Base.getproperty(x::__JL_Ctag_27, f::Symbol)
    r = Ref{__JL_Ctag_27}(x)
    ptr = Base.unsafe_convert(Ptr{__JL_Ctag_27}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{__JL_Ctag_27}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end


struct __JL_Ctag_30
    partial_magic::gsize
    type::Ptr{GVariantType}
    y::NTuple{14, guintptr}
end
function Base.getproperty(x::Ptr{__JL_Ctag_30}, f::Symbol)
    f === :partial_magic && return Ptr{gsize}(x + 0)
    f === :type && return Ptr{Ptr{GVariantType}}(x + 8)
    f === :y && return Ptr{NTuple{14, guintptr}}(x + 16)
    return getfield(x, f)
end

function Base.getproperty(x::__JL_Ctag_30, f::Symbol)
    r = Ref{__JL_Ctag_30}(x)
    ptr = Base.unsafe_convert(Ptr{__JL_Ctag_30}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{__JL_Ctag_30}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end


struct __pthread_mutex_s
    __lock::Cint
    __count::Cuint
    __owner::Cint
    __nusers::Cuint
    __kind::Cint
    __spins::Cint
    __list::__pthread_list_t
end

struct __JL_Ctag_32
    asv::Ptr{GVariant}
    partial_magic::gsize
    y::NTuple{14, guintptr}
end
function Base.getproperty(x::Ptr{__JL_Ctag_32}, f::Symbol)
    f === :asv && return Ptr{Ptr{GVariant}}(x + 0)
    f === :partial_magic && return Ptr{gsize}(x + 8)
    f === :y && return Ptr{NTuple{14, guintptr}}(x + 16)
    return getfield(x, f)
end

function Base.getproperty(x::__JL_Ctag_32, f::Symbol)
    r = Ref{__JL_Ctag_32}(x)
    ptr = Base.unsafe_convert(Ptr{__JL_Ctag_32}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{__JL_Ctag_32}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end


# exports
const PREFIXES = ["arv_", "ARV_"]
for name in names(@__MODULE__; all=true), prefix in PREFIXES
    if startswith(string(name), prefix)
        @eval export $name
    end
end

end # module
